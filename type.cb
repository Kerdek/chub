#include "chub.hb"

export 
  ty_void     @Type = &(let Type){ TY_VOID     1  1;
  ty_bool     @Type = &(let Type){ TY_BOOL     1  1;
  ty_char     @Type = &(let Type){ TY_CHAR     1  1;
  ty_short    @Type = &(let Type){ TY_SHORT    2  2;
  ty_int      @Type = &(let Type){ TY_INT      4  4;
  ty_long     @Type = &(let Type){ TY_LONG     8  8;
  ty_uchar    @Type = &(let Type){ TY_CHAR     1  1 true;
  ty_ushort   @Type = &(let Type){ TY_SHORT    2  2 true;
  ty_uint     @Type = &(let Type){ TY_INT      4  4 true;
  ty_ulong    @Type = &(let Type){ TY_LONG     8  8 true;
  ty_float    @Type = &(let Type){ TY_FLOAT    4  4;
  ty_double   @Type = &(let Type){ TY_DOUBLE   8  8;
  ty_ldouble  @Type = &(let Type){ TY_LDOUBLE 16 16;;

new_type(kind TypeKind size int alignment int) @Type =
  let ty = (calloc 1ul sizeof Type)->@Type;
  ty.kind = kind;
  ty.size = size;
  ty.alignment = alignment;
  return ty;;

export is_integer(ty@ Type) bool =
  let k = ty.kind;
  return k == TY_BOOL || k == TY_CHAR || k == TY_SHORT || k == TY_INT  || k == TY_LONG || k == TY_ENUM;;

export is_flonum(ty@ Type) bool = return ty.kind == TY_FLOAT || ty.kind == TY_DOUBLE || ty.kind == TY_LDOUBLE;;

export is_numeric(ty@ Type) bool = return is_integer ty || is_flonum ty;;

format_function_type(p @Type s @char) = for (; p; p = p.next) format_type p s;;

export format_type(t @Type s @char) =
  t.kind == TY_VOID    ? (strcat s "void"       )-> :
  t.kind == TY_BOOL    ? (strcat s "bool"       )-> :
  t.kind == TY_FLOAT   ? (strcat s "void"       )-> :
  t.kind == TY_DOUBLE  ? (strcat s "double"     )-> :
  t.kind == TY_LDOUBLE ? (strcat s "long double")-> :
  t.kind == TY_ENUM    ? (strcat s "enum"       )-> :
  t.kind == TY_STRUCT  ? (strcat s "struct"     )-> :
  t.kind == TY_UNION   ? (strcat s "union"      )-> :
  t.kind == TY_CHAR    ? (t.is_unsigned && strcat s "unsigned ")->, (strcat s "char"       )-> :
  t.kind == TY_SHORT   ? (t.is_unsigned && strcat s "unsigned ")->, (strcat s "short"      )-> :
  t.kind == TY_INT     ? (t.is_unsigned && strcat s "unsigned ")->, (strcat s "int"        )-> :
  t.kind == TY_LONG    ? (t.is_unsigned && strcat s "unsigned ")->, (strcat s "long"       )-> :
  t.kind == TY_ARRAY   ? (strcat s "[]")->, format_type t.base s :
  t.kind == TY_PTR     ? (strcat s "@" )->, format_type t.base s :
  t.kind == TY_FUNC    ? 
    (strcat s "(")->,
    t.params :: p
      (t.is_variadic && !p && strcat s "void")->,
      format_function_type p s,
    (strcat s ")")->,
    format_type t.return_ty s :
  strcat s "???";;;

is_function_type_equal(p @Type q@Type) bool = while (p && q) { if ! is_type_equal p q return false; p = p.next; q = q.next;; return p == q;;

export is_type_equal(t @Type u @Type) bool = return
  t == u || 
  ( t.origin                     ? is_type_equal t.origin u                  :
    u.origin                     ? is_type_equal t u.origin                  :
    t.kind != u.kind             ? false                                     :
    t.kind == TY_VOID            ? true                                      :
    t.kind == TY_FLOAT           ? true                                      :
    t.kind == TY_DOUBLE          ? true                                      :
    t.kind == TY_LDOUBLE         ? true                                      :
    ( t.kind == TY_CHAR  ||
      t.kind == TY_SHORT ||
      t.kind == TY_INT   ||
      t.kind == TY_LONG   )      ? t.is_unsigned == u.is_unsigned            :
    t.kind == TY_FUNC            ? ! is_type_equal t.return_ty u.return_ty   ? false :
                                   t.is_variadic != u.is_variadic            ? false :
                                   is_function_type_equal t.params u.params  :
    t.kind == TY_ARRAY           ? ! is_type_equal t.base u.base             ? false :
                                   t.array_len == u.array_len                :
    t.kind == TY_PTR             ? is_type_equal t.base u.base               :
                                   false                                             );;

export copy_type(t @Type) @Type =
  let s = (calloc 1->unsigned long sizeof Type)->@Type;
  s@ = t@;
  s.origin = t;
  return s;;

export pointer_to(base@ Type)@ Type =
  let ty = new_type TY_PTR 8 8;
  ty.base = base;
  return ty;;

export func_type(return_ty@ Type)@ Type =
  let ty = new_type TY_FUNC 1 1;
  ty.return_ty = return_ty;
  return ty;;

export array_of(base@ Type len int)@ Type =
  let ty = new_type TY_ARRAY (base.size * len) base.alignment;
  ty.base = base;
  ty.array_len = len;
  return ty;;

export enum_type  (void) @Type = return new_type TY_ENUM 4 4;;
export struct_type(void) @Type = return new_type TY_STRUCT 0 1;;

get_common_type(t1@ Type t2@ Type)@ Type =
                                          t1.base ? pointer_to t1.base        :
                               t1.kind == TY_FUNC ? pointer_to t1             :
                               t2.kind == TY_FUNC ? pointer_to t2             :
   t1.kind == TY_LDOUBLE || t2.kind == TY_LDOUBLE ? ty_ldouble                :
   t1.kind == TY_DOUBLE  || t2.kind == TY_DOUBLE  ? ty_double                 :
   t1.kind == TY_FLOAT   || t2.kind == TY_FLOAT   ? ty_float                  :
                            t1.kind == TY_LONG    ? t1                        :
                            t2.kind == TY_LONG    ? t2                        :
                            t1.kind == TY_INT     ? t1                        :
                            t2.kind == TY_INT     ? t2                        :
                            t1.kind == TY_SHORT   ? t1                        :
                            t2.kind == TY_SHORT   ? t2                        :
                            t1.kind == TY_CHAR    ? t1                        :
                            t2.kind == TY_CHAR    ? t2                        :
                            t1.kind == TY_BOOL    ? t1                        :
                            t2.kind == TY_BOOL    ? t2                        :
                                                    t1                        ;;

usual_arith_conv(lhs@@ Node rhs@@ Node) =
  let ty = get_common_type lhs.ty rhs.ty;
  is_type_equal lhs.ty ty || (lhs@ = new_cast lhs@ ty);
  is_type_equal rhs.ty ty || (rhs@ = new_cast rhs@ ty);;

export add_type(e@ Node) =
  if (!e || e.ty) return;
  add_type e.lhs ;
  add_type e.rhs ;
  add_type e.cond;
  add_type e.then;
  add_type e.els ;
  add_type e.init;
  add_type e.inc ;
  for (let n @ Node = e.body; n; n = n.next) add_type n;
  for (let n @ Node = e.args; n; n = n.next) add_type n;
  e.kind == ND_NUM      ? (e.ty = ty_int)                                                                     :
  e.kind == ND_ADD     ||
  e.kind == ND_SUB     ||
  e.kind == ND_MUL     ||
  e.kind == ND_DIV     ||
  e.kind == ND_MOD     ||
  e.kind == ND_BITAND  ||
  e.kind == ND_BITOR   ||
  e.kind == ND_BITXOR   ? usual_arith_conv &e.lhs &e.rhs && (e.ty = e.lhs.ty)                          :
  e.kind == ND_NEG      ? (e.ty = e.lhs.ty)                                                                  :
  e.kind == ND_ASSIGN   ? e.lhs.ty.kind == TY_ARRAY                                                           ? error_tok e.lhs.tok "not an lvalue"                   :
                             e.lhs.ty.kind != TY_STRUCT && ! is_type_equal e.rhs.ty e.lhs.ty               ? (e.rhs = new_cast e.rhs e.lhs.ty)                      :
                                                                                                                      (e.ty = e.lhs.ty)                                         :
  e.kind == ND_EQ      ||
  e.kind == ND_NE      ||
  e.kind == ND_LT      ||
  e.kind == ND_LE      ||
  e.kind == ND_GT      ||
  e.kind == ND_GE       ? (e.ty = ty_bool)                                                                    :
  e.kind == ND_LOGOR   || 
  e.kind == ND_LOGAND   ? usual_arith_conv &e.lhs &e.rhs && (e.ty = e.lhs.ty)                          :
  e.kind == ND_FUNCALL  ? (e.ty = e.func_ty.return_ty)                                                     :
  e.kind == ND_NOT      ? (e.ty = ty_bool)                                                                    :
  e.kind == ND_BITNOT  ||
  e.kind == ND_SHL     ||
  e.kind == ND_SHR      ? (e.ty = e.lhs.ty)                                                                :
  e.kind == ND_VAR      ? (e.ty = e.var.ty)                                                                :
  e.kind == ND_COND     ? e.then.ty.kind == TY_VOID || e.els.ty.kind == TY_VOID                            ? (e.ty = ty_void)                                             :
                                                                                                                      usual_arith_conv &e.then &e.els && (e.ty = e.then.ty) :
  e.kind == ND_COMMA    ? (e.ty = e.rhs.ty)                                                                :
    //if e.lhs.ty/*.kind != TY_VOID*/ error_tok(e.tok "value may not be discarded by comma expression without a cast to void");
  e.kind == ND_MEMBER   ? (e.ty = e.member.ty)                                                             :
  e.kind == ND_ADDR     ? (e.ty = pointer_to (e.lhs.ty.kind == TY_ARRAY ? e.lhs.ty.base : e.lhs.ty)) :
  e.kind == ND_DEREF    ? !e.lhs.ty.base ? error_tok e.tok "invalid pointer dereference" : e.lhs.ty.base.kind == TY_VOID ? error_tok e.tok "dereferencing a void pointer" : (e.ty = e.lhs.ty.base) :
  e.kind == ND_CAS      ?
    add_type e.cas_addr&&
    add_type e.cas_old &&
    add_type e.cas_new &&
    (e.ty = ty_bool)   &&
    e.cas_addr.ty.kind != TY_PTR ? error_tok e.cas_addr.tok "pointer expected" :
    e.cas_old .ty.kind != TY_PTR ? error_tok e.cas_old .tok "pointer expected" :
                                      0->                                                   :
  e.kind == ND_EXCH     ? e.lhs.ty.kind != TY_PTR ? error_tok e.cas_addr.tok "pointer expected" : (e.ty = e.lhs.ty.base) : 0->;;;
