# "chub.hb"

export 
  ty_void @Type = &new Type { TY_VOID  1  1 ;
  ty_bool @Type = &new Type { TY_BOOL  1  1 ;
  ty_i8   @Type = &new Type { TY_I08   1  1 ;
  ty_i16  @Type = &new Type { TY_I16   2  2 ;
  ty_i32  @Type = &new Type { TY_I32   4  4 ;
  ty_i64  @Type = &new Type { TY_I64   8  8 ;;

new_type(kind TypeKind size i32 alignment i32) @Type = return
cast @Type calloc 1ul sizeof Type is t t
:; (t.kind      = kind     )
:; (t.size      = size     )
:; (t.alignment = alignment)
;;

export format_type(t @Type s @i8) = return
!t ? strcat s "undefined" :
t.kind is c
( c == TY_VOID  ) ? strcat s "void"        :
( c == TY_BOOL  ) ? strcat s "bool"        :
( c == TY_I08   ) ? strcat s "i8"          :
( c == TY_I16   ) ? strcat s "i16"         :
( c == TY_I32   ) ? strcat s "i32"         :
( c == TY_I64   ) ? strcat s "i64"         :
( c == TY_ENUM  ) ? strcat s "enum"        :
( c == TY_STRUCT) ? strcat s "struct"      :
( c == TY_RING  ) ? strcat s "% "          :; format_type t.a s :
( c == TY_ARRAY ) ? strcat s "[]"          :; format_type t.a s :
( c == TY_PTR   ) ? strcat s "@"           :; format_type t.a s :
( c == TY_FUNC  ) ? strcat s "("           :;             t.a.s
        is p (p for p (!!p && p.s          :; format_type p   s
        ) as void) ;: cast void
                    strcat s ")"           :; format_type t.a s :
strcat s "???" as void;;

is_function_type_equal(p @Type q@Type) bool = while !(!p || !q) { if ! type_equal p q return false; (p = p.s); (q = q.s);; return p == q;;
export type_equal(t @Type u @Type) bool = return
  !!t &&
  !!u &&
  t.kind is c (
    t == u || (
      !!t.o ? type_equal t.o u :
      !!u.o ? type_equal t u.o :
      ( c == u.kind     && (
        c == TY_VOID    ||  
        c == TY_BOOL    ||((
            c == TY_I08  ||
            c == TY_I16 ||
            c == TY_I32   ||
            c == TY_I64)  ? true          :
            (c == TY_FUNC)  ? ! type_equal t.a u.a    ? false :
                          is_function_type_equal t.a.s u.a.s  :
            (c == TY_ARRAY) ? ! type_equal t.a u.a              ? false :
                          (t.array_len == u.array_len)                :
            (c == TY_PTR      ||
             c == TY_RING  )   ? type_equal t.a u.a                :
                          false                                             )))));;

export copy_type(t @Type) @Type = return
  cast @Type calloc 1ul sizeof Type is u
  (u@ = t@) ;:
  (u.o = t) ;:
  u;;
export pointer_to(base@ Type)@ Type = return
  new_type TY_PTR 8 8 is t
  (t.a = base) ;:
  t;;
export ring_of(base @Type) @Type = return
  new_type TY_RING base.size base.alignment is t
  (t.a = base) ;:
  t;;
export func_type(return_ty@ Type)@ Type = return
  new_type TY_FUNC 1 1 is t
  (t.a = return_ty) ;:
  t;;
export array_of(base @Type len i32)@ Type = return
  new_type TY_ARRAY (base.size * len) base.alignment is t
  (t.a = base) ;:
  (t.array_len = len) ;:
  t;;
export enum_type  () @Type = return new_type TY_ENUM 4 4;;
export struct_type() @Type = return new_type TY_STRUCT 0 1;;