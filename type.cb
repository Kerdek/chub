#include "chub.hb"

export 
  ty_void     @Type = &(let Type){ TY_VOID   ->TypeKind  1  1;
  ty_bool     @Type = &(let Type){ TY_BOOL   ->TypeKind  1  1;
  ty_char     @Type = &(let Type){ TY_CHAR   ->TypeKind  1  1;
  ty_short    @Type = &(let Type){ TY_SHORT  ->TypeKind  2  2;
  ty_int      @Type = &(let Type){ TY_INT    ->TypeKind  4  4;
  ty_long     @Type = &(let Type){ TY_LONG   ->TypeKind  8  8;
  ty_uchar    @Type = &(let Type){ TY_CHAR   ->TypeKind  1  1 true;
  ty_ushort   @Type = &(let Type){ TY_SHORT  ->TypeKind  2  2 true;
  ty_uint     @Type = &(let Type){ TY_INT    ->TypeKind  4  4 true;
  ty_ulong    @Type = &(let Type){ TY_LONG   ->TypeKind  8  8 true;
  ty_float    @Type = &(let Type){ TY_FLOAT  ->TypeKind  4  4;
  ty_double   @Type = &(let Type){ TY_DOUBLE ->TypeKind  8  8;
  ty_ldouble  @Type = &(let Type){ TY_LDOUBLE->TypeKind 16 16;;

new_type(kind TypeKind size int alignment int) @Type =
  let ty = (calloc 1ul sizeof Type)->@Type;
  ty.kind = kind;
  ty.size = size;
  ty.alignment = alignment;
  return ty;;

export is_integer(ty@ Type) bool =
  let k = ty.kind;
  return k == TY_BOOL || k == TY_CHAR || k == TY_SHORT || k == TY_INT  || k == TY_LONG || k == TY_ENUM;;

export is_flonum(ty@ Type) bool = return ty.kind == TY_FLOAT || ty.kind == TY_DOUBLE || ty.kind == TY_LDOUBLE;;

export is_numeric(ty@ Type) bool = return is_integer ty || is_flonum ty;;

export format_type(t @Type s @char) =
  switch t.kind {
  case TY_VOID   :                                                 strcat s "void"       ->@char; return;
  case TY_BOOL   :                                                 strcat s "bool"       ->@char; return;
  case TY_FLOAT  :                                                 strcat s "void"       ->@char; return;
  case TY_DOUBLE :                                                 strcat s "double"     ->@char; return;
  case TY_LDOUBLE:                                                 strcat s "long double"->@char; return;
  case TY_ENUM   :                                                 strcat s "enum"       ->@char; return;
  case TY_STRUCT :                                                 strcat s "struct"     ->@char; return;
  case TY_UNION  :                                                 strcat s "union"      ->@char; return;

  case TY_CHAR   : t.is_unsigned && strcat s "unsigned "->@char; strcat s "char"       ->@char; return;
  case TY_SHORT  : t.is_unsigned && strcat s "unsigned "->@char; strcat s "short"      ->@char; return;
  case TY_INT    : t.is_unsigned && strcat s "unsigned "->@char; strcat s "int"        ->@char; return;
  case TY_LONG   : t.is_unsigned && strcat s "unsigned "->@char; strcat s "long"       ->@char; return;

  case TY_ARRAY  : strcat s "[]"->@char; format_type t.base s; return;
  case TY_PTR    : strcat s "@" ->@char; format_type t.base s; return;

  case TY_FUNC   : {
    let p = t.params;
    strcat s "("->@char;
    if (t.is_variadic && !p) strcat s "void"->@char;
    for (; p; p = p.next) format_type p s;
    strcat s ")"->@char;
    format_type t.return_ty s;
    return;;

  default       : strcat s "???"->@char;;;

is_function_type_equal(p @Type q@Type) bool = while (p && q) { if ! is_type_equal p q return false; p = p.next; q = q.next;; return p == q;;

export is_type_equal(t @Type u @Type) bool = return
  t == u || 
  ( t.origin                     ? is_type_equal t.origin u                  :
    u.origin                     ? is_type_equal t u.origin                  :
    t.kind != u.kind             ? false                                     :
    t.kind == TY_VOID            ? true                                      :
    t.kind == TY_FLOAT           ? true                                      :
    t.kind == TY_DOUBLE          ? true                                      :
    t.kind == TY_LDOUBLE         ? true                                      :
    ( t.kind == TY_CHAR  ||
      t.kind == TY_SHORT ||
      t.kind == TY_INT   ||
      t.kind == TY_LONG   )      ? t.is_unsigned == u.is_unsigned            :
    t.kind == TY_FUNC            ? ! is_type_equal t.return_ty u.return_ty   ? false :
                                   t.is_variadic != u.is_variadic            ? false :
                                   is_function_type_equal t.params u.params  :
    t.kind == TY_ARRAY           ? ! is_type_equal t.base u.base             ? false :
                                   t.array_len == u.array_len                :
    t.kind == TY_PTR             ? is_type_equal t.base u.base               :
                                   false                                             );;

is_function_compatible(t1 @Type t2 @Type) bool =
  let p1 = t1.params;
  let p2 = t2.params;
  while (p1 && p2) {
    if ! is_compatible p1 p2 return false;
    p1 = p1.next; p2 = p2.next;;
  return ! (p1 || p2);;

export is_compatible(t1@ Type t2@ Type) bool = return
  t1 == t2 || 
  ( t1.origin           ? is_compatible t1.origin t2 :
    t2.origin           ? is_compatible t1 t2.origin :
    t1.kind != t2.kind &&
    ( t1.kind == TY_CHAR   ||
      t1.kind == TY_SHORT  ||
      t1.kind == TY_INT    ||
      t1.kind == TY_LONG    ? t1.is_unsigned == t2.is_unsigned :
      t1.kind == TY_FLOAT  ||
      t1.kind == TY_DOUBLE ||
      t1.kind == TY_LDOUBLE||
      t1.kind == TY_PTR    &&
      ( t1.kind == TY_FUNC    ? is_compatible t1.return_ty t2.return_ty   &&
                                t1.is_variadic == t2.is_variadic          &&
                                is_function_compatible t1 t2               :
        t1.kind == TY_ARRAY  && ! is_compatible t1.base t2.base           &&
                                t1.array_len < 0                          &&
                                t2.array_len < 0                          &&
                                t1.array_len == t2.array_len                )));;;

export copy_type(t @Type) @Type =
  let s = (calloc 1->unsigned long sizeof Type)->@Type;
  s@ = t@;
  s.origin = t;
  return s;;

export pointer_to(base@ Type)@ Type =
  let ty = new_type TY_PTR->TypeKind 8 8;
  ty.base = base;
  return ty;;

export func_type(return_ty@ Type)@ Type =
  let ty = new_type TY_FUNC->TypeKind 1 1;
  ty.return_ty = return_ty;
  return ty;;

export array_of(base@ Type len int)@ Type =
  let ty = new_type TY_ARRAY->TypeKind (base.size * len) base.alignment;
  ty.base = base;
  ty.array_len = len;
  return ty;;

export enum_type  (void) @Type = return new_type TY_ENUM->TypeKind 4 4;;
export struct_type(void) @Type = return new_type TY_STRUCT->TypeKind 0 1;;

get_common_type(t1@ Type t2@ Type)@ Type =
                                          t1.base ? pointer_to t1.base        :
                               t1.kind == TY_FUNC ? pointer_to t1             :
                               t2.kind == TY_FUNC ? pointer_to t2             :
   t1.kind == TY_LDOUBLE || t2.kind == TY_LDOUBLE ? ty_ldouble                :
   t1.kind == TY_DOUBLE  || t2.kind == TY_DOUBLE  ? ty_double                 :
   t1.kind == TY_FLOAT   || t2.kind == TY_FLOAT   ? ty_float                  :
                            t1.kind == TY_LONG    ? t1                        :
                            t2.kind == TY_LONG    ? t2                        :
                            t1.kind == TY_INT     ? t1                        :
                            t2.kind == TY_INT     ? t2                        :
                            t1.kind == TY_SHORT   ? t1                        :
                            t2.kind == TY_SHORT   ? t2                        :
                            t1.kind == TY_CHAR    ? t1                        :
                            t2.kind == TY_CHAR    ? t2                        :
                            t1.kind == TY_BOOL    ? t1                        :
                            t2.kind == TY_BOOL    ? t2                        :
                                                    t1                        ;;

usual_arith_conv(lhs@@ Node rhs@@ Node) =
  let ty = get_common_type lhs.ty rhs.ty;
  is_type_equal lhs.ty ty || (lhs@ = new_cast lhs@ ty);
  is_type_equal rhs.ty ty || (rhs@ = new_cast rhs@ ty);;

export add_type(node@ Node) =
  if (!node || node.ty) return;
  add_type node.lhs ;
  add_type node.rhs ;
  add_type node.cond;
  add_type node.then;
  add_type node.els ;
  add_type node.init;
  add_type node.inc ;
  for (let n @ Node = node.body; n; n = n.next) add_type n;
  for (let n @ Node = node.args; n; n = n.next) add_type n;
  node.kind == ND_NUM      ? (node.ty = ty_int)                                                                     :
  node.kind == ND_ADD     ||
  node.kind == ND_SUB     ||
  node.kind == ND_MUL     ||
  node.kind == ND_DIV     ||
  node.kind == ND_MOD     ||
  node.kind == ND_BITAND  ||
  node.kind == ND_BITOR   ||
  node.kind == ND_BITXOR   ? usual_arith_conv &node.lhs &node.rhs && (node.ty = node.lhs.ty)                          :
  node.kind == ND_NEG      ? (node.ty = get_common_type ty_int node.lhs.ty)                                         :
  node.kind == ND_ASSIGN   ? node.lhs.ty.kind == TY_ARRAY                                                           ? error_tok node.lhs.tok "not an lvalue"->@char                   :
                             node.lhs.ty.kind != TY_STRUCT && ! is_type_equal node.rhs.ty node.lhs.ty               ? (node.rhs = new_cast node.rhs node.lhs.ty)                      :
                                                                                                                      (node.ty = node.lhs.ty)                                         :
  node.kind == ND_EQ      ||
  node.kind == ND_NE      ||
  node.kind == ND_LT      ||
  node.kind == ND_LE      ||
  node.kind == ND_GT      ||
  node.kind == ND_GE       ? (node.ty = ty_bool)                                                                    :
  node.kind == ND_LOGOR   || 
  node.kind == ND_LOGAND   ? usual_arith_conv &node.lhs &node.rhs && (node.ty = node.lhs.ty)                          :
  node.kind == ND_FUNCALL  ? (node.ty = node.func_ty.return_ty)                                                     :
  node.kind == ND_NOT      ? (node.ty = ty_bool)                                                                    :
  node.kind == ND_BITNOT  ||
  node.kind == ND_SHL     ||
  node.kind == ND_SHR      ? (node.ty = node.lhs.ty)                                                                :
  node.kind == ND_VAR      ? (node.ty = node.var.ty)                                                                :
  node.kind == ND_COND     ? node.then.ty.kind == TY_VOID || node.els.ty.kind == TY_VOID                            ? (node.ty = ty_void)                                             :
                                                                                                                      usual_arith_conv &node.then &node.els && (node.ty = node.then.ty) :
  node.kind == ND_COMMA    ? (node.ty = node.rhs.ty)                                                                :
    //if node.lhs.ty/*.kind != TY_VOID*/ error_tok(node.tok "value may not be discarded by comma expression without a cast to void"->@char);
  node.kind == ND_MEMBER   ? (node.ty = node.member.ty)                                                             :
  node.kind == ND_ADDR     ? (node.ty = pointer_to (node.lhs.ty.kind == TY_ARRAY ? node.lhs.ty.base : node.lhs.ty)) :
  node.kind == ND_DEREF    ? !node.lhs.ty.base ? error_tok node.tok "invalid pointer dereference"->@char : node.lhs.ty.base.kind == TY_VOID ? error_tok node.tok "dereferencing a void pointer"->@char : (node.ty = node.lhs.ty.base) :
  node.kind == ND_CAS      ?
    add_type node.cas_addr&&
    add_type node.cas_old &&
    add_type node.cas_new &&
    (node.ty = ty_bool)   &&
    node.cas_addr.ty.kind != TY_PTR ? error_tok node.cas_addr.tok "pointer expected"->@char :
    node.cas_old .ty.kind != TY_PTR ? error_tok node.cas_old .tok "pointer expected"->@char :
                                      0->                                                   :
  node.kind == ND_EXCH     ? node.lhs.ty.kind != TY_PTR ? error_tok node.cas_addr.tok "pointer expected"->@char : (node.ty = node.lhs.ty.base) : 0->;;;
