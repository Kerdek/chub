# "chub.hb"

export
  ty_null @Type
  ty_none @Type
  ty_i1   @Type
  ty_i8   @Type
  ty_i32  @Type
  ty_i64  @Type;

new_type(kind TypeKind size i32 align i32) @Type = return
cast @Type calloc 1ul sizeof Type is t t
:; (t.kind  = kind )
:; (t.size  = size )
:; (t.align = align)
;;

export format_type(t @Type s @i8) = return
&strcat      is f
&format_type is g
t.kind       is c

!t                ? f@ s "null"   :
( c == TY_VOID  ) ? f@ s "none"   :
( c == TY_BOOL  ) ? f@ s "i1"     :
( c == TY_I08   ) ? f@ s "i8"     :
( c == TY_I32   ) ? f@ s "i32"    :
( c == TY_I64   ) ? f@ s "i64"    :
( c == TY_ENUM  ) ? f@ s "enum"   :
( c == TY_STRUCT) ? f@ s "struct" :
( c == TY_RING  ) ? f@ s "% "     :; g@ t.a s :
( c == TY_ARRAY ) ? f@ s "[]"     :; g@ t.a s :
( c == TY_PTR   ) ? f@ s "@"      :; g@ t.a s :
( c == TY_FUNC  ) ? f@ s "("      :;
  t.a.s is p (p for p (!!p && p.s :; g@ p   s ) as none) ;:
                    f@ s ")"      :; g@ t.a s :
                    f@ s "???"

as none
;;

is_function_type_equal(p @Type q@Type) bool = return
(true for _ (!!p && !!q && type_equal p q && (p = p.s) ;: (q = q.s) ) as none) ;: (p == q) ;;

export type_equal(t @Type u @Type) bool = return
  !!t &&
  !!u &&
  t.kind is c (
    t == u || (
      !!t.o ? type_equal t.o u :
      !!u.o ? type_equal t u.o :
      ( c == u.kind     && (
        c == TY_VOID    ||  
        c == TY_BOOL    ||((
            c == TY_I08  ||
            c == TY_I32   ||
            c == TY_I64)  ? true          :
            (c == TY_FUNC)  ? ! type_equal t.a u.a    ? false :
                          is_function_type_equal t.a.s u.a.s  :
            (c == TY_ARRAY) ? ! type_equal t.a u.a              ? false :
                          (t.array_len == u.array_len)                :
            (c == TY_PTR      ||
             c == TY_RING  )   ? type_equal t.a u.a                :
                          false                                             )))));;

export copy_type(t @Type) @Type = return
   cast @Type calloc 1ul sizeof Type is u u
:; (u@ = t@)
;: (u.o = t)
;;
export ptr_of(base@ Type)@ Type = return
   new_type TY_PTR 8 8 is t t
:; (t.a = base)
;;
export ring_of(base @Type) @Type = return
   new_type TY_RING base.size base.align is t t
:; (t.a = base)
;;
export func_of(return_ty@ Type)@ Type = return
   new_type TY_FUNC 1 1 is t t
:; (t.a = return_ty)
;;
export array_of(base @Type len i32)@ Type = return
   new_type TY_ARRAY (base.size * len) base.align is t t
:; (t.a = base)
;: (t.array_len = len)
;;
export enum_of  () @Type = return new_type TY_ENUM   4 4;;
export struct_of() @Type = return new_type TY_STRUCT 0 1;;