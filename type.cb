#include "chub.hb"

export 
  ty_void     @Type = &new Type { TY_VOID     1  1     ;
  ty_bool     @Type = &new Type { TY_BOOL     1  1     ;
  ty_char     @Type = &new Type { TY_CHAR     1  1     ;
  ty_short    @Type = &new Type { TY_SHORT    2  2     ;
  ty_int      @Type = &new Type { TY_INT      4  4     ;
  ty_long     @Type = &new Type { TY_LONG     8  8     ;
  ty_uchar    @Type = &new Type { TY_CHAR     1  1 true;
  ty_ushort   @Type = &new Type { TY_SHORT    2  2 true;
  ty_uint     @Type = &new Type { TY_INT      4  4 true;
  ty_ulong    @Type = &new Type { TY_LONG     8  8 true;
  ty_float    @Type = &new Type { TY_FLOAT    4  4     ;
  ty_double   @Type = &new Type { TY_DOUBLE   8  8     ;
  ty_ldouble  @Type = &new Type { TY_LDOUBLE 16 16     ;;

new_type(kind TypeKind size int alignment int) @Type = return
cast @Type calloc 1ul sizeof Type is t t
:; (t.kind      = kind     )
:; (t.size      = size     )
:; (t.alignment = alignment)
;;

export is_integer(t@ Type) bool = return
t.kind is c
(  c == TY_BOOL
|| c == TY_CHAR
|| c == TY_SHORT
|| c == TY_INT
|| c == TY_LONG
|| c == TY_ENUM
 ) ;;

export is_flonum(t@ Type) bool = return
t.kind is c
(  c == TY_FLOAT
|| c == TY_DOUBLE
|| c == TY_LDOUBLE
 ) ;;

export is_numeric(t@ Type) bool = return is_integer t || is_flonum t;;
format_function_type(p @Type s @char) = for (; p; p = p.s) format_type p s;;
export format_type(t @Type s @char) = return
t.kind is c
( c == TY_VOID    ) ? strcat s "void"        :
( c == TY_BOOL    ) ? strcat s "bool"        :
( c == TY_FLOAT   ) ? strcat s "float"       :
( c == TY_DOUBLE  ) ? strcat s "double"      :
( c == TY_LDOUBLE ) ? strcat s "long double" :
( c == TY_ENUM    ) ? strcat s "enum"        :
( c == TY_STRUCT  ) ? strcat s "struct"      :
( c == TY_UNION   ) ? strcat s "union"       :
( c == TY_ARRAY   ) ? strcat s "[]" :; format_type t.base s :
( c == TY_PTR     ) ? strcat s "@"  :; format_type t.base s :
( c == TY_CHAR    ) ? (t.is_unsigned && strcat s "unsigned " as void) ;: strcat s "char"  :
( c == TY_SHORT   ) ? (t.is_unsigned && strcat s "unsigned " as void) ;: strcat s "short" :
( c == TY_INT     ) ? (t.is_unsigned && strcat s "unsigned " as void) ;: strcat s "int"   :
( c == TY_LONG    ) ? (t.is_unsigned && strcat s "unsigned " as void) ;: strcat s "long"  :
( c == TY_FUNC    ) ? 
  (cast void strcat s "(")  ;:
  t.params is p
    (t.is_variadic && !p && strcat s "void" as void) ;:
    format_function_type p s ;:
  strcat s ")" :;
  format_type t.return_ty s :
strcat s "???" as void;;
is_function_type_equal(p @Type q@Type) bool = while !(!p || !q) { if ! type_equal p q return false; (p = p.s); (q = q.s);; return p == q;;
export type_equal(t @Type u @Type) bool = return
  t.kind is c (
    t == u || (
      !!t.origin      ? type_equal t.origin u :
      !!u.origin      ? type_equal t u.origin :
      ( c == u.kind     && (
        c == TY_VOID    ||  
        c == TY_BOOL    ||
        c == TY_FLOAT   ||
        c == TY_DOUBLE  ||
        c == TY_LDOUBLE || ((
            c == TY_CHAR  ||
            c == TY_SHORT ||
            c == TY_INT   ||
            c == TY_LONG)  ? (t.is_unsigned == u.is_unsigned)          :
            (c == TY_FUNC)  ? ! type_equal t.return_ty u.return_ty    ? false :
                          (t.is_variadic != u.is_variadic)            ? false :
                          is_function_type_equal t.params u.params  :
            (c == TY_ARRAY) ? ! type_equal t.base u.base              ? false :
                          (t.array_len == u.array_len)                :
            (c == TY_PTR)   ? type_equal t.base u.base                :
                          false                                             )))));;

export copy_type(t @Type) @Type = return
  cast @Type calloc 1ul sizeof Type is u
  (u@ = t@) ;:
  (u.origin = t) ;:
  u;;
export pointer_to(base@ Type)@ Type = return
  new_type TY_PTR 8 8 is t
  (t.base = base) ;:
  t;;
export func_type(return_ty@ Type)@ Type = return
  new_type TY_FUNC 1 1 is t
  (t.return_ty = return_ty) ;:
  t;;
export array_of(base@ Type len int)@ Type = return
  new_type TY_ARRAY (base.size * len) base.alignment is t
  (t.base = base) ;:
  (t.array_len = len) ;:
  t;;
export enum_type  (void) @Type = return new_type TY_ENUM 4 4;;
export struct_type(void) @Type = return new_type TY_STRUCT 0 1;;
get_common_type(t1@ Type t2@ Type)@ Type =
                                        !!t1.base ? pointer_to t1.base        :
  (                             t1.kind == TY_FUNC) ? pointer_to t1             :
  (                             t2.kind == TY_FUNC) ? pointer_to t2             :
  ( t1.kind == TY_LDOUBLE || t2.kind == TY_LDOUBLE) ? ty_ldouble                :
  ( t1.kind == TY_DOUBLE  || t2.kind == TY_DOUBLE ) ? ty_double                 :
  ( t1.kind == TY_FLOAT   || t2.kind == TY_FLOAT  ) ? ty_float                  :
  (                          t1.kind == TY_LONG   ) ? t1                        :
  (                          t2.kind == TY_LONG   ) ? t2                        :
  (                          t1.kind == TY_INT    ) ? t1                        :
  (                          t2.kind == TY_INT    ) ? t2                        :
  (                          t1.kind == TY_SHORT  ) ? t1                        :
  (                          t2.kind == TY_SHORT  ) ? t2                        :
  (                          t1.kind == TY_CHAR   ) ? t1                        :
  (                          t2.kind == TY_CHAR   ) ? t2                        :
  (                          t1.kind == TY_BOOL   ) ? t1                        :
  (                          t2.kind == TY_BOOL   ) ? t2                        :
                                                    t1                        ;;

export usual_arith_conv(a@@ Node b@@ Node) = return
  get_common_type a.t b.t is t
  (!type_equal a.t t && (a@ = new_cast a.j a@ t) as void) ;:
  (!type_equal b.t t && (b@ = new_cast b.j b@ t) as void) ;:
  none;;

export add_type(e@ Node) =
  if (!e || !!e.t) return;
  add_type e.a ;
  add_type e.b ;
  add_type e.cond;
  add_type e.then;
  add_type e.els ;
  add_type e.init;
  add_type e.inc ;
  for (let n @ Node = e.body; n; n = n.s) add_type n;
  for (let n @ Node = e.args; n; n = n.s) add_type n;
  (e.kind == ND_NUM   )   ? (e.t = ty_int)                                                                      :
  (e.kind == ND_ADD      ||
   e.kind == ND_SUB      ||
   e.kind == ND_MUL      ||
   e.kind == ND_DIV      ||
   e.kind == ND_MOD      ||
   e.kind == ND_BITAND   ||
   e.kind == ND_BITOR    ||
   e.kind == ND_BITXOR)   ? usual_arith_conv &e.a &e.b ;: (e.t = e.a.t)                            :
  (e.kind == ND_NEG   )   ? (e.t = e.a.t)                                                                    :
  (e.kind == ND_ASSIGN)   ? (e.a.t.kind == TY_ARRAY)                                                           ? (error_tok e.a.j "not an lvalue")                   :
                             (e.a.t.kind != TY_STRUCT && ! type_equal e.b.t e.a.t)               ? (e.b = new_cast e.j e.b e.a.t)                      :
                                                                                                                      (e.t = e.a.t)                                         :
  (e.kind == ND_EQ       ||
   e.kind == ND_NE       ||
   e.kind == ND_LT       ||
   e.kind == ND_LE       ||
   e.kind == ND_GT       ||
   e.kind == ND_GE     )  ? (e.t = ty_bool)                                                                    :
  (e.kind == ND_LOGOR    || 
   e.kind == ND_LOGAND )  ? usual_arith_conv &e.a &e.b ;: (e.t = e.a.t)                          :
  (e.kind == ND_FUNCALL)  ? (e.t = e.func_ty.return_ty)                                                     :
  (e.kind == ND_NOT    )  ? (e.t = ty_bool)                                                                    :
  (e.kind == ND_BITNOT   ||
   e.kind == ND_SHL      ||
   e.kind == ND_SHR    )  ? (e.t = e.a.t)                                                                :
  (e.kind == ND_VAR    )  ? (e.t = e.var.t)                                                                :
  (e.kind == ND_COND   )  ? (e.then.t.kind == TY_VOID || e.els.t.kind == TY_VOID)                            ? (e.t = ty_void)                                             :
                                                                                                                      usual_arith_conv &e.then &e.els ;: (e.t = e.then.t):
  (e.kind == ND_COMMA   ) ? (e.t = e.b.t)                                                                :
    //if e.a.t/*.kind != TY_VOID*/ error_tok(e.j "value may not be discarded by comma expression without a cast to void");
  (e.kind == ND_MEMBER  ) ? (e.t = e.member.t as @Type)                                                             :
  (e.kind == ND_ADDR    ) ? (e.t = pointer_to ((e.a.t.kind == TY_ARRAY) ? e.a.t.base : e.a.t)) :
  (e.kind == ND_DEREF   ) ? !e.a.t.base ? (error_tok e.j "invalid pointer dereference") : (e.a.t.base.kind == TY_VOID) ? (error_tok e.j "dereferencing a void pointer") : (e.t = e.a.t.base) :
  (e.kind == ND_CAS     ) ?
    add_type e.cas_addr ;:
    add_type e.cas_old  ;:
    add_type e.cas_new  ;:
    (e.t = ty_bool)    ;:
    (e.cas_addr.t.kind != TY_PTR) ? (error_tok e.cas_addr.j "pointer expected") :
    (e.cas_old .t.kind != TY_PTR) ? (error_tok e.cas_old .j "pointer expected") :
                                      none                                                   :
  (e.kind == ND_EXCH)     ? (e.a.t.kind != TY_PTR) ? (error_tok e.cas_addr.j "pointer expected") : (e.t = e.a.t.base) : none;;;
