export xisid  (x X) nat = (isaz x.kp@ or isAZ x.kp@)
export xisstr (x X) nat = (x.kp@ == '\"')
export xisnum (x X) nat = is09 x.kp@
export xischr (x X) nat = (x.kp@ == '\'')

xeq  (x X c byte) nat  = (x.p@ == c)
xseq (x X c byte) nat  = { (x.p@ or diag "unexpected end of file") (x.p^1 == c) }
xadv (x X       ) none = {
  (x.p@ or diag "unexpected end of file")
  (x.p = &x.p^1)
  xeq x '\n' ? {
    (x.col = 1)
    (x.line = x.line + 1)
  } (x.col = x.col + 1)
}

comment(x X) nat = {
  (xeq x '/' and xseq x '*') then
  xadv x
  xadv x
  { 1 for _
    (xeq x '*' and xseq x '/') ?
      { xadv x xadv x 0 }
      { xadv x        1 } }
  1
}

ws(x X) nat = {
  isws x.p@ then
  xadv x
  1
}

number(x X) nat = {
  x.p is q
  { 1 for _ is09 x.p@ then xadv x 1 }
  (x.p != q) then
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

string(x X) nat = {
  xeq x '"' then
  x.p is q
  xadv x
  { 1 for _
    { 1 for _ xeq x '\\' then xadv x xadv x 1}
    (xeq x '\n' and diag "newline in string literal")
    not xeq x '"' then
    xadv x
    1
  }
  xadv x
  (x.kp = q)
  (x.kn = x.p - q)
  gs x ".section .data..s" gn x (x.line * 10000 + x.col) glf x
  gs x ".s" gn x (x.line * 10000 + x.col) gc x ':' gs x ".string \""
  { &x.kp^1 for i (i < &x.kp^(x.kn - 1)) then gc x i@ &i^1 }
  gc x '\"' glf x
  gs x ".previous" glf x
  1
}

char(x X) nat = {
  xeq x '\'' then
  x.p is q
  xadv x
  { xeq x '\\' then
    xadv x }
  xadv x
  (xeq x '\'' or diag "expected '")
  xadv x
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

id(x X) nat = {
  x.p is q
  { 1 for _ isid x.p@ then xadv x 1 }
  (x.p != q) then
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

sw1(x X a byte       ) nat = { xeq x a then xadv x 1 }
sw2(x X a byte b byte) nat = { xeq x a then xseq x b then xadv x xadv x 1 }

punct(x X) nat = {
  x.p is q
  { sw2 x '=' '=' else
    sw2 x '!' '=' else
    sw2 x '<' '=' else
    sw2 x '>' '=' else
    sw2 x '<' '<' else
    sw2 x '>' '>' else
    sw2 x '/' '/' else
    sw1 x '='     else
    sw1 x '<'     else
    sw1 x '>'     else
    sw1 x '+'     else
    sw1 x '-'     else
    sw1 x '*'     else
    sw1 x '/'     else
    sw1 x '&'     else
    sw1 x '|'     else
    sw1 x '@'     else
    sw1 x '#'     else
    sw1 x '{'     else
    sw1 x '}'     else
    sw1 x '('     else
    sw1 x ')'     else
    sw1 x '['     else
    sw1 x ']'     else
    sw1 x '!'     else
    sw1 x '?'     else
    sw1 x ':'     else
    sw1 x ';'     else
    sw1 x ','     else
    sw1 x '.'     else
    sw1 x '~'     else
    sw1 x '^'     else
    sw1 x '$'     else
    sw1 x '`'     else
    sw1 x '%'
  }
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

nonws(x X) nat = {
  number x else
  string x else
  char   x else
  id     x else
  punct  x
}

export token(x X) none = {
  { 1 for _
    comment x else
    ws      x      }
  x.p@ ?
    { nonws   x else
      diag "invalid token" }
    (x.kp = cast @byte 0)
}