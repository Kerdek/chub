export JID  () none = 0
export JPCT () none = 0
export JCHR () none = 0
export JSTR () none = 0
export JNUM () none = 0

xeq  (x X c byte) nat  = (x.c0 == c)
xseq (x X c byte) nat  = { (x.c0 or diag "unexpected end of file") (x.c1 == cast byte -1 and (read &x.c1 1 or (x.c1 = cast byte 0))) (x.c1 == c) }
xadv (x X       ) none = {
  (x.c0 or diag "unexpected end of file")
  (x.p = &x.p^1)
  (x.col = x.col + 1)
  { xeq x '\n' then
    (x.col = 1)
    (x.line = x.line + 1) }
  (x.c1 == cast byte -1) ?
    (read &x.c0 1 or (x.c0 = cast byte 0))
    { (x.c0 = x.c1) (x.c1 = cast byte -1) }
  (x.p@ = x.c0)
}

ntoken(q TokenKind a @byte x X) K = {
  cast K alloc sizeof Token is k
  (k.s    = 0    )
  (k.q    = q    )
  (k.p    = a  )
  (k.n    = x.p - a)
  (k.line = x.line)
  (k.col = x.col)
  k
}

comment(x X) nat = {
  (xeq x '/' and xseq x '*') then
  xadv x
  xadv x
  { 1 for _
    (xeq x '*' and xseq x '/') ?
      { xadv x xadv x 0 }
      { xadv x        1 } }
  1
}

ws(x X) nat = {
  isws x.p@ then
  xadv x
  1
}

number(x X) nat = {
  x.p is q
  { 1 for _ is09 x.p@ then xadv x 1 }
  (x.p != q) then
  (x.k@ = ntoken &JNUM q x)
  1
}

string(x X) nat = {
  xeq x '"' then
  x.p is q
  xadv x
  { 1 for _
    { 1 for _ xeq x '\\' then xadv x xadv x 1}
    (xeq x '\n' and diag "newline in string literal")
    not xeq x '"' then
    xadv x
    1
  }
  xadv x
  ntoken &JSTR q x is k
  gs ".s" gn cast nat k gc ':' gs ".string \""
  { &k.p^1 for i (i < &k.p^(k.n - 1)) then gc i@ &i^1 }
  gc '\"' glf
  (x.k@ = k)
  1
}

char(x X) nat = {
  xeq x '\'' then
  x.p is q
  xadv x
  { xeq x '\\' then
    xadv x }
  xadv x
  (xeq x '\'' or diag "expected '")
  xadv x
  (x.k@ = ntoken &JCHR q x)
  1
}

id(x X) nat = {
  x.p is q
  { 1 for _ isid x.p@ then xadv x 1 }
  (x.p != q) then
  (x.k@ = ntoken &JID q x)
  1
}

sw1(x X a byte       ) nat = { xeq x a then xadv x 1 }
sw2(x X a byte b byte) nat = { xeq x a then xseq x b then xadv x xadv x 1 }

punct(x X) nat = {
  x.p is q
  { sw2 x '=' '=' else
    sw2 x '!' '=' else
    sw2 x '<' '=' else
    sw2 x '>' '=' else
    sw2 x '<' '<' else
    sw2 x '>' '>' else
    sw2 x '/' '/' else
    sw1 x '='     else
    sw1 x '<'     else
    sw1 x '>'     else
    sw1 x '+'     else
    sw1 x '-'     else
    sw1 x '*'     else
    sw1 x '/'     else
    sw1 x '&'     else
    sw1 x '|'     else
    sw1 x '@'     else
    sw1 x '#'     else
    sw1 x '{'     else
    sw1 x '}'     else
    sw1 x '('     else
    sw1 x ')'     else
    sw1 x '['     else
    sw1 x ']'     else
    sw1 x '!'     else
    sw1 x '?'     else
    sw1 x ':'     else
    sw1 x ';'     else
    sw1 x ','     else
    sw1 x '.'     else
    sw1 x '~'     else
    sw1 x '^'     else
    sw1 x '$'     else
    sw1 x '`'     else
    sw1 x '%'
  }
  (x.k@ = ntoken &JPCT q x)
  1
}

nonws(x X) nat = {
  number x else
  string x else
  char   x else
  id     x else
  punct  x
}

export token(x X) none = {
  { 1 for _
    comment x else
    ws      x      }
  x.p@ ?
    { nonws   x else
      diag "invalid token" }
    (x.k@ = cast K 0)
}