# span #

#
  a span for us is just a couple of pointers
  we're gonna use that for a couple things but the
  important one is to locate a token in the input
#

span--start (s)                  s
span--end   (s) add (span--start s) struct
struct-span ( )      span--end      struct

span-start (s) load (span--start s)
span-end   (s) load (span--end   s)

span-copy (a b)
pair-copy copy span--start copy span--end a b

span-equal (a b)
let span-start a starta
let span-start b startb
    streq starta sub starta span-end a
	      startb sub startb span-end b

span-init (s start end)
do  store (span--start s) start
    store (span--end   s) end

span-is (s lit)
let span-start s start
let span-end   s end
    substrcmpab lit start end

# location #

#
  loc just keeps track of line/column
#

loc--line  (l)                l
loc--col   (l) add (loc--line l) struct
struct-loc ( )      loc--col     struct

loc-load-line (s) load (loc--line s)
loc-load-col  (s) load (loc--col  s)

loc-copy (a b)
pair-copy copy loc--line
          copy loc--col  a b

loc--xr (x (l) l) store (x l) 1
loc--xf (x (l) l) inc   (x l)

loc--lr (l) loc--xr loc--line l
loc--lf (l) loc--xf loc--line l
loc--cr (l) loc--xr loc--col  l
loc--cf (l) loc--xf loc--col  l

loc--crlx (x (l) l)
do  loc--cr l
	x l

loc--crlf (l) loc--crlx loc--lf l
loc--crlr (l) loc--crlx loc--lr l

loc-init (l) loc--crlr l

loc-adv (a l)
if a (loc--crlf)
     (loc--cf  ) l

# caret #

#
  caret is where we use loc to keep track of line/col
  and we walk through the input at the same time
#

caret--ptr   (c)                  c
caret--loc   (c) add (caret--ptr  c) struct
struct-caret ( )      caret--loc     struct-loc

caret-ptr (c) load (caret--ptr c)
caret-loc (c) load (caret--loc c)

caret-copy (a b)
pair-copy     copy caret--ptr
          loc-copy caret--loc a b

caret-init (c ptr)
do  store (caret--ptr c) ptr
    loc-init (caret--loc c)

caret-peek (c) peek (caret-ptr c)

caret-adv (lf (a) c)
do  loc-adv (lf caret-peek c) (caret--loc c)
	inc (caret--ptr c)

# tokenizer state #

#
  here we pair caret and span to make a kind of caret for tokens.
  the span locates the token and the caret is positioned at the end
  of any trailing whitespace so we can look ahead to the next token.
#

token--span  (k)                   k
token--caret (k) add (token--span  k) struct-span
struct-token ( )      token--caret    struct-caret

token--set-span (k start end) span-init token--span k start end

token--read (nontext (c) text (c) k)
let (token--caret k) c
let (token--span  k) s
do  nontext c
if	caret-peek c
	let (caret-ptr c) start
	if  text c
		span-init s start (caret-ptr c)
		# invalid text #
		exit 6
	span-init s 0 0

token-copy (a b)
pair-copy  span-copy token--span
          caret-copy token--caret a b

token-init (read (impl (nontext (c) text (c) k) k) k in)
do  caret-init (token--caret k) in
    read token--read k

token-try-adv (read (impl (nontext (c) text (c) k) k) k)
and span-start token--span k
    read token--read k

token-adv (read (impl (nontext (c) text (c) k) k) k)
or  token-try-adv read k
    # unexpected end of tokens #
    exit 5

token-match (lex (c) k) lex (peek (span-start (token--span k)))

token-is (lit k) span-is (token--span k) lit

token-eat-lit (adv (k) k c)
and token-is c k
    adv k

token-equal (a b) span-equal (token--span a) (token--span b)

token-caret-peek (k) caret-peek (token--caret k)

token-put (out k)
let (span-start (token--span k)) a
let (span-end   (token--span k)) b
for a i
and cmpa i b
do  put-byte out (peek i)
    add 1 i

puts-mangle (out a)
do  put-byte out 'f
for a i
let (peek i) c
and c
do  put-bhex out c
    add 1 i

put-mangle (out a b)
do  put-byte out 'f
for a i
and cmpa i b
do  put-bhex out (peek i)
    add 1 i

token-mangle (out k)
put-mangle out (span-start (token--span k))
               (span-end   (token--span k))

# character ranges #

cmpin (a b c)
not or  cmpa a b
        cmpa c a

range-sq (a) cmpe  a '\'
range-dq (a) cmpe  a '\"
range-bs (a) cmpe  a '\\
range-hm (a) cmpe  a '#
range-qm (a) cmpe  a '?
range-lp (a) cmpe  a '(
range-rp (a) cmpe  a ')
range-us (a) cmpe  a '_
range-en (a) cmpe  a '-
range-sp (a) cmpe  a ' 
range-tb (a) cmpe  a '\t
range-lf (a) cmpe  a '\n
range-cr (a) cmpe  a '\r

range-09 (a) cmpin a '0 '9
range-AZ (a) cmpin a 'A 'Z
range-az (a) cmpin a 'a 'z

# lexer helpers #

lex-one (lf (a) c)
if  caret-peek c
    caret-adv lf c
    # unexpected end of file #
    exit 1

lex-by (by (a) lf (a) c)
and by (caret-peek c)
    caret-adv lf c

lex-escape (bs (c) skip (c) lex (c) c)
if  bs   c
    skip c
    lex  c

line-lex-one (c)
lex-one range-lf c

line-lex-by (by (a) c)
lex-by by range-lf c

# tokenizer helpers #

eat-group-one (lex (c) escape (c) c)
and not (lex c)
    escape c

eat-bunch (lex (c) c) repif lex c

eat-chunk (lex (c) escape (c) c)
and lex c
    escape c

eat-group (lex (c) escape (c) c)
and lex c
for 1 -
    eat-group-one lex escape c

# stack accounting #

pushpop (impl (out depth arg) out depth arg op (a b) size)
do  impl out depth arg
    store depth (op size (load depth))

fpop  (impl (out depth size) out depth size) pushpop impl out depth size add size
fpush (impl (out depth size) out depth size) pushpop impl out depth size sub size
pop   (impl (out depth reg ) out depth reg ) pushpop impl out depth reg  add 1
push  (impl (out depth reg ) out depth reg ) pushpop impl out depth reg  sub 1

# x86-64 implementation #

x86-64-ins0 (out s c)
do put-string out s
   put-byte   out c

x86-64-ins1  (out s) x86-64-ins0 out s ' 

x86-64-mnem1 (out s a)
do  put-seq  out s
    put-line out a

x86-64-mnem2 (out s a b)
do  put-seq  out s
do  put-list out a
    put-line out b

x86-64-cz (out)
do  put-seq  out "test"
do  put-list out "%rax"
    put-line out "%rax"

x86-64-label-id (out n)
do  put-byte out '.
do  put-number out n
    put-byte out '$

x86-64-jc (out n s)
do  put-seq out s
do  x86-64-label-id out n
    put-lf out

x86-64-jcn (out n s) x86-64-jc out n s

x86-64-czjc (out n s)
do  x86-64-cz out
    x86-64-jcn out n s

x86-64-je  (out n) x86-64-czjc out n "je"
x86-64-jne (out n) x86-64-czjc out n "jne"
x86-64-jmp (out n) x86-64-jcn  out n "jmp"

x86-64-rip (out)
do  put-list out "@GOTPCREL(%rip)"
    put-line out "%rax"

x86-64-load-rel (out then now)
do  put-number out (shl 3 (sub now then))
do  put-list out "(%rsp)"
	put-line out "%rax"

x86-64-if (j (out n) out)
let (load out) n
do  j out n
    n

x86-64-fpushpop (out y size ins)
and size
do  put-string out ins
do  put-number out (shl 3 size)
do  put-cm out
    put-line out "%rsp"

x86-64-str-label (out n)
do  put-string out ".s"
    put-number out n

x86-64-label-suf (out) put-line out ":"

x86-64-str-label-with (suf (out) out n)
do  x86-64-str-label out n
    suf out

x86-64-mov (out) put-seq out "mov"

x86-64-entry () "_start"

x86-64-pre (out)
do  put-seq  out ".globl "
do  put-line out x86-64-entry
do  put-seq  out ".equ"
do  put-list out x86-64-entry
do  puts-mangle out x86-64-entry
	put-lf out

x86-64-id (out k then now)
do  x86-64-mov out
if  then
    x86-64-load-rel out then now
	do  token-mangle out k
        x86-64-rip out

x86-64-addr (out k then now)
do  put-seq out "lea"
    x86-64-load-rel out then now

x86-64-lit (out k)
do  x86-64-mov out
do  put-string out "$"
do  token-put  out k
do  put-cm out
    put-line out "%rax"

x86-64-str (out k)
let (load out) n
do  put-string out ".section .text."
do  x86-64-str-label-with put-lf out n
do  x86-64-str-label-with x86-64-label-suf out n
do  put-list out ".string"
do  token-put out k
do  put-lf out
do  put-line out ".previous"
do  x86-64-mov out
    x86-64-str-label-with x86-64-rip out n

x86-64-and  (out  ) x86-64-if x86-64-je  out
x86-64-or   (out  ) x86-64-if x86-64-jne out
x86-64-else (out  ) x86-64-if x86-64-jmp out
x86-64-rep  (out n)           x86-64-jne out n

x86-64-label (out n)
do  x86-64-label-id out n 
    x86-64-label-suf out

x86-64-fpop  (out depth size) x86-64-fpushpop out depth size "add $"
x86-64-fpush (out depth size) x86-64-fpushpop out depth size "add $-"

x86-64-pushpop (out depth reg ins)
do  put-seq  out ins
    put-line out reg

x86-64-pop   (out depth reg )
x86-64-pushpop out depth reg "pop"

x86-64-push  (out depth reg )
x86-64-pushpop out depth reg "push"

x86-64-let (out depth)
let (load out) n
do  push x86-64-push out depth "%rax"
    n

x86-64-for (out depth)
let x86-64-let   out depth n
let x86-64-else  out m
do  x86-64-label out n
do  x86-64-mov out
do  put-list out "%rax"
do  put-line out "(%rsp)"
do  x86-64-label out m
    n

x86-64-buf (out depth)
let x86-64-let   out depth n
let x86-64-else  out m
do  x86-64-label out n
do  x86-64-mov out
do  put-list out "%rax"
do  put-line out "(%rsp)"
do  x86-64-label out m
    n

x86-64-unlet (out depth n) fpop x86-64-fpop out depth 1

x86-64-unfor (out depth n) 
do  x86-64-rep out n
    pop x86-64-pop out depth "%rax"

x86-64-unbuf (out depth n) 
do  x86-64-rep out n
    pop x86-64-pop out depth "%rax"

# ebrew's character classes #

ebrew-char-class-lf (a)     range-lf a
ebrew-char-class-hm (a)     range-hm a
ebrew-char-class-bs (a)     range-bs a
ebrew-char-class-sq (a)     range-sq a
ebrew-char-class-dq (a)     range-dq a
ebrew-char-class-09 (a)     range-09 a

ebrew-char-class-ws (a) or  range-sp a
                        or  range-tb a
                        or  range-lf a
                            range-cr a
ebrew-char-class-id (a) or  range-AZ a
                        or  range-az a
                        or  range-09 a
						or  range-en a
                            range-us a
ebrew-char-class-im (a) or  range-09 a
                            range-sq a
ebrew-char-class-pt (a) or  range-lp a
                        or  range-rp a
                            range-qm a

# ebrew's lexer #

ebrew-lex-one (c) line-lex-one c

ebrew-lex-hm  (c) line-lex-by ebrew-char-class-hm c
ebrew-lex-bs  (c) line-lex-by ebrew-char-class-bs c
ebrew-lex-dq  (c) line-lex-by ebrew-char-class-dq c
ebrew-lex-sq  (c) line-lex-by ebrew-char-class-sq c
ebrew-lex-09  (c) line-lex-by ebrew-char-class-09 c
ebrew-lex-pt  (c) line-lex-by ebrew-char-class-pt c
ebrew-lex-ws  (c) line-lex-by ebrew-char-class-ws c
ebrew-lex-id2 (c) line-lex-by ebrew-char-class-id c

ebrew-lex-id (c) lex-escape ebrew-lex-bs ebrew-lex-one ebrew-lex-id2 c

ebrew-lex-es (c) lex-escape ebrew-lex-bs ebrew-lex-one ebrew-lex-one c

# ebrew's token helpers #

ebrew-eat-bunch (lex (c) c) eat-bunch lex              c
ebrew-eat-chunk (lex (c) c) eat-chunk lex ebrew-lex-es c
ebrew-eat-group (lex (c) c) eat-group lex ebrew-lex-es c

# ebrew's tokens #

ebrew-eat-pt (c)                 ebrew-lex-pt c
ebrew-eat-id (c) ebrew-eat-bunch ebrew-lex-id c
ebrew-eat-09 (c) ebrew-eat-bunch ebrew-lex-09 c
ebrew-eat-ws (c) ebrew-eat-bunch ebrew-lex-ws c
ebrew-eat-sq (c) ebrew-eat-chunk ebrew-lex-sq c
ebrew-eat-dq (c) ebrew-eat-group ebrew-lex-dq c
ebrew-eat-nt (c) ebrew-eat-group ebrew-lex-hm c

# ebrew's tokenizer #

ebrew-eat-nontext (c)
for 1 -
or  ebrew-eat-ws c
    ebrew-eat-nt c

ebrew-eat-text (c)
or  ebrew-eat-id c
or  ebrew-eat-pt c
or  ebrew-eat-09 c
or  ebrew-eat-sq c
    ebrew-eat-dq c

ebrew-token-read (token-read (nontext (c) text (c) k) k)
token-read ebrew-eat-nontext
	       ebrew-eat-text
	       k

ebrew-token-init (k in) token-init ebrew-token-read k in
ebrew-token-adv  (k   ) token-adv  ebrew-token-read k

ebrew-token-class-do   (k) token-is "do"   k
ebrew-token-class-if   (k) token-is "if"   k
ebrew-token-class-or   (k) token-is "or"   k
ebrew-token-class-and  (k) token-is "and"  k
ebrew-token-class-buf  (k) token-is "buf"  k
ebrew-token-class-let  (k) token-is "let"  k
ebrew-token-class-for  (k) token-is "for"  k
ebrew-token-class-addr (k) token-is "addr" k

ebrew-token-class-lit (k) token-match ebrew-char-class-im k
ebrew-token-class-str (k) token-match ebrew-char-class-dq k
ebrew-token-class-id  (k) token-match ebrew-char-class-id k

ebrew-token-eat-lit (k c) token-eat-lit ebrew-token-adv k c

# semantics #

sem--book  (x)                          x
sem--brk   (x) add (sem--book  x) struct
sem--out   (x) add (sem--brk   x) struct
sem--token (x) add (sem--out   x) struct
sem--type  (x) add (sem--token x) struct-token
sem--val   (x) add (sem--type  x) struct
sem--isc   (x) add (sem--val   x) struct
sem--impl  (x) add (sem--isc   x) struct
struct-sem ( )      sem--impl     struct

sem-set-type (x t) store sem--type x t
sem-set-val  (x t) store sem--val  x t
sem-set-isc  (x t) store sem--isc  x t

sem-type (x) load sem--type x
sem-val  (x) load sem--val  x
sem-isc  (x) load sem--isc  x

# evil table
  all we're doing here is unpacking a struct.
  it's just a subset of the struct above.
  kinda pointless.
#

ebrew-sem-lit-str (impl (out k) x) impl sem--out x sem--token x
ebrew-sem-lit     (impl (out k) x) ebrew-sem-lit-str impl x 
ebrew-sem-str     (impl (out k) x) ebrew-sem-lit-str impl x

ebrew-sem-addr-id (impl (out k then now) x then) impl sem--out x sem--token x then load sem--impl x
ebrew-sem-addr    (impl (out k then now) x then) ebrew-sem-addr-id impl x then
ebrew-sem-id      (impl (out k then now) x then) ebrew-sem-addr-id impl x then

ebrew-sem-preamble (impl (out) x) impl sem--out x
ebrew-sem-and      (impl (out) x) impl sem--out x 
ebrew-sem-or       (impl (out) x) impl sem--out x 
ebrew-sem-else     (impl (out) x) impl sem--out x

ebrew-sem-label (impl (out impl) x n) impl sem--out x n

ebrew-sem-let (impl (out depth) x) impl sem--out x sem--impl x
ebrew-sem-for (impl (out depth) x) impl sem--out x sem--impl x
ebrew-sem-buf (impl (out depth) x) impl sem--out x sem--impl x

ebrew-sem-unlet (impl (out depth n) x n) impl sem--out x sem--impl x n
ebrew-sem-unfor (impl (out depth n) x n) impl sem--out x sem--impl x n
ebrew-sem-unbuf (impl (out depth n) x n) impl sem--out x sem--impl x n

# ebrew's typing system #

param--type  (t) t
param--token (t) add (param--type  t) struct
struct-param ( )      param--token    struct-token

type--next  (t)                  t
type--arg   (t) add (type--next  t) struct
type--token (t) add (type--arg   t) struct
type--kind  (t) add (type--token t) struct-token
struct-type ( )      type--kind     struct

type--alloc (brk kind)
let alloc brk struct-type t
do  store type--next t 0
do  store type--arg  t 0
do  store type--kind t kind
    t

type-new-unit     (brk) type--alloc brk 0
type-new-function (brk) type--alloc brk 1

type-kind (t) load type--kind t

type-arity (t)
and t
    add 1 type-arity load type--next t

type--kind-equal (a b) cmpe type-kind a type-kind b

type-equal2 (equal (a b) a b)
and type--kind-equal a b
    equal load type--arg  a load type--arg  b

type-list-equal (a b) ?

type-equal (a b) type-equal2 type-list-equal a b

type-list-equal (a b)
or  cmpe a b
and a
and b
and type-list-equal load type--next a load type--next b
    type-equal a b

# bookkeeping #

struct-decl-type  (o)                          o
struct-decl-impl  (o) add (struct-decl-type    o) struct
struct-decl-isdef (o) add (struct-decl-impl    o) struct
struct-decl       ( )      struct-decl-isdef      struct

struct-name-token (o)                          o
struct-name-decl  (o) add (struct-name-token   o) struct-token
struct-name       ( )      struct-name-decl       struct-decl

struct-book-next  (o)                       o
struct-book-name  (o) add (struct-book-next o) struct
struct-book       ( )      struct-book-name    struct-name

push-book (brk book token type impl)
let alloc brk struct-book ebrew-token-adv
do        copy struct-book-next  ebrew-token-adv book
let struct-book-name ebrew-token-adv name
do  token-copy struct-name-token name token
let struct-name-decl name decl
do        store struct-decl-type  decl type
do        copy struct-decl-impl  decl impl
do       store struct-decl-isdef decl 0
do  store book ebrew-token-adv
    name

pop-book (book)
copy book load struct-book-next book

try-lookup (book token)
let 0 r
do  for load book i
    if  token-equal token struct-name-token struct-book-name i
        load struct-book-next i
        do  store addr r struct-book-name i
            0
    r

lookup (book token)
or  try-lookup book token
    # lookup failed #
    exit 1

# stuff #

sem-addr  (x y) ebrew-sem-addr  x86-64-addr  x y
sem-id    (x y) ebrew-sem-id    x86-64-id    x y
sem-label (x n) ebrew-sem-label x86-64-label x n
sem-unlet (x n) ebrew-sem-unlet x86-64-unlet x n
sem-unfor (x n) ebrew-sem-unfor x86-64-unfor x n
sem-unbuf (x n) ebrew-sem-unbuf x86-64-unbuf x n
sem-let   (x  ) ebrew-sem-let   x86-64-let   x
sem-for   (x  ) ebrew-sem-for   x86-64-for   x
sem-buf   (x  ) ebrew-sem-buf   x86-64-buf   x
sem-and   (x  ) ebrew-sem-and   x86-64-and   x
sem-or    (x  ) ebrew-sem-or    x86-64-or    x
sem-else  (x  ) ebrew-sem-else  x86-64-else  x
sem-lit   (x  ) ebrew-sem-lit   x86-64-lit   x
sem-str   (x  ) ebrew-sem-str   x86-64-str   x

# ebrew's type syntax #

syn-type (x) ?

syn-param (x t)
do  store t alloc sem--brk x struct-type
do  token-copy type--token load t sem--token x
do  ebrew-token-adv sem--token x
let syn-type x u
do  copy type--next load t type--next u
do  copy type--arg  load t type--arg  u
    copy type--kind load t type--kind u

syn-type (x)
if  ebrew-token-eat-lit sem--token x "("
    let type-new-function sem--brk x t
    do  for type--arg t u
        and not ebrew-token-eat-lit sem--token x ")"
        do  syn-param x u
            type--next load u
        t
    type-new-unit sem--brk x

# ebrew's expression syntax #

ebrew-syn-and-or (sem (x) expr (x t) x t)
do  expr x t
let sem x n
do  expr x t
    sem-label x n

ebrew-syn-let-for (start (x) end (x n) expr (x t) x t u)
do  expr x u
let start x n
do  push-book
        sem--brk   x
        sem--book  x
        sem--token x
        sem-type   x
        sem--impl  x
do  ebrew-token-adv sem--token x
do  expr x t
do  pop-book sem--book x
    end x n

ebrew-syn-addr-id (sem (x y) o x)
let struct-name-decl o d
do  sem x load struct-decl-impl d
    ebrew-token-adv sem--token x

ebrew-syn-addr (expr (x t) x t)
let lookup sem--book x sem--token x o
do  ebrew-syn-addr-id sem-addr o x
    sem-set-type x type-new-unit sem--brk x

ebrew-syn-id   (expr (x t) x t)
let lookup sem--book x sem--token x o
do  ebrew-syn-addr-id sem-id o x
    sem-set-type x load struct-decl-type struct-name-decl o 

ebrew-syn-and  (expr (x t) x t) ebrew-syn-and-or  sem-and expr x t
ebrew-syn-or   (expr (x t) x t) ebrew-syn-and-or  sem-or  expr x t
ebrew-syn-let  (expr (x t) x t) ebrew-syn-let-for sem-let sem-unlet expr x t t
ebrew-syn-for  (expr (x t) x t) ebrew-syn-let-for sem-for sem-unfor expr x t t
ebrew-syn-buf  (expr (x t) x t) ebrew-syn-let-for sem-buf sem-unbuf expr x t t

ebrew-syn-do  (expr (x t) x t)
do expr x type-new-unit sem--brk x
   expr x t

ebrew-syn-literal (expr (x t) x t)
do  sem-lit x
do  ebrew-token-adv sem--token x
    sem-set-type x type-new-unit sem--brk x

ebrew-syn-string  (expr (x t) x t) 
do  sem-str x
do  ebrew-token-adv sem--token x
    sem-set-type x type-new-unit sem--brk x

ebrew-syn-if (expr (x t) x t)
do  expr x type-new-unit sem--brk x
let sem-and   x n
do  expr x t
let sem-else  x m
do  sem-label x n
do  expr x t
    sem-label x m

ebrew-syn-builtin (is (k) syn (expr (x t) x t) expr (x t) x t)
and is sem--token x
do  ebrew-token-adv sem--token x
    syn expr x t

ebrew-syn-primary (is (k) syn (expr (x t) x t) expr (x t) x t)
and is sem--token x
    syn expr x t

ebrew-syn-term (expr (x t) x t)
or  ebrew-syn-builtin ebrew-token-class-do   ebrew-syn-do      expr x t
or  ebrew-syn-builtin ebrew-token-class-if   ebrew-syn-if      expr x t
or  ebrew-syn-builtin ebrew-token-class-or   ebrew-syn-or      expr x t
or  ebrew-syn-builtin ebrew-token-class-and  ebrew-syn-and     expr x t
or  ebrew-syn-builtin ebrew-token-class-buf  ebrew-syn-buf     expr x t
or  ebrew-syn-builtin ebrew-token-class-let  ebrew-syn-let     expr x t
or  ebrew-syn-builtin ebrew-token-class-for  ebrew-syn-for     expr x t
or  ebrew-syn-builtin ebrew-token-class-addr ebrew-syn-addr    expr x t
or  ebrew-syn-primary ebrew-token-class-lit  ebrew-syn-literal expr x t
or  ebrew-syn-primary ebrew-token-class-str  ebrew-syn-string  expr x t
    ebrew-syn-primary ebrew-token-class-id   ebrew-syn-id      expr x t

# fuck #

argreg (d)
or and cmpe d 0 "%rdi"
or and cmpe d 1 "%rsi"
or and cmpe d 2 "%rdx"
or and cmpe d 3 "%rcx"
or and cmpe d 4 "%r8"
                "%r9"

syn-arg (x i)
do  x86-64-mov sem--out x
do  put-list sem--out x "%rax"
do  put-number sem--out x shl 3 load i
do  put-line sem--out x "(%rsp)"
    store i add 1 load i

syn-args (parse (x t) x parameters)
let 1 depth
and parameters
for parameters u
do  parse x u
do  or  type-equal u sem-type x
        # asymmetric argument #
        exit 12
do  syn-arg x addr depth
    load u

syn-argreg (x i)
pop x86-64-pop sem--out x sem--impl x argreg i

syn-nest (x t) ?
syn-expr (x t) ?

syn-call (x t)
do  or  syn-nest x t
	or  ebrew-syn-term syn-expr x t
		# expected expression #
		exit 11
or  token-is ")" sem--token x
or  type-equal t sem-type x
for 1 -
and type-kind sem-type x
let load sem--impl x depth
let sem-type x function-type
let load type--arg function-type parameters
let type-arity parameters arity
do  fpush x86-64-fpush sem--out x sem--impl x arity
do  push  x86-64-push  sem--out x sem--impl x "%rax"
do  syn-args syn-expr x parameters
do  pop x86-64-pop   sem--out x sem--impl x "%rax"
do  let if cmpa arity 6 arity 6 regargs
    for 0 i
    and cmpa i regargs
    do  syn-argreg x i
        add 1 i
do  x86-64-mnem1 sem--out x "call" "*%rax"
do  fpop x86-64-fpop sem--out x sem--impl x sub load sem--impl x depth
do  sem-set-type x type-new-unit sem--brk x
    1

syn-nest (x t)
and ebrew-token-eat-lit sem--token x "("
do  syn-call x t
    ebrew-token-eat-lit sem--token x ")"

syn-expr (x t)
or syn-nest x t
   syn-call x t

params (ebrew-token-adv (x t g) x t g)
if  t
    ebrew-token-adv x t g
    do  syn-expr x type-new-unit sem--brk x
        0

param-push-book (x t)
push-book sem--brk x sem--book x type--token t sem-type x sem--impl x

params-next (ebrew-token-adv (x t g) x t g)
let params ebrew-token-adv x load t g h
do  pop-book sem--book x
    h

register (ebrew-token-adv (x t g) x t reg g)
do  push x86-64-push sem--out x sem--impl x reg
do  sem-set-type x t
do  param-push-book x t
    add 1 params-next ebrew-token-adv x t g

stack (x t g)
do  sem-set-type x t
do  let param-push-book x t o
        store struct-decl-impl struct-name-decl o g
    params-next stack x t add 1 g

register-seq (ebrew-token-adv (x t g) reg x t g)
register ebrew-token-adv x t reg add 1 g

register5 (x t g) register-seq     stack "%r9"  x t 0
register4 (x t g) register-seq register5 "%r8"  x t g
register3 (x t g) register-seq register4 "%rcx" x t g
register2 (x t g) register-seq register3 "%rdx" x t g
register1 (x t g) register-seq register2 "%rsi" x t g
register0 (x t g) register-seq register1 "%rdi" x t g

parse-decl (whether-lookup (x) x)
and token-caret-peek sem--token x
let whether-lookup x o
do  or 	not load struct-decl-isdef struct-name-decl o
        # remention #
        exit 13
do  syn-param x struct-decl-type struct-name-decl o
do  store struct-decl-isdef struct-name-decl o not ebrew-token-eat-lit sem--token x "?"
do  and load struct-decl-isdef struct-name-decl o
    do  put-string sem--out x ".section .text."
    do  token-mangle  sem--out x struct-name-token o
    do  put-string sem--out x "\n"
    do  token-mangle  sem--out x struct-name-token o
    do  put-string sem--out x ":\n"
    do  store sem--impl x shl 63 1
    do  fpop x86-64-fpop sem--out x sem--impl x params register0 x load type--arg load struct-decl-type struct-name-decl o 0
        put-line sem--out x "ret"
    1

decl-first (x)
do  store sem--impl x 0
    push-book sem--brk x sem--book x sem--token x sem-type x sem--impl x

decl-rest (x)
or 	try-lookup sem--book x sem--token x
    decl-first x

parse-decls (which (x) x)
and parse-decl which x
    parse-decls decl-rest x

parse-ebrew (x)
do  ebrew-sem-preamble x86-64-pre x
    parse-decls decl-first x

arnica-main (x in out brk)
do  store      sem--book  x 0
do  store      sem--out   x out
do  store      sem--brk   x brk
do  ebrew-token-init sem--token x in
do  parse-ebrew x
    load sem--out x

init-runtime (heap inbuf outbuf)
let initbrk heap brk
let alloc addr brk inbuf  in
let alloc addr brk outbuf out
let alloc addr brk struct-sem x
do  poke retry stdin in add in inbuf 0
do  retry stdout out arnica-main x in out brk
    # OK #
    exit 0

_start ()
init-runtime
    shl 24 1
    shl 20 1
    shl 23 1
