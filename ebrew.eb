load  (a  ) ?
store (a b) ?
peek  (a  ) ?
poke  (a b) ?
add   (a b) ?
sub   (a b) ?
mul   (a b) ?
div   (a b) ?
mod   (a b) ?
shl   (a b) ?
cmpa  (a b) ?
cmpe  (a b) ?
cmpne (a b) ?
neg   (a  ) ?
not   (a  ) ?
linux (rdi rsi rdx rcx r8 r9 rax) ?

struct ( ) 8

copy (a b) store a load b

member-copy (copy (a b) member (x) a b) copy member a member b

pair-copy (copy-a (a b) member-a (x) copy-b (a b) member-b (x) a b)
do  member-copy copy-a member-a a b
    member-copy copy-b member-b a b

cmpin (a b c)
not or  cmpa a b
        cmpa c a

suc (a) add 1 a
prd (a) sub 1 a

post (op (a) -a)
let (load -a) a
do  store -a (op a)
    a

inc (-a) post suc -a
dec (-a) post prd -a

pow2 (n) shl n 1

exit   (a  ) linux a 0 0 0 0 0 60
brk    (a  ) linux a 0 0 0 0 0 12
stdin  (p n) linux 0 p n 0 0 0 0
stdout (p n) linux 1 p n 0 0 0 1
stderr (p n) linux 2 p n 0 0 0 1

initbrk (n)
let brk 0 i
do  brk add n i
    i

alloc (mem n)
let load mem r
do  store mem add n load mem
    r

retry (stdio (p n) a b)
let (neg 1) err
for a i
and not cmpe i err
let stdio i sub i b n
if  cmpe n err
	err
and n
	add n i

runtime (main (in out brk) heap inbuf outbuf)
let initbrk heap   in
let add in  inbuf  out
let add out outbuf brk
do  poke retry stdin in add in inbuf 0
do  retry stdout out main in out brk
    exit 0

strlen (s)
and peek s
	suc strlen suc s

strncmp (a b n)
or  not n
and cmpe (peek a) (peek b)
    strncmp (suc a) (suc b) (prd n)

put (out c)
let load out p
do  poke p c
    store out add 1 p

put-higit (out n) put out add if cmpa n 10 '0 '7 n

put-bhex (out n)
do  put-higit out div 16 n
    put-higit out mod 16 n

put-digit (out n) put out add '0 n

put-digits (out n)
and n
do  put-digits out div 10 n
    put-digit  out mod 10 n

put-number (out n)
if  n put-digits out if n n '0
    put out '0

put-cm (out) put out ',
put-sp (out) put out ' 
put-ds (out) put out '$
put-cr (out) put out '\r
put-lf (out) put out '\n

# write the bytes in [a, b) to `out` using `vput` #

vput-mem (vput (out a) out a b)
for a i
and cmpa i b
do  vput out (peek i)
    suc i

# write the bytes in string `s` to `out` using `vput` #

vput-string (vput (out a) out s)
for s p
let (peek p) a
and a
do  vput out a
    suc p

put-string (out s) vput-string put out s

put-delim (delim (out) out s)
do  put-string out s
    delim out

put-seq  (out s) put-delim put-sp out s
put-list (out s) put-delim put-cm out s
put-line (out s) put-delim put-lf out s

println (s) do retry stderr s add s strlen s stderr "\n" 1

err (code s) do retry stderr s add s strlen s do stderr "\n" 1 exit code

# book type #

book--next  (o)                 o
book--line  (o) add (book--next o) struct
struct-book ( )      book--line    struct

book-set-next (o next) store (book--next o) next
book-set-line (o line) store (book--line o) line

book-get-next (o) load (book--next o)
book-get-line (o) load (book--line o)

# type type #

type--args  (t)                  t
type--kind  (t) add (type--args  t) struct
struct-type ( )      type--kind     struct

type-set-args (t args) store (type--args t) args
type-set-kind (t kind) store (type--kind t) kind

type-get-args (t) load (type--args t)
type-get-kind (t) load (type--kind t)

# decl type #

decl--token (d)                  d
decl--type  (d) add (decl--token d) struct
struct-decl ( )      decl--type     struct

decl-set-token (d token) store (decl--token d) token
decl-set-type  (d type ) store (decl--type  d) type 

decl-token (d) load (decl--token d)
decl-get-type  (d) load (decl--type  d)

# span type #

span--start (s)                  s
span--end   (s) add (span--start s) struct
struct-span ( )      span--end      struct

span-set-start (s start) store (span--start s) start
span-set-end   (s end  ) store (span--end   s) end  

span-start (s) load (span--start s)
span-end   (s) load (span--end   s)

# loc type #

loc--line  (l)                l
loc--col   (l) add (loc--line l) struct
struct-loc ( )      loc--col     struct

loc-set-line (l line) store (loc--line l) line
loc-set-col  (l col ) store (loc--col  l) col 

loc-get-line (l) load (loc--line l)
loc-get-col  (l) load (loc--col  l)

# caret type #

caret--ptr   (c)                  c
caret-loc    (c) add (caret--ptr  c) struct
struct-caret ( )      caret-loc      struct-loc

caret-set-ptr (c ptr) store (caret--ptr c) ptr

caret-get-ptr (c) load (caret--ptr c)

# token type #

token-get-span  (k)                   k
token-get-caret (k) add (token-get-span  k) struct-span
struct-token ( )     token-get-caret    struct-caret

# name type #

name-token  (e)                 e
name--var   (e) add (name-token e) struct-token
struct-name ( )      name--var     struct

name-set-var (e var) store (name--var e) var

name-var    (e) load (name--var e)

# var type #

var--type  (v)                   v
var--impl  (v) add (var--type    v) struct
struct-var ( )      var--impl       struct

var-set-type (v type) store (var--type v) type
var-set-impl (v impl) store (var--impl v) impl

var-type (v) load (var--type v)
var-impl (v) load (var--impl v)

# sem type #

sem--book  (x)                 x
sem--mem   (x) add (sem--book  x) struct
sem--out   (x) add (sem--mem   x) struct
sem-token  (x) add (sem--out   x) struct
sem--type  (x) add (sem-token  x) struct-token
sem--val   (x) add (sem--type  x) struct
sem--isc   (x) add (sem--val   x) struct
sem--flake (x) add (sem--isc   x) struct
sem--impl  (x) add (sem--flake x) struct
struct-sem ( )      sem--impl     struct

sem-set-type  (x t) store (sem--type  x) t
sem-set-val   (x t) store (sem--val   x) t
sem-set-isc   (x t) store (sem--isc   x) t
sem-set-flake (x f) store (sem--flake x) f

sem-get-out   (x) load (sem--out   x)
sem-get-book  (x) load (sem--book  x)
sem-get-impl  (x) load (sem--impl  x)
sem-get-type  (x) load (sem--type  x)
sem-get-val   (x) load (sem--val   x)
sem-get-isc   (x) load (sem--isc   x)
sem-get-flake (x) load (sem--flake x)

# a little handy #

span-init (s start end)
do  span-set-start s start
    span-set-end   s end

span-copy (a b) span-init a (span-start b) (span-end b)

span-equal-rest (a b n)
or  not n
and cmpe peek a peek b
    span-equal-rest (suc a) (suc b) (prd n)

span-equal (a b)
let span-start a ap
let span-start b bp
let sub ap span-end a an
let sub bp span-end b bn
and cmpe an bn
    span-equal-rest ap bp bn

span-strcmp (s lit)
let span-start s start
let span-end   s end
let sub start end n
and strncmp lit start n
    not peek add lit n

vput-span (vput (out a) out s) vput-mem vput out (span-start s) (span-end s)

put-span (out s) vput-span put out s

# stack accounting #

to (pb op (a b) a) store pb (op a (load pb))

fpop  (y size) to y add size
fpush (y size) to y sub size

pop   (y     ) inc y
push  (y     ) dec y

# x86_64 implementation #

x86_64-string-mov              () "mov"
x86_64-string-lea              () "lea"
x86_64-string-add              () "add"
x86_64-string-test             () "test"
x86_64-string-je               () "je"
x86_64-string-jne              () "jne"
x86_64-string-jmp              () "jmp"
x86_64-string-push             () "push"
x86_64-string-pop              () "pop"
x86_64-string-call             () "call"
x86_64-string-ret              () "ret"
x86_64-string-entry            () "_start"
x86_64-string-stack-top        () "(%rsp)"
x86_64-string-pcrel-rip        () "@GOTPCREL(%rip)"
x86_64-string-str-label-prefix () ".s"
x86_64-string-globl            () ".globl"
x86_64-string-equ              () ".equ"
x86_64-string-section-text     () ".section .text."
x86_64-string-section-data     () ".section .data."
x86_64-string-string           () ".string"
x86_64-string-previous         () ".previous"
x86_64-string-rax              () "%rax"
x86_64-string-rsp              () "%rsp"
x86_64-string-rdi              () "%rdi"
x86_64-string-rsi              () "%rsi"
x86_64-string-rdx              () "%rdx"
x86_64-string-rcx              () "%rcx"
x86_64-string-r8               () "%r8"
x86_64-string-r9               () "%r9"

x86_64-mangle (vput (put (out a) out s) out s)
do  put out 'f
    vput put-bhex out s

x86_64-mangle-span   (out s) x86_64-mangle vput-span   out s
x86_64-mangle-string (out s) x86_64-mangle vput-string out s

x86_64-label-suf (out)
do  put    out ':
    put-lf out

x86_64-builtin-label (out s)
do  put-seq  out x86_64-string-globl
do  put-line out s
do  put-string out x86_64-string-section-text
do  put-line out s
do  put-string out s
    x86_64-label-suf out

x86_64-pre (out)
do  put-seq     out x86_64-string-globl
do  put-line    out x86_64-string-entry
do  put-seq     out x86_64-string-equ
do  put-list    out x86_64-string-entry
do  x86_64-mangle-string out x86_64-string-entry
do  put-lf out
do  x86_64-builtin-label out "f6C6F6164"
do  put-line out "mov (%rdi),%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f73746F7265"
do  put-line out "mov %rsi,(%rdi)"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f7065656B"
do  put-line out "movzb (%rdi),%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f706F6B65"
do  put-line out "movb %sil,(%rdi)"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f616464"
do  put-line out "mov %rsi,%rax"
do  put-line out "add %rdi,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f737562"
do  put-line out "mov %rsi,%rax"
do  put-line out "sub %rdi,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6D756C"
do  put-line out "mov %rsi,%rax"
do  put-line out "mul %rdi"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f646976"
do  put-line out "xor %edx,%edx"
do  put-line out "mov %rsi,%rax"
do  put-line out "div %rdi"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6D6F64"
do  put-line out "xor %edx,%edx"
do  put-line out "mov %rsi,%rax"
do  put-line out "div %rdi"
do  put-line out "mov %rdx,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f73686C"
do  put-line out "mov %rsi,%rax"
do  put-line out "mov %rdi,%rcx"
do  put-line out "shl %cl,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f636D7061"
do  put-line out "cmp %rdi,%rsi"
do  put-line out "seta %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f636D7065"
do  put-line out "cmp %rsi,%rdi"
do  put-line out "sete %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f636D706E65"
do  put-line out "cmp %rsi,%rdi"
do  put-line out "setne %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E6567"
do  put-line out "mov %rdi,%rax"
do  put-line out "neg %rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E6F74"
do  put-line out "test %rdi,%rdi"
do  put-line out "sete %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6C696E7578"
do  put-line out "mov 8(%rsp),%rax"
do  put-line out "syscall"
    put-line out x86_64-string-ret

x86_64-fpushpop (fpushpop (y size) out y size sign)
and size
do  put-seq    out x86_64-string-add
do  put        out '$
do  and sign
        put out '-
do  put-number out (shl 3 size)
do  put-cm     out
do  put-line   out x86_64-string-rsp
    fpushpop   y size

x86_64-pushpop (pushpop (y) out y reg sign)
do  put-seq  out if sign x86_64-string-push x86_64-string-pop
do  put-line out reg
    pushpop  y

x86_64-fpop  (out y size) x86_64-fpushpop fpop  out y size 0
x86_64-fpush (out y size) x86_64-fpushpop fpush out y size 1
x86_64-pop   (out y reg ) x86_64-pushpop  pop   out y reg  0
x86_64-push  (out y reg ) x86_64-pushpop  push  out y reg  1

x86_64-label-id (out n)
do  put        out '.
do  put-number out n
    put        out '$

x86_64-cz (out)
do  put-seq  out x86_64-string-test
do  put-list out x86_64-string-rax
    put-line out x86_64-string-rax

x86_64-jc (out n s)
do  put-seq         out s
do  x86_64-label-id out n
    put-lf          out

x86_64-czjc (out n s)
do  x86_64-cz out
    x86_64-jc out n s

x86_64-je  (out n) x86_64-czjc out n x86_64-string-je
x86_64-jne (out n) x86_64-czjc out n x86_64-string-jne
x86_64-jmp (out n) x86_64-jc   out n x86_64-string-jmp

x86_64-load (out y z)
do  put-number out (shl 3 (sub z y))
    put-list   out x86_64-string-stack-top

x86_64-id (out s y z)
do  put-seq out x86_64-string-mov
do  if  y
        x86_64-load out y z
        do  x86_64-mangle-span out s
            put-list out x86_64-string-pcrel-rip
    put-line out x86_64-string-rax

x86_64-lit (out s)
do  put-seq  out x86_64-string-mov
do  put-ds   out
do  put-span out s
do  put-cm   out
    put-line out x86_64-string-rax

x86_64-str-label (out n)
do  put-string out x86_64-string-str-label-prefix
    put-number out n

x86_64-str (out s a)
do  put-string       out x86_64-string-section-data
do  x86_64-str-label out a
do  put-lf           out
do  x86_64-str-label out a
do  x86_64-label-suf out
do  put-list         out x86_64-string-string
do  put-span         out s
do  put-lf           out
do  put-line         out x86_64-string-previous
do  put-seq          out x86_64-string-mov
do  x86_64-str-label out a
do  put-list         out x86_64-string-pcrel-rip
    put-line         out x86_64-string-rax

x86_64-do    (out a) 1

x86_64-label (out a)
do  x86_64-label-id  out a
    x86_64-label-suf out

x86_64-let-in  (out y a) x86_64-push out y x86_64-string-rax
x86_64-let-end (out y a) x86_64-fpop out y 1

x86_64-for-in (out y a)
do  x86_64-let-in out y a
do  put-string out "jmp b"
do  x86_64-label-id out a
do  put-lf out
do  x86_64-label  out   a
do  put-seq       out x86_64-string-mov
do  put-list      out x86_64-string-rax
do  put-line      out x86_64-string-stack-top
do  put out 'b
    x86_64-label  out   a

x86_64-for-end (out y a) 
do  x86_64-jne out a
    x86_64-pop out y x86_64-string-rax

x86_64-call-with (out y a)
let (load y) z
do  x86_64-fpush out y a
do  x86_64-push  out y x86_64-string-rax
    z

x86_64-call-arg (out i)
do  put-seq    out x86_64-string-mov
do  put-list   out x86_64-string-rax
do  put-number out (shl 3 i)
    put-line   out x86_64-string-stack-top

x86_64-call-end-pop (out i n y s)
and cmpa i n
    x86_64-pop out y s

x86_64-call-end (out y z n)
do  x86_64-pop   out y x86_64-string-rax
do  x86_64-call-end-pop out 0 n y x86_64-string-rdi
do  x86_64-call-end-pop out 1 n y x86_64-string-rsi
do  x86_64-call-end-pop out 2 n y x86_64-string-rdx
do  x86_64-call-end-pop out 3 n y x86_64-string-rcx
do  x86_64-call-end-pop out 4 n y x86_64-string-r8
do  x86_64-call-end-pop out 5 n y x86_64-string-r9
do  put-seq  out x86_64-string-call
do  put out '*
do  put-line out x86_64-string-rax
    x86_64-fpop out y (sub (load y) z)

x86_64-var-in (out y s)
do  put-string out x86_64-string-section-text
do  x86_64-mangle-span  out s
do  put-lf out
do  x86_64-mangle-span  out s
do  x86_64-label-suf    out
    store y (shl 63 1)

x86_64-var-end (out y z)
do  x86_64-fpop out y z
    put-line out x86_64-string-ret

# character ranges #

char-range-nz (a) not not a

char-range-sq (a) cmpe  a '\'
char-range-dq (a) cmpe  a '\"
char-range-bs (a) cmpe  a '\\
char-range-hm (a) cmpe  a '#
char-range-qm (a) cmpe  a '?
char-range-lp (a) cmpe  a '(
char-range-rp (a) cmpe  a ')
char-range-us (a) cmpe  a '_
char-range-en (a) cmpe  a '-
char-range-sp (a) cmpe  a ' 
char-range-tb (a) cmpe  a '\t
char-range-lf (a) cmpe  a '\n
char-range-cr (a) cmpe  a '\r

char-range-09 (a) cmpin a '0 '9
char-range-AZ (a) cmpin a 'A 'Z
char-range-az (a) cmpin a 'a 'z

# bookkeeping #

book-new (mem next line)
let (alloc mem struct-book) book
do  book-set-next book next
do  book-set-line book line
    book

book-count (book)
and book
    suc (book-count (book-get-next book))

book-lookup (match (line key) book key)
and book
let book-get-line book line
if  match line key
    line
    book-lookup match (book-get-next book) key

book-equal (line-equal (a b) a b)
or  cmpe a b
and a
and b
and            line-equal (book-get-line a) (book-get-line b)
    book-equal line-equal (book-get-next a) (book-get-next b)

type-new (mem args kind)
let alloc mem struct-type t
do  type-set-args t args
do  type-set-kind t kind
    t

type-new-unit     (mem     ) type-new mem 0    0
type-new-function (mem args) type-new mem args 1

type-decl-equal (arg-equal (a b) a b)
or  cmpe a b
and a
and b
and cmpe                 (type-get-kind a) (type-get-kind b)
    book-equal arg-equal (type-get-args a) (type-get-args b)

decl-new  (mem token type)
let (alloc mem struct-decl) decl
do  decl-set-token decl token
do  decl-set-type  decl type
    decl

decl-equal (a b) type-decl-equal decl-equal (decl-get-type a) (decl-get-type b)

type-equal (a b) type-decl-equal decl-equal a b

loc-cf (l) loc-set-line l (suc (loc-get-col l))

loc-crlf (l) 
do  loc-set-line l (suc (loc-get-line l))
    loc-set-col  l 1

loc-init (l line col) 
do  loc-set-line l line
    loc-set-col  l col

caret-init (c ptr)
do  caret-set-ptr c ptr
    loc-init (caret-loc c) 0 0

caret-copy (a b)
do  caret-set-ptr a (caret-get-ptr b)
    loc-init (caret-loc a) (loc-get-line caret-loc b) (loc-get-col caret-loc b)

caret-peek (c) peek (caret-get-ptr c)

token-copy (a b)
do  span-copy  (token-get-span  a) (token-get-span  b)
    caret-copy (token-get-caret a) (token-get-caret b)

token-clone (mem j)
let (alloc mem struct-token) k
do  token-copy k j
    k

token-match (lex (c) k) lex (peek (span-start (token-get-span k)))

token-is (lit k) span-strcmp (token-get-span k) lit

token-equal (a b) span-equal (token-get-span a) (token-get-span b)

name-new (mem token var)
let (alloc mem struct-name) n
do  token-copy (name-token n) token
do  name-set-var n var
    n

name-push (mem book token var) book-new mem book (name-new mem token var)

name-token-equal (n k) token-equal k (name-token n)

try-name-lookup (book k) book-lookup name-token-equal book k

var-new (mem type impl)
let (alloc mem struct-var) v
do  var-set-type v type
do  var-set-impl v impl
    v

var-push (mem o k t y) name-push mem o k (var-new mem t y)

try-var-lookup (o k)
let (try-name-lookup o k) e
and e
    name-var e

# character classes #

char-class-nz (a)     char-range-nz a

char-class-lf (a)     char-range-lf a
char-class-hm (a)     char-range-hm a
char-class-bs (a)     char-range-bs a
char-class-sq (a)     char-range-sq a
char-class-dq (a)     char-range-dq a
char-class-09 (a)     char-range-09 a

char-class-ws (a) or  char-range-sp a
                  or  char-range-tb a
                  or  char-range-lf a
                      char-range-cr a
char-class-id (a) or  char-range-AZ a
                  or  char-range-az a
                  or  char-range-09 a
                  or  char-range-en a
                      char-range-us a
char-class-im (a) or  char-range-09 a
                      char-range-sq a
char-class-un (a) or  char-range-09 a
                  or  char-range-sq a
                  or  char-range-AZ a
                  or  char-range-az a
                  or  char-range-09 a
                  or  char-range-en a
                  or  char-range-us a
                      char-range-dq a
char-class-pt (a) or  char-range-lp a
                  or  char-range-rp a
                      char-range-qm a

char-negclass (char-class (a) a)
and char-class-nz a
not char-class    a

char-class-sb (a) char-negclass char-class-dq a
char-class-cb (a) char-negclass char-class-hm a

# lexer #

lex-normal (char-class (a) c)
and char-class caret-peek c
do  if  char-range-lf (caret-peek c) (loc-crlf) (loc-cf) (caret-loc c)
    caret-set-ptr c (suc (caret-get-ptr c))

lex-escape (char-class (a) c)
if  lex-normal char-class-bs c
    lex-normal char-class-nz c
    lex-normal char-class    c

lex-hm (c) lex-normal char-class-hm c
lex-dq (c) lex-normal char-class-dq c
lex-sq (c) lex-normal char-class-sq c
lex-09 (c) lex-normal char-class-09 c
lex-pt (c) lex-normal char-class-pt c
lex-ws (c) lex-normal char-class-ws c
lex-id (c) lex-escape char-class-id c
lex-sb (c) lex-escape char-class-sb c
lex-cb (c) lex-escape char-class-cb c

# token parsers #

eat-bunch (body (c) c) 
for 0 _ body c

eat-pchar (delim (c) body (c) c)
and delim c
    body  c

eat-group (delim (c) body (c) c)
and delim c
do  eat-bunch body c
    delim c

# tokens #

eat-pt (c)           lex-pt        c
eat-id (c) eat-bunch lex-id        c
eat-09 (c) eat-bunch lex-09        c
eat-ws (c) eat-bunch lex-ws        c
eat-sq (c) eat-pchar lex-sq lex-sb c
eat-dq (c) eat-group lex-dq lex-sb c
eat-hm (c) eat-group lex-hm lex-cb c

eat-nontext (c)
for 0 _ or  eat-ws  c
            eat-hm  c

eat-text (c)
or  eat-id c
or  eat-pt c
or  eat-sq c
or  eat-dq c
    eat-09 c

# tokenizer #

token-read (c s)
do  eat-nontext c
let (caret-get-ptr c) start
if	peek start
    if  eat-text c
        span-init s start (caret-get-ptr c)
        err 1 "invalid text"
    span-init s start start

token-adv  (k)
and span-start token-get-span k
    token-read (token-get-caret k) (token-get-span k)

token-class-do   (k) token-is "do"   k
token-class-if   (k) token-is "if"   k
token-class-or   (k) token-is "or"   k
token-class-and  (k) token-is "and"  k
token-class-let  (k) token-is "let"  k
token-class-for  (k) token-is "for"  k

token-class-qm   (k) token-is "?" k
token-class-lp   (k) token-is "(" k
token-class-rp   (k) token-is ")" k

token-class-unit (k) token-match char-class-un k
token-class-str  (k) token-match char-class-dq k
token-class-im   (k) token-match char-class-im k
token-class-id   (k) token-match char-class-id k

# semantics #

sem-impl-pre (impl (-out) -out -book)
do  store -book 0
    impl  -out

sem-impl-flake (-flake) inc -flake

sem-impl-lit (impl (-out span) -mem -out span -type)
do  impl -out span
    store -type (type-new-unit -mem)

sem-impl-str (impl (-out span flake) -mem -out span -type flake)
do  impl -out span flake
    store -type (type-new-unit -mem)

sem-impl-ref (impl (-out span detail-old detail-new) -out book x)
let try-var-lookup book (sem-token x) v
if  v
do  impl -out (token-get-span sem-token x) (var-impl v) (sem-get-impl x) 
    sem-set-type x (var-type v)
    err 3 "lookup failed"


sem-impl-var-in (impl (-out y a) -mem -out -book token type -y a)
do  impl -out -y a
    store -book (var-push -mem (load -book) token type (load -y))

sem-impl-var-end (impl (out -y a) -mem -out -book -y a)
do  impl -out -y a
    store -book (book-get-next (load -book))

sem-impl-call-arg  (impl (-out i) -out t u i)
if  type-equal t u
    impl -out i
    err 4 "type error"

sem-impl-call-end  (impl (out y z n) -mem -out -type y z n)
do  impl -out y z n
    store -type (type-new-unit -mem)

# expression parsers #

parse-predef (is (k) syn (syn (x t) x t) syn-syn (x t) x t)
and is (sem-token x)
do  token-adv (sem-token x)
    syn syn-syn x t

parse-atom (is (k) syn (syn (x t) x t) syn-syn (x t) x t)
and is (sem-token x)
    syn syn-syn x t

parse-decl (is (k) syn (x) x)
and is (sem-token x)
    syn x

parse-skip (is (k) x)
and is (sem-token x)
    token-adv (sem-token x)

parse-unit (x) parse-skip token-class-unit x
parse-id   (x) parse-skip token-class-id   x
parse-lp   (x) parse-skip token-class-lp   x
parse-rp   (x) parse-skip token-class-rp   x
parse-qm   (x) parse-skip token-class-qm   x

# here we connect the syntaxes to their semantics #

syn-sem-pre (sem(x) x) sem x

syn-sem-unit (sem (x) x)
do  sem        x
    parse-unit x

syn-sem-str (sem (x) sem-end (x a) x)
let sem        x a
do  sem-end    x a
    parse-unit x

syn-sem-var (sem (x) sem-in (x a) sem-end (x a) syn (x t) x t)
let sem        x a
do  syn        x (type-new-unit (sem--mem x))
do  sem-in     x a
do  parse-id   x
do  syn        x t
    sem-end    x a

syn-sem-seq (sem (x) sem-then (x a) sem-end (x a) syn (x t) x t)
let sem        x a
do  syn        x t
do  sem-then   x a
do  syn        x t
    sem-end    x a

syn-sem-if (sem (x) sem-then (x a) sem-else (x a) sem-end (x a) syn (x t) x t)
let sem      x a
do  syn      x (type-new-unit (sem--mem x))
do  sem-then x a
do  syn      x t
let sem      x b
do  sem-else x b
do  sem-end  x a
do  syn      x t
    sem-end  x b

syn-sem-arg (sem (x t i) syn-first (x t) x t i)
do  syn-first x t
    sem       x t i

syn-sem-args (sem (x t i) syn-first (x t) x o i)
and o
do  syn-sem-arg  sem syn-first x (decl-get-type book-get-line o)      i
    syn-sem-args sem syn-first x (              book-get-next o) (suc i)

syn-sem-call (sem-with (x n) sem-arg (x o i) sem-end (x n y) syn (x t) x t)
let (book-count (type-get-args t)) n
let sem-with x n y
do  syn-sem-args sem-arg syn x (type-get-args t) 1
    sem-end  x n y

# here we say what implementation to use #

sem-pre            (x    ) sem-impl-pre       x86_64-pre        (sem--out x) (sem--book x)

sem-expr-lit       (x    ) sem-impl-lit       x86_64-lit        (sem--mem x) (sem--out x) (token-get-span sem-token x) (sem--type x)
sem-expr-str       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-str-end   (x a  ) sem-impl-str       x86_64-str        (sem--mem x) (sem--out x) (token-get-span sem-token x) (sem--type x) a
sem-expr-id        (x    ) sem-impl-ref       x86_64-id         (sem--out x) (sem-get-book x) x
sem-expr-let       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-let-in    (x a  ) sem-impl-var-in    x86_64-let-in     (sem--mem x) (sem--out x) (sem--book x) (sem-token x) (sem-get-type x) (sem--impl x) a
sem-expr-let-end   (x a  ) sem-impl-var-end   x86_64-let-end    (sem--mem x) (sem--out x) (sem--book x) (sem--impl x) a
sem-expr-for       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-for-in    (x a  ) sem-impl-var-in    x86_64-for-in     (sem--mem x) (sem--out x) (sem--book x) (sem-token x) (sem-get-type x) (sem--impl x) a
sem-expr-for-end   (x a  ) sem-impl-var-end   x86_64-for-end    (sem--mem x) (sem--out x) (sem--book x) (sem--impl x) a
sem-expr-do        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-do-then   (x a  )                    x86_64-do         (sem--out x) a
sem-expr-do-end    (x a  )                    x86_64-label      (sem--out x) a
sem-expr-and       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-and-then  (x a  )                    x86_64-je         (sem--out x) a
sem-expr-and-end   (x a  )                    x86_64-label      (sem--out x) a
sem-expr-or        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-or-else   (x a  )                    x86_64-jne        (sem--out x) a
sem-expr-or-end    (x a  )                    x86_64-label      (sem--out x) a
sem-expr-if        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-if-then   (x a  )                    x86_64-je         (sem--out x) a
sem-expr-if-else   (x a  )                    x86_64-jmp        (sem--out x) a
sem-expr-if-end    (x a  )                    x86_64-label      (sem--out x) a
sem-expr-call-with (x n  )                    x86_64-call-with  (sem--out x) (sem--impl x) n
sem-expr-call-arg  (x t i) sem-impl-call-arg  x86_64-call-arg   (sem--out x) (sem-get-type x) t i
sem-expr-call-end  (x n y) sem-impl-call-end  x86_64-call-end   (sem--mem x) (sem--out x) (sem--type x) (sem--impl x) y n

# here we say what semantics to use for each expression #

syn-pre (x) syn-sem-pre sem-pre x

syn-expr-lit  (syn (x t) x t) syn-sem-unit sem-expr-lit           x
syn-expr-str  (syn (x t) x t) syn-sem-str  sem-expr-str
                                           sem-expr-str-end       x
syn-expr-id   (syn (x t) x t) syn-sem-unit sem-expr-id            x
syn-expr-let  (syn (x t) x t) syn-sem-var  sem-expr-let
                                           sem-expr-let-in
                                           sem-expr-let-end   syn x t
syn-expr-for  (syn (x t) x t) syn-sem-var  sem-expr-for
                                           sem-expr-for-in
                                           sem-expr-for-end   syn x t
syn-expr-do   (syn (x t) x t) syn-sem-seq  sem-expr-do
                                           sem-expr-do-then
                                           sem-expr-do-end    syn x t
syn-expr-and  (syn (x t) x t) syn-sem-seq  sem-expr-and
                                           sem-expr-and-then 
                                           sem-expr-and-end   syn x t
syn-expr-or   (syn (x t) x t) syn-sem-seq  sem-expr-or
                                           sem-expr-or-else
                                           sem-expr-or-end    syn x t
syn-expr-if   (syn (x t) x t) syn-sem-if   sem-expr-if
                                           sem-expr-if-then
                                           sem-expr-if-else
                                           sem-expr-if-end    syn x t
syn-expr-call (syn (x t) x t) syn-sem-call sem-expr-call-with
                                           sem-expr-call-arg
                                           sem-expr-call-end  syn x t

syn-expr-term (syn (x t) x t)
or  parse-predef token-class-do   syn-expr-do   syn x t
or  parse-predef token-class-if   syn-expr-if   syn x t
or  parse-predef token-class-or   syn-expr-or   syn x t
or  parse-predef token-class-and  syn-expr-and  syn x t
or  parse-predef token-class-let  syn-expr-let  syn x t
or  parse-predef token-class-for  syn-expr-for  syn x t
or  parse-atom   token-class-im   syn-expr-lit  syn x t
or  parse-atom   token-class-str  syn-expr-str  syn x t
    parse-atom   token-class-id   syn-expr-id   syn x t

syn-expr-juxt (syn (x t) x t)
and not type-equal t (sem-get-type x)
and type-get-kind (sem-get-type x)
    syn-expr-call syn x (sem-get-type x)

syn-expr-nest (syn (x t) x t)
if  parse-lp x
do  syn-expr-term syn x t
or  parse-rp x
do  syn-expr-juxt syn x t
or  parse-rp x
    err 5 "missing paren"
if  syn-expr-term syn x t
    syn-expr-juxt syn x t
    err 6 "missing expression"

syn-expr (x t) syn-expr-nest syn-expr x t

# the ugliest code follows
#

# ebrew's declaration syntax #

params (next (x o y) x o y)
if  o
    next x o y
do  syn-expr x (type-new-unit (sem--mem x))
	0

params-next (next (x o y) x o y)
let params next x (book-get-next o) y h
do  store (sem--book x) (book-get-next sem-get-book x)
    h

param-name-push (x o y)
let (book-get-line o) d
    store (sem--book x) (var-push (sem--mem x) (sem-get-book x) (decl-token d) (decl-get-type d) y)

register (next (x o y) x o reg y)
do  x86_64-push (sem--out x) (sem--impl x) reg
do  param-name-push x o (sem-get-impl x)
    suc (params-next next x o y)

stack (x o y)
do  param-name-push   x o y
    params-next stack x o (suc y)

register-seq (next (x o y) reg x o y) register next x o reg (suc y)

register5 (x o y) register-seq     stack "%r9"  x o 0
register4 (x o y) register-seq register5 "%r8"  x o y
register3 (x o y) register-seq register4 "%rcx" x o y
register2 (x o y) register-seq register3 "%rdx" x o y
register1 (x o y) register-seq register2 "%rsi" x o y
register0 (x o y) register-seq register1 "%rdi" x o y

syn-body (x d)
if  try-name-lookup (sem-get-book x) (decl-token d)
    err 7 "duplicate"
do  store (sem--book x) (var-push (sem--mem x) (sem-get-book x) (decl-token d) (decl-get-type d) 0)
do  book-get-line sem-get-book x
or  parse-qm x
do  x86_64-var-in  (sem--out x) (sem--impl x) (token-get-span decl-token d)
let (params register0 x (type-get-args decl-get-type d) 0) y
	x86_64-var-end (sem--out x) (sem--impl x) y

syn-decl-seq (syn (x) x)
and token-class-id (sem-token x)
let (             syn x) d
let (syn-decl-seq syn x) o
	book-new (sem--mem x) o d

syn-decl-get-type (syn (x) x)
if  parse-lp x
let (syn-decl-seq syn x) o
if  parse-rp x
    type-new-function (sem--mem x) o
    err 5 "missing paren"
    type-new-unit     (sem--mem x)

syn-decl (x)
let token-clone (sem--mem x) (sem-token x) k
do  parse-id x
    decl-new (sem--mem x) k (syn-decl-get-type syn-decl x)

syn-def (x) syn-body x (syn-decl x)

syn-defs (x) for 0 _ parse-decl token-class-id syn-def x

syn (x)
do  syn-pre  x
    syn-defs x

main (in out x)
do  store (sem--mem x) add x struct-sem
do  store (sem--out x) out
do  caret-init (token-get-caret sem-token x) in
do  token-read (token-get-caret sem-token x) (token-get-span sem-token x)
do  syn x
    (sem-get-out x)

_start ()
runtime main
    pow2 24
    pow2 20
    pow2 23
