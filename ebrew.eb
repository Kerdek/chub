# external data functions #

(word) ?

(peek -byte) ?
(load -word) ?

(poke  -byte byte) ?
(store -word word) ?

# external arithmetic functions #

(neg n) ?
(not n) ?

(add  a b) ?
(sub  a b) ?
(mul  a b) ?
(div  a b) ?
(mod  a b) ?
(shl  a b) ?
(cmpa a b) ?
(cmpe a b) ?

# external io #

(linux rdi rsi rdx rcx r8 r9 rax) ?

# basic math #

(cmpex n a b) or (cmpa n a) (cmpa b n)
(cmpin n a b) not (cmpex n a b)

(suc n) add 1 n
(prd n) sub 1 n

(pow2 n) shl n 1

(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)

(inc -n) to -n add 1
(dec -n) to -n sub 1

# strings #

(strlen s) and (peek s) (suc (strlen (suc s)))

(memcmp a b n)
or  not n
and cmpe (peek a) (peek b)
    memcmp (suc a) (suc b) (prd n)

# basic io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (cmpe i error-key)
let byte-count (io i (sub i end))
and byte-count
if  cmpe byte-count error-key
    byte-count
    add i byte-count

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code -out -end) do (retry-mem stdout -out -end) (exit code)

(runtime (main (exit code -out -end) -in -out -mem -top) inbuf outbuf membuf)
let -in  brk 0
let -out add -in  inbuf 
let -mem add -out outbuf
let -top add -mem membuf
do  brk -top
do  retry-string-read stdin -in -out
    main runtime-exit -in -out -mem -top

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# basic data #

(dword) add word word

(pair--a pair)     pair
(pair--b pair) add pair word
(set-a pair a) do (store (pair--a pair) a) pair
(set-b pair b) do (store (pair--b pair) b) pair
(get-a pair) load (pair--a pair)
(get-b pair) load (pair--b pair)
(set-pair pair a b) set-b (set-a pair a) b
(pair-new -mem a b) set-pair (to -mem add dword) a b
(pair-clone -mem span) pair-new -mem (get-a span) (get-b span)

# basic formatting #

(put c out)
let p load out
do  poke p c
do  store out (add 1 p)
    out

(put-digit-16 n out) put (add n (if (cmpa n 10) '0 '7)) out
(put-digit-10 n out) put (add n                 '0    ) out

(put-digits (put-digit n out) base n out)
if  n
    put-digit                 (mod base n)
    put-digits put-digit base (div base n)
    out
    out

(put-number (put-digit n out) base n out)
if  n 
    put-digits put-digit base n out
    put '0 out

(put-dec n out) put-number put-digit-10 10 n out
(put-hex n out) put-number put-digit-16 16 n out

(vput-mem (put a out) a b out)
do  for i a
    and cmpa i b
    do  put (peek i) out
        suc i
    out

(vput-string (put a out) s out)
do  for p s
    let a (peek p)
    and a
    do  put a out
        suc p
    out

(put-string s out) vput-string put s out

# basic scanning #

(eat-bunch (body -caret) -caret) 
for _ 0 body -caret

(eat-grou  (delim -caret) (body -caret) -caret)
and delim -caret
    body  -caret

(eat-group (delim -caret) (body -caret) -caret)
and delim -caret
do  eat-bunch body -caret
    delim -caret

# basic lexing #

(lex-normal (char-class byte) -caret)
and char-class (peek (load -caret))
    store -caret (suc (load -caret))

(lex-escape (class byte) (class-normal byte) (class-alternate byte) -caret)
if  lex-normal class           -caret
    lex-normal class-alternate -caret
    lex-normal class-normal    -caret

# character classification #

(char-negclass (except byte) (class byte) byte)
and except byte
not class  byte

# spans #

(span-equal a b)
let ap (get-a a)
let bp (get-a b)
let an (sub ap (get-b a))
let bn (sub bp (get-b b))
and cmpe an bn
    memcmp ap bp bn

(span-strcmp s lit)
let start (get-a s)
let n (sub start (get-b s))
and memcmp lit start n
    not (peek (add lit n))

(span-set span a b) set-pair span a b
(span-new -mem a b) pair-new -mem a b
(span-clone -mem span) pair-clone -mem span
(vput-span (vput a out) s out) vput-mem vput (get-a s) (get-b s) out
(put-span s out) vput-span put s out

# bookkeeping #

(book-lookup (line-match hay needle) book needle)
and book
let line (get-a book)
if  line-match (get-a line) needle
    get-b line
    book-lookup line-match (get-b book) needle

(book-equal (line-equal a b) a b)
or  cmpe a b
and line-equal (get-b get-a a) (get-b get-a b)
    book-equal line-equal (get-b a) (get-b b)

(book-new -mem next line) pair-new -mem line next
(book-count book) and book (suc (book-count (get-b book)))
(book-pop -book) store -book (get-b (load -book))

# tokens #

(token-take (token-class k) (eat -caret span) -mem token)
and token-class token
let span (span-clone -mem (get-a token))
do  eat (pair--b token) (get-a token)
    span

(token-eat (eat -caret span) token) eat (pair--b token) (get-a token)
(token-init (eat -caret span) -mem -in token)
do  set-pair token pair-new -mem 0 0 -in
    token-eat eat token
(token-skip (token-class k) (eat -caret span) token) and (token-class token) token-eat eat token
(token-clone -mem token) pair-new -mem (span-clone -mem (get-a token)) (get-b token)
(token-match (lex c) token) lex (peek (get-a (get-a token)))
(token-is s token) span-strcmp (get-a token) s
(token-read (text -caret) -caret span) let caret (load -caret) (span-set span caret (if text -caret (load -caret) caret))

# vars #

(var-new -mem type detail) pair-new -mem type detail

# names #

(name-new -mem span var) pair-new -mem (pair-new -mem (get-a span) (get-b span)) var 
(name-push -mem -book span type detail) store -book (book-new -mem (load -book) (name-new -mem span (var-new -mem type detail)))
(name-lookup book span) book-lookup span-equal book span

# typing #

(type-equal a b) or (cmpe a b) (and (and a b) (and (cmpe (get-b a) (get-b b)) (book-equal type-equal (get-a a) (get-a b))))
(type-new -mem book kind) pair-new -mem book kind
(type-unit-new -mem) type-new -mem 0 0
(type-func-new -mem book) type-new -mem book 1

# x86_64 implementation #

(x86_64-string-mov              ) "mov "
(x86_64-string-add              ) "add "
(x86_64-string-test             ) "test "
(x86_64-string-je               ) "je "
(x86_64-string-jne              ) "jne "
(x86_64-string-jmp              ) "jmp "
(x86_64-string-push             ) "push "
(x86_64-string-pop              ) "pop "
(x86_64-string-call             ) "call "
(x86_64-string-ret              ) "ret\n"
(x86_64-string-entry            ) "_start"
(x86_64-string-str-label-prefix ) ".s"
(x86_64-string-globl            ) ".globl "
(x86_64-string-equ              ) "\n.equ "
(x86_64-string-section-text     ) ".section .text."
(x86_64-string-section-data     ) ".section .data."
(x86_64-string-string           ) ".string,"
(x86_64-string-previous         ) ".previous\n"
(x86_64-string-rip-relative     ) "@GOTPCREL(%rip)"
(x86_64-string-stack-top        ) "(%rsp)"
(x86_64-string-stack-ptr        ) ",%rsp\n"
(x86_64-string-rax              ) "%rax"
(x86_64-string-rdi              ) "%rdi"
(x86_64-string-rsi              ) "%rsi"
(x86_64-string-rdx              ) "%rdx"
(x86_64-string-rcx              ) "%rcx"
(x86_64-string-r8               ) "%r8"
(x86_64-string-r9               ) "%r9"

(x86_64-mangle (vput (put a -out) s -out) s -out) vput put-hex s put 'f -out
(x86_64-mangle-span   s -out) x86_64-mangle vput-span   s -out
(x86_64-mangle-string s -out) x86_64-mangle vput-string s -out

(x86_64-label-suf -out) put '\n put ': -out

(x86_64-section-header (vput name -out) name -out)
    x86_64-label-suf
    vput name
    put '\n
    vput name
    put-string x86_64-string-section-text
    -out

(x86_64-predef name body -out)
    put-string x86_64-string-ret
    put '\n
    put-string body
    x86_64-section-header x86_64-mangle-string name
    -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put '$ put '  put-string x86_64-string-add -out
do  and sign (put '- -out)
do  put-string x86_64-string-stack-ptr put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  put '\n
    put-string reg
    put-string sign
    -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  x86_64-string-pop
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  x86_64-string-push

(x86_64-label-id flake -out) put '$ put-dec flake put '. -out
(x86_64-str-label flake -out) put-dec flake put-string x86_64-string-str-label-prefix -out
(x86_64-to-rax -out) put '\n put-string x86_64-string-rax put ', -out
(x86_64-from-rax -out) put ', put-string x86_64-string-rax -out
(x86_64-cz -out) x86_64-to-rax put-string x86_64-string-rax put-string x86_64-string-test -out
(x86_64-jc flake s -out) put '\n x86_64-label-id flake put-string s -out
(x86_64-czjc flake s -out) x86_64-jc flake s x86_64-cz -out

(x86_64-predefs -out out)
do  store -out out
    x86_64-predef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-predef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-predef "cmpe"  "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "cmpa"  "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-predef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-predef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-predef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-predef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-predef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-predef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-predef "poke"  "movb %sil,(%rdi)"
    x86_64-predef "peek"  "movzb (%rdi),%eax"
    x86_64-predef "store" "mov %rsi,(%rdi)\nmov %rdi,%rax"
    x86_64-predef "load"  "mov (%rdi),%rax"
    x86_64-predef "word"  "mov $8,%rax"
    put '\n
    x86_64-mangle-string  x86_64-string-entry
    put ',
    put-string x86_64-string-entry
    put-string x86_64-string-equ
    put-string x86_64-string-entry
    put-string x86_64-string-globl
    -out

(x86_64-flake -flake) inc -flake

(x86_64-je  flake -out) x86_64-czjc flake x86_64-string-je  -out
(x86_64-jne flake -out) x86_64-czjc flake x86_64-string-jne -out
(x86_64-jmp flake -out) x86_64-jc   flake x86_64-string-jmp -out

(x86_64-ref text offset depth -out)
do  put-string x86_64-string-mov -out
    x86_64-to-rax
    if  offset
        put-string x86_64-string-stack-top
        put-dec (shl 3 (sub depth offset))
        -out
        put-string x86_64-string-rip-relative
        x86_64-mangle-span text
        -out

(x86_64-lit text -out)
    x86_64-to-rax
    put-span text
    put '$
    put-string x86_64-string-mov
    -out

(x86_64-str text -flake -out)
let flake (x86_64-flake -flake)
    x86_64-to-rax
    put-string x86_64-string-rip-relative
    x86_64-str-label flake
    put-string x86_64-string-mov
    put-string x86_64-string-previous
    put '\n
    put-span text
    put-string x86_64-string-string
    x86_64-label-suf
    x86_64-str-label flake
    put '\n
    x86_64-str-label flake
    put-string x86_64-string-section-data
    -out

(x86_64-do flake -out) 1

(x86_64-label flake -out)
    x86_64-label-suf
    x86_64-label-id  flake
    -out

(x86_64-var -detail -out) load
do x86_64-fpush -detail -out 1
   -detail

(x86_64-var-in flake -out)
    put '\n
    put-string x86_64-string-stack-top
    x86_64-from-rax
    put-string x86_64-string-mov
    x86_64-label flake
    -out

(x86_64-let-end -depth flake -out) x86_64-fpop -depth -out 1

(x86_64-for-end -depth flake -out)
do  x86_64-jne flake -out
do  x86_64-pop -depth -out x86_64-string-rax
    -out

(x86_64-call-with -depth flake -out)
let offset (load -depth)
do  x86_64-fpush -depth -out flake
do  x86_64-push  -depth -out x86_64-string-rax
    offset

(x86_64-call-arg index -out)
    put '\n
    put-string x86_64-string-stack-top
    put-dec (shl 3 index)
    x86_64-from-rax
    put-string x86_64-string-mov
    -out

(x86_64-call-end-pop index arity -depth reg -out)
do  and cmpa index arity
    x86_64-pop -depth -out reg
    -out

(x86_64-call-end -depth offset arity -out)
do  x86_64-pop   -depth -out x86_64-string-rax
do  put '\n
    put-string x86_64-string-rax
    put '*
    put-string x86_64-string-call
    x86_64-call-end-pop 5 arity -depth x86_64-string-r9
    x86_64-call-end-pop 4 arity -depth x86_64-string-r8
    x86_64-call-end-pop 3 arity -depth x86_64-string-rcx
    x86_64-call-end-pop 2 arity -depth x86_64-string-rdx
    x86_64-call-end-pop 1 arity -depth x86_64-string-rsi
    x86_64-call-end-pop 0 arity -depth x86_64-string-rdi
	-out
    x86_64-fpop -depth -out (sub (load -depth) offset)

(x86_64-decl-in -detail span -out)
do  x86_64-section-header x86_64-mangle-span span -out
    store -detail shl 63 1

(x86_64-decl-end -detail arity -out)
do  x86_64-fpop -detail -out arity
    put-string x86_64-string-ret -out

# character ranges #

(char-range-nz byte) not not byte

(char-range-sq byte) cmpe  byte '\'
(char-range-dq byte) cmpe  byte '\"
(char-range-bs byte) cmpe  byte '\\
(char-range-hm byte) cmpe  byte '#
(char-range-qm byte) cmpe  byte '?
(char-range-lp byte) cmpe  byte '(
(char-range-rp byte) cmpe  byte ')
(char-range-us byte) cmpe  byte '_
(char-range-en byte) cmpe  byte '-
(char-range-sp byte) cmpe  byte ' 
(char-range-tb byte) cmpe  byte '\t
(char-range-lf byte) cmpe  byte '\n
(char-range-cr byte) cmpe  byte '\r

(char-range-09 byte) cmpin byte '0 '9
(char-range-AZ byte) cmpin byte 'A 'Z
(char-range-az byte) cmpin byte 'a 'z

# character classes #

(char-class-nz byte)     char-range-nz byte

(char-class-hm byte)     char-range-hm byte
(char-class-bs byte)     char-range-bs byte
(char-class-sq byte)     char-range-sq byte
(char-class-dq byte)     char-range-dq byte
(char-class-09 byte)     char-range-09 byte
(char-class-qm byte)     char-range-qm byte
(char-class-lp byte)     char-range-lp byte
(char-class-rp byte)     char-range-rp byte

(char-class-ws byte) or  char-range-sp byte
                     or  char-range-tb byte
                     or  char-range-lf byte
                         char-range-cr byte
(char-class-id byte) or  char-range-AZ byte
                     or  char-range-az byte
                     or  char-range-09 byte
                     or  char-range-en byte
                         char-range-us byte
(char-class-im byte) or  char-range-09 byte
                         char-range-sq byte
(char-class-pt byte) or  char-range-lp byte
                     or  char-range-rp byte
                         char-range-qm byte

(char-class-sb byte) char-negclass char-class-nz char-class-dq byte
(char-class-cb byte) char-negclass char-class-nz char-class-hm byte

# token classes #

(token-class-do   -token) token-is "do"  -token
(token-class-if   -token) token-is "if"  -token
(token-class-or   -token) token-is "or"  -token
(token-class-and  -token) token-is "and" -token
(token-class-for  -token) token-is "for" -token
(token-class-let  -token) token-is "let" -token

(token-class-lp   -token) token-match char-class-lp -token
(token-class-rp   -token) token-match char-class-rp -token
(token-class-qm   -token) token-match char-class-qm -token
(token-class-str  -token) token-match char-class-dq -token
(token-class-lit  -token) token-match char-class-im -token
(token-class-id   -token) token-match char-class-id -token

# lexical units #

(lex-hm -caret) lex-normal char-class-hm -caret
(lex-dq -caret) lex-normal char-class-dq -caret
(lex-sq -caret) lex-normal char-class-sq -caret
(lex-09 -caret) lex-normal char-class-09 -caret
(lex-pt -caret) lex-normal char-class-pt -caret
(lex-ws -caret) lex-normal char-class-ws -caret
(lex-id -caret) lex-escape char-class-bs char-class-id char-class-nz -caret
(lex-sb -caret) lex-escape char-class-bs char-class-sb char-class-nz -caret
(lex-cb -caret) lex-escape char-class-bs char-class-cb char-class-nz -caret

# tokenizer #

(eat-user -caret)
for _ 0
or  eat-bunch lex-ws        -caret
    eat-group lex-hm lex-cb -caret

(eat-text -caret)
or  eat-bunch lex-id        -caret
or            lex-pt        -caret
or  eat-grou  lex-sq lex-sb -caret
or  eat-group lex-dq lex-sb -caret
    eat-bunch lex-09        -caret

(eat -caret -span)
do  eat-user -caret
    token-read eat-text -caret -span

# semantics #

(sem-pre (impl -out out) -book -out out)
do  store -book 0
    load impl -out out

(sem-do (impl -flake) -flake) impl -flake

(sem-lit (impl span -out) -mem -type span -out)
do  impl span -out
    type-unit-new -mem

(sem-str (impl span -flake -out) -mem -type span -flake -out)
do  impl span -flake -out
    type-unit-new -mem

(sem-ref (impl span offset -depth -out) -type book span -depth -out)
let var name-lookup book span
if  var
do  impl span (get-b var) -depth -out
    get-a var
    error 2 "undefined identifier"

(sem-var (impl -detail -out) -flake -mem -book -detail span type -out)
let flake x86_64-flake -flake
do  name-push -mem -book span (type-unit-new -mem) (impl -detail -out)
    flake

(sem-var-end (impl -detail flake -out) -mem -book -detail flake -out)
do  impl -detail flake -out
    book-pop -book

(sem-call-arg  (impl index -out) type-param type-arg index -out)
if  type-equal type-param type-arg
    impl index -out
    error 3 "illegal argument"

(sem-call-end  (impl offset depth arity -out) -mem -type offset depth arity -out) store -type
do  impl offset depth arity -out
    (type-unit-new -mem)

# sem type #

(sem--mem      -sem)                      -sem
(sem--book     -sem) add   (sem--mem      -sem) word
(sem--out      -sem) add   (sem--book     -sem) word
(sem--impl     -sem) add   (sem--out      -sem) word
(sem-get-token -sem) add   (sem--impl     -sem) word
(sem--type     -sem) add   (sem-get-token -sem) dword
(sem--val      -sem) add   (sem--type     -sem) word
(sem--fixed    -sem) add   (sem--val      -sem) word
(sem--flake    -sem) add   (sem--fixed    -sem) word
(word-sem          )        sem--flake          word

(sem-set-book  -sem book ) store (sem--book  -sem) book
(sem-set-mem   -sem mem  ) store (sem--mem   -sem) mem
(sem-set-out   -sem out  ) store (sem--out   -sem) out
(sem-set-type  -sem type ) store (sem--type  -sem) type
(sem-set-val   -sem val  ) store (sem--val   -sem) val
(sem-set-fixed -sem fixed) store (sem--fixed -sem) fixed
(sem-set-flake -sem flake) store (sem--flake -sem) flake

(sem-get-book  -sem) load  (sem--book  -sem)
(sem-get-mem   -sem) load  (sem--mem   -sem)
(sem-get-out   -sem) load  (sem--out   -sem)
(sem-get-type  -sem) load  (sem--type  -sem)
(sem-get-val   -sem) load  (sem--val   -sem)
(sem-get-fixed -sem) load  (sem--fixed -sem)
(sem-get-flake -sem) load  (sem--flake -sem)
(sem-get-impl  -sem) load  (sem--impl  -sem)

# expression parsers #

(parse-builtin (token-class k) (syn (syn x t) x t) (syn-syn x t) x t)
and token-skip token-class eat (sem-get-token x)
    syn syn-syn x t

(parse-atom (token-class k) (syn-atom (syn x t) x span) (syn x t) x)
let span (token-take token-class eat (sem--mem x) (sem-get-token x))
and span
    syn-atom syn x span

(parse-id x) token-skip token-class-id eat (sem-get-token x)
(parse-lp x) token-skip token-class-lp eat (sem-get-token x)
(parse-rp x) token-skip token-class-rp eat (sem-get-token x)
(parse-qm x) token-skip token-class-qm eat (sem-get-token x)

# term syntax #

(parse-init (sem x -out) x -mem -in -out token)
do  store -mem (add -mem word-sem)
do  token-init eat -mem -in token
    sem x -out

(parse-unit (sem x span) x span)  store (sem--type x) sem x span

(parse-var (sem x) (sem-in x a) (sem-end x a) (syn x t) x t)
let a
    sem      x
do  parse-id   x
do  syn      x 0
do  sem-in   x a
do  syn      x t
    sem-end  x a

(parse-seq (sem x) (sem-then x a) (sem-end x a) (syn x t) x t)
let a
    sem      x
do  syn      x t
do  sem-then x a
do  syn      x t
    sem-end  x a

(parse-if (sem x) (sem-then x a) (sem-else x a) (sem-end x a) (syn x t) x t)
let a
    sem      x
do  syn      x 0
do  sem-then x a
do  syn      x t
let b
    sem      x
do  sem-else x b
do  sem-end  x a
do  syn      x t
    sem-end  x b

(parse-arg (sem x t i) (syn x t) x t i)
do  syn      x t
    sem      x t i

(parse-args (sem x t i) (syn x t) x book i)
and book
do  parse-arg  sem syn x (get-b get-a book)      i
    parse-args sem syn x (      get-b book) (suc i)

(parse-call (sem x arity) (sem-arg x book index) (sem-end x arity depth) (syn x type) x type)
let arity (book-count (get-a type))
let depth sem x arity
do  parse-args sem-arg syn x (get-a type) 1
    sem-end  x arity depth

# here we say what implementation to use #

(impl-pre       x out        ) sem-pre       x86_64-predefs          (sem--book  x) (sem--out   x) out
(impl-lit       x span       ) sem-lit       x86_64-lit              (sem--mem   x) (sem--type x) span (sem--out  x)
(impl-str       x span       ) sem-str       x86_64-str              (sem--mem   x) (sem--type x) span (sem--flake x) (sem--out  x)
(impl-ref       x span       ) sem-ref       x86_64-ref              (sem--type  x) (sem-get-book x) span (sem-get-impl x) (sem--out   x)
(impl-let       x            ) sem-var       x86_64-var              (sem--flake x) (sem--mem   x) (sem--book x) (sem--impl x) (get-a sem-get-token x) (sem-get-type x) (sem--out x)
(impl-let-in    x flake      )               x86_64-var-in     flake (sem--out   x)
(impl-let-end   x flake      ) sem-var-end   x86_64-let-end          (sem--mem   x) (sem--book x) (sem--impl x) flake (sem--out  x)
(impl-for       x            ) sem-var       x86_64-var              (sem--flake x) (sem--mem   x) (sem--book x) (sem--impl x) (get-a sem-get-token x) (sem-get-type x) (sem--out x)
(impl-for-in    x flake      )               x86_64-var-in     flake (sem--out   x)
(impl-for-end   x flake      ) sem-var-end   x86_64-for-end          (sem--mem   x) (sem--book x) (sem--impl x) flake (sem--out  x)
(impl-do        x            ) sem-do        x86_64-flake            (sem--flake x)
(impl-do-then   x flake      )               x86_64-do         flake (sem--out   x)
(impl-do-end    x flake      )               x86_64-label      flake (sem--out   x)
(impl-and       x            ) sem-do        x86_64-flake            (sem--flake x)
(impl-and-then  x flake      )               x86_64-je         flake (sem--out   x)
(impl-and-end   x flake      )               x86_64-label      flake (sem--out   x)
(impl-or        x            ) sem-do        x86_64-flake            (sem--flake x)
(impl-or-else   x flake      )               x86_64-jne        flake (sem--out   x)
(impl-or-end    x flake      )               x86_64-label      flake (sem--out   x)
(impl-if        x            ) sem-do        x86_64-flake            (sem--flake x)
(impl-if-then   x flake      )               x86_64-je         flake (sem--out   x)
(impl-if-else   x flake      )               x86_64-jmp        flake (sem--out   x)
(impl-if-end    x flake      )               x86_64-label      flake (sem--out   x)
(impl-call-with x arity      )               x86_64-call-with        (sem--impl  x) arity (sem--out   x)
(impl-call-arg  x type  index) sem-call-arg  x86_64-call-arg         (sem-get-type x) type index (sem--out   x)
(impl-call-end  x arity depth) sem-call-end  x86_64-call-end         (sem--mem   x) (sem--type x) (sem--impl x) depth arity (sem--out x)

# expression syntax #

(syn-init x -in -out) parse-init  impl-pre x (sem--mem x) -in -out (sem-get-token x)

(syn-lit  (syn x type) x span) parse-unit impl-lit           x span
(syn-str  (syn x type) x span) parse-unit impl-str           x span
(syn-ref  (syn x type) x span) parse-unit impl-ref           x span
(syn-let  (syn x type) x type) parse-var  impl-let
                                          impl-let-in
                                          impl-let-end   syn x type
(syn-for  (syn x type) x type) parse-var  impl-for
                                          impl-for-in
                                          impl-for-end   syn x type
(syn-do   (syn x type) x type) parse-seq  impl-do
                                          impl-do-then
                                          impl-do-end    syn x type
(syn-and  (syn x type) x type) parse-seq  impl-and
                                          impl-and-then 
                                          impl-and-end   syn x type
(syn-or   (syn x type) x type) parse-seq  impl-or
                                          impl-or-else
                                          impl-or-end    syn x type
(syn-if   (syn x type) x type) parse-if   impl-if
                                          impl-if-then
                                          impl-if-else
                                          impl-if-end    syn x type
(syn-call (syn x type) x type) parse-call impl-call-with
                                          impl-call-arg
                                          impl-call-end  syn x type

(parse-term (syn x type) x type)
or  parse-builtin token-class-do  syn-do  syn x type
or  parse-builtin token-class-if  syn-if  syn x type
or  parse-builtin token-class-or  syn-or  syn x type
or  parse-builtin token-class-and syn-and syn x type
or  parse-builtin token-class-let syn-let syn x type
or  parse-builtin token-class-for syn-for syn x type
or  parse-atom    token-class-lit syn-lit syn x
or  parse-atom    token-class-str syn-str syn x
or  parse-atom    token-class-id  syn-ref syn x
    error 4 "expected term"

(syn-juxt (syn x t) x t)
let u (sem-get-type x)   
and not type-equal t    u
and get-b       u
    syn-call syn x u

(syn-nest (syn x t) x t)
if  parse-lp x
do  parse-term syn x t
or  parse-rp x
do  syn-juxt syn x t
or  parse-rp x
    error 5 "expected `)`"
do  parse-term syn x t
    syn-juxt syn x t

(syn-expr x t) syn-nest syn-expr x t

# declaration syntax #

(params (impl x o y) x o y)
if  o
    impl x o y
do  syn-expr x (type-unit-new (sem--mem x))
    0

(params-next (impl x o -depth) x o -depth offset)
let d (get-a o)
do  name-push (sem--mem x) (sem--book x) (get-a get-a d) (get-b d) offset
let h params impl x (get-b o) -depth
do  book-pop (sem--book x)
    h

(register (impl x o y) x o reg y)
do  x86_64-push (sem--impl x) (sem--out x) reg 
    suc (params-next impl x o y (sem-get-impl x))

(stack x o y) params-next stack x o (suc y) y

(register-seq (impl x o y) reg x o y) register impl x o reg (suc y)

(register5 x o y) register-seq     stack "%r9"  x o 0
(register4 x o y) register-seq register5 "%r8"  x o y
(register3 x o y) register-seq register4 "%rcx" x o y
(register2 x o y) register-seq register3 "%rdx" x o y
(register1 x o y) register-seq register2 "%rsi" x o y
(register0 x o y) register-seq register1 "%rdi" x o y

(syn-body x d)
if  name-lookup (sem-get-book x) (get-a get-a d)
    error 6 "redefinition"
do  name-push (sem--mem x) (sem--book x) (get-a get-a d) (get-b d) 0
or  parse-qm x
do  x86_64-decl-in  (sem--impl x) (get-a get-a d) (sem--out x)
let y (params register0 x (get-a get-b d) 0)
    load x86_64-decl-end (sem--impl x) y (sem--out x)

(syn-decl-unit x) type-unit-new (sem--mem x)

(syn-decl (syn x) x)
let token token-clone (sem--mem x) (sem-get-token x)
do  parse-id x
    pair-new (sem--mem x) token (syn x)

(syn-param (syn x) x) syn-decl (if parse-lp x syn syn-decl-unit) x

(syn-params (syn x) x)
and not parse-rp x
let decl (syn-param syn x)
    book-new (sem--mem x) (syn-params syn x) decl

(syn-decl-func x) type-func-new (sem--mem x) (syn-params syn-decl-func x)

(syn x in out)
for _ syn-init x in out
if  parse-lp x
    syn-body x (syn-decl syn-decl-func x)
    0

(main (return code out end) in out mem top) return 0 out (syn mem in out)
(_start) runtime main (pow2 20) (pow2 20) (pow2 20)
