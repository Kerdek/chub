# lexer #

is_dq (a)
cmpe a '\"

is_ndq (a)
not is_dq a

is_09 (a)
not or  cmpa a '0
        cmpa '9 a

is_ws (a)
or  cmpe a ' 
or  cmpe a '\t
or  cmpe a '\n
    cmpe a '\r

is_id (a) not
and or  cmpa a 'A cmpa 'Z a
and or  cmpa a 'a cmpa 'z a
    not or  is_09 a
            cmpe a '_

is_lit (a)
or  is_09 a
    cmpe a '\'

# caret #

struct_caret_ptr  (c)                        c
struct_caret_line (c) add (struct_caret_ptr  c) scalar
struct_caret_col  (c) add (struct_caret_line c) scalar
struct_caret      ( )      struct_caret_col     scalar

caret_init (c ptr line col)
do  store struct_caret_ptr  c ptr
do  store struct_caret_line c line
    store struct_caret_col  c col

caret_peek (c)
peek load struct_caret_ptr c

caret_skip (c)
do  or  caret_peek c
    # unexpected eof #
    exit 2
do  store struct_caret_ptr c add 1 load struct_caret_ptr c
    if  cmpe caret_peek c '\n
    do  store struct_caret_col  c  1
        store struct_caret_line c add 1 load struct_caret_line c
        store struct_caret_col  c add 1 load struct_caret_col  c

caret_eat (c a)
and cmpe a caret_peek c
    caret_skip c

caret_eat_by (is (a) c)
and is caret_peek c
    caret_skip c

caret_eat_for (is (a) c)
and is caret_peek c
for 1 _
    caret_eat_by is c

caret_ptr  (c)
load struct_caret_ptr  c

caret_line (c)
load struct_caret_line c

caret_col (c)
load struct_caret_col  c

# tokenizer  #

ws (c)
for 1 _
or  and caret_eat c '#
        for 1 _
        and not caret_eat c '#
            caret_skip c
        caret_eat_by is_ws c

id (c)
caret_eat_for is_id c

number (c)
caret_eat_for is_09 c

string (c)
and caret_eat c '"
    do  for 1 _
        do  for 1 _
            and caret_eat c '\\
                caret_skip c
        caret_eat_by is_ndq c
        caret_skip c

char (c)
and caret_eat  c '\'
do  caret_eat  c '\\
do  caret_skip c
do  caret_eat  c '\'
    1

punct (c)
or  caret_eat c '(
or  caret_eat c ')
    caret_eat c '?

# token #

struct_token_start (k)                           k
struct_token_end   (k) add (struct_token_start   k) scalar
struct_token_caret (k) add (struct_token_end     k) scalar
struct_token       ( )      struct_token_caret      struct_caret

token_copy (a b)
memcpy a b struct_token

init_token (k in)
do  caret_init struct_token_caret k in 1 1
do  ws struct_token_caret k
or  and not caret_peek struct_token_caret k
        do  store struct_token_start  k 0
        do  store struct_token_end    k 0
            1
let caret_ptr struct_token_caret k start
do  or  id struct_token_caret k
        # invalid token #
        exit 5
do  store struct_token_start  k start
    store struct_token_end    k caret_ptr struct_token_caret k

next (k)
do  or load struct_token_start k
    # no more tokens #
    exit 5
do  ws struct_token_caret k
or	and not caret_peek struct_token_caret k
        do  store struct_token_start  k 0
        do  store struct_token_end    k 0
            1
let caret_ptr struct_token_caret k start
do  or number struct_token_caret k
    or string struct_token_caret k
    or char   struct_token_caret k
    or id     struct_token_caret k
    or punct struct_token_caret  k
       # invalid token #
       exit 6
do  store struct_token_start  k start
    store struct_token_end    k caret_ptr struct_token_caret k

have (k literal)
let load struct_token_start  k start
let load struct_token_end    k end
let sub start end length
and start
    substrcmp literal start length

token_is (is (c) k)
is peek load struct_token_start k

have_lit (k)
token_is is_lit k

have_str (k)
token_is is_dq k

have_id (k)
token_is is_id k

eat (k c)
let have k c r
do  and r
    next k r

token_equal (ka kb)
let load struct_token_start ka starta
let load struct_token_start kb startb
    streq starta sub starta load struct_token_end ka startb sub startb load struct_token_end kb

put_token (out k)
let load struct_token_start  k start
let load struct_token_end    k end
let sub start end length
for start in
and cmpa in end
do  put_byte out peek in
    add 1 in

more_tokens (k)
caret_peek struct_token_caret k

# stack accounting #

pushpop (impl (out depth arg) out depth arg sign (a b) size)
do  impl out depth arg
    store depth sign size load depth

fpop  (impl (out depth size) out depth size) pushpop impl out depth size add size
fpush (impl (out depth size) out depth size) pushpop impl out depth size sub size
pop   (impl (out depth reg ) out depth reg ) pushpop impl out depth reg  add 1
push  (impl (out depth reg ) out depth reg ) pushpop impl out depth reg  sub 1

# x86_64 #

ins0 (out s c)
do put_string out s
   put_byte   out c

ins1 (out s)
ins0 out s ' 

mnem0 (out s)
ins0 out s '\n

mnem1 (out s a)
do  ins1  out s
    mnem0 out a

mnem2 (out s a b)
do  ins1  out s
do  ins0 out a ',
    mnem0 out b

cz (out)
mnem2 out "test" "%rax" "%rax"

label_id (out n)
do  put_byte out 'l
do  put_number out n
    put_byte out '$

label (out n)
do  label_id out n 
    put_string out ":\n"

jc (out n s)
do  ins0 out s ' 
do  label_id out n
    put_byte out '\n

jcn (out n s)
jc out n s

czjc (out n s)
do  cz out
    jcn out n s

x86_64_je  (out n) czjc out n "je"
x86_64_jne (out n) czjc out n "jne"
x86_64_jmp (out n) jcn  out n "jmp"

x86_64_rip (out)
put_string out "@GOTPCREL(%rip),%rax\n"

x86_64_load_rel (out then now)
do  put_number out shl 3 sub now then
    put_string out "(%rsp),%rax\n"

x86_64_if (j (out n) out)
let load out n
do  j out n
    n

x86_64_fpushpop (out depth size ins)
and size
do  put_string out ins
do  put_number out shl 3 size
    put_string out ",%rsp\n"

x86_64_fpop (out depth size)
x86_64_fpushpop out depth size "add $"

x86_64_fpush (out depth size)
x86_64_fpushpop out depth size "add $-"

x86_64_pop  (out depth reg)
mnem1 out "pop" reg

x86_64_push (out depth reg)
mnem1 out "push" reg

# implementation #

impl_x86_64_preamble (out)
mnem0 out ".globl _start"

impl_x86_64_id (out k then now)
do  put_string out "mov "
if  then
    x86_64_load_rel out then now
    do  put_token out k
        x86_64_rip out

impl_x86_64_addr (out k then now)
do  put_string out "lea "
    x86_64_load_rel out then now

impl_x86_64_lit (out k)
do  put_string out "mov $"
do  put_token  out k
    put_string out ",%rax\n"

impl_x86_64_str (out k)
let load out n
do  put_string out ".section .text..s"
do  put_number out n
do  put_string out "\n.s"
do  put_number out n
do  put_string out ":.string "
do  put_token  out k
do  put_string out "\n.previous\n"
do  put_string out "mov .s" 
do  put_number out n
    x86_64_rip out

impl_x86_64_and  (out) x86_64_if x86_64_je  out
impl_x86_64_or   (out) x86_64_if x86_64_jne out
impl_x86_64_else (out) x86_64_if x86_64_jmp out

impl_x86_64_loop (out n)
x86_64_jne out n

impl_x86_64_let (out depth)
let load out n
do  push x86_64_push out depth "%rax"
    n

impl_x86_64_unlet (out depth)
fpop x86_64_fpop out depth 1

impl_x86_64_for (out)
mnem2 out "mov" "%rax" "(%rsp)"

impl_x86_64_unfor (out depth)
pop x86_64_pop out depth "%rax"

impl_x86_64_label (out n)
label out n

# types #

struct_type_next  (t)                        t
struct_type_arg   (t) add (struct_type_next  t) scalar
struct_type_token (t) add (struct_type_arg   t) scalar
struct_type_kind  (t) add (struct_type_token t) struct_token
struct_type       ( )      struct_type_kind     scalar

new_type (brk token kind)
let alloc brk struct_type t
do  store struct_type_next t 0
do  token_copy struct_type_token t token
do  store struct_type_kind t kind
    t

type_arity (t)
let 0 d
do  and struct_type_next t
    for struct_type_next t u
    do  store addr d add 1 d
        load struct_type_next u
    d

type_equal (a b)
and a
and b
or  cmpe a b
and cmpe load struct_type_kind a
         load struct_type_kind b
do  copy addr a struct_type_arg a
do  copy addr b struct_type_arg b
do  for 1 _
    and type_equal a b
    do  copy addr a struct_type_next a
    do  copy addr b struct_type_next b
        1
    cmpe a b

# semantics #

struct_arnica_book   (x)                           x
struct_arnica_brk    (x) add (struct_arnica_book   x) scalar
struct_arnica_out    (x) add (struct_arnica_brk    x) scalar
struct_arnica_token  (x) add (struct_arnica_out    x) scalar
struct_arnica_scalar (x) add (struct_arnica_token  x) struct_token
struct_arnica_type   (x) add (struct_arnica_scalar x) scalar
struct_arnica_impl   (x) add (struct_arnica_type   x) scalar
struct_arnica        ( )      struct_arnica_impl      scalar

arnica_constant (impl (out k) x t)
do  impl struct_arnica_out x struct_arnica_token x
do  next struct_arnica_token x
    copy struct_arnica_type x struct_arnica_scalar x

arnica_variable (impl (out k then now) x t then)
do  impl struct_arnica_out x struct_arnica_token x then load struct_arnica_impl x
do  next struct_arnica_token x
    store struct_arnica_type x t

sem_arnica_lit  (x t) arnica_constant impl_x86_64_lit x t
sem_arnica_str  (x t) arnica_constant impl_x86_64_str x t

sem_arnica_addr (x t then) arnica_variable impl_x86_64_addr x t then
sem_arnica_id   (x t then) arnica_variable impl_x86_64_id   x t then

sem_arnica_and   (x) impl_x86_64_and  struct_arnica_out x 
sem_arnica_or    (x) impl_x86_64_or   struct_arnica_out x 
sem_arnica_else  (x) impl_x86_64_else struct_arnica_out x

sem_arnica_label (x n) impl_x86_64_label struct_arnica_out x n

sem_arnica_let   (x  ) impl_x86_64_let   struct_arnica_out x struct_arnica_impl x
sem_arnica_unlet (x n) impl_x86_64_unlet struct_arnica_out x struct_arnica_impl x

sem_arnica_for (x)
let impl_x86_64_let   struct_arnica_out x struct_arnica_impl x n
let impl_x86_64_else  struct_arnica_out x m
do  impl_x86_64_label struct_arnica_out x n
do  impl_x86_64_for   struct_arnica_out x
do  impl_x86_64_label struct_arnica_out x m
    n

sem_arnica_unfor (x n)
do  impl_x86_64_loop  struct_arnica_out x n
    impl_x86_64_unfor struct_arnica_out x struct_arnica_impl x

# bookkeeping #

struct_decl_type  (o)                          o
struct_decl_impl  (o) add (struct_decl_type    o) scalar
struct_decl_isdef (o) add (struct_decl_impl    o) scalar
struct_decl       ( )      struct_decl_isdef      scalar

struct_name_token (o)                          o
struct_name_decl  (o) add (struct_name_token   o) struct_token
struct_name       ( )      struct_name_decl       struct_decl

struct_book_next  (o)                       o
struct_book_name  (o) add (struct_book_next o) scalar
struct_book       ( )      struct_book_name    struct_name

push_book (brk book token type impl)
let alloc brk struct_book next
do        copy struct_book_next  next book
let struct_book_name next name
do  token_copy struct_name_token name token
let struct_name_decl name decl
do        copy struct_decl_type  decl type
do        copy struct_decl_impl  decl impl
do       store struct_decl_isdef decl 0
do  store book next
    name

pop_book (book)
copy book load struct_book_next book

try_lookup (book token)
let 0 r
do  for load book i
    if  token_equal token struct_name_token struct_book_name i
        load struct_book_next i
        do  store addr r struct_book_name i
            0
    r

lookup (book token)
or  try_lookup book token
    # lookup failed #
    exit 1

# syntax #

syn_and_or (sem (x) p (x t) x t)
do  p x t
let sem x n
do  p x t
    sem_arnica_label x n

syn_let_for (sem (x) sem_un (x n) p (x t) x t u)
do  p x u
let sem x n
do  push_book
        struct_arnica_brk   x
        struct_arnica_book  x
        struct_arnica_token x
        struct_arnica_type  x
        struct_arnica_impl  x
do  next struct_arnica_token x
do  p x t
do  pop_book struct_arnica_book x
    sem_un x n

syn_literal (p (x t) x t) sem_arnica_lit  x t
syn_string  (p (x t) x t) sem_arnica_str  x t

syn_addr    (p (x t) x t)
let lookup struct_arnica_book x struct_arnica_token x o
    sem_arnica_addr x load struct_arnica_scalar x load struct_decl_impl struct_name_decl o

syn_id      (p (x t) x t)
let lookup struct_arnica_book x struct_arnica_token x o
    sem_arnica_id x load struct_decl_type struct_name_decl o load struct_decl_impl struct_name_decl o

syn_and (p (x t) x t) syn_and_or sem_arnica_and p x t
syn_or  (p (x t) x t) syn_and_or sem_arnica_or  p x t

syn_let (p (x t) x t)
syn_let_for sem_arnica_let sem_arnica_unlet p x t 0

syn_for (p (x t) x t)
syn_let_for sem_arnica_for sem_arnica_unfor p x t t

syn_if (p (x t) x t)
do  p x 0
let sem_arnica_and   x n
do  p x t
let sem_arnica_else  x m
do  sem_arnica_label x n
do  p x t
    sem_arnica_label x m

syn_do  (p (x t) x t)
do p x 0
   p x t

#
`parse_expr` is the main expression syntax.
It's just polish notation with a bit
of type sensitivity. If a `parse_expr` has
parse_rest_decls type, the parser expects
appropriate arguments. We need a
syntax for referring to a parse_rest_decls
without expecting more arguments, for
passing to HOFs sometimes. `parse_arg` is
where parens cancel call parsing.
#

parse_type (x) ?

parse_param (x t)
do  store t alloc struct_arnica_brk x struct_type
do  token_copy struct_type_token load t struct_arnica_token x
do  next struct_arnica_token x
let parse_type x u
do  copy struct_type_arg  load t struct_type_arg  u
    copy struct_type_kind load t struct_type_kind u

parse_type (x)
if  eat struct_arnica_token x "("
    let new_type struct_arnica_brk x struct_arnica_token x 1 t
    do  for struct_type_arg t u
        and not eat struct_arnica_token x ")"
        do  parse_param x u
            load u
        t
    load struct_arnica_scalar x

parse_nest (x t) ?

kind_expr (c gen (parse (x t) x t) parse (x t) x t)
and eat struct_arnica_token x c gen parse x t

parse_arg (x t) ?

parse_primary (x t)
or  parse_nest x t
or  kind_expr "do"   syn_do   parse_arg x t
or  kind_expr "or"   syn_or   parse_arg x t
or  kind_expr "if"   syn_if   parse_arg x t
or  kind_expr "and"  syn_and  parse_arg x t
or  kind_expr "let"  syn_let  parse_arg x t
or  kind_expr "for"  syn_for  parse_arg x t
or  kind_expr "addr" syn_addr parse_arg x t
or  and have_lit struct_arnica_token x syn_literal parse_arg x t
or  and have_str struct_arnica_token x syn_string parse_arg x t
or  and have_id  struct_arnica_token x syn_id  parse_arg x t
    # expected expression #
    exit 11

argreg (d)
or and cmpe d 0 "%rdi"
or and cmpe d 1 "%rsi"
or and cmpe d 2 "%rdx"
or and cmpe d 3 "%rcx"
or and cmpe d 4 "%r8"
                "%r9"

syn_arg (x i)
do  put_string struct_arnica_out x "mov %rax,"
do  put_number struct_arnica_out x shl 3 load i
do  put_string struct_arnica_out x "(%rsp)\n"
    store i add 1 load i

syn_args (parse (x t) x parameters)
let 1 depth
and parameters
for parameters u
do  parse x u
do  or  type_equal u load struct_arnica_type x
        # asymmetric argument #
        exit 12
do  syn_arg x addr depth
    load u

syn_call (parse (x t) x parameters arity)
do  fpush x86_64_fpush struct_arnica_out x struct_arnica_impl x arity
do  push  x86_64_push  struct_arnica_out x struct_arnica_impl x "%rax"
do  syn_args parse x parameters
    pop x86_64_pop   struct_arnica_out x struct_arnica_impl x "%rax"

syn_argreg (x i)
pop x86_64_pop struct_arnica_out x struct_arnica_impl x argreg i

parse_call (x t)
or  have struct_arnica_token x ")" 
or  and t
        type_equal t
                   load struct_arnica_type x
for 1 _
and load struct_type_kind load struct_arnica_type x
let load struct_arnica_impl x depth
let load struct_arnica_type x function_type
let load struct_type_arg function_type parameters
let type_arity parameters arity
do  syn_call parse_arg x parameters arity
do  let if cmpa arity 6 arity 6 regargs
    for 0 i
    and cmpa i regargs
    do  syn_argreg x i
        add 1 i
do  mnem1 struct_arnica_out x "call" "*%rax"
do  fpop x86_64_fpop struct_arnica_out x struct_arnica_impl x sub load struct_arnica_impl x depth
do  copy struct_arnica_type x struct_arnica_scalar x
    1

parse_expr (x t)
do  parse_primary x t
    parse_call x t

parse_nest (x t)
and eat struct_arnica_token x "("
do  parse_expr x t
    eat struct_arnica_token x ")"

parse_arg (x t)
or parse_nest x t
   parse_expr x t

params (next (x t g) x t g)
if  t
    next x t g
    do  parse_arg x 0
        0

param_push_book (x t)
push_book struct_arnica_brk x struct_arnica_book x struct_type_token t struct_arnica_type x struct_arnica_impl x

params_next (next (x t g) x t g)
let params next x load t g h
do  pop_book struct_arnica_book x
    h

register (next (x t g) x t reg g)
do  push x86_64_push struct_arnica_out x struct_arnica_impl x reg
do  store struct_arnica_type x t
do  param_push_book x t
    add 1 params_next next x t g

stack (x t g)
do  store struct_arnica_type x t
do  let param_push_book x t o
        store struct_decl_impl struct_name_decl o g
    params_next stack x t add 1 g

register_seq (next (x t g) reg x t g)
register next x t reg add 1 g

register5 (x t g) register_seq     stack "%r9"  x t 0
register4 (x t g) register_seq register5 "%r8"  x t g
register3 (x t g) register_seq register4 "%rcx" x t g
register2 (x t g) register_seq register3 "%rdx" x t g
register1 (x t g) register_seq register2 "%rsi" x t g
register0 (x t g) register_seq register1 "%rdi" x t g

parse_decl (whether_lookup (x) x)
and more_tokens struct_arnica_token x
let whether_lookup x o
do  or 	not load struct_decl_isdef struct_name_decl o
        # remention #
        exit 13
do  parse_param x struct_decl_type struct_name_decl o
do  store struct_decl_isdef struct_name_decl o not eat struct_arnica_token x "?"
do  and load struct_decl_isdef struct_name_decl o
    do  put_string struct_arnica_out x ".section .text." 
    do  put_token struct_arnica_out x struct_name_token o
    do  put_byte  struct_arnica_out x '\n
    do  put_token struct_arnica_out x struct_name_token o
    do  put_string struct_arnica_out x ":\n"
    do  store struct_arnica_impl x shl 63 1
    do  fpop x86_64_fpop struct_arnica_out x struct_arnica_impl x params register0 x load struct_type_arg load struct_decl_type struct_name_decl o 0
        mnem0 struct_arnica_out x "ret"
    1

decl_nolookup (x)
do  store struct_arnica_impl x 0
    push_book struct_arnica_brk x struct_arnica_book x struct_arnica_token x struct_arnica_type x struct_arnica_impl x

decl_lookup (x)
or 	try_lookup struct_arnica_book x struct_arnica_token x
    decl_nolookup x

parse_rest_decls (x)
and parse_decl decl_lookup x
    parse_rest_decls x

parse_first_decl (x)
and parse_decl decl_nolookup x
    parse_rest_decls x

runtime (heap inbuf outbuf)
let initbrk heap x
do  store x 0
do  store struct_arnica_brk x add x struct_arnica
let alloc struct_arnica_brk x inbuf  in
let alloc struct_arnica_brk x outbuf out
do  store struct_arnica_out x out
do  poke retry stdin in add in inbuf 0
do  store struct_arnica_scalar x new_type struct_arnica_brk x struct_arnica_token x 0
do  init_token struct_arnica_token x in
do  impl_x86_64_preamble struct_arnica_out x
do  parse_first_decl x
do  retry stdout out load struct_arnica_out x
    # OK #
    exit 0

_start ()
runtime shl 24 1
        shl 20 1
        shl 23 1
