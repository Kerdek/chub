load  (a  ) ?
store (a b) ?
peek  (a  ) ?
poke  (a b) ?
add   (a b) ?
sub   (a b) ?
mul   (a b) ?
div   (a b) ?
mod   (a b) ?
shl   (a b) ?
cmpa  (a b) ?
cmpe  (a b) ?
neg   (a  ) ?
not   (a  ) ?
linux (rdi rsi rdx rcx r8 r9 rax) ?

struct ( ) 8

copy (a b) store a load b

member-copy (copy (a b) member (x) a b) copy member a member b

pair-copy (copy-a (a b) member-a (x) copy-b (a b) member-b (x) a b)
do  member-copy copy-a member-a a b
    member-copy copy-b member-b a b

inc (a) store a add 1 load a

exit (a) linux a 0 0 0 0 0 60

brk (a) linux a 0 0 0 0 0 12

initbrk (n)
let brk 0 i
do  brk add n i
    i

alloc (brk n)
let load brk r
do  store brk add n load brk
    r

strlen (s)
for 0 n
and peek s
do  inc addr s
    add 1 n

memcmp (a b n)
let 1 r
and n 
do  for n m
    if  cmpe peek a peek b
		do  inc addr a
		do  inc addr b
			sub 1 m
		do  store addr r 0
			0
    r

strncmp (a b n)
let 1 r
and n
do  for n i
    if 	cmpe peek a peek b
        and peek a
        do  inc addr a
        do  inc addr b
            sub 1 i
        do  store addr r 0
            0 
    r

streq (a na b nb)
or  not cmpe na nb
    not memcmp
        a
        b
        na

put (out c)
let load out p
do  poke p c
    store out add 1 p

put-higit (out n) put out add if cmpa n 10 '0 '7 n

put-bhex (out n)
do  put-higit out div 16 n
    put-higit out mod 16 n

put-digit (out n) put out add '0 n

put-digits (out n)
and n
do  put-digits out div 10 n
    put-digit  out mod 10 n

put-number (out n)
if  n put-digits out if n n '0
    put out '0

put-cm (out) put out ',
put-sp (out) put out ' 
put-ds (out) put out '$
put-cr (out) put out '\r
put-lf (out) put out '\n

vput-mem (vput (out a) out a b)
for a i
and cmpa i b
do  vput out (peek i)
    add 1 i

vput-string (vput (out a) out s)
for s p
let (peek p) a
and a
do  vput out a
    add 1 p

put-string (out s) vput-string put out s

put-delim (delim (out) out s)
do  put-string out s
    delim out

put-seq  (out s) put-delim put-sp out s
put-list (out s) put-delim put-cm out s
put-line (out s) put-delim put-lf out s

stdin  (p n) linux 0 p n 0 0 0 0
stdout (p n) linux 1 p n 0 0 0 1
stderr (p n) linux 2 p n 0 0 0 1

retry (stdio (p n) p q)
let 0 a
let for p i
    let stdio i sub i q n
    do and cmpe n neg 1 store addr a neg 1
    and n
	add n i
	b
or a b

runtime (main (in out brk) heap inbuf outbuf)
let initbrk heap brk
let alloc addr brk inbuf  in
let alloc addr brk outbuf out
do  poke retry stdin in add in inbuf 0
do  retry stdout out main in out brk
    # OK #
    exit 0

err (code s) do retry stderr s add s strlen s do stderr "\n" 1 exit code

# span #

span--start (s)                  s
span--end   (s) add (span--start s) struct
struct-span ( )      span--end      struct

span-start (s) load (span--start s)
span-end   (s) load (span--end   s)

span-copy (a b)
pair-copy copy span--start copy span--end a b

span-equal (a b)
let span-start a starta
let span-start b startb
    streq starta sub starta span-end a
          startb sub startb span-end b

span-init (s start end)
do  store (span--start s) start
    store (span--end   s) end

span-strcmp (s lit)
let span-start s start
let span-end   s end
let sub start end n
and strncmp lit start n
    not peek add lit n

vput-span (vput (out a) out s) vput-mem vput out (span-start s) (span-end s)

put-span (out s) vput-span put out s

# stack accounting #

pushpop (out y op (a b) size) store y (op size (load y))

fpop  (out y size) pushpop out y add size
fpush (out y size) pushpop out y sub size
pop   (out y     ) pushpop out y add 1
push  (out y     ) pushpop out y sub 1

# x86_64 implementation #

x86_64-string-mov              () "mov"
x86_64-string-lea              () "lea"
x86_64-string-add              () "add"
x86_64-string-test             () "test"
x86_64-string-je               () "je"
x86_64-string-jne              () "jne"
x86_64-string-jmp              () "jmp"
x86_64-string-push             () "push"
x86_64-string-pop              () "pop"
x86_64-string-call             () "call"
x86_64-string-ret              () "ret"
x86_64-string-entry            () "_start"
x86_64-string-stack-top        () "(%rsp)"
x86_64-string-pcrel-rip        () "@GOTPCREL(%rip)"
x86_64-string-str-label-prefix () ".s"
x86_64-string-globl            () ".globl"
x86_64-string-equ              () ".equ"
x86_64-string-section-text     () ".section .text."
x86_64-string-string           () ".string"
x86_64-string-previous         () ".previous"
x86_64-string-rax              () "%rax"
x86_64-string-rsp              () "%rsp"
x86_64-string-rdi              () "%rdi"
x86_64-string-rsi              () "%rsi"
x86_64-string-rdx              () "%rdx"
x86_64-string-rcx              () "%rcx"
x86_64-string-r8               () "%r8"
x86_64-string-r9               () "%r9"

x86_64-mangle (vput (put (out a) out s) out s)
do  put out 'f
    vput put-bhex out s

x86_64-mangle-span   (out s) x86_64-mangle vput-span   out s
x86_64-mangle-string (out s) x86_64-mangle vput-string out s

x86_64-cz (out)
do  put-seq  out x86_64-string-test
do  put-list out x86_64-string-rax
    put-line out x86_64-string-rax

x86_64-label-id (out n)
do  put out '.
do  put-number out n
    put out '$

x86_64-jc (out n s)
do  put-seq out s
do  x86_64-label-id out n
    put-lf out

x86_64-jcn (out n s) x86_64-jc out n s

x86_64-czjc (out n s)
do  x86_64-cz out
    x86_64-jcn out n s

x86_64-je  (out n) x86_64-czjc out n x86_64-string-je
x86_64-jne (out n) x86_64-czjc out n x86_64-string-jne
x86_64-jmp (out n) x86_64-jcn  out n x86_64-string-jmp

x86_64-rip (out)
do  put-list out x86_64-string-pcrel-rip
    put-line out x86_64-string-rax

x86_64-load-rel (out y z)
do  put-number out (shl 3 (sub z y))
do  put-list out x86_64-string-stack-top
    put-line out x86_64-string-rax

x86_64-if (j (out n) out)
let (load out) n
do  j out n
    n

x86_64-str-label (out n)
do  put-string out x86_64-string-str-label-prefix
    put-number out n

x86_64-label-suf (out)
do  put out ':
    put-lf out

x86_64-str-label-with (suf (out) out n)
do  x86_64-str-label out n
    suf out

x86_64-builtin-label (out s)
do  put-seq  out x86_64-string-globl
do  put-line out s
do  put-string out x86_64-string-section-text
do  put-line out s
do  put-string out s
    x86_64-label-suf out

x86_64-pre (out)
do  put-seq     out x86_64-string-globl
do  put-line    out x86_64-string-entry
do  put-seq     out x86_64-string-equ
do  put-list    out x86_64-string-entry
do  x86_64-mangle-string out x86_64-string-entry
do  put-lf out
do  x86_64-builtin-label out "f6C6F6164"
do  put-line out "mov (%rdi),%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f73746F7265"
do  put-line out "mov %rsi,(%rdi)"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f7065656B"
do  put-line out "movzb (%rdi),%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f706F6B65"
do  put-line out "movb %sil,(%rdi)"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f616464"
do  put-line out "mov %rsi,%rax"
do  put-line out "add %rdi,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f737562"
do  put-line out "mov %rsi,%rax"
do  put-line out "sub %rdi,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6D756C"
do  put-line out "mov %rsi,%rax"
do  put-line out "mul %rdi"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f646976"
do  put-line out "xor %edx,%edx"
do  put-line out "mov %rsi,%rax"
do  put-line out "div %rdi"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6D6F64"
do  put-line out "xor %edx,%edx"
do  put-line out "mov %rsi,%rax"
do  put-line out "div %rdi"
do  put-line out "mov %rdx,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f73686C"
do  put-line out "mov %rsi,%rax"
do  put-line out "mov %rdi,%rcx"
do  put-line out "shl %cl,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f636D7061"
do  put-line out "cmp %rdi,%rsi"
do  put-line out "seta %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f636D7065"
do  put-line out "cmp %rsi,%rdi"
do  put-line out "sete %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E65"
do  put-line out "cmp %rsi,%rdi"
do  put-line out "setne %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E6567"
do  put-line out "mov %rdi,%rax"
do  put-line out "neg %rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E6F74"
do  put-line out "test %rdi,%rdi"
do  put-line out "sete %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6C696E7578"
do  put-line out "mov 8(%rsp),%rax"
do  put-line out "syscall"
    put-line out x86_64-string-ret

x86_64-id (out s then now)
do  put-seq out x86_64-string-mov
if  then
    x86_64-load-rel out then now
    do  x86_64-mangle-span out s
        x86_64-rip out

x86_64-addr (out s then now)
do  put-seq out x86_64-string-lea
    x86_64-load-rel out then now

x86_64-lit (out s)
do  put-seq  out x86_64-string-mov
do  put-ds   out
do  put-span out s
do  put-cm   out
    put-line out x86_64-string-rax

x86_64-str (out s)
let (load out) n
do  put-string out x86_64-string-section-text
do  x86_64-str-label-with put-lf out n
do  x86_64-str-label-with x86_64-label-suf out n
do  put-list out x86_64-string-string
do  put-span out s
do  put-lf   out
do  put-line out x86_64-string-previous
do  put-seq  out x86_64-string-mov
    x86_64-str-label-with x86_64-rip out n

x86_64-do   (out  ) load out
x86_64-and  (out  ) x86_64-if x86_64-je  out
x86_64-or   (out  ) x86_64-if x86_64-jne out
x86_64-else (out  ) x86_64-if x86_64-jmp out
x86_64-rep  (out n)           x86_64-jne out n

x86_64-label (out n)
do  x86_64-label-id out n 
    x86_64-label-suf out

x86_64-fpushpop (fpushpop (out y size) out y size sign)
and size
do  put-seq    out x86_64-string-add
do  put        out '$
do  (and sign put out '-)
do  put-number out (shl 3 size)
do  put-cm     out
do  put-line   out x86_64-string-rsp
    fpushpop   out y size

x86_64-pushpop (pushpop (out y) out y reg sign)
do  put-seq  out if sign x86_64-string-push x86_64-string-pop
do  put-line out reg
    pushpop  out y

x86_64-fpop  (out y size) x86_64-fpushpop fpop  out y size 0
x86_64-fpush (out y size) x86_64-fpushpop fpush out y size 1
x86_64-pop   (out y reg ) x86_64-pushpop  pop   out y reg  0
x86_64-push  (out y reg ) x86_64-pushpop  push  out y reg  1

x86_64-let (out y)
let (load out) n
do  x86_64-push out y x86_64-string-rax
    n

x86_64-for (out y)
let x86_64-let   out y n
let x86_64-else  out m
do  x86_64-label out n
do  put-seq      out x86_64-string-mov
do  put-list     out x86_64-string-rax
do  put-line     out x86_64-string-stack-top
do  x86_64-label out m
    n

x86_64-unlet (out y n) x86_64-fpop out y 1

x86_64-unfor (out y n) 
do  x86_64-rep out n
    x86_64-pop out y x86_64-string-rax

x86_64-uncall (out y z arity)
do  x86_64-pop   out y x86_64-string-rax
do  and cmpa 0 arity do  x86_64-pop out y x86_64-string-rdi
    and cmpa 1 arity do  x86_64-pop out y x86_64-string-rsi
    and cmpa 2 arity do  x86_64-pop out y x86_64-string-rdx
    and cmpa 3 arity do  x86_64-pop out y x86_64-string-rcx
    and cmpa 4 arity do  x86_64-pop out y x86_64-string-r8
    and cmpa 5 arity     x86_64-pop out y x86_64-string-r9
do  put-seq  out x86_64-string-call
do  put out '*
do  put-line out x86_64-string-rax
    x86_64-fpop out y (sub (load y) z)

# ebrew's typing system #

type--next  (t)                  t
type--arg   (t) add (type--next  t) struct
type--token (t) add (type--arg   t) struct
type--kind  (t) add (type--token t) struct
struct-type ( )      type--kind     struct

type--alloc (brk kind)
let alloc brk struct-type t
do  store (type--next t) 0
do  store (type--arg  t) 0
do  store (type--kind t) kind
    t

type-new-unit     (brk) type--alloc brk 0
type-new-function (brk) type--alloc brk 1

type-kind (t) load (type--kind t)

type-arity (t)
and t
    add 1 (type-arity (load (type--next t)))

type--kind-equal (a b) cmpe (type-kind a) (type-kind b)

type-list-equal (equal (a b) a b)
or  cmpe a b
and a
and b
and type-list-equal equal (load (type--next a)) (load (type--next b))
    equal a b

type-equal (a b) 
and type--kind-equal a b
    type-list-equal type-equal (load (type--arg a)) (load (type--arg b))

# location #

#
  loc just keeps track of line/column
#

loc--line  (l)                l
loc--col   (l) add (loc--line l) struct
struct-loc ( )      loc--col     struct

loc-load-line (s) load (loc--line s)
loc-load-col  (s) load (loc--col  s)

loc-copy (a b)
pair-copy copy loc--line
          copy loc--col  a b

loc--xr (x (l) l) store (x l) 1
loc--xf (x (l) l) inc   (x l)

loc--lr (l) loc--xr loc--line l
loc--lf (l) loc--xf loc--line l
loc--cr (l) loc--xr loc--col  l
loc--cf (l) loc--xf loc--col  l

loc--crlx (x (l) l)
do  loc--cr l
    x l

loc--crlf (l) loc--crlx loc--lf l
loc--crlr (l) loc--crlx loc--lr l

loc-init (l) loc--crlr l

loc-adv (a l)
if a loc--crlf l
     loc--cf   l
     
# character ranges #

cmpin (a b c)
not or  cmpa a b
        cmpa c a

char-range-sq (a) cmpe  a '\'
char-range-dq (a) cmpe  a '\"
char-range-bs (a) cmpe  a '\\
char-range-hm (a) cmpe  a '#
char-range-qm (a) cmpe  a '?
char-range-lp (a) cmpe  a '(
char-range-rp (a) cmpe  a ')
char-range-us (a) cmpe  a '_
char-range-en (a) cmpe  a '-
char-range-sp (a) cmpe  a ' 
char-range-tb (a) cmpe  a '\t
char-range-lf (a) cmpe  a '\n
char-range-cr (a) cmpe  a '\r

char-range-09 (a) cmpin a '0 '9
char-range-AZ (a) cmpin a 'A 'Z
char-range-az (a) cmpin a 'a 'z

# caret #

#
  caret is where we use loc to keep track of line/col
  and we walk through the input at the same time
#

caret--ptr   (c)                  c
caret--loc   (c) add (caret--ptr  c) struct
struct-caret ( )      caret--loc     struct-loc

caret-ptr (c) load (caret--ptr c)
caret-loc (c) load (caret--loc c)

caret-copy (a b)
pair-copy     copy caret--ptr
          loc-copy caret--loc a b

caret-init (c ptr)
do  store (caret--ptr c) ptr
    loc-init (caret--loc c)

caret-peek (c) peek (caret-ptr c)

caret-adv (c)
do  loc-adv (char-range-lf caret-peek c) (caret--loc c)
    inc (caret--ptr c)

# tokenizer state #

# here we pair caret and span to make a kind of caret for tokens.
  the span locates the token and the caret is positioned at the end
  of any trailing whitespace so we can look ahead to the next token.
#

token--span  (k)                   k
token--caret (k) add (token--span  k) struct-span
struct-token ( )      token--caret    struct-caret

token--set-span (k start end) span-init token--span k start end

token--read (nontext (c) text (c) k)
let (token--caret k) c
let (token--span  k) s
do  nontext c
if	caret-peek c
    let (caret-ptr c) start
    if  text c
        span-init s start (caret-ptr c)
        err 1 "invalid text"
    span-init s 0 0

token-copy (a b)
pair-copy  span-copy token--span
          caret-copy token--caret a b

token-init (read (impl (nontext (c) text (c) k) k) k in)
do  caret-init (token--caret k) in
    read token--read k

token-try-adv (read (impl (nontext (c) text (c) k) k) k)
and span-start token--span k
    read token--read k

token-adv (read (impl (nontext (c) text (c) k) k) k)
or  token-try-adv read k
    err 2 "missing token"

token-match (lex (c) k) lex (peek (span-start (token--span k)))

token-is (lit k) span-strcmp (token--span k) lit

token-eat-lit (adv (k) k c)
and token-is c k
    adv k

token-equal (a b) span-equal (token--span a) (token--span b)

token-caret-peek (k) caret-peek (token--caret k)

# bookkeeping #

struct-name-token (o)                          o
struct-name-decl  (o) add (struct-name-token   o) struct-token
struct-name       ( )      struct-name-decl       struct

struct-book-next  (o)                       o
struct-book-name  (o) add (struct-book-next o) struct
struct-book       ( )      struct-book-name    struct-name

push-book (brk book token type impl d)
let alloc brk struct-book o
do        copy struct-book-next  o book
let struct-book-name o name
do  token-copy struct-name-token name token
do  store struct-name-decl name d
do  store book o
    name

pop-book (book)
copy book load struct-book-next book

try-lookup (book token)
let 0 r
do  for load book i
    if  token-equal token struct-name-token struct-book-name i
        load struct-book-next i
        do  store addr r struct-book-name i
            0
    r

lookup (book token)
or  try-lookup book token
    err 3 "lookup failed"

# semantics #

sem--book  (x)                          x
sem--brk   (x) add (sem--book  x) struct
sem--out   (x) add (sem--brk   x) struct
sem--token (x) add (sem--out   x) struct
sem--type  (x) add (sem--token x) struct-token
sem--val   (x) add (sem--type  x) struct
sem--isc   (x) add (sem--val   x) struct
sem--impl  (x) add (sem--isc   x) struct
struct-sem ( )      sem--impl     struct

sem-set-type (x t) store sem--type x t
sem-set-val  (x t) store sem--val  x t
sem-set-isc  (x t) store sem--isc  x t

sem-type (x) load sem--type x
sem-val  (x) load sem--val  x
sem-isc  (x) load sem--isc  x

struct-decl-type  (o)                          o
struct-decl-impl  (o) add (struct-decl-type    o) struct
struct-decl-isdef (o) add (struct-decl-impl    o) struct
struct-decl       ( )      struct-decl-isdef      struct

ebrew-sem-lit (impl (out s) x)
do  impl (sem--out x) (token--span (sem--token x))
    sem-set-type x (type-new-unit (sem--brk x))

ebrew-sem-addr-id (impl (out s y z) x o t)
do  impl (sem--out x) (token--span (sem--token x)) (load (struct-decl-impl (load (struct-name-decl o)))) (load (sem--impl x))
    sem-set-type x t

ebrew-sem-addr (impl (out s y z) x o) ebrew-sem-addr-id impl x o (type-new-unit (sem--brk x))
ebrew-sem-id   (impl (out s y z) x o) ebrew-sem-addr-id impl x o (load (struct-decl-type (load (struct-name-decl o))))

ebrew-sem-do     (impl (out  ) x  ) impl sem--out x 
ebrew-sem-label  (impl (out n) x n) impl sem--out x n

ebrew-sem-else (impl-jmp (out) impl-label (out n) x n)
let impl-jmp   sem--out x m
do  impl-label sem--out x n
    m

ebrew-sem-vardecl (x k)
let (alloc (sem--brk x) struct-decl) d
do  store struct-decl-type  d (sem-type x)
do  copy  struct-decl-impl  d (sem--impl x)
do  store struct-decl-isdef d 0
	push-book
		(sem--brk   x)
		(sem--book  x)
		k
		(sem-type   x)
		(sem--impl  x)
		d

ebrew-sem-var-in (impl (out y) x)
let impl sem--out x sem--impl x n
do  ebrew-sem-vardecl x (sem--token x)
    n

ebrew-sem-var-end (impl (out y n) x n)
do  impl sem--out x sem--impl x n
    pop-book (sem--book x)

ebrew-sem-uncall (impl (out y z arity) x z arity)
do  impl (sem--out x) (sem--impl x) z arity
    sem-set-type x (type-new-unit (sem--brk x))

# another shit table #

ebrew-sem-impl-pre      (x  ) ebrew-sem-do      x86_64-pre   x
ebrew-sem-impl-lit      (x  ) ebrew-sem-lit     x86_64-lit   x
ebrew-sem-impl-str      (x  ) ebrew-sem-lit     x86_64-str   x
ebrew-sem-impl-addr     (x d) ebrew-sem-addr    x86_64-addr  x d
ebrew-sem-impl-id       (x d) ebrew-sem-id      x86_64-id    x d
ebrew-sem-impl-let-in   (x  ) ebrew-sem-var-in  x86_64-let   x
ebrew-sem-impl-let-end  (x n) ebrew-sem-var-end x86_64-unlet x n
ebrew-sem-impl-for-in   (x  ) ebrew-sem-var-in  x86_64-for   x
ebrew-sem-impl-for-end  (x n) ebrew-sem-var-end x86_64-unfor x n
ebrew-sem-impl-do-then  (x  ) ebrew-sem-do      x86_64-do    x
ebrew-sem-impl-do-end   (x n) ebrew-sem-label   x86_64-label x n
ebrew-sem-impl-and-then (x  ) ebrew-sem-do      x86_64-and   x
ebrew-sem-impl-and-end  (x n) ebrew-sem-label   x86_64-label x n
ebrew-sem-impl-or-else  (x  ) ebrew-sem-do      x86_64-or    x
ebrew-sem-impl-or-end   (x n) ebrew-sem-label   x86_64-label x n
ebrew-sem-impl-if-then  (x  ) ebrew-sem-do      x86_64-and   x
ebrew-sem-impl-if-else  (x n) ebrew-sem-else    x86_64-else
                                                x86_64-label x n
ebrew-sem-impl-if-end   (x n) ebrew-sem-label   x86_64-label x n

ebrew-sem-impl-call   (x arity)
do  x86_64-fpush (sem--out x) (sem--impl x) arity
    x86_64-push  (sem--out x) (sem--impl x) x86_64-string-rax

ebrew-sem-impl-call-arg (x i)
do  put-seq    (sem--out x) x86_64-string-mov
do  put-list   (sem--out x) x86_64-string-rax
do  put-number (sem--out x) (shl 3 i)
    put-line   (sem--out x) x86_64-string-stack-top

ebrew-sem-impl-call-end (x z arity) ebrew-sem-uncall x86_64-uncall x z arity

# ebrew's character classes #

ebrew-char-class-nz (a) a

ebrew-char-class-lf (a)     char-range-lf a
ebrew-char-class-hm (a)     char-range-hm a
ebrew-char-class-bs (a)     char-range-bs a
ebrew-char-class-sq (a)     char-range-sq a
ebrew-char-class-dq (a)     char-range-dq a
ebrew-char-class-09 (a)     char-range-09 a

ebrew-char-class-ws (a) or  char-range-sp a
                        or  char-range-tb a
                        or  char-range-lf a
                            char-range-cr a
ebrew-char-class-id (a) or  char-range-AZ a
                        or  char-range-az a
                        or  char-range-09 a
                        or  char-range-en a
                            char-range-us a
ebrew-char-class-im (a) or  char-range-09 a
                            char-range-sq a
ebrew-char-class-pt (a) or  char-range-lp a
                        or  char-range-rp a
                            char-range-qm a

# ebrew's lexer #

ebrew-lex-normal (char-class (a) c)
and char-class caret-peek c
    caret-adv c

ebrew-lex-escape (char-class (a) c)
if  ebrew-lex-normal ebrew-char-class-bs c
    ebrew-lex-normal ebrew-char-class-nz c
    ebrew-lex-normal char-class c

ebrew-lex-hm (c) ebrew-lex-normal ebrew-char-class-hm c
ebrew-lex-dq (c) ebrew-lex-normal ebrew-char-class-dq c
ebrew-lex-sq (c) ebrew-lex-normal ebrew-char-class-sq c
ebrew-lex-09 (c) ebrew-lex-normal ebrew-char-class-09 c
ebrew-lex-pt (c) ebrew-lex-normal ebrew-char-class-pt c
ebrew-lex-ws (c) ebrew-lex-normal ebrew-char-class-ws c
ebrew-lex-id (c) ebrew-lex-escape ebrew-char-class-id c
ebrew-lex-sb (c) ebrew-lex-escape ebrew-char-class-nz c

# ebrew's token helpers #

ebrew-eat-bunch (body (c) c) 
and body c
for 1 _
    body c

ebrew-eat-pchar (delim (c) c)
and delim c
    ebrew-lex-sb c

ebrew-eat-group (delim (c) c)
and delim c
for 1 _
and not (delim c)
    ebrew-lex-sb c

# ebrew's tokens #

ebrew-eat-pt (c)                 ebrew-lex-pt c
ebrew-eat-id (c) ebrew-eat-bunch ebrew-lex-id c
ebrew-eat-09 (c) ebrew-eat-bunch ebrew-lex-09 c
ebrew-eat-ws (c) ebrew-eat-bunch ebrew-lex-ws c
ebrew-eat-sq (c) ebrew-eat-pchar ebrew-lex-sq c
ebrew-eat-dq (c) ebrew-eat-group ebrew-lex-dq c
ebrew-eat-nt (c) ebrew-eat-group ebrew-lex-hm c

# ebrew's tokenizer #

ebrew-tokenize-nontext (c)
for 1 -
or  ebrew-eat-ws c
    ebrew-eat-nt c

ebrew-tokenize-text (c)
or  ebrew-eat-id c
or  ebrew-eat-pt c
or  ebrew-eat-09 c
or  ebrew-eat-sq c
    ebrew-eat-dq c

ebrew-token-read (token-read (nontext (c) text (c) k) k)
token-read ebrew-tokenize-nontext
           ebrew-tokenize-text
           k

ebrew-token-init (k in) token-init ebrew-token-read k in
ebrew-token-adv  (k   ) token-adv  ebrew-token-read k

ebrew-token-class-do   (k) token-is "do"   k
ebrew-token-class-if   (k) token-is "if"   k
ebrew-token-class-or   (k) token-is "or"   k
ebrew-token-class-and  (k) token-is "and"  k
ebrew-token-class-let  (k) token-is "let"  k
ebrew-token-class-for  (k) token-is "for"  k
ebrew-token-class-addr (k) token-is "addr" k

ebrew-token-class-qm   (k) token-is "?" k
ebrew-token-class-lp   (k) token-is "(" k
ebrew-token-class-rp   (k) token-is ")" k

ebrew-token-class-lit  (k) token-match ebrew-char-class-im k
ebrew-token-class-str  (k) token-match ebrew-char-class-dq k
ebrew-token-class-id   (k) token-match ebrew-char-class-id k

# ebrew's parsers #

ebrew-syn-expr-lit (sem (x) x)
do  sem x
    ebrew-token-adv (sem--token x)

ebrew-syn-expr-id (sem (x o) x)
let lookup sem--book x (sem--token x) o
do  sem x o
do  ebrew-token-adv (sem--token x)
    o

ebrew-syn-expr-var (sem-in (x) sem-end (x n) syn (x t) x t)
do  syn      x (type-new-unit (sem--brk x))
let sem-in   x   n
do  ebrew-token-adv (sem--token x)
do  syn      x t
    sem-end  x n

ebrew-syn-expr-seq (sem-then (x) sem-end (x n) syn (x t) x t)
do  syn      x t
let sem-then x   a
do  syn      x t
    sem-end  x a

ebrew-syn-expr-if (sem-then (x) sem-else (x n) sem-end (x n) syn (x t) x t)
do  syn      x (type-new-unit (sem--brk x))
let sem-then x   a
do  syn      x t
let sem-else x a b
do  syn      x t
    sem-end  x b

ebrew-syn-sem-expr-lit  (expr (x t) x t) ebrew-syn-expr-lit ebrew-sem-impl-lit           x
ebrew-syn-sem-expr-str  (expr (x t) x t) ebrew-syn-expr-lit ebrew-sem-impl-str           x
ebrew-syn-sem-expr-addr (expr (x t) x t) ebrew-syn-expr-id  ebrew-sem-impl-addr          x
ebrew-syn-sem-expr-id   (expr (x t) x t) ebrew-syn-expr-id  ebrew-sem-impl-id            x
ebrew-syn-sem-expr-let  (expr (x t) x t) ebrew-syn-expr-var ebrew-sem-impl-let-in
                                            	            ebrew-sem-impl-let-end  expr x t
ebrew-syn-sem-expr-for  (expr (x t) x t) ebrew-syn-expr-var ebrew-sem-impl-for-in
                                                            ebrew-sem-impl-for-end  expr x t
ebrew-syn-sem-expr-do   (expr (x t) x t) ebrew-syn-expr-seq ebrew-sem-impl-do-then
                                                            ebrew-sem-impl-do-end   expr x t
ebrew-syn-sem-expr-and  (expr (x t) x t) ebrew-syn-expr-seq ebrew-sem-impl-and-then 
                                                            ebrew-sem-impl-and-end  expr x t
ebrew-syn-sem-expr-or   (expr (x t) x t) ebrew-syn-expr-seq ebrew-sem-impl-or-else
                                                            ebrew-sem-impl-or-end   expr x t
ebrew-syn-sem-expr-if   (expr (x t) x t) ebrew-syn-expr-if  ebrew-sem-impl-if-then
                                                            ebrew-sem-impl-if-else
                                                            ebrew-sem-impl-if-end   expr x t

ebrew-syn-expr-predef (is (k) syn (expr (x t) x t) expr (x t) x t)
and is (sem--token x)
do  ebrew-token-adv (sem--token x)
    syn expr x t

ebrew-syn-expr-atom (is (k) syn (expr (x t) x t) expr (x t) x t)
and is (sem--token x)
    syn expr x t

ebrew-syn-expr-punct (is (k) x)
and is (sem--token x)
    ebrew-token-adv (sem--token x)

ebrew-syn-expr-term (syn (x t) x t)
or  ebrew-syn-expr-predef ebrew-token-class-do   ebrew-syn-sem-expr-do   syn x t
or  ebrew-syn-expr-predef ebrew-token-class-if   ebrew-syn-sem-expr-if   syn x t
or  ebrew-syn-expr-predef ebrew-token-class-or   ebrew-syn-sem-expr-or   syn x t
or  ebrew-syn-expr-predef ebrew-token-class-and  ebrew-syn-sem-expr-and  syn x t
or  ebrew-syn-expr-predef ebrew-token-class-let  ebrew-syn-sem-expr-let  syn x t
or  ebrew-syn-expr-predef ebrew-token-class-for  ebrew-syn-sem-expr-for  syn x t
or  ebrew-syn-expr-predef ebrew-token-class-addr ebrew-syn-sem-expr-addr syn x t
or  ebrew-syn-expr-atom   ebrew-token-class-lit  ebrew-syn-sem-expr-lit  syn x t
or  ebrew-syn-expr-atom   ebrew-token-class-str  ebrew-syn-sem-expr-str  syn x t
    ebrew-syn-expr-atom   ebrew-token-class-id   ebrew-syn-sem-expr-id   syn x t

ebrew-syn-expr-args (syn (x t) x y t)
let (type-arity t) arity
do  ebrew-sem-impl-call x arity
do  let 1 i
    and t
    for t u
    do  syn x u
    do  or  type-equal u (sem-type x)
            err 4 "wrong"
    do  ebrew-sem-impl-call-arg x i
    do  inc addr i
        load u
    ebrew-sem-impl-call-end x y arity

ebrew-syn-expr-call (syn (x t) x t)
or  type-equal t (sem-type x)
for 1 _
and type-kind (sem-type x)
	ebrew-syn-expr-args syn x (load (sem--impl x)) (load (type--arg (sem-type x)))

ebrew-syn-expr-lp (x) ebrew-syn-expr-punct ebrew-token-class-lp x
ebrew-syn-expr-rp (x) ebrew-syn-expr-punct ebrew-token-class-rp x

ebrew-syn-expr-nest (syn (x t) x t)
if  ebrew-syn-expr-lp x
do  ebrew-syn-expr-term syn x t
or  ebrew-syn-expr-rp x
do  ebrew-syn-expr-call syn x t
or  ebrew-syn-expr-rp x
	err 5 "missing paren"
if  ebrew-syn-expr-term syn x t
	ebrew-syn-expr-call syn x t
	err 6 "missing expression"

ebrew-syn-expr (x t) ebrew-syn-expr-nest ebrew-syn-expr x t

# the ugliest code follows
#

# ebrew's type syntax #

ebrew-syn-param (syn (x) x t)
do  store t alloc sem--brk x struct-type
do  store type--token load t alloc sem--brk x struct-token
do  token-copy load type--token load t sem--token x
do  ebrew-token-adv sem--token x
let (syn x) u
do  copy type--next load t type--next u
do  copy type--arg  load t type--arg  u
    copy type--kind load t type--kind u

ebrew-syn-type (x)
if  token-eat-lit ebrew-token-adv (sem--token x) "("
    let (type-new-function (sem--brk x)) t
    do  for (type--arg t) u
        and not (token-eat-lit ebrew-token-adv (sem--token x) ")")
        do  ebrew-syn-param ebrew-syn-type x u
            type--next (load u)
        t
    type-new-unit (sem--brk x)

# ebrew's declaration syntax #

params (ebrew-token-adv (x t g) x t g)
if  t
    ebrew-token-adv x t g
    do  ebrew-syn-expr x type-new-unit (sem--brk x)
        0

param-push-book (x t)
ebrew-sem-vardecl x (load (type--token t))

params-next (ebrew-token-adv (x t g) x t g)
let params ebrew-token-adv x (load t) g h
do  pop-book (sem--book x)
    h

register (ebrew-token-adv (x t g) x t reg g)
do  x86_64-push (sem--out x) (sem--impl x) reg
do  sem-set-type x t
do  param-push-book x t
    add 1 (params-next ebrew-token-adv x t g)

stack (x t g)
do  sem-set-type x t
do  let param-push-book x t o
        store struct-decl-impl load struct-name-decl o g
    params-next stack x t add 1 g

register-seq (ebrew-token-adv (x t g) reg x t g)
register ebrew-token-adv x t reg add 1 g

register5 (x t g) register-seq     stack "%r9"  x t 0
register4 (x t g) register-seq register5 "%r8"  x t g
register3 (x t g) register-seq register4 "%rcx" x t g
register2 (x t g) register-seq register3 "%rdx" x t g
register1 (x t g) register-seq register2 "%rsi" x t g
register0 (x t g) register-seq register1 "%rdi" x t g

decl-first (x) ebrew-sem-vardecl x (sem--token x)

decl-rest (x)
if	try-lookup (sem--book x) (sem--token x)
    err 7 "duplicate"
	decl-first x

parse-decls (which (x) x)
and token-caret-peek (sem--token x)
do  store (sem--impl x) 0
let (which x) o
do  ebrew-syn-param ebrew-syn-type x (struct-decl-type (load (struct-name-decl o)))
do  store struct-decl-isdef (load (struct-name-decl o)) not (token-eat-lit ebrew-token-adv sem--token x "?")
do  and load (struct-decl-isdef (load (struct-name-decl o)))
    do  put-string (sem--out x) x86_64-string-section-text
    do  x86_64-mangle-span  (sem--out x)  (token--span (struct-name-token o))
    do  put-lf (sem--out x)
    do  x86_64-mangle-span  (sem--out x)  (token--span (struct-name-token o))
    do  x86_64-label-suf (sem--out x)
    do  store (sem--impl x) (shl 63 1)
    do  x86_64-fpop (sem--out x) (sem--impl x) (params register0 x (load (type--arg (load (struct-decl-type (load (struct-name-decl o)))))) 0)
        put-line (sem--out x) "ret"
    parse-decls decl-rest x

parse-ebrew (x)
do  ebrew-sem-impl-pre x
    parse-decls decl-first x

main (in out brk)
let (alloc addr brk struct-sem) x
do  store (sem--book x) 0
do  store (sem--out  x) out
do  store (sem--brk  x) brk
do  ebrew-token-init (sem--token x) in
do  parse-ebrew x
    load (sem--out x)

pow2 (n) shl n 1

_start ()
runtime main
    pow2 24
    pow2 20
    pow2 23
