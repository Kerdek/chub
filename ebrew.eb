# external functions #

(word) ?
(peek -a) ? (poke -a a) ?
(load -a) ? (store -a a) ?

(neg n) ? (not n) ?
(add a b) ? (mul a b) ? (mod a b) ? (cmpe a b) ?
(sub a b) ? (div a b) ? (shl a b) ? (cmpa a b) ?

(linux rdi rsi rdx rcx r8 r9 rax) ?

# math #

(cmpex n a b) or (cmpa n a) (cmpa b n)
(cmpin n a b) not (cmpex n a b)
(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)
(pow2 n) shl n 1
(suc n) add 1 n
(prd n) sub 1 n
(inc -n) to -n add 1
(dec -n) to -n sub 1

# strings #

(strlen s) and (peek s) (suc (strlen (suc s)))

(memcmp a b n)
or  not n
and cmpe (peek a) (peek b)
    memcmp (suc a) (suc b) (prd n)

(strncmp a b an bn)
and cmpe an bn
    memcmp a b bn

# io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (cmpe i error-key)
let byte-count (io i (sub i end))
and byte-count
if  cmpe byte-count error-key
    byte-count
    add i byte-count

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code out end) do (retry-mem stdout out end) (exit code)

(runtime (main (exit code out end) in out mem) inbuf outbuf membuf)
let in  (brk 0)
let out (add in  inbuf )
let mem (add out outbuf)
do  brk (add mem membuf)
do  store mem (add mem word)
do  retry-string-read stdin in out
    main runtime-exit in out mem

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# putting #

(vput-mem (put a -out) a b -out)
do  for i a
    and cmpa i b
    do  put (peek i) -out
        suc i
    -out

(vput-string (put a -out) s -out)
do  for p s
    let a (peek p)
    and a
    do  put a -out
        suc p
    -out

(put byte -out)
do  poke (load -out) byte
do  inc -out
    -out

(putlf -out) put '\n -out

(put-digits (put-digit a -out) base a -out)
if  a
    put-digit                 (mod base a)
    put-digits put-digit base (div base a)
    -out
    -out

(put-number (put-digit a -out) base a -out)
if  a 
    put-digits put-digit base a -out
    put '0 -out

(put-digit-16 a -out) put (add a (if (cmpa a 10) '0 '7)) -out
(put-digit-10 a -out) put (add a                 '0    ) -out

(put-dec a -out) put-number put-digit-10 10 a -out
(put-hex a -out) put-number put-digit-16 16 a -out

(put-string s -out) vput-string put s -out
(put-mem a b -out) vput-mem put a b -out

# x86_64 implementation #

(x86_64-str-mov  ) "mov "
(x86_64-str-ret  ) "ret\n"
(x86_64-str-entry) "_start"
(x86_64-str-rip  ) "@GOTPCREL(%rip)"
(x86_64-str-rsp  ) "(%rsp)"
(x86_64-str-rax  ) "%rax"
(x86_64-str-rdi  ) "%rdi"
(x86_64-str-rsi  ) "%rsi"
(x86_64-str-rdx  ) "%rdx"
(x86_64-str-rcx  ) "%rcx"
(x86_64-str-r8   ) "%r8"
(x86_64-str-r9   ) "%r9"

(x86_64-mangle (vput (put a -out) s -out) s -out) vput put-hex s put 'f -out
(x86_64-mangle-mem a b -out) vput-mem put-hex a b put 'f -out
(x86_64-mangle-string s -out) vput-string put-hex s put 'f -out

(x86_64-label-suf -out) putlf put ': -out

(x86_64-section-header (vput a b -out) a b -out)
    x86_64-label-suf vput a b putlf vput a b put-string ".section .text." -out

(x86_64-initdef name body -out)
    put-string x86_64-str-ret
    putlf
    put-string body
    x86_64-section-header x86_64-mangle-mem name (add name strlen name)
    -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put-string "add $" -out
do  and sign (put '- -out)
do  put-string ",%rsp\n" put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  putlf put-string reg put-string sign -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  "pop "
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  "push "

(x86_64-label-id flake -out) put '$ put-dec flake put '. -out
(x86_64-str-label flake -out) put-dec flake put-string ".s" -out
(x86_64-to-rax -out) putlf put-string x86_64-str-rax put ', -out
(x86_64-from-rax -out) put ', put-string x86_64-str-rax -out
(x86_64-jc flake s -out) putlf x86_64-label-id flake put-string s -out
(x86_64-czjc flake s -out) x86_64-jc flake s x86_64-to-rax put-string x86_64-str-rax put-string "test " -out

(x86_64-argreg index)
if  cmpe index 0 x86_64-str-rdi
if  cmpe index 1 x86_64-str-rsi
if  cmpe index 2 x86_64-str-rdx
if  cmpe index 3 x86_64-str-rcx
if  cmpe index 4 x86_64-str-r8
                 x86_64-str-r9

(x86_64-argpop index arity -depth reg -out)
do  and cmpa index arity
    x86_64-pop -depth -out reg
    -out

(Out   impl)            impl
(Depth impl) add (Out   impl) word
(Flake impl) add (Depth impl) word
(X86_64    )      Flake       word

(x86_64-init -mem out)
let impl (to -mem add X86_64)
do  store (Out impl) out
do  store (Depth impl) (shl (sub 1 (shl 3 word)) 1)
do  store (Flake impl) 0
do  x86_64-initdef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-initdef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-initdef "cmpe"  "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "cmpa"  "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-initdef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-initdef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-initdef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-initdef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-initdef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-initdef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-initdef "poke"  "movb %sil,(%rdi)"
    x86_64-initdef "peek"  "movzb (%rdi),%eax"
    x86_64-initdef "store" "mov %rsi,(%rdi)\nmov %rdi,%rax"
    x86_64-initdef "load"  "mov (%rdi),%rax"
    x86_64-initdef "word"  "mov $8,%rax"
    putlf
    x86_64-mangle-string  x86_64-str-entry
    put ',
    put-string x86_64-str-entry
    put-string "\n.equ "
    put-string x86_64-str-entry
    put-string ".globl "
    (Out impl)
    impl

(x86_64-flake impl) inc (Flake impl)

(x86_64-do  impl flake) 0
(x86_64-je  impl flake) x86_64-czjc flake "je "  (Out impl)
(x86_64-jne impl flake) x86_64-czjc flake "jne " (Out impl)
(x86_64-jmp impl flake) x86_64-jc   flake "jmp " (Out impl)

(x86_64-ref impl a b offset)
do  put-string x86_64-str-mov (Out impl)
    x86_64-to-rax
    if  offset
        put-string x86_64-str-rsp
        put-dec (shl 3 (sub load (Depth impl) offset))
        (Out impl)
        put-string x86_64-str-rip
        x86_64-mangle-mem a b
        (Out impl)

(x86_64-lit impl a b)
    x86_64-to-rax
    put-mem a b
    put '$
    put-string x86_64-str-mov
    (Out impl)

(x86_64-str impl a b)
let flake (x86_64-flake impl)
    x86_64-to-rax
    put-string x86_64-str-rip
    x86_64-str-label flake
    put-string x86_64-str-mov
    put-string ".previous\n"
    putlf
    put-mem a b
    put-string ".string,"
    x86_64-label-suf
    x86_64-str-label flake
    putlf
    x86_64-str-label flake
    put-string ".section .data."
    (Out impl)

(x86_64-label impl flake)
    x86_64-label-suf
    x86_64-label-id flake
    (Out impl)

(x86_64-var-is impl flake)
do  x86_64-fpush (Depth impl) (Out impl) 1
    load (Depth impl)

(x86_64-var-in impl flake)
do  x86_64-label impl flake
    putlf
    put-string x86_64-str-rsp
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-let-end impl flake) x86_64-fpop (Depth impl) (Out impl) 1

(x86_64-for-end impl flake)
do  x86_64-jne impl flake
    x86_64-pop (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-with impl arity)
do  x86_64-fpush (Depth impl) (Out impl) arity
    x86_64-push  (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-arg impl index)
    putlf
    put-string x86_64-str-rsp
    put-dec (shl 3 index)
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-call-end impl arity)
do  x86_64-pop (Depth impl) (Out impl) x86_64-str-rax
do  putlf
    put-string x86_64-str-rax
    put '*
    put-string "call "
    x86_64-argpop 5 arity (Depth impl) x86_64-str-r9
    x86_64-argpop 4 arity (Depth impl) x86_64-str-r8
    x86_64-argpop 3 arity (Depth impl) x86_64-str-rcx
    x86_64-argpop 2 arity (Depth impl) x86_64-str-rdx
    x86_64-argpop 1 arity (Depth impl) x86_64-str-rsi
    x86_64-argpop 0 arity (Depth impl) x86_64-str-rdi
	(Out impl)
and cmpa 6 arity
    x86_64-fpop (Depth impl) (Out impl) (sub 6 arity)

(x86_64-decl-in impl a b)
    x86_64-section-header x86_64-mangle-mem a b (Out impl)
    
(x86_64-decl       impl flake      ) 0

(x86_64-decl-param impl index)
if  cmpa index 6
do  x86_64-push (Depth impl) (Out impl) (x86_64-argreg index)
    load (Depth impl)
    sub 5 index

(x86_64-decl-end impl arity)
do  x86_64-fpop (Depth impl) (Out impl) (if cmpa arity 6 arity 6)
    put-string x86_64-str-ret (Out impl)

(x86_64-del impl) load (Out impl)

# tree #

(Node) add word word

(A node)     node
(B node) add node word

(node -mem a b)
let x (to -mem add Node)
do  store (A x) a
do  store (B x) b
    x

# operational semantics #

(stack-equal (hay-equal a b) a b)
or  cmpe a b
and hay-equal (load B load A a) (load B load A b)
    stack-equal hay-equal (load B a) (load B b)

(type-equal a b) or (cmpe a b) (and (and a b) (and (cmpe (load B a) (load B b)) (stack-equal type-equal (load A a) (load A b))))

(count stack) and stack (suc (count (load B stack)))

(lookup stack a b)
and stack
let hay (load A stack)
let span (load A hay)
let src-a (load A span)
let src-b (load B span)
if  strncmp src-a a (sub src-a src-b) (sub a b)    
    load B hay
let rest (load B stack)
    lookup rest a b

(Mem  sem)           sem
(Book sem) add (Mem  sem) word
(Impl sem) add (Book sem) word
(struct-Sem)    Impl      word

(op-init (gen -mem out) -mem out)
let impl (gen -mem out)
let sem (to -mem add struct-Sem)
do  store (Mem sem) (load -mem)
do  store (Book sem) 0
do  store (Impl sem) impl
    sem

(op-unit (gen impl a b) sem a b)
do  gen (load Impl sem) a b
    0

(op-flake (gen impl) sem) gen (load Impl sem)
(op-label (gen impl flake) sem flake) gen (load Impl sem) flake

(op-ref (gen impl a b offset) sem a b)
let var (lookup (load Book sem) a b)
if  not var
    error 1 "unknown reference"
do  gen (load Impl sem) a b (load B var)
    load A var

(op-var-def (gen impl flake) sem a b result flake)
if  lookup (load Book sem) a b
    error 2 "redefinition" 
    store (Book sem) (node (Mem sem) (node (Mem sem) (node (Mem sem) a b) (node (Mem sem) result (gen (load Impl sem) flake))) (load Book sem))

(op-var-end (gen impl flake) sem flake)
do  gen (load Impl sem) flake
    store (Book sem) (load B (load (Book sem))) 

(op-call-with (gen impl arity) sem result)
let arity (count (load A result))
do  gen (load Impl sem) arity
    arity

(op-call-arg (gen impl index) sem expect result index)
if  type-equal expect result
    gen (load Impl sem) index
    error 3 "illegal argument"

(op-call-end (gen impl arity) sem arity)
do  gen (load Impl sem) arity
    0

(op-decl (gen impl flake) sem a b type)
do  gen (load Impl sem) 0
    node (Mem sem) node (Mem sem) a b type

(op-param (gen impl flake) sem decl stack)
do  gen (load Impl sem) 0
    node (Mem sem) decl stack

(op-type-func sem stack) node (Mem sem) stack 1
(op-type-unit            ) 0

(op-del (gen impl) -impl)
    gen (load -impl)

# denotational semantics #

(den-init -mem out) op-init x86_64-init -mem out
(den-del sem) op-del x86_64-del (Impl sem)

(den-lit        sem a b                ) op-unit      x86_64-lit        sem a b
(den-str        sem a b                ) op-unit      x86_64-str        sem a b
(den-ref        sem a b                ) op-ref       x86_64-ref        sem a b
(den-do         sem                    ) op-flake     x86_64-flake      sem
(den-do-then    sem label              ) op-label     x86_64-do         sem label
(den-do-end     sem label              ) op-label     x86_64-label      sem label
(den-if         sem                    ) op-flake     x86_64-flake      sem
(den-if-then    sem label              ) op-label     x86_64-je         sem label
(den-if-else    sem label              ) op-label     x86_64-jmp        sem label
(den-if-end     sem label              ) op-label     x86_64-label      sem label
(den-or         sem                    ) op-flake     x86_64-flake      sem
(den-or-else    sem label              ) op-label     x86_64-jne        sem label
(den-or-end     sem label              ) op-label     x86_64-label      sem label
(den-and        sem                    ) op-flake     x86_64-flake      sem
(den-and-then   sem label              ) op-label     x86_64-je         sem label
(den-and-end    sem label              ) op-label     x86_64-label      sem label
(den-let        sem                    ) op-flake     x86_64-flake      sem 
(den-let-is     sem label a b          ) op-var-def   x86_64-var-is     sem a b 0 label
(den-let-in     sem label              ) op-label     x86_64-var-in     sem label
(den-let-end    sem label              ) op-var-end   x86_64-let-end    sem label
(den-for        sem                    ) op-flake     x86_64-flake      sem
(den-for-is     sem label a b          ) op-var-def   x86_64-var-is     sem a b 0 label
(den-for-in     sem label              ) op-label     x86_64-var-in     sem label
(den-for-end    sem label              ) op-var-end   x86_64-for-end    sem label
(den-call-with  sem result             ) op-call-with x86_64-call-with  sem result
(den-call-arg   sem expect result index) op-call-arg  x86_64-call-arg   sem expect result index
(den-call-end   sem arity              ) op-call-end  x86_64-call-end   sem arity
(den-param      sem decl index         ) op-var-def   x86_64-decl-param sem                         (load A load A decl) (load B load A decl) (load B decl) index
(den-param-end  sem label              ) op-var-end   x86_64-do         sem label
(den-decl       sem a b type           ) op-decl      x86_64-do         sem a b type
(den-type-func  sem stack              ) op-type-func                   sem stack
(den-type-unit  sem                    ) op-type-unit
(den-type-param sem decl stack         ) op-param     x86_64-do         sem decl stack
(den-body       sem                    ) op-flake     x86_64-flake      sem 
(den-body-is    sem label decl         ) op-var-def   x86_64-decl       sem                         (load A load A decl) (load B load A decl) (load B decl) label
(den-body-in    sem label decl         )              x86_64-decl-in    (load Impl sem)             (load A load A decl) (load B load A decl)
(den-body-end   sem label decl         )              x86_64-decl-end   (load Impl sem) count (load A load B decl)

# character classes #

(negclass (class byte) (except byte) byte)
and except byte
not class  byte

(class-nz byte)       byte
(class-hm byte) cmpe  byte '#
(class-bs byte) cmpe  byte '\\
(class-sq byte) cmpe  byte '\'
(class-dq byte) cmpe  byte '\"
(class-qm byte) cmpe  byte '?
(class-lp byte) cmpe  byte '(
(class-rp byte) cmpe  byte ')
(class-09 byte) cmpin byte '0 '9

(class-ws byte) or  cmpe  byte ' 
                or  cmpe  byte '\t
                or  cmpe  byte '\n
                    cmpe  byte '\r
(class-id byte) or  cmpin byte 'A 'Z
                or  cmpin byte 'a 'z
                or  cmpin byte '0 '9
                or  cmpe  byte '-
                    cmpe  byte '_
(class-im byte) or  cmpin byte '0 '9
                    cmpe  byte '\'
(class-pt byte) or  cmpe  byte '(
                or  cmpe  byte ')
                    cmpe  byte '?

(class-sb byte) negclass class-dq class-nz byte
(class-cb byte) negclass class-hm class-nz byte

# lexer #

(lex-one (class byte) -in)
and class (peek (load -in))
    inc -in

(lex-esc (class byte) -in)
if  lex-one class-bs -in
    lex-one class-nz -in
    lex-one class         -in

(lex-hm -in) lex-one class-hm -in
(lex-dq -in) lex-one class-dq -in
(lex-sq -in) lex-one class-sq -in
(lex-09 -in) lex-one class-09 -in
(lex-pt -in) lex-one class-pt -in
(lex-ws -in) lex-one class-ws -in
(lex-id -in) lex-esc class-id -in
(lex-sb -in) lex-esc class-sb -in
(lex-cb -in) lex-esc class-cb -in

# tokenizer #

(token-bunch (body -in) -in) 
for _ 0 body -in

(token-prefix (delim -in) (body -in) -in)
and delim -in
    body  -in

(token-group (delim -in) (body -in) -in)
and delim -in
do  token-bunch body -in
    delim -in

(token-ws -in)
for _ 0
or  token-bunch lex-ws        -in
    token-group lex-hm lex-cb -in

(token-text -in)
or  token-bunch  lex-id        -in
or               lex-pt        -in
or  token-prefix lex-sq lex-sb -in
or  token-group  lex-dq lex-sb -in
    token-bunch  lex-09        -in

# parser #

(Sem    syn)             syn
(In     syn) add (Sem    syn) word
(Span   syn) add (In     syn) word
(Result syn) add (Span   syn) word
(struct-Syn)      Result      word

(parse -in span)
do  token-ws -in
let caret (load -in)
do  store (A span) caret
    store (B span) (if (token-text -in) (load -in) caret)

(parse-init -mem -in -out)
let syn (to -mem add struct-Syn)
do  store (Span syn) node -mem 0 0
do  store (In syn) -in
do  store (Sem syn) den-init -mem -out
do  parse (In syn) (load Span syn)
    syn

(parse-del syn) den-del (load (Sem syn))

(stem lit (syn-with (syn-expr syn expect) syn expect) (syn-expr syn expect) syn expect)
let start (load A (load Span syn))
let n (sub start (load B (load Span syn)))
and strncmp lit start strlen lit n
and not (peek (add lit n))
do  parse (In syn) (load Span syn)
do  syn-with syn-expr syn expect
    1

(leaf (class byte) (op syn a b) syn)
and class (peek (load A (load Span syn)))
let a (load A load Span syn)
let b (load B load Span syn)
do  parse (In syn) (load Span syn)
do  store (Result syn) op load Sem syn a b
    1

(punct syn (class byte))
and class (peek (load A (load Span syn)))
    parse (In syn) (load Span syn)

# syntax #

(syn-var (den syn) (den-is syn flake a b) (den-in syn flake) (den-end syn flake) (syn-expr syn expect) syn expect)
let flake (den (load Sem syn))
do  den-is (load Sem syn) flake (load A load Span syn) (load B load Span syn)
do  punct syn class-id
do  syn-expr syn 0
do  den-in (load Sem syn) flake
let result (syn-expr syn expect)
do  den-end (load Sem syn) flake
    result

(syn-seq (den syn) (den-then syn flake) (den-end syn flake) (syn-expr syn expect) syn expect)
let flake (den (load Sem syn))
let result-a (syn-expr syn expect)
do  den-then load Sem syn flake
let result-b (syn-expr syn expect)
do  den-end load Sem syn flake
    result-b

(syn-arg (syn-expr syn expect) syn expect index)
do  syn-expr syn expect
    den-call-arg load Sem syn expect (load Result syn) index

(syn-args (syn-expr syn expect) syn stack index)
and stack
do  syn-arg  syn-expr syn (load B load A stack)      index
    syn-args syn-expr syn (       load B stack) (suc index)

(syn-call (syn-expr syn expect) syn result)
and result
let arity (den-call-with load Sem syn result)
do  syn-args syn-expr syn (load A result) 1
    store (Result syn) den-call-end load Sem syn arity

(syn-if (syn-expr syn expect) syn expect)
let flake-a (den-if load Sem syn)
let result-a (syn-expr syn 0)
do  den-if-then load Sem syn flake-a
let result-b (syn-expr syn expect)
let flake-b (den-if load Sem syn)
do  den-if-else load Sem syn flake-b
do  den-if-end  load Sem syn flake-a
let result-c (syn-expr syn expect)
do  den-if-end  load Sem syn flake-b
    result-c

(syn-do   (syn-expr syn expect) syn expect) syn-seq  den-do den-do-then den-do-end syn-expr syn expect
(syn-or   (syn-expr syn expect) syn expect) syn-seq  den-or den-or-else den-or-end syn-expr syn expect
(syn-and  (syn-expr syn expect) syn expect) syn-seq  den-and den-and-then den-and-end syn-expr syn expect
(syn-let  (syn-expr syn expect) syn expect) syn-var  den-let den-let-is den-let-in den-let-end syn-expr syn expect
(syn-for  (syn-expr syn expect) syn expect) syn-var  den-for den-for-is den-for-in den-for-end syn-expr syn expect

(syn-type-params (syn-type syn) syn)
and not (punct syn class-rp)
let decl (syn-type syn)
    den-type-param (load Sem syn) decl (syn-type-params syn-type syn)

(syn-type-func (syn-type syn) syn) den-type-func (load Sem syn) (syn-type-params syn-type syn)
(syn-type-unit (syn-type syn) syn) den-type-unit (load Sem syn)

(syn-term (syn-expr syn expect) syn expect) 
or  stem "do"  syn-do  syn-expr syn expect
or  stem "if"  syn-if  syn-expr syn expect
or  stem "or"  syn-or  syn-expr syn expect
or  stem "and" syn-and syn-expr syn expect
or  stem "let" syn-let syn-expr syn expect
or  stem "for" syn-for syn-expr syn expect
or  leaf class-im den-lit syn
or  leaf class-dq den-str syn
or  leaf class-id den-ref syn
    error 4 "expected term"

(syn-juxt (syn-expr syn expect) syn expect result)
and not (type-equal expect result)
    syn-call syn-expr syn result

(syn-param (syn-expr syn type) syn stack index)
if  stack
let decl (load A stack)
let offset (den-param (load Sem syn) decl index)
do  syn-param syn-expr syn (load B stack) (suc index)
    den-param-end load Sem syn offset
    syn-expr syn 0

(syn-body (syn-expr syn expect) syn decl) 
and decl
let flake (den-body load Sem syn)
do  den-body-is load Sem syn flake decl
or  punct syn class-qm
do  den-body-in load Sem syn flake decl
do  syn-param syn-expr syn (load A load B decl) 0
    den-body-end load Sem syn flake decl

(syn-expr syn expect)
if  punct syn class-lp
do  syn-term syn-expr syn expect
or  punct syn class-rp
if  syn-juxt syn-expr syn expect (load Result syn)
    punct syn class-rp
    error 5 "expected )"
do  syn-term syn-expr syn expect
    syn-juxt syn-expr syn expect (load Result syn)

(syn-decl (den sem a b type) (syn-type-which (syn-type syn) syn) (syn-type syn) syn)
let a (load A load Span syn)
let b (load B load Span syn)
and punct syn class-id
    den (load Sem syn) a b (syn-type-which syn-type syn)

(syn-type syn) syn-decl den-decl (if (punct syn class-lp) syn-type-func syn-type-unit) syn-type syn

(main (return code out end) in out -mem)
let syn (parse-init -mem in out)
do  for _ 0 syn-body syn-expr syn (syn-type syn)
    return 0 out (parse-del syn)

(_start) runtime main (pow2 15) (pow2 18) (pow2 20)