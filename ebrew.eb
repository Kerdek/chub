type FILE struct {};

export __errno_location    ( ) @nat

export open_memstream      (p    @@byte n    @nat) @FILE

export fclose              (io @FILE) nat
export fflush              (io @FILE) nat

export fread               (ptr @none m nat n nat io @FILE) nat
export fwrite              (ptr @none m nat n nat io @FILE) nat
export fputc               (c nat io @FILE) nat
export fputs               (s @byte io @FILE) nat

export exit                (status nat) none

export calloc              (m nat  n nat) @none
export malloc              (m nat) @none
export free                (p @none) none

export memcmp              (p @none q @none n nat) nat

export strtoul             (p @byte q @@byte  b nat) nat
export strstr              (p @byte q  @byte       ) @byte
export strcmp              (p @byte q  @byte       ) nat
export strncmp             (p @byte q  @byte  n nat)  nat
export strndup             (p @byte           n nat) @byte
export strlen              (p @byte                ) nat

/* end preamble */

type
  TokenKind @()none

  Token struct {
    q     TokenKind
    s    @Token
    l     nat
    p    @byte
    n     nat
    t    @none
    str  @byte
    line  nat
  }

  Type struct  {
    size    nat
    align   nat
    offset  nat
    n       nat
    s      @Type
    o      @Type
    a      @Type
    params @Type
    name   @Token
    format @(t @Type s @byte) none
  }

  Obj struct {
    s               @Obj
    name            @byte
    t               @Type
    j               @Token
    is_local         bit
    is_definition    bit
    is_export        bit
    params          @Obj
    body            @none
    sp               nat
  }

  Node struct {
    s @Node
    a @Node
    j @Token
    t @Type
    o @Obj
    l  nat
    gen @(e @Node c nat l nat) nat
  }

  Scope struct {
    s @Scope
    c @byte
    o @Obj
    t @Type
  }

  Ctx struct {
    j @Token
    c @byte
    locals   @Obj
    globals  @Obj
    s @Scope
  }

  J @Token
  O @Obj
  K @Ctx
  E @Node
  T @Type
  N nat
  C byte
  S @byte

  ftfn (t T s S) none

  cis  (c C    ) bit
  cisd (c C d C) bit

  tk   (k K                    ) T
  ek   (k K                ) E
  eka  (k K         a E    ) E
  ekj  (k K j J            ) E
  ekja (k K j J     a E    ) E
  eju  (j J u T            ) E
  ejua (j J u T a E        ) E
  eja  (j J     a E        ) E
  ejab (j J     a E b E    ) E
  ejul (j J u T         l N) E

  necl (e E c N l N) N

  gelfn (v N) N
  geefn (e E c N l N gop @() none) N
  gegfn () none
;

ftnone ftfn ftbit  ftfn ftbyte ftfn
ftnat  ftfn ftstct ftfn ftptr  ftfn
ftfunc ftfn

p2     ek p3     ek p5     ek p7     ek
pmul   ek padd   ek psh    ek pcmp   ek
pband  ek pbor   ek

ptype  tk

gelit   necl gesize  necl gederef necl geaddr  necl gethe   necl gecast  necl
geid    necl gelnot  necl gebnot  necl geneg   necl gediv   necl gemod   necl
gee     necl gene    necl geb     necl gebe    necl gea     necl geae    necl
geadd   necl gesub   necl gemul   necl geband  necl gebor   necl gexor   necl
geshl   necl geshr   necl geelem  necl gemem   necl geseq   necl geret   necl
gecond  necl geland  necl gelor   necl geis    necl gefor   necl gecall  necl
geass   necl gestr   necl

esize  ekj ethe   ekj ecast  ekj elit   ekj eaddr  ekj
eneg   ekj elnot  ekj ebnot  ekj eid    ekj estr   ekj
ebrace ekj eparen ekj

eas    ekja efrom  ekja eelem  ekja ederef ekja eseq   ekja
eret   ekja emul   ekja ediv   ekja emod   ekja ethen  ekja
eelse  ekja econd  ekja eadd   ekja esub   ekja eshl   ekja
eshr   ekja eb     ekja ea     ekja ebe    ekja eae    ekja
ee     ekja ene    ekja eband  ekja ebor   ekja eland  ekja
elor   ekja eass   ekja eis    ekja efor   ekja emem   ekja
ecall  ekja

JID  () none = (0)
JPCT () none = (0)
JSTR () none = (0)
JNUM () none = (0)

is cisd = (c == d)

issp cis = is c ' '
istb cis = is c '\t'
islf cis = is c '\n'
iscr cis = is c '\r'
is_  cis = is c '_'

isin(c C a C b C) bit = {(a <= c) then (c <= b)}

isAZ cis = isin c 'A' 'Z'
isaz cis = isin c 'a' 'z'
is09 cis = isin c '0' '9'
isaf cis = isin c 'a' 'f'

isws cis = {
   issp c else
   istb c else
   islf c else
   iscr c
}
is0f cis = {
   is09 c else
   isaf c
}
isid cis = {
   isAZ c else
   isaz c else
   is09 c else
   is_  c
}

read_ident(p S) N = {
  0 is r
  { p for q { isid q@ then &q^1 } else (r = q - p as N) '\0' }
  r
}

sw1(p S a C    ) bit = {(p^0 == a) then 1}
sw2(p S a C b C) bit = {(p^0 == a) then (p^1 == b) then 2}

read_punct(p S) N = {
  sw2 p '=' '=' else
  sw2 p '!' '=' else
  sw2 p '<' '=' else
  sw2 p '>' '=' else
  sw2 p '&' '&' else
  sw2 p '|' '|' else
  sw2 p '<' '<' else
  sw2 p '>' '>' else
  sw2 p '/' '/' else
  sw1 p '='     else
  sw1 p '<'     else
  sw1 p '>'     else
  sw1 p '+'     else
  sw1 p '-'     else
  sw1 p '*'     else
  sw1 p '/'     else
  sw1 p '&'     else
  sw1 p '|'     else
  sw1 p '@'     else
  sw1 p '#'     else
  sw1 p '{'     else
  sw1 p '}'     else
  sw1 p '('     else
  sw1 p ')'     else
  sw1 p '['     else
  sw1 p ']'     else
  sw1 p '!'     else
  sw1 p '?'     else
  sw1 p ':'     else
  sw1 p ';'     else
  sw1 p ','     else
  sw1 p '.'     else
  sw1 p '~'     else
  sw1 p '^'     else
  sw1 p '$'     else
  sw1 p '`'     else
  sw1 p '%'
}

export stdout () none
export stderr () none
export stdin  () none

gc (c C) none = fputc cast N c (cast @@FILE &stdout)@
gs (s S) none = fputs s (cast @@FILE &stdout)@
glf() none = gc  '\n'
gn1(n N) none = { n then gn1  (n / 10) gc  cast byte ('0' + n % 10) }
gn (n N) none = { n ? (gn1  n) (gc  '0') }

oc (c C) none = fputc cast N c (cast @@FILE &stderr)@
os (s S) none = fputs s (cast @@FILE &stderr)@
olf(   ) none = oc '\n'
on1(n N) none = { n then on1 (n / 10) oc cast byte ('0' + n % 10) }
on (n N) none = { n ? on1 n  oc '0' }

align(n N a N) N = ((n + a - 1) / a * a)

vdiag(c S line_n N p S s S) none = {
  {p for q {(c < q) then (q^-1 != '\n') then &q^-1}} is line
  os ":(" on line_n oc ',' on (p - line + 1) os "): " os s olf
}

diag(p S c @byte s S) none = {
  1 is line
  { c for p
    (p@ == '\n') then
    (line = line + 1)
    &p^1 }
  vdiag c line p s
  exit 1
}

jdiag(k K s S) none = {
  vdiag k.c k.j.line k.j.p s
  exit 1
}

type_equal(t T u T) bit = {
  !t else
  !u else
  t.format is c
  (t == u) else
  !!t.o ? type_equal t.o u
  !!u.o ? type_equal t u.o
  (c == u.format) then
  (c == &ftnone ) else
  (c == &ftbit  ) else
  (c == &ftbyte ) else
  (c == &ftnat  ) else
  (c == &ftptr  ) ? type_equal t.a u.a
    { (c == &ftfunc ) then
      type_equal t.a u.a then
      u.a.s is p
      t.a.s is q
      { 1b for _
        !!p then
        !!q then
        type_equal p q then
        (p = p.s)
        (q = q.s)
        1b }
      (p == q) }
}

ntype(size N align N format @(t T s S) none) T = {
  cast T calloc 1 sizeof Type is t t ret
  (t.size  = size  )
  (t.align = align )
  (t.format = format)
}

ntypea(size N align N format @(t T s S) none a T) T = {
  ntype size align format is t
  (t.a = a)
  t
}

nnone (   ) T = ntype  0 0 &ftnone
nbit  (   ) T = ntype  1 1 &ftbit
nbyte (   ) T = ntype  1 1 &ftbyte
nnat  (   ) T = ntype  8 8 &ftnat
nstct (   ) T = ntype  0 1 &ftstct
nptr  (a T) T = ntypea 8 8 &ftptr  a
nfunc (a T) T = ntypea 1 1 &ftfunc a

tree(j J t T gen @necl             ) E = {cast E calloc 1 sizeof Node is e e ret (e.j = j)  (e.t = t) (e.gen = gen)}
t0  (j J t T gen @necl             ) E = {tree j t gen}
t1  (j J t T gen @necl  a E        ) E = {tree j t gen is e e ret (e.a   = a)}
t2  (j J t T gen @necl  a E b E    ) E = {tree j t gen is e e ret (e.a   = a)  (e.a.s = b)}
t3  (j J t T gen @necl  a E b E c E) E = {tree j t gen is e e ret (e.a   = a)  (e.a.s = b)  (e.a.s.s = c)}
tt  (j J t T gen @necl  u T        ) E = {t0   j t gen is e e ret (e.t.s = u)}
to  (j J t T gen @necl  o O        ) E = {t0   j t gen is e e ret (e.o   = o)}
tl  (j J t T gen @necl  l N        ) E = {t0   j t gen is e e ret (e.l   = l)}

copy_type(t T) T = {
  cast T calloc 1 sizeof Type is u
  (u@ = t@)
  (u.o = t)
  u
}

ntoken(q TokenKind a S b S line N) J = {
  cast J calloc 1 sizeof Token is j
  (j.q = q    )
  (j.p = a    )
  (j.n = b - a)
  (j.line = line)
  j
}

read_file() S = {
  calloc 1 4096 is rfbuf2
  cast S 0 is buf
  0 is buflen
  &buflen is b
  open_memstream &buf b is y
  { 1b for k
    fread rfbuf2 1 4096 (cast @@FILE &stdin)@ is n
    (n == 0) ?
      (k = 0b)
      fwrite rfbuf2 1 n y
    k }
  free rfbuf2
  fflush y
  { {(buflen == 0) else (buf^(buflen - 1) != '\n')} then
    fputc cast N '\n' y }
  fputc 0 y
  fclose y
  buf
}

push_scope  (k K c S    ) @Scope = {
  cast @Scope calloc 1 sizeof Scope is s
  (s.c = c)
  (s.s = k.s)
  (k.s = s)
  s
}

try_search_scope(k K c S n N) @Scope = {
  cast @Scope 0 is r
  { !!k.s then
    k.s for s
    {(n != strlen s.c ) else !!strncmp s.c c n} ?
      s.s 
    {(r = s)
    cast @Scope 0 }}
  r
}

search_scope(k K c S n N) @Scope = {
  try_search_scope k c n else
  jdiag k "lookup failed"
}

nvar (k K s S t T) O = {
  cast O calloc 1 sizeof Obj is o
  (o.name = s) 
  (o.t = t) 
  o
}

nletvar (k K s S t T) O = {
  nvar k s t is o
  (o.is_local = 1b)
  ((push_scope k s).o = o) 
  o
}

nlvar (k K s S t T) O = {
  nvar k s t is o
  (o.is_local = 1b)
  (o.s = k.locals)
  (k.locals = o)
  ((push_scope k s).o = o) 
  o
}

ngvar (k K s S t T) O = {
  nvar k s t is o
  (o.s = k.globals)
  (k.globals = o)
  ((push_scope k s).o = o) 
  o
}

id(k K) S = {
  { !!k.j then
    (k.j.q != &JID) then
    jdiag k "expected <id>" }
  strndup k.j.p k.j.n
}

jadv   (k K    ) J    = {k.j ret (k.j = k.j.s)}
jeq    (k K c S) bit  = {!!k.j then !memcmp cast @none k.j.p cast @none c cast N k.j.n then !c^k.j.n}
expect (k K c S) none = {{!jeq k c then jdiag k "unexpected"} jadv k}
consume(k K c S) bit  = {jeq k c is r {r then jadv k} r}

declarator (k K t @T) none = {
  (t@ = cast T calloc 1u sizeof Type)
  jadv k is j
  ptype k is u
  (t@@ = u@)
  (t.o = u)
  (t.name = j)
}

struct_decl tk = {
  nstct is t
  expect k "{"
  &t.a is u
  { 1b for _ 
     !consume k "}" then
      (declarator k u)
      (u = &u.s) }
  0 is bits
  { !!t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

func_params tk = {
  cast T 0 is params
  &params is u
  { 1b for _
    !jeq k ")" then
    !jeq k "}" then
    (declarator k u)
    (u = &u.s)
    1b }
  jadv k
  nfunc ptype k is t
  (t.params = params)
  t
}

ptype tk = (
  consume k "none"   ? nnone
  consume k "bit"    ? nbit
  consume k "byte"   ? nbyte
  consume k "nat"    ? nnat
  consume k "@"      ? nptr        ptype k
  consume k "("      ? func_params       k
  consume k "struct" ? struct_decl       k
  { search_scope k k.j.p k.j.n is s
    jadv k
    s.t }
)

pj(k K     q TokenKind e @ekj ) E = {(k.j.q == q) then jadv k is j e@ k j}
pl(k K     c S         e @ekj ) E = {jeq k c then jadv k is j e@ k j  }
pr(k K a E c S         e @ekja) E = {jeq k c then jadv k is j e@ k j a}
pu(k K a E c S         e @ekja) E = (consume k c ? a e@ k k.j a)

pcast eka = {
  pr k a "as"   &eas    else
  pr k a "from" &efrom
}

pa1    ek  = { pj k &JID  &eid  else
               pj k &JSTR &estr else
               pj k &JNUM &elit              }
pa3    eka = { (a.t.format == &ftfunc) then ecall k k.j a }

pa4    eka = { pr    k a "?"    &econd      }
pa5    eka = { pr    k a "ret"  &eret  else
               pr    k a "is"   &eis   else
               pr    k a "for"  &efor  else
               pr    k a "then" &ethen else
               pr    k a "else" &eelse else
               pu    k a "}"    &eseq       }
pamul  eka = { pr    k a "*"    &emul  else
               pr    k a "/"    &ediv  else
               pr    k a "%"    &emod       }
paadd  eka = { pr    k a "+"    &eadd  else
               pr    k a "-"    &esub       }
pash   eka = { pr    k a "<<"   &eshl  else
               pr    k a ">>"   &eshr       }
pacmp  eka = { pr    k a "<"    &eb    else
               pr    k a ">"    &ea    else
               pr    k a "<="   &ebe   else
               pr    k a ">="   &eae   else
               pr    k a "=="   &ee    else
               pr    k a "!="   &ene        }
paband eka = { pr    k a "&"    &eband      }
pabor  eka = { pr    k a "|"    &ebor       }
paland eka = { pr    k a "&&"   &eland else
               pr    k a "and"  &eland      }
palor  eka = { pr    k a "||"   &elor  else
               pr    k a "or"   &elor       }
pa7    eka = { pcast k a                    }

p2 ek = {
  pl k "&"      &eaddr else
  pl k "-"      &eneg  else
  pl k "!"      &elnot else
  pl k "not"    &elnot else
  pl k "~"      &ebnot else
  pl k "cast"   &ecast else
  pl k "the"    &ethe  else
  pl k "sizeof" &esize else
  { consume k "(" ?
      { { p7    k for a
          pr    k a "=" &eass else
          pcast k a
        } ret
        expect k ")"                     }
    pl  k "{"  &ebrace else
    pa1 k else
    jdiag k "expected an expression"
  } for a
  pr    k     a "^"       &eelem   else
  pr    k     a "."       &emem   else
  pr    k     a "@"       &ederef
}

p3    ek = { p2    k for a pa3    k a }
p4    ek = { p3    k for a pa4    k a }
p5    ek = { p4    k is  a pa5    k a }
pmul  ek = { p4    k for a pamul  k a }
padd  ek = { pmul  k for a paadd  k a }
psh   ek = { padd  k for a pash   k a }
pcmp  ek = { psh   k for a pacmp  k a }
pband ek = { pcmp  k for a paband k a }
pbor  ek = { pband k for a pabor  k a }
pland ek = { pbor  k for a paland k a }
plor  ek = { pland k for a palor  k a }
p7    ek = { plor  k for a pcast  k a }

typedecl(k K) J = {
  k.j for j
  !consume k ";" then
  push_scope k id k is s
  (declarator k &s.t)
  k.j
}

create_lvars(k K t T) none = {
  !!t then
  create_lvars k t.s
  k.j is j
  (k.j = t.name)
  nlvar k id k t
  (k.j = j)
}

argreg1(d N) S = {
  (d == 0) ? "dil"
  (d == 1) ? "sil"
  (d == 2) ? "dl"
  (d == 3) ? "cl"
  (d == 4) ? "r8b"
             "r9b"
}

argreg8(d N) S = {
  (d == 0) ? "rdi"
  (d == 1) ? "rsi"
  (d == 2) ? "rdx"
  (d == 3) ? "rcx"
  (d == 4) ? "r8"
             "r9"
}

gtreg(s S        ) none = { gc  '%' gs  s }
gt0  (s S        ) none = { gs  s glf  }
gt1  (s S a S    ) none = { gs  s gc  ' ' gtreg  a glf  }
gt2  (s S a S b S) none = { gs  s gc  ' ' gtreg  a gc  ',' gtreg  b glf  }

gtz (a S) none = gt2  "xor"  a a
gtcz(a S) none = gt2  "test" a a

gtlit(l N a S) none = (!!l ? { gs "mov $" gn l gs ",%rax" glf } gtz  "eax")

gtnot(    a S) none = gt1 "not" a
gtneg(    a S) none = gt1 "neg" a
gmul (    a S) none = gt1 "mul" a
gdiv (       ) none = { gtz  "edx" gt1 "div" "rdi" }
gmod (       ) none = { gdiv
                        gs "mov %rdx,%rax" glf }
gshx (x C    ) none = { gs "mov %dil,%cl" glf
                        gs "sh" gc x gs " %cl,%rax" glf }

gadd (a S b S) none = gt2 "add" a b
gsub (a S b S) none = gt2 "sub" a b
gand (a S b S) none = gt2 "and" a b
gor  (a S b S) none = gt2 "or"  a b
gxor (a S b S) none = gt2 "xor" a b
gcmp (a S b S) none = gt2 "cmp" a b
gshr () none = gshx 'r'
gshl () none = gshx 'l'

gpromote(b S) none = (gt2 "movzbl" "al" b)

gsetf     (s S     b S    ) none = { gs "set" gs s gc ' ' gtreg "al" glf gpromote b }
gcmp_setf (s S a S b S c S) none = { gcmp a b gsetf s c }
gcmpz_setf(s S a S b S    ) none = { gtcz a   gsetf s b }
glnot     (    a S b S    ) none = { gcmpz_setf "e" a b }

gj        (e E l S    ) none = { gs "jmp " gs l gn cast nat e gc '$' glf }
gjc       (e E l S s S) none = { gs "j" gs s gc ' ' gs l gn cast nat e gc '$' glf }
glabel    (e E l S    ) none = { gs l gn cast nat e gs "$:" glf }

gje  (e E l S) none = gjc e l "e"
gjne (e E l S) none = gjc e l "ne"
gjb  (e E l S) none = gjc e l "b"
gjbe (e E l S) none = gjc e l "be"
gja  (e E l S) none = gjc e l "a"
gjae (e E l S) none = gjc e l "ae"

gegcmp(s S) none = gcmp_setf s "rdi" "rax" "eax"

ge  () none = gegcmp "e"
gne () none = gegcmp "ne"
gb  () none = gegcmp "b"
gbe () none = gegcmp "be"
ga  () none = gegcmp "a"
gae () none = gegcmp "ae"

gcast(a T b T) none = (
  (b.format == &ftnone) ?  gtz     "eax"
  { (b.format == &ftbyte) then
    gpromote  "eax" }
)

gfpush(c @N  l N ) none = { !!l then gs "sub $" gn (l << 3) gc ',' gtreg "rsp" glf (c@ = c@ + l) }
gfpop (c @N  l N ) none = { !!l then gs "add $" gn (l << 3) gc ',' gtreg "rsp" glf (c@ = c@ - l) }
gpush (c @N  d S ) none = { gt1 "push" d (c@ = c@ + 1) }
gpop  (c @N  s S ) none = { gt1 "pop"  s (c@ = c@ - 1) }

gindex(      l N ) none = { !!l then gs  "add $" gn  l gc  ',' gtreg  "rax" glf  }

gaddr(q @ftfn n N s S d S) none = {(strcmp s d or n) then gs  "lea " gn  n gs  "(%r" gs  s gs  "),%r" gs  d glf }
gload(q @ftfn n N s S d S) none = (
  {(q == &ftstct) else (q == &ftfunc)} ?
    gaddr  q n s d 
  {(q == &ftbyte) else (q == &ftbit)} ?
    {gs  "movzbl " gn  n gs  "(%r" gs  s gs  "),%e" gs  d glf }
  {gs  "mov " gn  n gs  "(%r" gs  s gs  "),%r" gs  d glf }
)

gaddrg(e E c @N d S) none = { gs "mov " gs e.o.name gs "@GOTPCREL(%rip),%r" gs d glf }
gaddrl(e E c @N d S) none = { gaddr e.o.t.format (c@ - e.o.sp << 3) "sp" d }
gloadl(e E c @N d S) none = { gload e.o.t.format (c@ - e.o.sp << 3) "sp" d }

gloadsp(q @ftfn d S) none = (
  (q == &ftstct) ?
    { gs  "mov %rsp,%" gs  d glf }
  {(q == &ftbyte) else (q == &ftbit)} ?
    { gs  "movzbq (%rsp), %" gs  d glf }
  { gs  "mov (%rsp),%" gs  d glf }
)

gstoresp(t T) none = {
  {(t.format == &ftbyte) else (t.format == &ftbit)} ?
    {gs "mov %al,(%rsp)" glf }
  {gs "mov %rax,(%rsp)" glf }
}

gstore(t T c @N) none = {
  gpop c "rdi"
  (t.format == &ftstct) ?
    { 0 for i
      (i < t.size) then
      (i + 1) ret
      gs "mov " gn i gs "(%rax),%r8b" glf
      gs "mov %r8b," gn i gs "(%rdi)" glf }
  (t.format == &ftbyte || t.format == &ftbit) ?
    { gs "mov %al,(%rdi)"  glf }
    { gs "mov %rax,(%rdi)" glf }
}

gexpr necl  = e.gen@  e c l

gdrop (e E c N    ) none = { cast none gexpr  e c 0 }
geval (e E c N l N) none = {
  gexpr e c l is l1
  !!l1 then
  l1 for l2
  gload ((l2 == 1 and l == 0) ? e.t.format &ftptr) 0 "ax" "ax"
  (l2 - 1)
}

glet(e E c N l N d S gen @necl) N = {
  geval e.a c 0
  gfpush &c 1
  (e.o.sp = c)
  gstoresp e.o.t
  gen@ e c l ret
  gloadsp e.o.t.format d
  gfpop &c 1
}

gtpars(e E o O c N g N) N = {
  !o ? { gdrop e c 0 }
    { (o.sp = -g)
      gtpars e o.s c (g + 1) }
}
gtparr(e E o O c N g N) N = {
  !o ? { gdrop e c 0 }
    { gpush &c argreg8 g
      (o.sp = c)
      (((g == 5) ? &gtpars &gtparr)@ e o.s c (g + 1) + 1) }
}
function(k K) none = {
  consume k "export" is is_export
  cast T 0 is t
  declarator k &t
  {
    try_search_scope k t.name.p cast N t.name.n is s
    (!!s and !!s.o and (s.o.t.format == &ftfunc) and s.o)
  } is o
  ( !!o ?
    { (o.t.format != &ftfunc and jdiag k "redeclared as a different type of symbol")
      (o.is_definition and jeq k "=" and jdiag k "redefinition")
      (o.is_export != is_export and jdiag k "mismatched visibility") }
    { k.j is j
      (k.j = t.name)
      (o = ngvar k id k t)
      (k.j = j)
      (o.is_export = is_export) } )
  { consume k "=" then
    (o.is_definition = 1b)
    (k.locals = cast O 0)
    k.s is s
    create_lvars k t.params
    (o.params = k.locals)
  !!o.is_definition then
  gs ".section .text." gs o.name glf
  { o.is_export then gs ".globl" gc ' ' gs o.name glf }
  gs ".type " gs o.name gs ",%function" glf
  gs o.name gc ':' glf
  0 is c
    (o.body = cast @none p4 k)
  gfpop &c gtparr cast E o.body o.params c 0
  gt0 "ret"
    (k.s = s) }
}

export main(argc N argv @S) N = {
  cast @byte 0 is c
  gt0 ".data"
  read_file is p
  (c = p)
  cast J 0 is j
  1 is n
  &j is k
  { 1b for _
    p@ then
    ( p^0 == '/' and p^1 == '*') ? {
      strstr &p^2 "*/" is q
      (!q and diag p c "unclosed block comment")
      (p = &q^2) }
    isws p@ ?
      (p = &p^1)
    { is09 p@ ? {
      { &p^1 for q isid q@ then &q^1 } is q
      (k@ = ntoken &JNUM p q n)
      { k.p is p
        10 is a
        { !strncmp p "0x" 2 then
          is0f p^2 then
          (p = &p^2)
          (a = 16) }
        strtoul p &p a is v
        ( (p^0 == 'b') ?
            { (p = &p^1)
              nbit }
            nnat
        ) is t
        (k.l = v as N)
        (k.t = t as @none)
      1b }
    (p = q) }
  (p@ == '"') ? {
      { &p^1 for q
        (q@ == '\\') ?
        { (q^2 == '\0' and diag p c "unclosed string literal")
          &q^2 }
        { (q^1 == '\0' and diag p c "unclosed string literal")
          (q@ != '"') then
            &q^1 }
      } is end
      cast S calloc 1 (end - p) is buf
    ntoken &JSTR p &end^1 n is j
      gs ".s" gn cast nat j gc ':' gs ".string \""
      { &j.p^1 for i (i < &j.p^(j.n - 1)) then gc i@ &i^1 }
      gc '\"' glf
      (j.t = nptr nbyte)
      (j.str = buf)
    (k@ = j)
    (p = &p^k.n) }
  (p@ == '\'') ?
    { &p^1 is q
      (q@ == '\0' and diag p c "unclosed literal byte")
      (q@ == '\\') ?
        { (q = &q^1)
          (q@ == '\0' and diag p c "unclosed literal byte")
          (q@ == 'a' ) ?'\a'
            (q@ == 'b' ) ?'\b'
            (q@ == 'f' ) ?'\f'
            (q@ == 'n' ) ?'\n'
            (q@ == 'r' ) ?'\r'
            (q@ == 't' ) ?'\t'
            (q@ == 'v' ) ?'\v'
            (q@ == '\'') ? '\''
            (q@ == '\"') ? '\"'
            (q@ == '\\') ? '\\'
              { '\0' ret
              (q@ != '0' and diag q c "invalid escape sequence") } }
      q@
      is l
    (q = &q^1)
    (q@ != '\'' and diag p c "unclosed literal byte")
      ntoken &JNUM p &q^1 n is j
    (j.l = l as N)
    (j.t = cast @none nbyte)
      (k@ = j)
  (k.l = k.l as C as N)
    (p = &p^k.n) }
  { 0 is n
    { p for q { { isid q@ then &q^1 } else cast S 0 ret (n = q - p as N) } }
    !!n ?
        { (k@ = ntoken &JID p &p^n n)
          (p = &p^k.n) }
      { read_punct p is n
        !!n ?
            { (k@ = ntoken &JPCT p &p^n n)
              (p = &p^k.n) }
            diag p c "invalid token" } }
    (k = &k.s) } }
  cast @Ctx malloc sizeof Ctx is k
  (k.j = j)
  (k.c = c)
  (k.globals = 0)
  (k.locals = 0)
  (k.s = 0)
  { !!k.j then
    k.j for j
    ( consume k "type" ? &typedecl &function)@ k
    k.j }
  0
}

ge0     gelfn = {
  gtlit   v "rax"
  0
}

ge1     geefn = {
  geval  e.a c 0
  gop@
  0
}

ge2     geefn = {
  geval  e.a.s  c 0
  gpush        &c "rax"
  geval  e.a    c 0
  gpop         &c "rdi"
  gop@
  0
}

gegadd  gegfn = gadd   "rdi" "rax"
gegsub  gegfn = gsub   "rdi" "rax"
gegand  gegfn = gand   "rdi" "rax"
gegor   gegfn = gor    "rdi" "rax"
gegxor  gegfn = gxor   "rdi" "rax"
gegbnot gegfn = gtnot  "rax"
gegneg  gegfn = gtneg  "rax"
geglnot gegfn = glnot  "rax" "eax"
gegmul  gegfn = gmul   "rdi"
gegdiv  gegfn = gdiv
gegmod  gegfn = gmod
gegshr  gegfn = gshr
gegshl  gegfn = gshl
gege    gegfn = ge
gegne   gegfn = gne
gegb    gegfn = gb
gegbe   gegfn = gbe
gega    gegfn = ga
gegae   gegfn = gae

ebrace ekj  = p5 k
eparen ekj  = p7 k

elit    ekj   = tl j cast T j.t &gelit j.l
gelit   necl  = ge0 e.l

esize   ekj   = tt j nnat &gesize ptype k
gesize  necl  = ge0 e.t.s.size

ederef  ekja  = t1 j a.t.a &gederef a
gederef necl  = (gexpr e.a c 0 + 1 - l)

eaddr   ekj   = { p2 k is a t1 j nptr a.t &geaddr a }
geaddr  necl  = gexpr e.a c 1

efrom   ekja  = t1 j ptype k &gethe a
ethe    ekj   = { ptype k is u p4 k is a t1 j a.t &gethe a }
gethe   necl  = gexpr e.a c l

eas     ekja  = t1 j ptype k &gecast a
ecast   ekj   = { ptype k is u t1 j u &gecast p4 k }
gecast  necl  = {
  geval  e.a c 0
  gcast  e.a.t e.t
  0
}

estr   ekj  = { t0 j nptr nbyte &gestr }
gestr necl  = {
  gs "mov .s" gn cast nat e.j gs "@GOTPCREL(%rip),%rax" glf
  0
}
eid    ekj  = { (search_scope k j.p j.n).o is o to j o.t &geid o }
geid   necl  = {
  (e.o.is_local ? !l ? &gloadl &gaddrl &gaddrg)@ e &c "ax"
  0
}

elnot ekj  = t1 j nbit &gelnot   p3    k gelnot necl  = ge1 e c l &geglnot
ebnot ekj  = t1 j nnat &gebnot   p3    k gebnot necl  = ge1 e c l &gegbnot
eneg  ekj  = t1 j nnat &geneg    p3    k geneg  necl  = ge1 e c l &gegneg
ediv  ekja = t2 j nnat &gediv  a p4    k gediv  necl  = ge2 e c l &gegdiv
emod  ekja = t2 j nnat &gemod  a p4    k gemod  necl  = ge2 e c l &gegmod
ee    ekja = t2 j nbit &gee    a psh   k gee    necl  = ge2 e c l &gege
ene   ekja = t2 j nbit &gene   a psh   k gene   necl  = ge2 e c l &gegne
eae   ekja = t2 j nbit &geae   a psh   k geae   necl  = ge2 e c l &gegae
ea    ekja = t2 j nbit &gea    a psh   k gea    necl  = ge2 e c l &gega
eb    ekja = t2 j nbit &geb    a psh   k geb    necl  = ge2 e c l &gegb
ebe   ekja = t2 j nbit &gebe   a psh   k gebe   necl  = ge2 e c l &gegbe
eadd  ekja = t2 j nnat &geadd  a pmul  k geadd  necl  = ge2 e c l &gegadd
esub  ekja = t2 j nnat &gesub  a pmul  k gesub  necl  = ge2 e c l &gegsub
emul  ekja = t2 j nnat &gemul  a p4    k gemul  necl  = ge2 e c l &gegmul
eband ekja = t2 j nnat &geband a pcmp  k geband necl  = ge2 e c l &gegand
ebor  ekja = t2 j nnat &gebor  a pband k gebor  necl  = ge2 e c l &gegor
eshl  ekja = t2 j nnat &geshl  a padd  k geshl  necl  = ge2 e c l &gegshl
eshr  ekja = t2 j nnat &geshr  a padd  k geshr  necl  = ge2 e c l &gegshr

eelem  ekja = t2 j a.t.a &geelem a p3 k
geelem necl   = {
  geval  e.a    c 0
  gpush        &c "rax"
  geval  e.a.s  c 0
  gpop         &c "rdx"
  gs  "lea (%rdx,%rax," gn  e.a.t.a.size gs  "),%rax" glf 
  (1 - l)
}

emem  ekja  = {
  jadv k
  { a.t for t (t.format == &ftptr) then t.a } is t
  (t.format != &ftstct and jdiag k "not a struct")
  cast T 0 is g
  { t.a for a
    { (a.name.n == j.s.n) then !strncmp a.name.p j.s.p j.s.n }
    ? { (g = a) cast T 0 }
      a.s }
  { !g then jdiag k "no such member" }
  t1 j.s g &gemem a
}
gemem   necl  = {
  geval  e.a c 0
  { e.a.t for t
    (t.format == &ftptr) then
    t.a ret
    gload  t.a.format 0 "ax" "ax" }
  gindex  e.t.offset
  (1 - l)
}

eseq   ekja  = { p5 k is b t2 j b.t &geseq a b}
geseq  necl  = {
  gdrop  e.a   c
  geval  e.a.s c l
  0
}

eret  ekja  = t2 j a.t &geret a p5 k
geret necl  = {
  geval  e.a    c l
  gpush        &c "rax"
  gdrop  e.a.s  c
  gpop         &c "rax"
  0
}

econd  ekja = { p4 k is b t3 j b.t &gecond a b p4 k }
gecond necl   = {
  geval   e.a     c 0
  gtcz              "eax"
  gje     e         "a"
  geval   e.a.s   c l
  gj      e         "b"
  glabel  e         "a"
  geval   e.a.s.s c l
  glabel  e         "b"
  0
}

ethen  ekja  = { p5   k is b t2 j b.t &geland a b }
eland  ekja  = { pbor k is b t2 j b.t &geland a b }
geland necl  = {
  (e.a.s.t.format == &ftnone) is keep
  geval  e.a c 0
  gtcz  "eax"
  gje    e         "a"
  { keep then
    gpush        &c "rax" }
  geval  e.a.s c 0
  { keep then
    gpop         &c "rax" }
  glabel  e        "a"
  0
}

eelse  ekja  = t2 j a.t &gelor a p5    k
elor   ekja  = t2 j a.t &gelor a pland k
gelor  necl  = {
  (e.a.s.t.format == &ftnone) is keep
  geval    e.a   c 0
  gtcz    "eax"
  gjne     e       "a"
  { keep then
    gpush        &c "rax" }
  geval    e.a.s c 0
  { keep then
    gpop         &c "rax" }
  glabel   e       "a"
  0
}

eis    ekja = { k.s is s nletvar k id k a.t is o jadv k p5 k is b { t2 j b.t &geis a b is e (e.o = o) e } ret (k.s = s) }
geisa  necl = {
  geval   e.a.s  c l
  0
}
geis   necl = {
  glet    e      c l "rdx" &geisa
}

efor   ekja = { k.s is s nletvar k id k a.t is o jadv k p5 k is b { t2 j b.t &gefor  a b is e (e.o = o) e } ret (k.s = s) }
gefora necl = {
  gj        e        "b"
  glabel    e        "a"
  gstoresp  e.a.t
  glabel    e        "b"
  geval     e.a.s  c 0
  gtcz               "eax"
  gjne      e        "a"
  0
}
gefor  necl = {
  glet      e      c l "rax" &gefora
}

ecall ekja = {
  a.t.params is u
  { a for b
    !!u then
    (b.s = p3 k)
    { !type_equal b.s.t u then jdiag k "asymmetric argument" }
    (u = u.s)
    b.s }
  t1 k.j a.t.a &gecall a
}
gargs(e E c @N) none = {
  !!e then
  gargs e.s c
  geval e c@ 0
  gpush c "rax"
}
gecall necl  = {
  gargs e.a.s &c
  geval e.a    c 0
  0 is d
  { !!e.a.s then
    e.a.s for e (d < 6) then e.s ret
    gpop &c argreg8 d
    (d = d + 1) }
  gs "call *%rax" glf
  0
}

eass   ekja  = t2 j nnone &geass a p7 k
geass  necl  = {
  geval   e.a    c 1
  gpush         &c "rax"
  geval   e.a.s  c 0
  gstore  e.a.t &c
  gtz             "eax"
  0
}

ftnone ftfn = 0
ftbit  ftfn = 0
ftbyte ftfn = 0
ftnat  ftfn = 0
ftstct ftfn = 0
ftptr  ftfn = 0
ftfunc ftfn = 0