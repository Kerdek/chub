issp (c C    ) nat = (c == ' ' )
istb (c C    ) nat = (c == '\t')
islf (c C    ) nat = (c == '\n')
iscr (c C    ) nat = (c == '\r')
is_  (c C    ) nat = (c == '_' )

isin(c C a C b C) nat = (a <= c and c <= b)

isAZ (c C    ) nat = isin c 'A' 'Z'
isaz (c C    ) nat = isin c 'a' 'z'
is09 (c C    ) nat = isin c '0' '9'
isaf (c C    ) nat = isin c 'a' 'f'

isws (c C    ) nat = {
   issp c else
   istb c else
   islf c else
   iscr c
}
is0f (c C    ) nat = {
   is09 c else
   isaf c
}
isid (c C    ) nat = {
   isAZ c else
   isaz c else
   is09 c else
   is_  c
}

sw1(p S a C    ) nat = { (p^0 == a) then 1 }
sw2(p S a C b C) nat = { (p^0 == a) then (p^1 == b) then 2 }

read_punct(p S) N = {
  sw2 p '=' '=' else
  sw2 p '!' '=' else
  sw2 p '<' '=' else
  sw2 p '>' '=' else
  sw2 p '<' '<' else
  sw2 p '>' '>' else
  sw2 p '/' '/' else
  sw1 p '='     else
  sw1 p '<'     else
  sw1 p '>'     else
  sw1 p '+'     else
  sw1 p '-'     else
  sw1 p '*'     else
  sw1 p '/'     else
  sw1 p '&'     else
  sw1 p '|'     else
  sw1 p '@'     else
  sw1 p '#'     else
  sw1 p '{'     else
  sw1 p '}'     else
  sw1 p '('     else
  sw1 p ')'     else
  sw1 p '['     else
  sw1 p ']'     else
  sw1 p '!'     else
  sw1 p '?'     else
  sw1 p ':'     else
  sw1 p ';'     else
  sw1 p ','     else
  sw1 p '.'     else
  sw1 p '~'     else
  sw1 p '^'     else
  sw1 p '$'     else
  sw1 p '`'     else
  sw1 p '%'
}

ntoken(q TokenKind a S b S) K = {
  cast K alloc sizeof Token is k
  (k.s    = 0    )
  (k.q    = q    )
  (k.p    = a    )
  (k.n    = b - a)
  k
}

export _start() N = {
  ibrk 0
  gt0 ".data"
  gt0 ".globl .scurbrk"
  gt0 ".weak .scurbrk"
  gt0 ".scurbrk:.quad 0"
  (1 << 20) is big
  cast @byte alloc big is p
  { p is q
    { 1 for _
      read q big is n
      { (n == -1) then
        exit 1 }
      (q = &q^n)
      (big = big - n)
      n }
    (q@ = cast byte 0) }
  cast K 0 is k
  &k is x
  { 1 for _
    p@ then
    (p^0 == '/' and p^1 == '*') ? {
      (p = &p^2)
      { 1 for _
        (p@ or diag "unclosed block comment")
        (p^0 == '*' and p^1 == '/') ?
          { (p = &p^2) 0 }
          { (p = &p^1)
            1 } } }
    isws p@ ? {
      (p = &p^1) }
    { is09 p@ ? {
        { &p^1 for q is09 q@ then &q^1 } is q
        (x@ = ntoken &JNUM p q)
        (p = q) }
      (p@ == '"') ? {
        { &p^1 for q
          (q^0 or diag "unclosed string literal")
          (q^0 == '\n' and diag "newline in string literal")
          (q^0 == '\\') ?
          { (q^1 or diag "unclosed string literal")
            (q^1 == '\n' and diag "newline in string literal")
            &q^2 }
          { (q^0 != '"') then
            &q^1 }
        } is end
        ntoken &JSTR p &end^1 is k
        gs ".s" gn cast nat k gc ':' gs ".string \""
        { &k.p^1 for i (i < &k.p^(k.n - 1)) then gc i@ &i^1 }
        gc '\"' glf
        (x@ = k)
        (p = &p^x.n) }
      (p@ == '\'') ? {
        p is p1
        (p^1 or diag "unclosed literal byte")
        { (p^1 == '\\') then
          (p = &p^1)
          (p^1 or diag "unclosed escape") }
        (p = &p^2)
        (p@ != '\'' and diag "expected '")
        (p = &p^1)
        (x@ = ntoken &JCHR p1 p) }
      { 0 is n
        { p for q { { isid q@ then &q^1 } else cast S 0 ret (n = q - p as N) } }
        !!n ?
            { (x@ = ntoken &JID p &p^n)
              (p = &p^n) }
          { read_punct p is n
            !!n ?
                { (x@ = ntoken &JPCT p &p^n)
                  (p = &p^n) }
                diag "invalid token" } }
      (x = &x.s) }
    1 }
  decls &k cast O 0
  exit 0
}

