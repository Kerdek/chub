alloc (n nat) @none = cast @none brk n

strlen(a @byte) nat = { 0 for i a^i then (i + 1) }

memcpy (a @byte b @byte n nat) none = {
  n then
  n for m
  (a@ = b@)
  (a = &a^1)
  (b = &b^1)
  (m - 1)
}

memcmp(a @byte b @byte n nat) nat = {
  1 is r
  { n then n for m
    (a@ == b@) ?
      { (a = &a^1)
        (b = &b^1)
        (m - 1) }
      { (r = 0)
        0 } }
  r
}

strncmp(a @byte b @byte n nat) nat = {
  1 is r
  { n then
    n for m
    (a@ == b@) ?
      { a@ then
        (a = &a^1)
        (b = &b^1)
        (m - 1) }
      { (r = 0)
        0 } }
  r
}

strcmp(a @byte b @byte) nat = {
  1 is r
  { 1 for _
    (a@ == b@) ?
      { a@ then
        (a = &a^1)
        (b = &b^1)
        1 }
      { (r = 0)
        0 } }
  r
}

type

  TokenKind @()none
  TypeKind  @()none

  C byte
  N nat
  S @C

  Token {
    s    @Token
    q     TokenKind
    p     S
    n     N
  }

  K @Token

  Type {
    s      @Type
    a      @Type
    q       TypeKind
    k       K
    size    N
    align   N
    offset  N
  }

  T @Type

  Expr {
    s @Expr
    a @Expr
    q @(e @Expr c N l N) N
    k  K
    t  T
    u  T
    c  N
  }

  E @Expr

  Scope {
    s        @Scope
    k        K
    t        T
    e        E
    is_type  N
    is_def   N
  }

  O @Scope

  tko   (k @K o O         ) T
  eko   (k @K o O         ) E
  ekoa  (k @K o O      a E) E
  ekok  (k @K o O k1 K    ) E
  ekoka (k @K o O k1 K a E) E

  necl (e E c N l N) N
;

ptype  tko

p2     eko p3     eko p5     eko p7     eko
pmul   eko padd   eko psh    eko pcmp   eko

esize  ekok ecast  ekok enat   ekok eaddr  ekok escratch ekok ebrk ekok eibrk ekok
eneg   ekok elnot  ekok eid    ekok estr   ekok ebrace ekok eparen ekok eexit  ekok ebyte  ekok eread ekok ewrite ekok eerr ekok

eas    ekoka eelem  ekoka ederef ekoka eseq   ekoka
eret   ekoka emul   ekoka ediv   ekoka emod   ekoka ethen  ekoka
eelse  ekoka econd  ekoka eadd   ekoka esub   ekoka eshl   ekoka
eshr   ekoka eb     ekoka ea     ekoka ebe    ekoka eae    ekoka
ee     ekoka ene    ekoka eland  ekoka ecall  ekoka emem   ekoka
elor   ekoka eass   ekoka eis    ekoka efor   ekoka

TNONE () none = 0 
TBYTE () none = 0
TNAT  () none = 0
TSTCT () none = 0
TPTR  () none = 0
TFUNC () none = 0

JID  () none = 0
JPCT () none = 0
JCHR () none = 0
JSTR () none = 0
JNUM () none = 0

issp (c C    ) nat = (c == ' ' )
istb (c C    ) nat = (c == '\t')
islf (c C    ) nat = (c == '\n')
iscr (c C    ) nat = (c == '\r')
is_  (c C    ) nat = (c == '_' )

isin(c C a C b C) nat = (a <= c and c <= b)

isAZ (c C    ) nat = isin c 'A' 'Z'
isaz (c C    ) nat = isin c 'a' 'z'
is09 (c C    ) nat = isin c '0' '9'
isaf (c C    ) nat = isin c 'a' 'f'

isws (c C    ) nat = {
   issp c else
   istb c else
   islf c else
   iscr c
}
is0f (c C    ) nat = {
   is09 c else
   isaf c
}
isid (c C    ) nat = {
   isAZ c else
   isaz c else
   is09 c else
   is_  c
}

sw1(p S a C    ) nat = { (p^0 == a) then 1 }
sw2(p S a C b C) nat = { (p^0 == a) then (p^1 == b) then 2 }

read_punct(p S) N = {
  sw2 p '=' '=' else
  sw2 p '!' '=' else
  sw2 p '<' '=' else
  sw2 p '>' '=' else
  sw2 p '<' '<' else
  sw2 p '>' '>' else
  sw2 p '/' '/' else
  sw1 p '='     else
  sw1 p '<'     else
  sw1 p '>'     else
  sw1 p '+'     else
  sw1 p '-'     else
  sw1 p '*'     else
  sw1 p '/'     else
  sw1 p '&'     else
  sw1 p '|'     else
  sw1 p '@'     else
  sw1 p '#'     else
  sw1 p '{'     else
  sw1 p '}'     else
  sw1 p '('     else
  sw1 p ')'     else
  sw1 p '['     else
  sw1 p ']'     else
  sw1 p '!'     else
  sw1 p '?'     else
  sw1 p ':'     else
  sw1 p ';'     else
  sw1 p ','     else
  sw1 p '.'     else
  sw1 p '~'     else
  sw1 p '^'     else
  sw1 p '$'     else
  sw1 p '`'     else
  sw1 p '%'
}

gc (c C) none = write &c 1
gs (s S) none = write s strlen s
gsn(s S n N) none = write s n
glf() none = gc '\n'
gn1(n N) none = { n then gn1 (n / 10) gc cast byte ('0' + n % 10) }
gn (n N) none = { n ? gn1 n gc '0' }

oc (c C) none = err &c 1
os (s S) none = err s strlen s
osn(s S n N) none = err s n
olf(   ) none = oc '\n'
on1(n N) none = { n then on1 (n / 10) oc cast byte ('0' + n % 10) }
on (n N) none = { n ? on1 n oc '0' }

diag (s S) none = { os s olf exit 1 }

ntoken(q TokenKind a S b S) K = {
  cast K alloc sizeof Token is k
  (k.s    = 0    )
  (k.q    = q    )
  (k.p    = a    )
  (k.n    = b - a)
  k
}

ntype(size N align N q TypeKind) T = {
  cast T alloc sizeof Type is t
  (t.size  = size  )
  (t.align = align )
  (t.q = q)
  (t.s = 0)
  t
}

ntypea(size N align N q TypeKind a T) T = {
  ntype size align q is t
  (t.a = a)
  t
}

nnone (   ) T = ntype  0 0 &TNONE
nbyte (   ) T = ntype  1 1 &TBYTE
nnat  (   ) T = ntype  8 8 &TNAT
nstct (   ) T = ntype  0 1 &TSTCT
nptr  (a T) T = ntypea 8 8 &TPTR  a
nfunc (a T) T = ntypea 1 1 &TFUNC a

type_equal(t T u T) nat = {
  t then
  u then
  (t == u) else
  { (t.q == u.q) then
    (t.q == &TNONE ) else
    (t.q == &TBYTE ) else
    (t.q == &TNAT  ) else
    (t.q == &TPTR  ) ? type_equal t.a u.a
      { (t.q == &TFUNC ) then
        t.a is p
        u.a is q
        { 1 for _
          type_equal p q then
          (p = p.s)
          (q = q.s)
          1 }
        (p == q) } }
}

tree(k K t T q @necl) E = {
  cast E alloc sizeof Expr is e
  (e.k = k)
  (e.t = t)
  (e.q = q)
  e
}

t0  (k K t T q @necl            ) E = {tree k t q}
t1  (k K t T q @necl         a E) E = {tree k t q is e e ret (e.a = a)}
t2  (k K t T q @necl     b E a E) E = {tree k t q is e e ret (e.a = a)  (e.a.s = b)}
t3  (k K t T q @necl c E b E a E) E = {tree k t q is e e ret (e.a = a)  (e.a.s = b)  (e.a.s.s = c)}
tt  (k K t T q @necl u T        ) E = {t0   k t q is e e ret (e.u = u)}

try_search_scope(o O c S n N) O = {
  cast O 0 is r
  { o then
    o for oi
    (n != oi.k.n or !strncmp oi.k.p c n) ?
      oi.s
      { (r = oi)
        cast O 0 } }
  r
}

search_scope(k @K o O c S n N) @Scope = {
  try_search_scope o c n else
  diag "lookup failed"
}

jadv   (k @K    ) K    = { k@ ret (k@ = k.s) }
jeq    (k @K c S) nat  = { k@ then memcmp k.p c k.n then !c^k.n }
expect (k @K c S) none = { { !jeq k c then diag "unexpected" } jadv k }
consume(k @K c S) nat  = { jeq k c is r { r then jadv k } r }

declarator (k @K o O t @T) none = {
  (t@ = cast T alloc sizeof Type)
  jadv k is k1
  ptype k o is u
  memcpy cast S t@ cast S u sizeof Type
  (t.k = k1)
}

align(n N a N) N = ((n + a - 1) / a * a)

struct_decl tko = {
  nstct is t
  &t.a is u
  { 1 for _ 
     !consume k "}" then
      declarator k o u
      (u = &u.s) }
  0 is bits
  { !!t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

func_params tko = {
  cast T 0 is params
  &params is u
  { 1 for _
    !jeq k ")" then
    declarator k o u
    (u = &u.s)
    1 }
  jadv k
  ptype k o is ret
  nfunc cast T alloc sizeof Type is t
  memcpy cast S t.a cast S ret sizeof Type
  (t.a.s = params)
  t
}

ptype tko = {
  consume k "none"   ? nnone
  consume k "byte"   ? nbyte
  consume k "nat"    ? nnat
  consume k "@"      ? nptr        ptype k o
  consume k "("      ? func_params       k o
  consume k "{"      ? struct_decl       k o
  { search_scope k o k.p k.n is s
    (s.is_type or diag "not a type")
    jadv k
    s.t }
}

pj(k @K o O     q TokenKind e @ekok ) E = {k@ then (k.q == q) then jadv k is k1 e@ k o k1}
pl(k @K o O     c S         e @ekok ) E = {k@ then jeq k c then jadv k is k1 e@ k o k1  }
pr(k @K o O a E c S         e @ekoka) E = {k@ then jeq k c then jadv k is k1 e@ k o k1 a}
pu(k @K o O a E c S         e @ekoka) E = {k@ then consume k c ? a e@ k o k@ a}

pa1    eko  = { pj    k o   &JID   &eid   else
               pj    k o   &JSTR  &estr  else
               pj    k o   &JNUM  &enat  else
               pj    k o   &JCHR  &ebyte      }
pa3    ekoa = { (a.t.q == &TFUNC) then ecall k o k@ a }
pa4    ekoa = { pr    k o a "?"    &econd      }
pa5    ekoa = { pr    k o a "ret"  &eret  else
               pr    k o a "is"   &eis   else
               pr    k o a "for"  &efor  else
               pr    k o a "then" &ethen else
               pr    k o a "else" &eelse else
               pu    k o a "}"    &eseq       }
pamul  ekoa = { pr    k o a "*"    &emul  else
               pr    k o a "/"    &ediv  else
               pr    k o a "%"    &emod       }
paadd  ekoa = { pr    k o a "+"    &eadd  else
               pr    k o a "-"    &esub       }
pash   ekoa = { pr    k o a "<<"   &eshl  else
               pr    k o a ">>"   &eshr       }
pacmp  ekoa = { pr    k o a "<"    &eb    else
               pr    k o a ">"    &ea    else
               pr    k o a "<="   &ebe   else
               pr    k o a ">="   &eae   else
               pr    k o a "=="   &ee    else
               pr    k o a "!="   &ene        }
paland ekoa = { pr    k o a "and"  &eland      }
palor  ekoa = { pr    k o a "or"   &elor       }
pa7    ekoa = { pr    k o a "as"   &eas        }

p2 eko = {
  pl k o "&"       &eaddr    else
  pl k o "-"       &eneg     else
  pl k o "!"       &elnot    else
  pl k o "not"     &elnot    else
  pl k o "cast"    &ecast    else
  pl k o "sizeof"  &esize    else
  pl k o "exit"    &eexit    else
  pl k o "brk"     &ebrk     else
  pl k o "ibrk"    &eibrk    else
  pl k o "read"    &eread    else
  pl k o "write"   &ewrite   else
  pl k o "err"     &eerr     else
  { consume k "(" ?
      { { p7    k o for a
          pr    k o a "=" &eass else
          pa7   k o a
        } ret
        expect k ")"                     }
    pl  k o "{"  &ebrace else
    pa1 k o else
    diag "expected an expression"
  } for a
  pr    k o     a "^"       &eelem   else
  pr    k o     a "."       &emem   else
  pr    k o     a "@"       &ederef
}

p3    eko = { p2    k o for a pa3    k o a }
p4    eko = { p3    k o for a pa4    k o a }
p5    eko = { pl    k o "scratch" &escratch else
             p4    k o is  a pa5    k o a }
pmul  eko = { p4    k o for a pamul  k o a }
padd  eko = { pmul  k o for a paadd  k o a }
psh   eko = { padd  k o for a pash   k o a }
pcmp  eko = { psh   k o for a pacmp  k o a }
pland eko = { pcmp  k o for a paland k o a }
plor  eko = { pland k o for a palor  k o a }
p7    eko = { plor  k o for a pa7    k o a }


argreg1(d N) S = {
  (d == 0) ? "dil"
  (d == 1) ? "sil"
  (d == 2) ? "dl"
  (d == 3) ? "cl"
  (d == 4) ? "r8b"
             "r9b"
}

argreg8(d N) S = {
  (d == 0) ? "rdi"
  (d == 1) ? "rsi"
  (d == 2) ? "rdx"
  (d == 3) ? "rcx"
  (d == 4) ? "r8"
             "r9"
}

gtreg(s S        ) none = { gc '%' gs s }
gt0  (s S        ) none = { gs s glf  }
gt1  (s S a S    ) none = { gs s gc ' ' gtreg a glf }
gt2  (s S a S b S) none = { gs s gc ' ' gtreg a gc ',' gtreg b glf }

gtz (a S) none = gt2  "xor"  a a
gtcz(a S) none = gt2  "test" a a

gtlit(l N a S) none = (!!l ? { gs "mov $" gn l gc ',' gtreg a glf } gtz  a)

gtnot(    a S) none = gt1 "not" a
gtneg(    a S) none = gt1 "neg" a
gmul (    a S) none = gt1 "mul" a
gdiv (       ) none = { gtz "edx" gt1 "div" "rdi" }
gmod (       ) none = { gdiv
                        gt2 "mov" "rdx" "rax" }
gshx (x C    ) none = { gt2 "mov" "dil" "cl" gs "sh" gc x gs " %cl,%rax" glf }

gadd (a S b S) none = gt2 "add" a b
gsub (a S b S) none = gt2 "sub" a b
gand (a S b S) none = gt2 "and" a b
gor  (a S b S) none = gt2 "or"  a b
gxor (a S b S) none = gt2 "xor" a b
gcmp (a S b S) none = gt2 "cmp" a b
gshr () none = gshx 'r'
gshl () none = gshx 'l'

gpromote(b S) none = (gt2 "movzbl" "al" b)

gsetf     (s S     b S    ) none = { gs "set" gs s gc ' ' gtreg "al" glf gpromote b }
gcmp_setf (s S a S b S c S) none = { gcmp a b gsetf s c }
gcmpz_setf(s S a S b S    ) none = { gtcz a   gsetf s b }
glnot     (    a S b S    ) none = { gcmpz_setf "e" a b }

gj        (e E l S    ) none = { gs "jmp " gs l gn cast nat e gc '$' glf }
gjc       (e E l S s S) none = { gs "j" gs s gc ' ' gs l gn cast nat e gc '$' glf }
glabel    (e E l S    ) none = { gs l gn cast nat e gs "$:" glf }

gje  (e E l S) none = gjc e l "e"
gjne (e E l S) none = gjc e l "ne"
gjb  (e E l S) none = gjc e l "b"
gjbe (e E l S) none = gjc e l "be"
gja  (e E l S) none = gjc e l "a"
gjae (e E l S) none = gjc e l "ae"

gegcmp(s S) none = gcmp_setf s "rdi" "rax" "eax"

ge  () none = gegcmp "e"
gne () none = gegcmp "ne"
gb  () none = gegcmp "b"
gbe () none = gegcmp "be"
ga  () none = gegcmp "a"
gae () none = gegcmp "ae"

gcast(a T b T) none = (
  (b.q == &TNONE) ?  gtz     "eax"
  { (b.q == &TBYTE) then
    gpromote  "eax" }
)

gfpush(c @N  l N ) none = { !!l then gs "sub $" gn (l << 3) gc ',' gtreg "rsp" glf (c@ = c@ + l) }
gfpop (c @N  l N ) none = { !!l then gs "add $" gn (l << 3) gc ',' gtreg "rsp" glf (c@ = c@ - l) }
gpush (c @N  d S ) none = { gt1 "push" d (c@ = c@ + 1) }
gpop  (c @N  s S ) none = { gt1 "pop"  s (c@ = c@ - 1) }

gindex(      l N ) none = { !!l then gs  "add $" gn  l gc  ',' gtreg  "rax" glf  }

gaddr(t T n N s S d S) none = {
  (n or !strcmp s d) then
  gs "lea " { n then gn n } gs "(%" gs s gs "),%" gs d glf
}
gload(t T n N s S d S) none = {
  (t.q == &TBYTE) ?
    {gs  "movzbq " gn n gs "(%" gs s gs "),%" gs  d glf }
    {gs  "mov "    gn n gs "(%" gs s gs "),%" gs  d glf }
}
gstore(t T d S) none = {
  (t.q == &TBYTE) ?
    { gs "mov %al,(%"  gs d gc ')' glf }
    { gs "mov %rax,(%" gs d gc ')' glf }
}

gexpr necl  = { e.q@ e c l }

gdrop (e E c N    ) none = { cast none gexpr e c 0 }
geval (e E c N l N) none = {
  gexpr e c l is l1
  l1 then
  l1 for l2
  (l2 == 1 and not l) ?
    { (e.t.q == &TFUNC) else gload e.t 0 "rax" "rax" }
    { gs "mov (%rax),%rax" glf }
  (l2 - 1)
}

gtpars(k @K o O t T c N g N) N = {
  !t ? { gdrop p4 k o c 0 }
    { scratch Expr nd
      scratch Scope o1
      (o1.s = o)
      (o1.k = t.k)
      (o1.e = &nd)
      (o1.is_type = 0)
      (nd.c  = -g)
      (nd.u   = t)
      gtpars k &o1 t.s c (g + 1) }
}
gtparr(k @K o O t T c N g N) N = {
  !t ? { gdrop p4 k o c 0 }
    { gpush &c argreg8 g
      scratch Expr nd
      scratch Scope o1
      (o1.s = o)
      (o1.k = t.k)
      (o1.is_type = 0)
      (o1.e = &nd)
      (nd.c = c)
      (nd.u  = t)
      (((g == 5) ? &gtpars &gtparr)@ k &o1 t.s c (g + 1) + 1) }
}

decls(k @K o O) none

typedecl(k @K o O) none = {
  consume k ";" ?
    decls k o
    { scratch Scope o1
      (o1.s = o)
      (o1.k = k@)
      (o1.is_type = 1)
      declarator k &o1 &o1.t
      typedecl k &o1 }
}

function(k @K o O) none = {
  consume k "export" is globl
  scratch T t
  declarator k o &t
  try_search_scope o t.k.p t.k.n is o1
  { o1 then
    (o1.is_type and diag "redeclared as a different type of symbol")
    (o1.is_def >= jeq k "=" and diag "remention") }
  scratch Scope o2
  (o2.s = o)
  (o2.k = t.k)
  (o2.t = t)
  (o2.e = 0)
  (o2.is_type = 0)
  (o2.is_def = jeq k "=")
  { o2.is_def then
    jadv k
    gs ".section .text." gsn t.k.p t.k.n glf
    { globl then gs ".globl" gc ' ' gsn t.k.p t.k.n glf }
    gsn t.k.p t.k.n gc ':' glf
    0 is c
    gfpop &c gtparr k &o2 t.a.s c 0
    gt0 "ret" }
  decls k &o2
}

decls(k @K o O) none = {
  k@ then
  (consume k "type" ? &typedecl &function)@ k o
}

export _start(argc N argv @S) N = {
  ibrk 0
  gt0 ".data"
  gt0 ".scurbrk:.quad 0"
  (1 << 20) is big
  cast @byte alloc big is p
  read p big is n
  (p^n = cast byte 0)
  cast K 0 is k
  &k is x
  { 1 for _
    p@ then
    (p^0 == '/' and p^1 == '*') ? {
      (p = &p^2)
      { 1 for _
        (p@ or diag "unclosed block comment")
        (p^0 == '*' and p^1 == '/') ?
          { (p = &p^2) 0 }
          { (p = &p^1)
            1 } } }
    isws p@ ? {
      (p = &p^1) }
    { is09 p@ ? {
        { &p^1 for q is09 q@ then &q^1 } is q
        (x@ = ntoken &JNUM p q)
        (p = q) }
      (p@ == '"') ? {
        { &p^1 for q
          (q^0 or diag "unclosed string literal")
          (q^0 == '\n' and diag "newline in string literal")
          (q^0 == '\\') ?
          { (q^1 or diag "unclosed string literal")
            (q^1 == '\n' and diag "newline in string literal")
            &q^2 }
          { (q^0 != '"') then
            &q^1 }
        } is end
        ntoken &JSTR p &end^1 is k
        gs ".s" gn cast nat k gc ':' gs ".string \""
        { &k.p^1 for i (i < &k.p^(k.n - 1)) then gc i@ &i^1 }
        gc '\"' glf
        (x@ = k)
        (p = &p^x.n) }
      (p@ == '\'') ? {
        p is p1
        (p^1 or diag "unclosed literal byte")
        { (p^1 == '\\') then
          (p = &p^1)
          (p^1 or diag "unclosed escape") }
        (p = &p^2)
        (p@ != '\'' and diag "expected '")
        (p = &p^1)
        (x@ = ntoken &JCHR p1 p) }
      { 0 is n
        { p for q { { isid q@ then &q^1 } else cast S 0 ret (n = q - p as N) } }
        !!n ?
            { (x@ = ntoken &JID p &p^n)
              (p = &p^n) }
          { read_punct p is n
            !!n ?
                { (x@ = ntoken &JPCT p &p^n)
                  (p = &p^n) }
                diag "invalid token" } }
      (x = &x.s) }
    1 }
  decls &k cast O 0
  exit 0
}


ge1     (e E c N l N gop @() none) N = {
  geval  e.a c 0
  gop@
  0
}

ge2     (e E c N l N gop @() none) N = {
  geval  e.a.s  c 0
  gpush        &c "rax"
  geval  e.a    c 0
  gpop         &c "rdi"
  gop@
  0
}

gegneg  () none = gtneg  "rax"
geglnot () none = glnot  "rax" "eax"
gegadd  () none = gadd   "rdi" "rax"
gegsub  () none = gsub   "rdi" "rax"
gegmul  () none = gmul   "rdi"

ebrace   ekok  = p5 k o
eparen   ekok  = p7 k o

genat    necl  = { gs "mov $" gsn e.k.p e.k.n gs ",%rax" glf 0 }
enat     ekok   = t0 k1 nnat  &genat

gebyte   necl  = { gs "mov $" gsn e.k.p ((e.k.p^1 == '\\') ? 3 2) gs ",%rax" glf 0 }
ebyte    ekok   = t0 k1 nbyte &gebyte

gesize   necl  = { gtlit e.u.size "rax" 0 }
esize    ekok   = tt k1 nnat &gesize ptype k o

gederef  necl  = (gexpr e.a c 0 + 1 - l)
ederef   ekoka  = t1 k1 a.t.a &gederef a

geaddr   necl  = gexpr e.a c 1
eaddr    ekok   = {
  p2 k o is a
  t1 k1 nptr a.t &geaddr a
}

gecast  necl  = {
  geval  e.a c 0
  gcast  e.a.t e.t
  0
}
eas      ekoka  = t1 k1 ptype k o &gecast a
ecast    ekok   = {
  ptype k o is u
  t1 k1 u &gecast p4 k o
}

gestr necl  = {
  gs "mov .s" gn cast nat e.k gs "@GOTPCREL(%rip),%rax" glf
  0
}
estr   ekok  = t0 k1 nptr nbyte &gestr

geid   necl  = {
  e.a ?
    (l or e.a.u.q == &TSTCT) ?
      { gaddr e.a.u (c - e.a.c << 3) "rsp" "rax" }
      { gload e.a.u (c - e.a.c << 3) "rsp" "rax" }
    { gs "mov " gsn e.t.k.p e.t.k.n gs "@GOTPCREL(%rip),%r" gs "ax" glf }
  0
}
eid    ekok  = {
  (search_scope k o k1.p k1.n) is s
  (s.is_type and diag "not a variable")
  cast E alloc sizeof Expr is e
  (e.s   = 0      )
  (e.q = &geid  )
  (e.k   = k      )
  s.e ? {
    (e.a = s.e    )
    (e.t = s.e.u  )
  }{(e.a = 0      )
    (e.t = s.t    ) }
  e
}

gelnot necl  = ge1 e c l &geglnot elnot ekok  = t1 k1 nnat &gelnot p3    k o   
geneg  necl  = ge1 e c l &gegneg  eneg  ekok  = t1 k1 nnat &geneg  p3    k o   
gediv  necl  = ge2 e c l &gdiv  ediv  ekoka = t2 k1 nnat &gediv  p4    k o a 
gemod  necl  = ge2 e c l &gmod  emod  ekoka = t2 k1 nnat &gemod  p4    k o a 
gee    necl  = ge2 e c l &ge    ee    ekoka = t2 k1 nnat &gee    psh   k o a 
gene   necl  = ge2 e c l &gne   ene   ekoka = t2 k1 nnat &gene   psh   k o a 
geae   necl  = ge2 e c l &gae   eae   ekoka = t2 k1 nnat &geae   psh   k o a 
gea    necl  = ge2 e c l &ga    ea    ekoka = t2 k1 nnat &gea    psh   k o a 
geb    necl  = ge2 e c l &gb    eb    ekoka = t2 k1 nnat &geb    psh   k o a 
gebe   necl  = ge2 e c l &gbe   ebe   ekoka = t2 k1 nnat &gebe   psh   k o a 
geadd  necl  = ge2 e c l &gegadd  eadd  ekoka = t2 k1 nnat &geadd  pmul  k o a 
gesub  necl  = ge2 e c l &gegsub  esub  ekoka = t2 k1 nnat &gesub  pmul  k o a 
gemul  necl  = ge2 e c l &gegmul  emul  ekoka = t2 k1 nnat &gemul  p4    k o a 
geshl  necl  = ge2 e c l &gshl  eshl  ekoka = t2 k1 nnat &geshl  padd  k o a 
geshr  necl  = ge2 e c l &gshr  eshr  ekoka = t2 k1 nnat &geshr  padd  k o a 

geelem necl   = {
  geval  e.a    c 0
  gpush        &c "rax"
  geval  e.a.s  c 0
  gpop         &c "rdx"
  gs  "lea (%rdx,%rax," gn  e.a.t.a.size gs  "),%rax" glf 
  (1 - l)
}
eelem  ekoka = t2 k1 a.t.a &geelem p3 k o a

gemem   necl  = {
  geval  e.a c 0
  { e.a.t for t
    (t.q == &TPTR) then
    t.a ret
    (t.a.q == &TSTCT) ?
      gaddr t.a 0 "rax" "rax"
      gload t.a 0 "rax" "rax" }
  gindex e.t.offset
  (1 - l)
}
emem  ekoka  = {
  jadv k
  { a.t for t (t.q == &TPTR) then t.a } is t
  (t.q != &TSTCT and diag "not a struct")
  cast T 0 is g
  { t.a for a
    { (a.k.n == k1.s.n) then strncmp a.k.p k1.s.p k1.s.n }
    ? { (g = a) cast T 0 }
      a.s }
  { !g then diag "no such member" }
  t1 k1.s g &gemem a
}

geseq  necl  = {
  gdrop  e.a   c
  geval  e.a.s c l
  0
}
eseq   ekoka  = {
  p5 k o is b
  t2 k1 b.t &geseq b a
}

geret necl  = {
  geval  e.a    c l
  gpush        &c "rax"
  gdrop  e.a.s  c
  gpop         &c "rax"
  0
}
eret  ekoka  = t2 k1 a.t &geret p5 k o a

gecond necl   = {
  geval   e.a     c 0
  gtcz              "rax"
  gje     e         "a"
  geval   e.a.s   c l
  gj      e         "b"
  glabel  e         "a"
  geval   e.a.s.s c l
  glabel  e         "b"
  0
}
econd  ekoka = {
  p4 k o is b
  t3 k1 b.t &gecond p4 k o b a
}

geland necl  = {
  (e.a.s.t.q == &TNONE) is keep
  geval  e.a c 0
  gtcz              "rax"
  gje    e          "a"
  { keep then
    gpush        &c "rax" }
  geval  e.a.s c 0
  { keep then
    gpop         &c "rax" }
  glabel  e         "a"
  0
}
ethen  ekoka  = {
  p5 k o is b
  t2 k1 b.t &geland b a
}
eland  ekoka  = {
  pcmp k o is b
  t2 k1 b.t &geland b a
}

gelor  necl  = {
  (e.a.s.t.q == &TNONE) is keep
  geval    e.a   c  0
  gtcz              "rax"
  gjne     e        "a"
  { keep then
    gpush        &c "rax" }
  geval    e.a.s  c 0
  { keep then
    gpop         &c "rax" }
  glabel   e        "a"
  0
}
eelse  ekoka  = t2 k1 a.t &gelor p5    k o a
elor   ekoka  = t2 k1 a.t &gelor pland k o a

gescratch necl = {
  (e.u.size + 7 >> 3) is d
  gfpush    &c d
  (e.c = c)
  geval e.a  c   l
  gfpop     &c d
  0
}
escratch  ekok   = {
  cast E alloc sizeof Expr is e
  (e.s   = 0         )
  (e.q   = &gescratch)
  (e.k   = k1        )
  (e.u   = ptype k o )
  scratch Scope o1
  (o1.s  = o         )
  (o1.k  = jadv k    )
  (o1.e  = e         )
  (o1.is_type = 0    )
  (e.a   = p5 k &o1  )
  (e.t   = e.a.t     )
  e
}

geis   necl = {
  (e.u.size + 7 >> 3) is d
  geval    e.a    c   0
  gfpush         &c d
  (e.c = c)
  gstore   e.u          "rsp"
  geval    e.a.s  c   l
  gfpop          &c d
  0
}
eis    ekoka = {
  cast E alloc sizeof Expr is e
  (e.s   = 0      )
  (e.q   = &geis  )
  (e.k   = k1     )
  (e.a   = a      )
  (e.u   = a.t    )
  scratch Scope o1
  (o1.s  = o      )
  (o1.k  = jadv k )
  (o1.e  = e      )
  (o1.is_type = 0 )
  (e.a.s = p5 k &o1)
  (e.t   = e.a.s.t)
  e
}

gefor  necl = {
  (e.u.size + 7 >> 3) is d
  geval     e.a    c   0
  gfpush          &c d
  (e.c = c)
  gstore    e.u          "rsp"
  gj        e            "b"
  glabel    e            "a"
  gstore    e.u          "rsp"
  glabel    e            "b"
  geval     e.a.s  c   0
  gtcz                   "rax"
  gjne      e            "a"
  gload     e.u      0   "rsp" "rax"
  gfpop           &c d
  0
}
efor   ekoka = {
  cast E alloc sizeof Expr is e
  (e.s   = 0      )
  (e.q   = &gefor )
  (e.k   = k1     )
  (e.a   = a      )
  (e.u   = a.t    )
  scratch Scope o1
  (o1.s  = o      )
  (o1.k  = jadv k )
  (o1.e  = e      )
  (o1.is_type = 0 )
  (e.a.s = p5 k &o1)
  (e.t   = e.a.s.t)
  e
}

geass  necl  = {
  geval   e.a    c 1
  gpush         &c   "rax"
  geval   e.a.s  c 0
  gpop          &c   "rdi"
  gstore  e.a.t      "rdi"
  gtz                "eax"
  0
}
eass   ekoka  = t2 k1 nnone &geass p7 k o a


gargs(e E c @N) none = {
  !!e then
  gargs e.s c
  geval e c@ 0
  gpush c "rax"
}
gecall necl  = {
  gargs e.a.s &c
  geval e.a    c 0
  0 is d
  { !!e.a.s then
    e.a.s for e (d < 6) then e.s ret
    gpop &c argreg8 d
    (d = d + 1) }
  gs "call *%rax" glf
  0
}
ecall ekoka = {
  a.t.a.s is u
  { a for b
    u then
    (b.s = p3 k o)
    { !type_equal b.s.t u then diag "asymmetric argument" }
    (u = u.s)
    b.s }
  t1 k@ a.t.a &gecall a
}

geexit necl = {
  geval e.a c 0
  gt2 "mov" "rax" "rdi"
  gtlit 60 "rax"
  gt0 "syscall"
  0
}
eexit  ekok  = t1 k1 nnone &geexit p3 k o

geibrk  necl = {
  geval e.a c 0
  gt0 "mov $0,%rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov %rax,.scurbrk"
  0
}
eibrk   ekok  = t1 k1 nnone &geibrk p3 k o

gebrk  necl = {
  geval e.a c 0
  gt0 "mov .scurbrk,%rdi"
  gt0 "add %rax,%rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov .scurbrk,%rax"
  gt0 "mov %rdi,.scurbrk"
  0
}
ebrk   ekok  = t1 k1 nnat &gebrk p3 k o

gegsys3 (n N a0 N e E c N) none = {
  geval e.a    c 0
  gpush       &c "rax"
  geval e.a.s  c 0
  gpop        &c "rsi"
  gt2 "mov" "rax" "rdx"
  gtlit a0 "rdi"
  gtlit n "rax"
  gt0 "syscall"
  0
}

geread  necl = gegsys3 0 0 e c
eread   ekok  = t2 k1 nnat &geread p3 k o p3 k o

gewrite necl = gegsys3 1 1 e c
ewrite  ekok  = t2 k1 nnat &gewrite p3 k o p3 k o

geerr   necl = gegsys3 1 2 e c
eerr    ekok  = t2 k1 nnat &geerr p3 k o p3 k o