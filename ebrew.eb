#
    LIB
#

# externals #

(word) ?
(peek -a) ? (poke -a a) ?
(load -a) ? (store -a a) ?

(neg n) ? (not n) ?
(add a b) ? (mul a b) ? (mod a b) ? (equal a b) ?
(sub a b) ? (div a b) ? (shl a b) ? (above a b) ?

(linux rdi rsi rdx rcx r8 r9 rax) ?

# math #

(range n a b) not or (above n a) (above b n)
(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)
(pow2 n) shl n 1
(successive n) add 1 n
(preceding n) sub 1 n
(inc -n) to -n add 1
(dec -n) to -n sub 1

# yes we have this #

(memcmp a b n)
or  not n
and equal (peek a) (peek b)
    memcmp (successive a) (successive b) (preceding n)

(strncmp a b an bn)
and equal an bn
    memcmp a b bn

(strlen s) and (peek s) (successive (strlen (successive s)))

# io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (equal i error-key)
let n-read (io i (sub i end))
and n-read
if  equal n-read error-key
    n-read
    add i n-read

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code out end)
do  retry-mem stdout out end
    exit code

(runtime (main (exit code out end) in out mem) inbuf outbuf membuf)
let in  (brk 0)
let out (add in  inbuf )
let mem (add out outbuf)
do  brk (add mem membuf)
do  store mem (add mem word)
do  retry-string-read stdin in out
    main runtime-exit in out mem

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# printing #

(vput-mem (put a -out) a b -out)
do  for i a
    and above i b
    let byte (peek i)
    do  put byte -out
        successive i
    -out

(vput-string (put a -out) s -out)
do  for p s
    let a (peek p)
    and a
    do  put a -out
        successive p
    -out

(put byte -out)
do  poke (load -out) byte
do  inc -out
    -out

(put-lf -out)
    put '\n -out

(put-digits (put-digit a -out) base a -out)
if  a
    put-digit                 (mod base a)
    put-digits put-digit base (div base a)
    -out
    -out

(put-number (put-digit a -out) base a -out)
if  a 
    put-digits put-digit base a -out
    put '0 -out

(put-digit-16 a -out) put (add a (if (above a 10) '0 '7)) -out
(put-digit-10 a -out) put (add a                  '0    ) -out

(put-dec a -out) put-number put-digit-10 10 a -out
(put-hex a -out) put-number put-digit-16 16 a -out

(put-string s -out) vput-string put s -out
(put-mem a b -out) vput-mem put a b -out

# scanning #

(lex (class byte) -in)
and class (peek load -in)
    inc -in

#
    X86_64 BACKEND
#

(x86_64-mangle (vput (put a -out) s -out) s -out) vput put-hex s put 'f -out
(x86_64-mangle-mem a b -out) vput-mem put-hex a b put 'f -out
(x86_64-mangle-string s -out) vput-string put-hex s put 'f -out

(x86_64-label-suf -out) put-lf put ': -out
(x86_64-section-header (vput a b -out) a b -out) x86_64-label-suf vput a b put-lf vput a b put-string ".section .text." -out
(x86_64-initdef name body -out) put-string "ret\n" put-lf put-string body x86_64-section-header x86_64-mangle-mem name (add name strlen name) -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put-string "add $" -out
do  and sign (put '- -out)
do  put-string ",%rsp\n" put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  put-lf put-string reg put-string sign -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  "pop "
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  "push "

(x86_64-put-label  flake -out) put-dec flake put-string "." -out

(x86_64-jc flake s -out) put-lf x86_64-put-label flake put-string s -out
(x86_64-czjc flake s -out) x86_64-jc flake s put-string "test %rax,%rax\n" -out

(X86_64-out   impl)            impl
(X86_64-depth impl) add (X86_64-out   impl) word
(X86_64)                 X86_64-depth       word

(x86_64-new -mem out)
let impl (to -mem add X86_64)
do  store (X86_64-out   impl) out
do  store (X86_64-depth impl) (shl (sub 1 (shl 3 word)) 1)
do  x86_64-initdef "linux" "mov 56(%rsp),%rdi\nmov 48(%rsp),%rsi\nmov 40(%rsp),%rdx\nmov 32(%rsp),%rcx\nmov 24(%rsp),%r8\nmov 16(%rsp),%r9\nmov 8(%rsp),%rax\nsyscall"
    x86_64-initdef "not"   "mov 8(%rsp),%rdi\ntest %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "neg"   "mov 8(%rsp),%rdi\nmov %rdi,%rax\nneg %rax"
    x86_64-initdef "equal" "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\ncmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "above" "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\ncmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-initdef "shl"   "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nmov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-initdef "mod"   "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nxor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-initdef "div"   "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nxor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-initdef "mul"   "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nmov %rsi,%rax\nmul %rdi"
    x86_64-initdef "sub"   "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nmov %rsi,%rax\nsub %rdi,%rax"
    x86_64-initdef "add"   "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nmov %rsi,%rax\nadd %rdi,%rax"
    x86_64-initdef "poke"  "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nmovb %sil,(%rdi)"
    x86_64-initdef "peek"  "mov 8(%rsp),%rdi\nmovzb (%rdi),%eax"
    x86_64-initdef "store" "mov 16(%rsp),%rdi\nmov 8(%rsp),%rsi\nmov %rsi,(%rdi)\nmov %rdi,%rax"
    x86_64-initdef "load"  "mov 8(%rsp),%rdi\nmov (%rdi),%rax"
    x86_64-initdef "word"  "mov $8,%rax"
    put-lf
let entry "_start"
    x86_64-mangle-string entry
    put ',
    put-string entry
    put-string "\n.equ "
    put-string entry
    put-string ".globl "
    (X86_64-out impl)
    impl

(x86_64-del -mem impl)
let out (load X86_64-out impl)
do  to -mem sub X86_64
    out

(x86_64-do  impl flake) 0

(x86_64-decl  impl flake) 0

(x86_64-and  impl flake) x86_64-czjc flake "je "  (X86_64-out impl)
(x86_64-or   impl flake) x86_64-czjc flake "jne " (X86_64-out impl)
(x86_64-else impl flake) x86_64-jc   flake "jmp " (X86_64-out impl)

# We are trying to reference
a function or variable. First,
we'll move the stack top into 
the accumulator.
#

(x86_64-ref impl)
    put-string "mov %rsp,%rax\n" (X86_64-out impl)

# As we encounter
lambda frames, we'll load
the capture pointer through
the accumulator. #

(x86_64-capture impl offset)
    put-string "(%rax),%rax\n"
    put-dec (shl 3 (sub (load X86_64-depth impl) offset))
    put-string "mov "
    (X86_64-out impl)

# If we find a declaration,
we'll either load it through
the accumulator or through
the program counter depending
whether it's global. We waste
any capture loads for a global
but we'll fix that when it
matters.#

(x86_64-ref-end impl a b offset)
do  put-string "mov " (X86_64-out impl)
    put-string ",%rax\n"
    if  offset
        put-string "(%rax)"
        put-dec (shl 3 (sub (load X86_64-depth impl) offset))
        (X86_64-out impl)
        put-string "@GOTPCREL(%rip)"
        x86_64-mangle-mem a b
        (X86_64-out impl)

(x86_64-lit impl a b label)
    put-string ",%rax\n"
    put-mem a b
    put-string "mov $"
    (X86_64-out impl)

(x86_64-str impl a b label)
    put-string "@GOTPCREL(%rip),%rax\n"
    x86_64-put-label label
    put-string "\n.previous\nmov "
    put-mem a b
    put-string ".string,"
    x86_64-label-suf
    x86_64-put-label label
    put-lf
    x86_64-put-label label
    put-string ".section .data."
    (X86_64-out impl)

(x86_64-label impl label) x86_64-label-suf x86_64-put-label label (X86_64-out impl)

(x86_64-var impl label)
do  x86_64-fpush (X86_64-depth impl) (X86_64-out impl) 1
    load (X86_64-depth impl)

(x86_64-var-in impl label)
do  x86_64-label impl label
    put-string "mov %rax,(%rsp)\n" (X86_64-out impl)

(x86_64-let-end impl flake)
    x86_64-fpop (X86_64-depth impl) (X86_64-out impl) 1

(x86_64-for-end impl flake)
do  x86_64-or impl flake
    x86_64-pop (X86_64-depth impl) (X86_64-out impl) "%rax"

(x86_64-trunk impl) x86_64-push (X86_64-depth impl) (X86_64-out impl) "%rax"

(x86_64-branch impl) x86_64-push (X86_64-depth impl) (X86_64-out impl) "%rax"

(x86_64-call impl arity)
do  put-string "(%rsp),%rax\ncall *%rax\n" put-dec (shl 3 arity) put-string "mov " (X86_64-out impl)
    x86_64-fpop (X86_64-depth impl) (X86_64-out impl) 1

(x86_64-def impl a b) x86_64-section-header x86_64-mangle-mem a b (X86_64-out impl)
(x86_64-def-end impl) put-string "ret\n" (X86_64-out impl)

(x86_64-param impl index) add (load X86_64-depth impl) successive index
(x86_64-arg impl) x86_64-fpop (X86_64-depth impl) (X86_64-out impl) 1

#
(x86_64-lambda impl label)
do  x86_64-label-suf
    x86_64-put-label label
    put-lf
    x86_64-put-label label
    put-string ".section .text."
    (X86_64-out impl)
    x86_64-push (X86_64-depth impl) (X86_64-out impl) "%rbx"

(x86_64-lambda-end impl label arity)
do  x86_64-fpop (X86_64-depth impl) (X86_64-out impl) 1
do  x86_64-fpop (X86_64-depth impl) (X86_64-out impl) (if above arity 6 arity 6)
do  put-lf
    put-string ".previous"
    put-string x86_64-str-ret (X86_64-out impl)
do  x86_64-to-rax
    put-string x86_64-str-rip
    x86_64-put-label label
    put-string "mov " (X86_64-out impl)
    x86_64-push (X86_64-depth load impl) (X86_64-out load impl) "%rax"
#

#
    OPERATIONAL SEMANTICS
#

# span #

(Span-begin span)                 span
(Span-end   span) add (Span-begin span) word
(Span)                 Span-end         word

(make-span -mem a b)
let span (to -mem add Span)
do  store (Span-begin span) a
do  store (Span-end span) b
    span

# list #

(List-elem list)                list
(List-rest list) add (List-elem list) word
(List)                List-rest       word

(push -mem elem rest)
let list (to -mem add List)
do  store (List-elem list) elem
do  store (List-rest list) rest
    list

(pop list) load List-rest list

(count list)
and list
    successive (count (load List-rest list))

(judge-list (judge-param type-a type-b) params-a params-b)
or  not or params-a params-b
and judge-param            (load List-elem params-a) (load List-elem params-b)
    judge-list judge-param (load List-rest params-a) (load List-rest params-b)

# type #

(Type-params type)                  type
(Type-kind   type) add (Type-params type) word
(Type)                  Type-kind         word

(judge-type (judge-param param-a param-b) type-a type-b)
or  equal type-a type-b
and type-a
and type-b
and equal (load Type-kind type-a) (load Type-kind type-b)
    judge-list judge-param (load Type-params type-a) (load Type-params type-b)

# param #

(Param-kind param)                 param
(Param-span param) add (Param-kind param) word
(Param-type param) add (Param-span param) word
(Param-impl param) add (Param-type param) word
(Param)                 Param-impl        word

(judge-param param-a param-b)
judge-type judge-param (load Param-type param-a) (load Param-type param-b)

# semantic context #

(Sem-mem   sem)                sem
(Sem-list  sem) add (Sem-mem   sem) word
(Sem-flake sem) add (Sem-list  sem) word
(Sem-type  sem) add (Sem-flake sem) word
(Sem-impl  sem) add (Sem-type  sem) word
(Sem)                Sem-impl       word

(type-unit sem) 0

(type-list sem list param) push (Sem-mem sem) param list

(type-func sem list)
let type (to (Sem-mem sem) add Type)
do  store (Type-kind type) 1
do  store (Type-params type) list
    type

(type-param sem span type impl)
let param (to (Sem-mem sem) add Param)
do  store (Param-kind param) 0
do  store (Param-span param) span
do  store (Param-type param) type
do  store (Param-impl param) impl
    param

(type-param-name sem a b type) type-param sem (make-span (Sem-mem sem) a b) type 0

(book sem list span-a type impl)
if  list
let span-b (load Param-span load List-elem list)
or  and span-b
    let a (load Span-begin span-a)
    let b (load Span-end span-a)
    let src-a (load Span-begin span-b)
    let src-b (load Span-end span-b)
    and strncmp src-a a (sub src-a src-b) (sub a b)
        error 2 "redefinition"
    book sem (pop list) span-a type impl
    load store (Sem-list sem) (push (Sem-mem sem) type-param sem span-a type impl (load Sem-list sem))

(reference impl list a b depth)
and list
let var (load List-elem list)
let span (load Param-span var)
if  span #zero in case of lambda token#
let src-a (load Span-begin span)
let src-b (load Span-end span)
if  strncmp src-a a (sub src-a src-b) (sub a b)
    var
    reference impl pop list a b depth
    #do lambda token stuff here#
let offset (load Param-impl var)
do  x86_64-capture impl offset
    reference impl pop list a b offset

(parameters (gen impl index) sem params)
and params
let param (load List-elem params)
let rest (load List-rest params)
let index (parameters gen sem rest)
let list (load Sem-list sem)
let span (load Param-span param)
let type (load Param-type param)
let impl (gen (load Sem-impl sem) index)
do  book sem list span type impl
    (successive index)

(parameters-end sem params)
and params
do  store (Sem-list sem) (pop (load Sem-list sem))
    parameters-end sem (load List-rest params)

(arguments (gen-arg impl) sem params)
and params
do  gen-arg (load Sem-impl sem)
    arguments gen-arg sem (load List-rest params)

(call (gen-call impl arity) (gen-arg impl) sem params)
do  gen-call (load Sem-impl sem) (count params)
do  arguments gen-arg sem params
    store (Sem-type sem) type-unit sem

# api #

(op-new (gen -mem out) -mem out)
let impl (gen -mem out)
let sem (to -mem add Sem)
do  store (Sem-mem   sem) (load -mem)
do  store (Sem-list  sem) 0
do  store (Sem-flake sem) 0
do  store (Sem-impl  sem) impl
    sem

(op-del (gen -mem impl) -mem -impl)
do  to -mem sub Sem
    (gen -mem (load -impl))

(op-flake sem) inc (Sem-flake sem)
(op-term params) load Param-type (load List-elem params)

(op-label (gen impl label) sem label) gen (load Sem-impl sem) label

(op-lit (gen-lit impl a b label) sem a b label)
do  gen-lit (load Sem-impl sem) a b label
do  store (Sem-type sem) type-unit sem
    0

(op-ref (gen-ref impl) (gen-ref-end impl a b offset) sem a b)
do  gen-ref (load Sem-impl sem)
let param (reference (load Sem-impl sem) (load Sem-list sem) a b (load X86_64-depth load Sem-impl sem))
if  not param
    error 1 "unknown reference"
let type (load Param-type param)
let impl (load Param-impl param)
do  gen-ref-end (load Sem-impl sem) a b impl
    store (Sem-type sem) type

(op-decl (gen-decl impl label) sem param)
let span (load Param-span param)
    book sem (load Sem-list sem) (make-span (Sem-mem sem) (load Span-begin span) (load Span-end span)) (load Param-type param) (gen-decl (load Sem-impl sem) 0)

(op-def (gen-def impl a b) (gen-param impl index) sem param)
let span (load Param-span param)
do  gen-def (load Sem-impl sem) (load Span-begin span) (load Span-end span)
    parameters gen-param sem (load Type-params (load Param-type param))

(op-def-end (gen-def-end impl) sem param)
do  parameters-end sem (load Type-params load Param-type param)
    gen-def-end (load Sem-impl sem)

(op-branch (gen-term impl) (gen-call impl params) (gen-arg impl) sem params rest)
do  gen-term (load Sem-impl sem)
or  (load List-rest rest)
do  call gen-call gen-arg sem params
    0

(op-trunk (gen-trunk impl) (gen-call impl params) (gen-arg impl) sem type)
let param (load Sem-type sem)
and not judge-type judge-param type param
let params (load Type-params param)
do  gen-trunk (load Sem-impl sem)
# we call on the parser's behalf when
it can't tell between scalar and nullary #
or  params
do  call gen-call gen-arg sem params
    0

# lies #

(op-var (gen impl label) sem label a b type)
    book sem (load Sem-list sem) (make-span (Sem-mem sem) a b) type (gen (load Sem-impl sem) label)

(op-var-in (gen impl label) sem label)
    gen (load Sem-impl sem) label

(op-var-end (gen impl label) sem label)
do  gen (load Sem-impl sem) label
    store (Sem-list sem) (pop (load Sem-list sem))

#
    DENOTATIONAL SEMANTICS

    NOT DETONATIONAL SATANICS
#

(denote-new -mem out) op-new x86_64-new -mem out
(denote-del -mem sem) op-del x86_64-del -mem (Sem-impl sem)

# truth #

(denote-nest sem) 0
(denote-nest-end sem) 0

(denote-flake sem) op-flake sem
(denote-term params) op-term params

(denote-decl sem param) op-decl x86_64-decl sem param

(denote-def sem param) op-def x86_64-def x86_64-param sem param
(denote-def-end sem param) op-def-end x86_64-def-end sem param

(denote-type-unit sem) type-unit sem
(denote-type-func sem params) type-func sem params
(denote-type-list sem params param) type-list sem params param
(denote-type-param sem a b type) type-param-name sem a b type

(denote-trunk sem type ) op-trunk x86_64-trunk x86_64-call x86_64-arg sem type
(denote-branch sem params rest) op-branch x86_64-branch x86_64-call x86_64-arg sem params rest

(denote-lit sem a b label) op-lit x86_64-lit sem a b label
(denote-str sem a b label) op-lit x86_64-str sem a b label
(denote-ref sem a b label) op-ref x86_64-ref x86_64-ref-end sem a b

# lies #

(denote-then  sem label) op-label x86_64-and   sem label
(denote-else  sem label) op-label x86_64-else  sem label
(denote-endif sem label) op-label x86_64-label sem label

# damn lies #

(denote-var sem label a b) op-var x86_64-var sem label a b (type-unit sem)

(denote-var-in  sem label) op-var-in  x86_64-var-in  sem label
(denote-for-end sem label) op-var-end x86_64-for-end sem label
(denote-let-end sem label) op-var-end x86_64-let-end sem label

(denote-do      sem label) op-label x86_64-do    sem label
(denote-do-end  sem label) op-label x86_64-label sem label
(denote-or      sem label) op-label x86_64-or    sem label
(denote-or-end  sem label) op-label x86_64-label sem label
(denote-and     sem label) op-label x86_64-and   sem label
(denote-and-end sem label) op-label x86_64-label sem label

#
    CLASSIFIER
#

(class-nz byte) byte

(negclass (class byte) byte)
and class-nz byte
    not class byte

(class-hm byte) equal byte '#
(class-bs byte) equal byte '\\
(class-sq byte) equal byte '\'
(class-dq byte) equal byte '\"
(class-qm byte) equal byte '?
(class-lp byte) equal byte '(
(class-rp byte) equal byte ')
(class-09 byte) range byte '0 '9

(class-ws byte) or  equal byte ' 
                or  equal byte '\t
                or  equal byte '\n
                    equal byte '\r
(class-id byte) or  range byte 'A 'Z
                or  range byte 'a 'z
                or  range byte '0 '9
                or  equal byte '-
                    equal byte '_
(class-im byte) or  range byte '0 '9
                    equal byte '\'
(class-pt byte) or  equal byte '(
                or  equal byte ')
                    equal byte '?

(class-sb byte) negclass class-dq byte
(class-cb byte) negclass class-hm byte

#
    LEXER
#

(esc (class byte) -in)
if  lex class-bs -in
    lex class-nz -in
    lex class    -in

(lex-hm -in) lex class-hm -in
(lex-dq -in) lex class-dq -in
(lex-sq -in) lex class-sq -in
(lex-09 -in) lex class-09 -in
(lex-pt -in) lex class-pt -in
(lex-ws -in) lex class-ws -in
(lex-id -in) esc class-id -in
(lex-sb -in) esc class-sb -in
(lex-cb -in) esc class-cb -in

#
    TOKENIZER
#

(bunch (each -in) -in) for _ 0 (each -in)
(prefix (delim -in) (each -in) -in) and (delim -in) (each -in)
(group (delim -in) (each -in) -in) and and (delim -in) (bunch each -in) (delim -in)

(token -in span)
do  for _ 0
    or  bunch  lex-ws        -in
        group  lex-hm lex-cb -in
let a load -in
do  or  bunch  lex-id        -in
    or         lex-pt        -in
    or  prefix lex-sq lex-sb -in
    or  group  lex-dq lex-sb -in
        bunch  lex-09        -in
let b load -in
do  store Span-begin span a
    store Span-end span b

#
    PARSER
#

# syntactic context #

(Syn-sem  syn)               syn
(Syn-in   syn) add (Syn-sem  syn) word
(Syn-span syn) add (Syn-in   syn) word
(Syn)               Syn-span      word

(parse-init -mem in out)
let syn (to -mem add Syn)
do  store (Syn-span syn) make-span -mem 0 0
do  store (Syn-in   syn) in
do  store (Syn-sem  syn) denote-new -mem out
do  token (Syn-in   syn) (load Syn-span syn)
    syn

(parse-del -mem syn)
let end (denote-del -mem (load Syn-sem syn))
do  to -mem sub Syn
    end

# abstract syntax #

(graft lit
    (branch
        (tree syn type)
        syn type label)
    (tree syn type)
    syn type)
let span (load Syn-span syn)
let a (load Span-begin span)
let b (load Span-end span)
and strncmp lit a (strlen lit) (sub a b)
do  token (Syn-in syn) span
let label 
    denote-flake (load Syn-sem syn)
do  branch tree syn type label
    1

(leaf
    (class byte)
    (denote syn a b label)
    syn)
let span (load Syn-span syn)
let a (load Span-begin span)
let b (load Span-end span)
and class (peek a)
do  token (Syn-in syn) span
let label 
    denote-flake (load Syn-sem syn)
do  denote (load Syn-sem syn) a b label
    1

(knot
    (class byte)
    syn)
let span (load Syn-span syn)
and class (peek (load Span-begin span))
do  token (Syn-in syn) span
    1

#
    EBREW
#

# expression syntax #

# damn lies #

(stem-seq (denote syn label) (denote-end syn label) (tree syn type) syn type label)
let sem (load Syn-sem syn)
do  tree syn type
do  denote sem label
do  tree syn type
    denote-end sem label

(stem-do  (tree syn type) syn type label) stem-seq denote-do  denote-do-end  tree syn type label
(stem-or  (tree syn type) syn type label) stem-seq denote-or  denote-or-end  tree syn type label
(stem-and (tree syn type) syn type label) stem-seq denote-and denote-and-end tree syn type label

(stem-var (denote-end syn flake) (tree syn type) syn type label)
let sem (load Syn-sem syn)
let span (load Syn-span syn)
let a (load Span-begin span)
let b (load Span-end span)
if  not knot class-id syn
    error 3 "missing id"
do  tree syn (denote-type-unit (load Syn-sem syn))
do  denote-var sem label a b
do  denote-var-in sem label
do  tree syn type
    denote-end sem label

(stem-let (tree syn type) syn type label) stem-var denote-let-end tree syn type label
(stem-for (tree syn type) syn type label) stem-var denote-for-end tree syn type label

# a lie #

(stem-if (tree syn type) syn type label)
let sem (load Syn-sem syn)
do  tree syn (denote-type-unit (load Syn-sem syn))
do  denote-then sem label
do  tree syn type
let label-else 
    denote-flake sem
do  denote-else sem label-else
do  denote-endif sem label
do  tree syn type
    denote-endif sem label-else

#
if we are expecting a function:
    push a closure parameter onto the list:
        the closure parameter says where the
        capture pointer is in each frame. we
        use that to a) find the capture pointer
        in the lambda frame, then b) find
        closed variables in the captured frame.
    start a lambda section.
    compile the lambda
    .previous
    pop the closure token
otherwise:
    just branch
#

#if  (and type (load Type-kind type))
let sem (load Syn-sem syn)
let label (op-flake sem)
let capture (x86_64-lambda (load Sem-impl sem) label)
let var (to (Sem-mem sem) add struct-Var)
do  store (Param-span var) 0
do  store (Param-type var) frame
do  store (Param-impl var) capture
do  store (Sem-list sem) push (Sem-mem sem) var (load Sem-list sem)
let params (load Type-params type)
do  parameters tree syn params 0
do  tree syn 0
do  x86_64-lambda-end (load Sem-impl sem) label (count load Type-params type)
do  store (Sem-list sem) pop (load Sem-list sem)
let rest 
    denote-branch (load Syn-sem syn) params index
    branches tree syn rest (successive index)#

# truth #

(branches (tree syn type) syn list rest)
and rest
do  tree syn (denote-term rest)
    branches tree syn list (denote-branch (load Syn-sem syn) list rest)

(trunk (tree syn type) syn type)
let list denote-trunk (load Syn-sem syn) type
and list
do  branches tree syn list list
    trunk tree syn type

(stem (tree syn type) syn type)
# lies #
or  graft "do"  stem-do  tree syn type
or  graft "if"  stem-if  tree syn type
or  graft "or"  stem-or  tree syn type
or  graft "and" stem-and tree syn type
or  graft "let" stem-let tree syn type
or  graft "for" stem-for tree syn type
# truth #
or  leaf class-im denote-lit syn
or  leaf class-id denote-ref syn
or  leaf class-dq denote-str syn
    error 4 "missing stem"

(nest (tree syn type) syn type)
if  knot class-lp syn
do  denote-nest (load Syn-sem syn)
do  nest tree syn type
do  denote-nest-end (load Syn-sem syn)
or  knot class-rp syn
    error 5 "missing paren"
do  stem tree syn type
    trunk tree syn type

(tree syn type) nest tree syn type

# type syntax #

# badly written and buggy #

(typedecl (den sem a b type) (typename-which (parameter syn) syn) (parameter syn) syn)
let span (load Syn-span syn)
let a (load Span-begin span)
let b (load Span-end span)
and knot class-id syn
    den (load Syn-sem syn) a b (typename-which parameter syn)

(typename-params (parameter syn) syn)
and not knot class-rp syn
let x (parameter syn)
    denote-type-list (load Syn-sem syn) (typename-params parameter syn) x 

(typename-func (parameter syn) syn) denote-type-func (load Syn-sem syn) (typename-params parameter syn)
(typename-unit (parameter syn) syn) denote-type-unit (load Syn-sem syn)

(parameter syn) typedecl denote-type-param (if (knot class-lp syn) typename-func typename-unit) parameter syn

# declaration syntax #

(decl syn)
let param (parameter syn)
and param
do  denote-decl (load Syn-sem syn) param
or  knot class-qm syn
do  denote-def (load Syn-sem syn) param
do  tree syn 0
    denote-def-end (load Syn-sem syn) param

#
    ENTRY
#

(main (return code out end) in out -mem)
let syn (parse-init -mem in out)
do  for _ 0 decl syn
let end (parse-del -mem syn)
    return 0 out end

# set memory layout config here #

(_start) runtime main (pow2 15) (pow2 18) (pow2 17)
