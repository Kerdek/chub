# externals #

(word) ?
(peek -a) ? (poke -a a) ?
(load -a) ? (store -a a) ?

(neg n) ? (not n) ?
(add a b) ? (mul a b) ? (mod a b) ? (equal a b) ?
(sub a b) ? (div a b) ? (shl a b) ? (above a b) ?

(linux rdi rsi rdx rcx r8 r9 rax) ?

# math #

(cmpex n a b) or (above n a) (above b n)
(range n a b) not (cmpex n a b)
(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)
(pow2 n) shl n 1
(suc n) add 1 n
(prd n) sub 1 n
(inc -n) to -n add 1
(dec -n) to -n sub 1

# yes we have this #

(strlen s) and (peek s) (suc (strlen (suc s)))

# io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (equal i error-key)
let n-rest (sub i end)
let n-read (io i n-rest)
and n-read
if  equal n-read error-key
    n-read
    add i n-read

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code out end)
do  retry-mem stdout out end
    exit code

(runtime (main (exit code out end) in out mem) inbuf outbuf membuf)
let in  (brk 0)
let out (add in  inbuf )
let mem (add out outbuf)
do  brk (add mem membuf)
do  store mem (add mem word)
do  retry-string-read stdin in out
    main runtime-exit in out mem

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# printing #

(vput-mem (put a -out) a b -out)
do  for i a
    and above i b
    let byte (peek i)
    do  put byte -out
        suc i
    -out

(vput-string (put a -out) s -out)
do  for p s
    let a (peek p)
    and a
    do  put a -out
        suc p
    -out

(put byte -out)
let out (load -out)
do  poke out byte
do  inc -out
    -out

(putlf -out)
    put '\n -out

(put-digits (put-digit a -out) base a -out)
if  a
let remainder (mod base a)
let digit (div base a)
    put-digit                 remainder
    put-digits put-digit base digit
    -out
    -out

(put-number (put-digit a -out) base a -out)
if  a 
    put-digits put-digit base a -out
    put '0 -out

(put-digit-16 a -out) put (add a (if (above a 10) '0 '7)) -out
(put-digit-10 a -out) put (add a                 '0    ) -out

(put-dec a -out) put-number put-digit-10 10 a -out
(put-hex a -out) put-number put-digit-16 16 a -out

(put-string s -out) vput-string put s -out
(put-mem a b -out) vput-mem put a b -out

# x86_64 implementation #

(x86_64-str-mov  ) "mov "
(x86_64-str-ret  ) "ret\n"
(x86_64-str-entry) "_start"
(x86_64-str-rip  ) "@GOTPCREL(%rip)"
(x86_64-str-rsp  ) "(%rsp)"
(x86_64-str-rax  ) "%rax"
(x86_64-str-rdi  ) "%rdi"
(x86_64-str-rsi  ) "%rsi"
(x86_64-str-rdx  ) "%rdx"
(x86_64-str-rcx  ) "%rcx"
(x86_64-str-r8   ) "%r8"
(x86_64-str-r9   ) "%r9"

(x86_64-mangle (vput (put a -out) s -out) s -out)
    vput put-hex s put 'f -out

(x86_64-mangle-mem a b -out)
    vput-mem put-hex a b put 'f -out

(x86_64-mangle-string s -out)
    vput-string put-hex s put 'f -out

(x86_64-label-suf -out)
    putlf put ': -out

(x86_64-section-header (vput a b -out) a b -out)
    x86_64-label-suf vput a b putlf vput a b put-string ".section .text." -out

(x86_64-initdef name body -out)
    put-string x86_64-str-ret
    putlf
    put-string body
    x86_64-section-header x86_64-mangle-mem name (add name strlen name)
    -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put-string "add $" -out
do  and sign (put '- -out)
do  put-string ",%rsp\n" put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  putlf put-string reg put-string sign -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  "pop "
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  "push "

(x86_64-label-id flake -out)
    put '$
    put-dec flake
    put '.
    -out

(x86_64-str-label flake -out)
    put-dec flake
    put-string ".s"
    -out

(x86_64-to-rax -out)
    putlf
    put-string
    x86_64-str-rax
    put ',
    -out

(x86_64-from-rax -out)
    put ',
    put-string x86_64-str-rax
    -out

(x86_64-jc flake s -out)
    putlf x86_64-label-id flake put-string s
    -out

(x86_64-czjc flake s -out)
    x86_64-jc flake s
    x86_64-to-rax
    put-string x86_64-str-rax
    put-string "test "
    -out

(x86_64-argreg index)
if  equal index 0 x86_64-str-rdi
if  equal index 1 x86_64-str-rsi
if  equal index 2 x86_64-str-rdx
if  equal index 3 x86_64-str-rcx
if  equal index 4 x86_64-str-r8
                 x86_64-str-r9

(x86_64-argpop index arity -depth reg -out)
do  and above index arity
    x86_64-pop -depth -out reg
    -out

(Out   impl)            impl
(Depth impl) add (Out   impl) word
(Flake impl) add (Depth impl) word
(X86_64    )      Flake       word

(x86_64-new -mem out)
let impl (to -mem add X86_64)
do  store (Out   impl) out
do  store (Depth impl) (shl (sub 1 (shl 3 word)) 1)
do  store (Flake impl) 0
do  x86_64-initdef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-initdef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-initdef "equal" "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "above" "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-initdef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-initdef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-initdef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-initdef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-initdef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-initdef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-initdef "poke"  "movb %sil,(%rdi)"
    x86_64-initdef "peek"  "movzb (%rdi),%eax"
    x86_64-initdef "store" "mov %rsi,(%rdi)\nmov %rdi,%rax"
    x86_64-initdef "load"  "mov (%rdi),%rax"
    x86_64-initdef "word"  "mov $8,%rax"
    putlf
    x86_64-mangle-string  x86_64-str-entry
    put ',
    put-string x86_64-str-entry
    put-string "\n.equ "
    put-string x86_64-str-entry
    put-string ".globl "
    (Out impl)
    impl

(x86_64-del -mem impl)
let out (load Out impl)
do  to -mem sub X86_64
    out

(x86_64-flake impl)
    inc (Flake impl)

(x86_64-do  impl flake) 0

(x86_64-je  impl flake)
    x86_64-czjc flake "je "  (Out impl)

(x86_64-jne impl flake)
    x86_64-czjc flake "jne " (Out impl)

(x86_64-jmp impl flake)
    x86_64-jc   flake "jmp " (Out impl)

(x86_64-ref impl a b offset)
do  put-string x86_64-str-mov (Out impl)
    x86_64-to-rax
    if  offset
        put-string x86_64-str-rsp
        put-dec (shl 3 (sub load (Depth impl) offset))
        (Out impl)
        put-string x86_64-str-rip
        x86_64-mangle-mem a b
        (Out impl)

(x86_64-lit impl a b)
    x86_64-to-rax
    put-mem a b
    put '$
    put-string x86_64-str-mov
    (Out impl)

(x86_64-str impl a b)
let flake (x86_64-flake impl)
    x86_64-to-rax
    put-string x86_64-str-rip
    x86_64-str-label flake
    put-string x86_64-str-mov
    put-string ".previous\n"
    putlf
    put-mem a b
    put-string ".string,"
    x86_64-label-suf
    x86_64-str-label flake
    putlf
    x86_64-str-label flake
    put-string ".section .data."
    (Out impl)

(x86_64-label impl flake)
    x86_64-label-suf
    x86_64-label-id flake
    (Out impl)

(x86_64-var-is impl flake)
do  x86_64-fpush (Depth impl) (Out impl) 1
    load (Depth impl)

(x86_64-var-in impl flake)
do  x86_64-label impl flake
    putlf
    put-string x86_64-str-rsp
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-let-end impl flake)
    x86_64-fpop (Depth impl) (Out impl) 1

(x86_64-for-end impl flake)
do  x86_64-jne impl flake
    x86_64-pop (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-with impl arity)
do  x86_64-fpush (Depth impl) (Out impl) arity
    x86_64-push  (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-arg impl index)
    putlf
    put-string x86_64-str-rsp
    put-dec (shl 3 (suc index))
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-call-end impl arity)
do  x86_64-pop (Depth impl) (Out impl) x86_64-str-rax
do  putlf
    put-string x86_64-str-rax
    put '*
    put-string "call "
    x86_64-argpop 5 arity (Depth impl) x86_64-str-r9
    x86_64-argpop 4 arity (Depth impl) x86_64-str-r8
    x86_64-argpop 3 arity (Depth impl) x86_64-str-rcx
    x86_64-argpop 2 arity (Depth impl) x86_64-str-rdx
    x86_64-argpop 1 arity (Depth impl) x86_64-str-rsi
    x86_64-argpop 0 arity (Depth impl) x86_64-str-rdi
	(Out impl)
and above 6 arity
    x86_64-fpop (Depth impl) (Out impl) (sub 6 arity)

(x86_64-decl-in impl a b)
    x86_64-section-header x86_64-mangle-mem a b (Out impl)
    
(x86_64-decl impl label) 0

(x86_64-decl-param impl index)
if  above index 6
do  x86_64-push (Depth impl) (Out impl) (x86_64-argreg index)
    load (Depth impl)
    sub 5 index

(x86_64-decl-end impl arity)
do  x86_64-fpop (Depth impl) (Out impl) (if above arity 6 arity 6)
    put-string x86_64-str-ret (Out impl)

# tree #

(dword) add word word

(A node)     node
(B node) add node word

(qual -mem a)
let x (to -mem add word)
let -a (A x)
do  store -a a
    x

(node -mem a b)
let x (to -mem add dword)
let -a (A x)
let -b (B x)
do  store -a a
do  store -b b
    x

# operational semantics #

(memcmp a b n)
or  not n
let a-byte (peek a)
let b-byte (peek b)
and equal a-byte b-byte
let a-next (suc a)
let b-next (suc b)
let n-remaining (prd n)
    memcmp a-next b-next n-remaining

(strncmp a b an bn)
and equal an bn
    memcmp a b bn

(lookup book a b)
and book
let decl (load A #decl# book)
let span (load A #span# decl)
let src-a (load A #a# span)
let src-b (load B #b# span)
let n-src (sub src-a src-b)
let n (sub a b)
if  strncmp src-a a n-src n
    load B #type# decl
let rest (load B #book# book)
    lookup rest a b

(book-equal (op-check type-a type-b) book-a book-b)
or  equal book-a book-b
let decl-a (load A #decl# book-a)
let decl-b (load A #decl# book-b)
let type-a (load B #type# decl-a)
let type-b (load B #type# decl-b)
and op-check type-a type-b
let rest-a (load B #book# book-a)
let rest-b (load B #book# book-b)
    book-equal op-check rest-a rest-b

(op-check type-a type-b)
or  equal type-a type-b
and type-a
and type-b
let kind-a (load B #kind# type-a)
let kind-b (load B #kind# type-b)
and equal kind-a kind-b
let book-a (load A #book# type-a)
let book-b (load A #book# type-b)
    book-equal op-check book-a book-b

(op-count book)
and book
let rest (load B #book# book)
let n-rest (op-count rest)
    suc n-rest

(Mem  sem)           sem
(Book sem) add (Mem  sem) word
(Impl sem) add (Book sem) word
(Type sem) add (Impl sem) word
(struct-Sem)    Type      word

(op-type-func sem book)
    node #type# (Mem sem) book 1

(op-type-unit) 0

(op-new (gen -mem out) -mem out)
let impl (gen -mem out)
let sem (to -mem add struct-Sem)
do  store (Mem sem) (load -mem)
do  store (Book sem) 0
do  store (Impl sem) impl
    sem

(op-del (gen -mem impl) -mem -impl)
let impl (load -impl)
let out (gen -mem impl)
do  to -mem sub struct-Sem
    out

(op-unit (gen impl a b) sem a b)
let impl (load Impl sem)
do  gen impl a b
do  store (Type sem) op-type-unit
    0

(op-flake (gen impl) sem)
let impl (load Impl sem)
    gen impl

(op-label (gen impl flake) sem flake)
let impl (load Impl sem)
    gen impl flake

(op-ref (gen impl a b offset) sem a b)
let book (load Book sem)
let var (lookup book a b)
if  not var
    error 1 "unknown reference"
let impl (load Impl sem)
let offset (load B #offset# var)
do  gen impl a b offset
do  store (Type sem) (load A #type# var)
    load A #type# var

(op-var (gen impl label) sem label a b result)
let book (load Book sem)
if  lookup book a b
    error 2 "redefinition"
let -mem (Mem sem)
let span (node #span# -mem a b)
let impl (load Impl sem)
let offset (gen impl label)
let var (node #var# -mem result offset)
let name (node #name# -mem span var)
let next (node #book# -mem name book)
let -book (Book sem)
    store -book next

(op-var-end (gen impl flake) sem flake)
let impl (load Impl sem)
do  gen impl flake
let -book (Book sem)
let book (load -book)
let rest (load B #book# book)
    store -book rest

(op-call (gen impl arity) sem)
let type (load Type sem)
let book (load A type)
let impl (load Impl sem)
let arity (op-count book)
do  gen impl arity
    book

(op-arg sem book)
let decl (load A book)
let type (load B decl)
    type

(op-arg-end (gen impl index) sem index book)
let impl (load Impl sem)
do  gen impl index
let rest (load B book)
    rest

(op-call-end (gen impl arity) sem arity)
let impl (load Impl sem)
do  gen impl arity
do  store (Type sem) op-type-unit
    0

(op-decl (gen impl flake) sem a b type)
let impl (load Impl sem)
do  gen impl 0
let span (node #span# (Mem sem) a b)
    node #name# (Mem sem) span type

(op-param (gen impl flake) sem name book)
let impl (load Impl sem)
do  gen impl 0
    node #book# (Mem sem) name book

# denotational semantics #

(denote-new -mem out) op-new x86_64-new -mem out
(denote-del -mem sem) op-del x86_64-del -mem (Impl sem)

(denote-lit        sem       a b          ) op-unit      x86_64-lit        sem a b
(denote-str        sem       a b          ) op-unit      x86_64-str        sem a b
(denote-ref        sem       a b          ) op-ref       x86_64-ref        sem a b
(denote-do         sem                    ) op-flake     x86_64-flake      sem
(denote-do-then    sem label              ) op-label     x86_64-do         sem label
(denote-do-end     sem label              ) op-label     x86_64-label      sem label
(denote-if         sem                    ) op-flake     x86_64-flake      sem
(denote-if-then    sem label              ) op-label     x86_64-je         sem label
(denote-if-else    sem label              ) op-label     x86_64-jmp        sem label
(denote-if-end     sem label              ) op-label     x86_64-label      sem label
(denote-or         sem                    ) op-flake     x86_64-flake      sem
(denote-or-else    sem label              ) op-label     x86_64-jne        sem label
(denote-or-end     sem label              ) op-label     x86_64-label      sem label
(denote-and        sem                    ) op-flake     x86_64-flake      sem
(denote-and-then   sem label              ) op-label     x86_64-je         sem label
(denote-and-end    sem label              ) op-label     x86_64-label      sem label
(denote-let        sem                    ) op-flake     x86_64-flake      sem 
(denote-let-is     sem label a b expect   ) do op-var       x86_64-var-is     sem label a b 0 op-type-unit
(denote-let-in     sem label              ) op-label     x86_64-var-in     sem label
(denote-let-end    sem label              ) op-var-end   x86_64-let-end    sem label
(denote-for        sem                    ) op-flake     x86_64-flake      sem
(denote-for-is     sem label a b expect   ) do op-var       x86_64-var-is     sem label a b 0 expect
(denote-for-in     sem label              ) op-label     x86_64-var-in     sem label
(denote-for-end    sem label              ) op-var-end   x86_64-for-end    sem label
(denote-check      sem       expect       ) op-check                           expect (load Type sem)
(denote-call       sem                    ) op-call      x86_64-call-with  sem
(denote-call-end   sem arity              ) op-call-end  x86_64-call-end   sem arity
(denote-arg        sem       book         ) op-arg                         sem book
(denote-arg-end    sem index book         ) op-arg-end   x86_64-call-arg   sem index book
(denote-param      sem index a b    result) op-var       x86_64-decl-param sem index a b result
(denote-param-end  sem label              ) op-var-end   x86_64-do         sem label
(denote-decl       sem       a b    result) op-decl      x86_64-do         sem a b result
(denote-type-func  sem       book         ) op-type-func                   sem book
(denote-type-unit  sem                    ) op-type-unit
(denote-type-param sem decl  book         ) op-param     x86_64-do         sem decl book
(denote-body       sem       a b    result) op-var       x86_64-decl       sem 0 a b result
(denote-body-in    sem       a b    result)              x86_64-decl-in    (load Impl sem) a b
(denote-body-end   sem       a b    result)              x86_64-decl-end   (load Impl sem) op-count (load result)

# character classes #

(class-nz byte) byte

(negclass (class byte) byte)
and class-nz byte
    not class byte

(class-hm byte) equal byte '#
(class-bs byte) equal byte '\\
(class-sq byte) equal byte '\'
(class-dq byte) equal byte '\"
(class-qm byte) equal byte '?
(class-lp byte) equal byte '(
(class-rp byte) equal byte ')
(class-09 byte) range byte '0 '9

(class-ws byte) or  equal byte ' 
                or  equal byte '\t
                or  equal byte '\n
                    equal byte '\r
(class-id byte) or  range byte 'A 'Z
                or  range byte 'a 'z
                or  range byte '0 '9
                or  equal byte '-
                    equal byte '_
(class-im byte) or  range byte '0 '9
                    equal byte '\'
(class-pt byte) or  equal byte '(
                or  equal byte ')
                    equal byte '?

(class-sb byte) negclass class-dq byte
(class-cb byte) negclass class-hm byte

# lexer #

(lex-one (class byte) -in)
let in (load -in)
let byte (peek in)
and class byte
    inc -in

(lex-esc (class byte) -in)
if  lex-one class-bs -in
    lex-one class-nz -in
    lex-one class    -in

(lex-hm -in) lex-one class-hm -in
(lex-dq -in) lex-one class-dq -in
(lex-sq -in) lex-one class-sq -in
(lex-09 -in) lex-one class-09 -in
(lex-pt -in) lex-one class-pt -in
(lex-ws -in) lex-one class-ws -in
(lex-id -in) lex-esc class-id -in
(lex-sb -in) lex-esc class-sb -in
(lex-cb -in) lex-esc class-cb -in

# tokenizer #

(bunch (body -in) -in) 
for _ 0
    body -in

(prefix (delim -in) (body -in) -in)
and delim -in
    body  -in

(group (delim -in) (body -in) -in)
and delim -in
do  bunch body -in
    delim -in

# parser #

(token -in span)
do  for _ 0
    or  bunch  lex-ws        -in
        group  lex-hm lex-cb -in
let a (load -in)
do  or  bunch  lex-id        -in
    or         lex-pt        -in
    or  prefix lex-sq lex-sb -in
    or  group  lex-dq lex-sb -in
        bunch  lex-09        -in
let b (load -in)
do  store (A span) a
    store (B span) b

(Sem    syn)             syn
(In     syn) add (Sem    syn) word
(Span   syn) add (In     syn) word
(struct-Syn)      Span        word

(parse-init -mem in out)
let syn (to -mem add struct-Syn)
do  store (Span syn) node #span# -mem 0 0
do  store (In syn) in
do  store (Sem syn) denote-new -mem out
let span (load Span syn)
do  token (In syn) span
    syn

(parse-del -mem syn)
let sem (load Sem syn)
let end (denote-del -mem sem)
do  to -mem sub struct-Syn
    end

(stem lit (syntax-with (expr syn expect) syn expect) (expr syn expect) syn expect)
let span (load Span syn)
let a (load A span)
let b (load B span)
let n (sub a b)
let n-lit (strlen lit)
and strncmp lit a n-lit n
let -in (In syn)
do  token -in span
do  syntax-with expr syn expect
    1

(leaf (class byte) (op syn a b) syn)
let span (load Span syn)
let a (load A span)
let b (load B span)
let byte (peek a)
and class byte
let -in (In syn)
do  token -in span
let sem (load Sem syn)
do  op sem a b
    1

(punct syn (class byte))
let span (load Span syn)
let a (load A span)
let byte (peek a)
and class byte
    token (In syn) span

# expression syntax #

(expr-seq (den syn) (denote-then syn flake) (denote-end syn flake) (expr syn expect) syn expect)
let sem (load Sem syn)
let flake (den sem)
do  expr syn expect
do  denote-then sem flake
do  expr syn expect
    denote-end sem flake

(expr-do  (expr syn expect) syn expect) expr-seq denote-do  denote-do-then  denote-do-end  expr syn expect
(expr-or  (expr syn expect) syn expect) expr-seq denote-or  denote-or-else  denote-or-end  expr syn expect
(expr-and (expr syn expect) syn expect) expr-seq denote-and denote-and-then denote-and-end expr syn expect

(expr-var (den syn) (denote-is syn flake a b expect) (denote-in syn flake) (denote-end syn flake) (expr syn expect) syn expect)
let sem (load Sem syn)
let flake (den sem)
let span (load Span syn)
let a (load A span)
let b (load B span)
do  punct syn class-id
let expect-in (denote-is sem flake a b expect)
do  expr syn expect-in
do  denote-in sem flake
do  expr syn expect
    denote-end sem flake

(expr-let (expr syn expect) syn expect) expr-var denote-let denote-let-is denote-let-in denote-let-end expr syn expect
(expr-for (expr syn expect) syn expect) expr-var denote-for denote-for-is denote-for-in denote-for-end expr syn expect

(expr-if (expr syn expect) syn expect)
let sem (load Sem syn)
let flake-a (denote-if sem)
let expect-then (denote-type-unit sem)
do  expr syn expect-then
do  denote-if-then sem flake-a
do  expr syn expect
let flake-b (denote-if sem)
do  denote-if-else sem flake-b
do  denote-if-end sem flake-a
do  expr syn expect
    denote-if-end sem flake-b

(args (expr syn expect) syn book index)
if  book
let sem (load Sem syn)
let expect (denote-arg sem book)
do  expr syn expect
let rest (denote-arg-end sem index book)
    args expr syn rest (suc index)
    index

(call (expr syn expect) syn expect)
or  stem "do"  expr-do  expr syn expect
or  stem "if"  expr-if  expr syn expect
or  stem "or"  expr-or  expr syn expect
or  stem "and" expr-and expr syn expect
or  stem "let" expr-let expr syn expect
or  stem "for" expr-for expr syn expect
do  or  leaf class-im denote-lit syn
    or  leaf class-id denote-ref syn
    or  leaf class-dq denote-str syn
        error 3 "expected term"
let sem (load Sem syn)
or  denote-check sem expect
let parameters (denote-call sem)
# we shouldn't have to keep track of arity #
let arity (args expr syn parameters 0)
do  denote-call-end sem arity
or  denote-check sem expect
    error 4 "illegal argument"

(expr syn expect)
if  punct syn class-lp
do  call expr syn expect
or  punct syn class-rp
    error 5 "expected )"
    call expr syn expect

# type syntax #

(syntax-decl (den sem a b type) (syntax-type-which (syntax-type syn) syn) (syntax-type syn) syn)
let span (load Span syn)
let a (load A span)
let b (load B span)
and punct syn class-id
let sem (load Sem syn)
let type (syntax-type-which syntax-type syn)
    den sem a b type

(syntax-type-params (syntax-type syn) syn)
and not punct syn class-rp
let sem (load Sem syn)
let decl (syntax-type syn)
let rest (syntax-type-params syntax-type syn)
    denote-type-param sem decl rest

(syntax-type-func (syntax-type syn) syn) denote-type-func (load Sem syn) (syntax-type-params syntax-type syn)
(syntax-type-unit (syntax-type syn) syn) denote-type-unit (load Sem syn)

(syntax-type syn) syntax-decl denote-decl (if (punct syn class-lp) syntax-type-func syntax-type-unit) syntax-type syn

# declaration syntax #

(param syn book index)
if  book
let decl (load A #decl# book)
let sem (load Sem syn)
let span (load A #span# decl)
let result (load B #type# decl)
let a (load A span)
let b (load B span)
let offset (denote-param sem index a b result)
let rest (load B #book# book)
let next-index (suc index)
do  param syn rest next-index
    denote-param-end sem offset
    expr syn 0

(body syn)
let decl (syntax-type syn)
    and decl
    let sem (load Sem syn)
    let span (load A #span# decl)
    let a (load A span)
    let b (load B span)
    let result (load B #result# decl)
    let book (load result)
    do  denote-body sem a b result
    or  punct syn class-qm
    do  denote-body-in sem a b result
    do  param syn book 0
        denote-body-end sem a b result

# entry #

(main (return code out end) in out -mem)
let syn (parse-init -mem in out)
do  for _ 0 body syn
let end (parse-del -mem syn)
    return 0 out end

(_start) runtime main (pow2 15) (pow2 18) (pow2 17)