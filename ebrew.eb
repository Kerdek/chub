load  (a  ) ?
store (a b) ?
peek  (a  ) ?
poke  (a b) ?
add   (a b) ?
sub   (a b) ?
mul   (a b) ?
div   (a b) ?
mod   (a b) ?
shl   (a b) ?
cmpa  (a b) ?
cmpe  (a b) ?
<<<<<<< HEAD
=======
cmpne (a b) ?
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7
neg   (a  ) ?
not   (a  ) ?
linux (rdi rsi rdx rcx r8 r9 rax) ?

struct ( ) 8

<<<<<<< HEAD
copy (a b) store a load b

member-copy (copy (a b) member (x) a b) copy member a member b

pair-copy (copy-a (a b) member-a (x) copy-b (a b) member-b (x) a b)
do  member-copy copy-a member-a a b
    member-copy copy-b member-b a b

inc (a) store a add 1 load a

exit (a) linux a 0 0 0 0 0 60

brk (a) linux a 0 0 0 0 0 12
=======
cmpin (a b c) not or (cmpa a b) (cmpa c a)

suc (a) add 1 a
prd (a) sub 1 a

post (op (a) -a)
let (load -a) a
do  store -a (op a)
    a

to (-b op (a b) a)
let (load -b) b
do  store -b (op a b)
    b

inc (-a) post suc -a
dec (-a) post prd -a

pow2 (n) shl n 1

exit   (a  ) linux a 0 0 0 0 0 60
brk    (a  ) linux a 0 0 0 0 0 12
stdin  (p n) linux 0 p n 0 0 0 0
stdout (p n) linux 1 p n 0 0 0 1
stderr (p n) linux 2 p n 0 0 0 1
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7

initbrk (n)
let brk 0 i
do  brk add n i
    i

<<<<<<< HEAD
alloc (brk n)
let load brk r
do  store brk add n load brk
    r

strlen (s)
for 0 n
and peek s
do  inc addr s
    add 1 n

memcmp (a b n)
let 1 r
and n 
do  for n m
    if  cmpe peek a peek b
		do  inc addr a
		do  inc addr b
			sub 1 m
		do  store addr r 0
			0
    r

strncmp (a b n)
let 1 r
and n
do  for n i
    if 	cmpe peek a peek b
        and peek a
        do  inc addr a
        do  inc addr b
            sub 1 i
        do  store addr r 0
            0 
    r

streq (a na b nb)
or  not cmpe na nb
    not memcmp
        a
        b
        na

put (out c)
let load out p
do  poke p c
    store out add 1 p

put-higit (out n) put out add if cmpa n 10 '0 '7 n

put-bhex (out n)
do  put-higit out div 16 n
    put-higit out mod 16 n

put-digit (out n) put out add '0 n

put-digits (out n)
and n
do  put-digits out div 10 n
    put-digit  out mod 10 n

put-number (out n)
if  n put-digits out if n n '0
    put out '0

put-cm (out) put out ',
put-sp (out) put out ' 
put-ds (out) put out '$
put-cr (out) put out '\r
put-lf (out) put out '\n

vput-mem (vput (out a) out a b)
for a i
and cmpa i b
do  vput out (peek i)
    add 1 i

vput-string (vput (out a) out s)
for s p
let (peek p) a
and a
do  vput out a
    add 1 p

put-string (out s) vput-string put out s

put-delim (delim (out) out s)
do  put-string out s
    delim out

put-seq  (out s) put-delim put-sp out s
put-list (out s) put-delim put-cm out s
put-line (out s) put-delim put-lf out s

stdin  (p n) linux 0 p n 0 0 0 0
stdout (p n) linux 1 p n 0 0 0 1
stderr (p n) linux 2 p n 0 0 0 1

retry (stdio (p n) p q)
let 0 a
let for p i
    let stdio i sub i q n
    do and cmpe n neg 1 store addr a neg 1
    and n
	add n i
	b
or a b

runtime (main (in out brk) heap inbuf outbuf)
let initbrk heap brk
let alloc addr brk inbuf  in
let alloc addr brk outbuf out
do  poke retry stdin in add in inbuf 0
do  retry stdout out main in out brk
    # OK #
    exit 0

err (code s) do retry stderr s add s strlen s do stderr "\n" 1 exit code

# span #
=======
io-retry (io (p n) a b)
let (neg 1) err
for a i
and not cmpe i err
let (io i (sub i b)) n
if  cmpe n err
	err
and n
	add n i

runtime (main (-in -out -brk) heap inbuf outbuf)
let (initbrk heap   ) -in
let (add -in  inbuf ) -out
let (add -out outbuf) -brk
do  poke (io-retry stdin -in (add -in inbuf)) 0
do  io-retry stdout -out (main -in -out -brk)
    exit 0

strlen (s)
and peek s
	suc (strlen (suc s))

strncmp (a b n)
or  not n
and cmpe (peek a) (peek b)
    strncmp (suc a) (suc b) (prd n)

put (c out)
let load out p
do  poke p c
do  store out (add 1 p)
    out

put-digit-16  (n out) put (add n (if (cmpa n 10) '0 '7)) out
put-digit-10  (n out) put (add n                 '0    ) out

base-10 (put-number (put-digit (n out) base n out) n out) put-number put-digit-10 10 n out
base-16 (put-number (put-digit (n out) base n out) n out) put-number put-digit-16 16 n out

put-digits-nonzero (put-digits (put-digit (n out) base n out) put-digit (n out) base n out)
    put-digit                 (mod base n)
	put-digits put-digit base (div base n)
	out

put-digits-zero (put-digits (put-digit (n out) base n out) put-digit (n out) base n out)
	out

put-digits (put-digit (n out) base n out)
if  n (put-digits-nonzero) (put-digits-zero) put-digits put-digit base n out

put-number-nonzero (put-digit (n out) base n out)
    put-digit                 (mod base n)
	put-digits put-digit base (div base n)
	out

put-number-zero (put-digit (n out) base n out)
	out

put-number (put-digit (n out) base n out)
if  n (put-number-nonzero) (put-number-zero) put-digit base n out

put-number-10 (n out) base-10 put-number n out
put-number-16 (n out) base-16 put-number n out

vput-mem (put (a out) a b out)
do  for a i
    and cmpa i b
    do  put (peek i) out
        suc i
	out
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7

vput-string (put (a out) s out)
do  for s p
    let (peek p) a
    and a
    do  put a out
        suc p
	out

<<<<<<< HEAD
span-start (s) load (span--start s)
span-end   (s) load (span--end   s)

span-copy (a b)
pair-copy copy span--start copy span--end a b

span-equal (a b)
let span-start a starta
let span-start b startb
    streq starta sub starta span-end a
          startb sub startb span-end b

span-init (s start end)
do  store (span--start s) start
    store (span--end   s) end
=======
put-string (s out) vput-string put s out

err (code s) do io-retry stderr s add s strlen s do stderr "\n" 1 exit code

# data functions #

pair--a     (-pair)     -pair
pair--b     (-pair) add -pair 8
struct-pair (     )           16

pair-set-a (-pair a) store (pair--a -pair) a
pair-set-b (-pair b) store (pair--b -pair) b

pair-get-a (-pair) load (pair--a -pair)
pair-get-b (-pair) load (pair--b -pair)

pair-set (-pair a b)
do  pair-set-a -pair a
    pair-set-b -pair b

pair-new  (-mem a b)
let (to -mem add 16) -pair
do  pair-set -pair a b
    -pair

pair-copy (a b) pair-set a (pair-get-a b) (pair-get-b b)

pair-equal (equal-a (a b) equal-b (a b) a b)
and equal-a (pair-get-a a) (pair-get-b a)
    equal-b (pair-get-a b) (pair-get-b b)

# token type #

token-get-span (-token)                     -token
token--caret   (-token) add (token-get-span -token) struct-pair
struct-token   (      )      token--caret           struct

token-get-caret (-token) load  (token--caret -token)

# name type #

name-get-span   (-name)                     -name
name--var       (-name) add (name-get-span  -name) struct-pair 
struct-name     (     )      name--var             struct

name-set-var (-name -var) store (name--var -name) -var

name-get-var (-name     ) load  (name--var -name)

# sem type #

sem--book     (-sem      )                      -sem
sem--mem      (-sem      ) add   (sem--book     -sem) struct
sem--out      (-sem      ) add   (sem--mem      -sem) struct
sem-get-token (-sem      ) add   (sem--out      -sem) struct
sem--type     (-sem      ) add   (sem-get-token -sem) struct-token
sem--val      (-sem      ) add   (sem--type     -sem) struct
sem--fixed    (-sem      ) add   (sem--val      -sem) struct
sem--flake    (-sem      ) add   (sem--fixed    -sem) struct
sem--impl     (-sem      ) add   (sem--flake    -sem) struct
struct-sem    (          )        sem--impl           struct

sem-set-book  (-sem book ) store (sem--book  -sem) book
sem-set-mem   (-sem mem  ) store (sem--mem   -sem) mem
sem-set-out   (-sem out  ) store (sem--out   -sem) out
sem-set-type  (-sem type ) store (sem--type  -sem) type
sem-set-val   (-sem val  ) store (sem--val   -sem) val
sem-set-fixed (-sem fixed) store (sem--fixed -sem) fixed
sem-set-flake (-sem flake) store (sem--flake -sem) flake
sem-set-impl  (-sem impl ) store (sem--impl  -sem) impl 

sem-get-book  (-sem      ) load  (sem--book  -sem)
sem-get-mem   (-sem      ) load  (sem--mem   -sem)
sem-get-out   (-sem      ) load  (sem--out   -sem)
sem-get-type  (-sem      ) load  (sem--type  -sem)
sem-get-val   (-sem      ) load  (sem--val   -sem)
sem-get-fixed (-sem      ) load  (sem--fixed -sem)
sem-get-flake (-sem      ) load  (sem--flake -sem)
sem-get-impl  (-sem      ) load  (sem--impl  -sem)

span-equal-rest (a b n)
or  not n
and cmpe peek a peek b
    span-equal-rest (suc a) (suc b) (prd n)

span-equal (a b)
let pair-get-a a ap
let pair-get-a b bp
let sub ap pair-get-b a an
let sub bp pair-get-b b bn
and cmpe an bn
    span-equal-rest ap bp bn
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7

span-strcmp (s lit)
let pair-get-a s start
let pair-get-b s end
let sub start end n
and strncmp lit start n
    not peek add lit n

vput-span (vput (a out) s out) vput-mem vput (pair-get-a s) (pair-get-b s) out

put-span (s out) vput-span put s out

# bookkeeping #

<<<<<<< HEAD
pushpop (out y op (a b) size) store y (op size (load y))

fpop  (out y size) pushpop out y add size
fpush (out y size) pushpop out y sub size
pop   (out y     ) pushpop out y add 1
push  (out y     ) pushpop out y sub 1
=======
book-count (-book)
and -book
    suc (book-count (pair-get-a -book))

book-lookup (match (line key) -book key)
and -book
let pair-get-b -book line
if  match line key
    line
    book-lookup match (pair-get-a -book) key

book-equal (line-equal (a b) a b)
or  cmpe a b
and a
and b
and            line-equal (pair-get-b a) (pair-get-b b)
    book-equal line-equal (pair-get-a a) (pair-get-a b)

type-new-unit     (mem     ) pair-new mem 0    0
type-new-function (mem args) pair-new mem args 1

type-decl-equal (arg-equal (a b) a b)
or  cmpe a b
and a
and b
and cmpe                 (pair-get-b a) (pair-get-b b)
    book-equal arg-equal (pair-get-a a) (pair-get-a b)

decl-equal (a b) type-decl-equal decl-equal (pair-get-b a) (pair-get-b b)

type-equal (a b) type-decl-equal decl-equal a b

token-copy (a b)
do  pair-copy  (token-get-span  a) (token-get-span  b)
    store (token--caret a) (token-get-caret b)

token-clone (mem j)
let (to mem add struct-token) k
do  token-copy k j
    k

token-match (lex (c) k) lex (peek (pair-get-a (token-get-span k)))

token-is (lit k) span-strcmp (token-get-span k) lit

token-equal (a b) span-equal (token-get-span a) (token-get-span b)

name-new (mem span var)
let (to mem add struct-name) n
do  pair-copy (name-get-span n) span
do  name-set-var n var
    n

name-push (-mem -book span var) pair-new -mem -book (name-new -mem span var)

name-get-span-equal (n span) span-equal (name-get-span n) span

try-name-lookup (book span) book-lookup name-get-span-equal book span

var-push (mem o span t y) name-push mem o span (pair-new mem t y)

try-var-lookup (o span)
let (try-name-lookup o span) e
and e
    name-get-var e

# token parsers #

eat-bunch (body (c) c) 
for 0 _ body c

eat-grou  (delim (c) body (c) c)
and delim c
    body  c

eat-group (delim (c) body (c) c)
and delim c
do  eat-bunch body c
    delim c

lex-normal (char-class (a) -caret)
and char-class peek load -caret
    store -caret (suc (load -caret))

lex-escape (class (a) class-normal (a) class-alternate (a) -caret)
if  lex-normal class           -caret
    lex-normal class-alternate -caret
    lex-normal class-normal    -caret
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7

# x86_64 implementation #

x86_64-string-mov              () "mov"
x86_64-string-add              () "add"
x86_64-string-test             () "test"
x86_64-string-je               () "je"
x86_64-string-jne              () "jne"
x86_64-string-jmp              () "jmp"
x86_64-string-push             () "push"
x86_64-string-pop              () "pop"
x86_64-string-call             () "call"
x86_64-string-ret              () "ret"
x86_64-string-entry            () "_start"
x86_64-string-stack-top        () "(%rsp)"
x86_64-string-gotpcrel-rip     () "@GOTPCREL(%rip)"
x86_64-string-str-label-prefix () ".s"
x86_64-string-globl            () ".globl"
x86_64-string-equ              () ".equ"
x86_64-string-section-text     () ".section .text."
x86_64-string-string           () ".string"
x86_64-string-previous         () ".previous"
x86_64-string-rax              () "%rax"
x86_64-string-rsp              () "%rsp"
x86_64-string-rdi              () "%rdi"
x86_64-string-rsi              () "%rsi"
x86_64-string-rdx              () "%rdx"
x86_64-string-rcx              () "%rcx"
x86_64-string-r8               () "%r8"
x86_64-string-r9               () "%r9"

x86_64-mangle (vput (put (a out) s out) s out)
    vput put-number-16 s
    put 'f
	out

x86_64-mangle-span   (s out) x86_64-mangle vput-span   s out
x86_64-mangle-string (s out) x86_64-mangle vput-string s out

x86_64-cz (out)
do  put-seq  out x86_64-string-test
do  put-list out x86_64-string-rax
    put-line out x86_64-string-rax

x86_64-label-id (out n)
do  put out '.
do  put-number out n
    put out '$

x86_64-jc (out n s)
do  put-seq out s
do  x86_64-label-id out n
    put-lf out

x86_64-jcn (out n s) x86_64-jc out n s

x86_64-czjc (out n s)
do  x86_64-cz out
    x86_64-jcn out n s

x86_64-je  (out n) x86_64-czjc out n x86_64-string-je
x86_64-jne (out n) x86_64-czjc out n x86_64-string-jne
x86_64-jmp (out n) x86_64-jcn  out n x86_64-string-jmp

x86_64-rip (out)
do  put-list out x86_64-string-pcrel-rip
    put-line out x86_64-string-rax

x86_64-load-rel (out y z)
do  put-number out (shl 3 (sub z y))
do  put-list out x86_64-string-stack-top
    put-line out x86_64-string-rax

x86_64-if (j (out n) out)
let (load out) n
do  j out n
    n

x86_64-str-label (out n)
do  put-string out x86_64-string-str-label-prefix
    put-number out n

x86_64-label-suf (out)
<<<<<<< HEAD
do  put out ':
    put-lf out

x86_64-str-label-with (suf (out) out n)
do  x86_64-str-label out n
    suf out

x86_64-builtin-label (out s)
do  put-seq  out x86_64-string-globl
do  put-line out s
do  put-string out x86_64-string-section-text
do  put-line out s
do  put-string out s
    x86_64-label-suf out

x86_64-pre (out)
do  put-seq     out x86_64-string-globl
do  put-line    out x86_64-string-entry
do  put-seq     out x86_64-string-equ
do  put-list    out x86_64-string-entry
do  x86_64-mangle-string out x86_64-string-entry
do  put-lf out
do  x86_64-builtin-label out "f6C6F6164"
do  put-line out "mov (%rdi),%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f73746F7265"
do  put-line out "mov %rsi,(%rdi)"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f7065656B"
do  put-line out "movzb (%rdi),%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f706F6B65"
do  put-line out "movb %sil,(%rdi)"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f616464"
do  put-line out "mov %rsi,%rax"
do  put-line out "add %rdi,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f737562"
do  put-line out "mov %rsi,%rax"
do  put-line out "sub %rdi,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6D756C"
do  put-line out "mov %rsi,%rax"
do  put-line out "mul %rdi"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f646976"
do  put-line out "xor %edx,%edx"
do  put-line out "mov %rsi,%rax"
do  put-line out "div %rdi"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6D6F64"
do  put-line out "xor %edx,%edx"
do  put-line out "mov %rsi,%rax"
do  put-line out "div %rdi"
do  put-line out "mov %rdx,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f73686C"
do  put-line out "mov %rsi,%rax"
do  put-line out "mov %rdi,%rcx"
do  put-line out "shl %cl,%rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f636D7061"
do  put-line out "cmp %rdi,%rsi"
do  put-line out "seta %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f636D7065"
do  put-line out "cmp %rsi,%rdi"
do  put-line out "sete %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E65"
do  put-line out "cmp %rsi,%rdi"
do  put-line out "setne %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E6567"
do  put-line out "mov %rdi,%rax"
do  put-line out "neg %rax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6E6F74"
do  put-line out "test %rdi,%rdi"
do  put-line out "sete %al"
do  put-line out "movzbl %al,%eax"
do  put-line out x86_64-string-ret
do  x86_64-builtin-label out "f6C696E7578"
do  put-line out "mov 8(%rsp),%rax"
do  put-line out "syscall"
    put-line out x86_64-string-ret

x86_64-id (out s then now)
do  put-seq out x86_64-string-mov
if  then
    x86_64-load-rel out then now
    do  x86_64-mangle-span out s
        x86_64-rip out

x86_64-addr (out s then now)
do  put-seq out x86_64-string-lea
    x86_64-load-rel out then now

x86_64-lit (out s)
do  put-seq  out x86_64-string-mov
do  put-ds   out
do  put-span out s
do  put-cm   out
    put-line out x86_64-string-rax

x86_64-str (out s)
let (load out) n
do  put-string out x86_64-string-section-text
do  x86_64-str-label-with put-lf out n
do  x86_64-str-label-with x86_64-label-suf out n
do  put-list out x86_64-string-string
do  put-span out s
do  put-lf   out
do  put-line out x86_64-string-previous
do  put-seq  out x86_64-string-mov
    x86_64-str-label-with x86_64-rip out n

x86_64-do   (out  ) load out
x86_64-and  (out  ) x86_64-if x86_64-je  out
x86_64-or   (out  ) x86_64-if x86_64-jne out
x86_64-else (out  ) x86_64-if x86_64-jmp out
x86_64-rep  (out n)           x86_64-jne out n

x86_64-label (out n)
do  x86_64-label-id out n 
    x86_64-label-suf out

x86_64-fpushpop (fpushpop (out y size) out y size sign)
and size
do  put-seq    out x86_64-string-add
do  put        out '$
do  (and sign put out '-)
do  put-number out (shl 3 size)
do  put-cm     out
do  put-line   out x86_64-string-rsp
    fpushpop   out y size

x86_64-pushpop (pushpop (out y) out y reg sign)
do  put-seq  out if sign x86_64-string-push x86_64-string-pop
do  put-line out reg
    pushpop  out y

x86_64-fpop  (out y size) x86_64-fpushpop fpop  out y size 0
x86_64-fpush (out y size) x86_64-fpushpop fpush out y size 1
x86_64-pop   (out y reg ) x86_64-pushpop  pop   out y reg  0
x86_64-push  (out y reg ) x86_64-pushpop  push  out y reg  1

x86_64-let (out y)
let (load out) n
do  x86_64-push out y x86_64-string-rax
    n

x86_64-for (out y)
let x86_64-let   out y n
let x86_64-else  out m
do  x86_64-label out n
do  put-seq      out x86_64-string-mov
do  put-list     out x86_64-string-rax
do  put-line     out x86_64-string-stack-top
do  x86_64-label out m
    n

x86_64-unlet (out y n) x86_64-fpop out y 1

x86_64-unfor (out y n) 
do  x86_64-rep out n
    x86_64-pop out y x86_64-string-rax

x86_64-uncall (out y z arity)
do  x86_64-pop   out y x86_64-string-rax
do  and cmpa 0 arity do  x86_64-pop out y x86_64-string-rdi
    and cmpa 1 arity do  x86_64-pop out y x86_64-string-rsi
    and cmpa 2 arity do  x86_64-pop out y x86_64-string-rdx
    and cmpa 3 arity do  x86_64-pop out y x86_64-string-rcx
    and cmpa 4 arity do  x86_64-pop out y x86_64-string-r8
    and cmpa 5 arity     x86_64-pop out y x86_64-string-r9
do  put-seq  out x86_64-string-call
do  put out '*
do  put-line out x86_64-string-rax
    x86_64-fpop out y (sub (load y) z)

# ebrew's typing system #

type--next  (t)                  t
type--arg   (t) add (type--next  t) struct
type--token (t) add (type--arg   t) struct
type--kind  (t) add (type--token t) struct
struct-type ( )      type--kind     struct

type--alloc (brk kind)
let alloc brk struct-type t
do  store (type--next t) 0
do  store (type--arg  t) 0
do  store (type--kind t) kind
    t

type-new-unit     (brk) type--alloc brk 0
type-new-function (brk) type--alloc brk 1

type-kind (t) load (type--kind t)

type-arity (t)
and t
    add 1 (type-arity (load (type--next t)))

type--kind-equal (a b) cmpe (type-kind a) (type-kind b)

type-list-equal (equal (a b) a b)
or  cmpe a b
and a
and b
and type-list-equal equal (load (type--next a)) (load (type--next b))
    equal a b

type-equal (a b) 
and type--kind-equal a b
    type-list-equal type-equal (load (type--arg a)) (load (type--arg b))

# location #

#
  loc just keeps track of line/column
#

loc--line  (l)                l
loc--col   (l) add (loc--line l) struct
struct-loc ( )      loc--col     struct

loc-load-line (s) load (loc--line s)
loc-load-col  (s) load (loc--col  s)

loc-copy (a b)
pair-copy copy loc--line
          copy loc--col  a b

loc--xr (x (l) l) store (x l) 1
loc--xf (x (l) l) inc   (x l)

loc--lr (l) loc--xr loc--line l
loc--lf (l) loc--xf loc--line l
loc--cr (l) loc--xr loc--col  l
loc--cf (l) loc--xf loc--col  l

loc--crlx (x (l) l)
do  loc--cr l
    x l
=======
    put '

    put ':
	out

x86_64-section-header (vput (s out) s out)
    x86_64-label-suf
    vput s
    put '

    vput s
    put-string x86_64-string-section-text
	out

x86_64-predef (string body out)
	put '

    put-string            x86_64-string-ret
	put '

    put-string            body
    x86_64-section-header
    x86_64-mangle-string  string
	put '

    put-string            string
	put ' 
    put-string            x86_64-string-globl
	out

x86_64-pre (out)
    x86_64-predef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-predef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-predef "cmpe"  "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "cmpa"  "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-predef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-predef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-predef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-predef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-predef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-predef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-predef "poke"  "movb %sil,(%rdi)"
    x86_64-predef "peek"  "movzb (%rdi),%eax"
    x86_64-predef "store" "mov %rsi,(%rdi)"
    x86_64-predef "load"  "mov (%rdi),%rax"
    put '

    x86_64-mangle-string  x86_64-string-entry
	put ',
    put-string            x86_64-string-entry
	put ' 
    put-string            x86_64-string-equ
	put '

    put-string            x86_64-string-entry
	put ' 
    put-string            x86_64-string-globl
	out

x86_64-fpushpop (op (y size) y size sign out)
if  size
do  put        '$
	put ' 
    put-string x86_64-string-add
	out
do  and sign
        put '- out
do  put '

    put-string   x86_64-string-rsp
    put ',
    put-number-10 (shl 3 size)
    out
do  to y op size
	out
    out

x86_64-pushpop (op (y) y reg sign out)
do  put '

    put-string reg
	put ' 
    put-string (if sign x86_64-string-push x86_64-string-pop)
    out
do  op y
    out

x86_64-fpop  (y size out) x86_64-fpushpop add y size 0 out
x86_64-fpush (y size out) x86_64-fpushpop sub y size 1 out
x86_64-pop   (y reg  out) x86_64-pushpop  inc y reg  0 out
x86_64-push  (y reg  out) x86_64-pushpop  dec y reg  1 out

x86_64-label-id (n out)
    put           '$
    put-number-10 n 
    put           '.
	out

x86_64-cz (out)
	put '

    put-string x86_64-string-rax
	put ',
    put-string x86_64-string-rax
	put ' 
    put-string x86_64-string-test
	out

x86_64-jc (n s out)
    put '

    x86_64-label-id n
	put ' 
    put-string      s
	out

x86_64-czjc (n s out)
    x86_64-jc n s
    x86_64-cz
	out

x86_64-je  (n out) x86_64-czjc n x86_64-string-je  out
x86_64-jne (n out) x86_64-czjc n x86_64-string-jne out
x86_64-jmp (n out) x86_64-jc   n x86_64-string-jmp out

x86_64-id (s y z out)
do  put ' 
	put-string x86_64-string-mov out
    put '

	put-string x86_64-string-rax
    if  y
		put ',
		put-string x86_64-string-stack-top
	    put-number-10 (shl 3 (sub z y))
	    out
		put ',
		put-string x86_64-string-gotpcrel-rip
	    x86_64-mangle-span s
	    out

x86_64-lit (s out)
    put '

	put-string x86_64-string-rax
    put ',
    put-span s
    put '$
	put ' 
    put-string x86_64-string-mov
	out

x86_64-str-label (n out)
    put-number-10 n
    put-string x86_64-string-str-label-prefix
	out

x86_64-str (s a out)
    put '

	put-string       x86_64-string-rax
	put ',
    put-string       x86_64-string-gotpcrel-rip
    x86_64-str-label a
	put ' 
    put-string       x86_64-string-mov
    put '

	put-string       x86_64-string-previous
    put '

    put-span         s
	put ',
    put-string       x86_64-string-string
    x86_64-label-suf
    x86_64-str-label a
    put '

    x86_64-str-label a
    put-string       x86_64-string-section-data
	out

x86_64-do    (a out) 1

x86_64-label (a out)
    x86_64-label-suf
    x86_64-label-id  a
    out

x86_64-let-in  (y a out) x86_64-push y x86_64-string-rax out
x86_64-let-end (y a out) x86_64-fpop y 1 out

x86_64-for-in (y a out)
    x86_64-label  a
    put 'b
	put '

    put-string    x86_64-string-stack-top
	put ',
    put-string    x86_64-string-rax
	put ' 
    put-string    x86_64-string-mov
    x86_64-label    a
    put '

    x86_64-label-id a
    put-string "jmp b"
    x86_64-let-in y a
	out

x86_64-for-end (y a out)
    x86_64-pop y x86_64-string-rax
    x86_64-jne a
    out

x86_64-call-with (y a out)
let (load y) z
do  x86_64-push  y x86_64-string-rax
    x86_64-fpush y a
    out
    z

x86_64-call-arg (i out)
	put '

    put-string    x86_64-string-stack-top
    put-number-10 (shl 3 i)
	put ',
    put-string    x86_64-string-rax
	put ' 
    put-string    x86_64-string-mov
	out

x86_64-call-end-pop (i n y s out)
if  cmpa i n
    x86_64-pop y s out
	out

x86_64-call-end (y z n out)
do  x86_64-call-end-pop 5 n y x86_64-string-r9
    x86_64-call-end-pop 4 n y x86_64-string-r8
    x86_64-call-end-pop 3 n y x86_64-string-rcx
    x86_64-call-end-pop 2 n y x86_64-string-rdx
    x86_64-call-end-pop 1 n y x86_64-string-rsi
    x86_64-call-end-pop 0 n y x86_64-string-rdi
    x86_64-pop   y x86_64-string-rax
    out
    x86_64-fpop y (sub (load y) z)
	put '

    put-string x86_64-string-rax
    put '*
	put ' 
    put-string x86_64-string-call
	out

x86_64-decl-in (y span out)
do  x86_64-section-header x86_64-mangle-span span out
    store y (shl 63 1)

x86_64-decl-end (y z out)
	put '

    put-string x86_64-string-ret
    x86_64-fpop y z
    out
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7

loc--crlf (l) loc--crlx loc--lf l
loc--crlr (l) loc--crlx loc--lr l

loc-init (l) loc--crlr l

loc-adv (a l)
if a loc--crlf l
     loc--cf   l
     
# character ranges #

cmpin (a b c)
not or  cmpa a b
        cmpa c a

char-range-sq (a) cmpe  a '\'
char-range-dq (a) cmpe  a '\"
char-range-bs (a) cmpe  a '\\
char-range-hm (a) cmpe  a '#
char-range-qm (a) cmpe  a '?
char-range-lp (a) cmpe  a '(
char-range-rp (a) cmpe  a ')
char-range-us (a) cmpe  a '_
char-range-en (a) cmpe  a '-
char-range-sp (a) cmpe  a ' 
char-range-tb (a) cmpe  a '\t
char-range-lf (a) cmpe  a '\n
char-range-cr (a) cmpe  a '\r

char-range-09 (a) cmpin a '0 '9
char-range-AZ (a) cmpin a 'A 'Z
char-range-az (a) cmpin a 'a 'z

<<<<<<< HEAD
# caret #

#
  caret is where we use loc to keep track of line/col
  and we walk through the input at the same time
#

caret--ptr   (c)                  c
caret--loc   (c) add (caret--ptr  c) struct
struct-caret ( )      caret--loc     struct-loc

caret-ptr (c) load (caret--ptr c)
caret-loc (c) load (caret--loc c)

caret-copy (a b)
pair-copy     copy caret--ptr
          loc-copy caret--loc a b

caret-init (c ptr)
do  store (caret--ptr c) ptr
    loc-init (caret--loc c)

caret-peek (c) peek (caret-ptr c)

caret-adv (c)
do  loc-adv (char-range-lf caret-peek c) (caret--loc c)
    inc (caret--ptr c)

# tokenizer state #

# here we pair caret and span to make a kind of caret for tokens.
  the span locates the token and the caret is positioned at the end
  of any trailing whitespace so we can look ahead to the next token.
#

token--span  (k)                   k
token--caret (k) add (token--span  k) struct-span
struct-token ( )      token--caret    struct-caret

token--set-span (k start end) span-init token--span k start end

token--read (nontext (c) text (c) k)
let (token--caret k) c
let (token--span  k) s
do  nontext c
if	caret-peek c
    let (caret-ptr c) start
    if  text c
        span-init s start (caret-ptr c)
        err 1 "invalid text"
    span-init s 0 0

token-copy (a b)
pair-copy  span-copy token--span
          caret-copy token--caret a b

token-init (read (impl (nontext (c) text (c) k) k) k in)
do  caret-init (token--caret k) in
    read token--read k

token-try-adv (read (impl (nontext (c) text (c) k) k) k)
and span-start token--span k
    read token--read k

token-adv (read (impl (nontext (c) text (c) k) k) k)
or  token-try-adv read k
    err 2 "missing token"

token-match (lex (c) k) lex (peek (span-start (token--span k)))

token-is (lit k) span-strcmp (token--span k) lit

token-eat-lit (adv (k) k c)
and token-is c k
    adv k

token-equal (a b) span-equal (token--span a) (token--span b)

token-caret-peek (k) caret-peek (token--caret k)

# bookkeeping #

struct-name-token (o)                          o
struct-name-decl  (o) add (struct-name-token   o) struct-token
struct-name       ( )      struct-name-decl       struct

struct-book-next  (o)                       o
struct-book-name  (o) add (struct-book-next o) struct
struct-book       ( )      struct-book-name    struct-name

push-book (brk book token type impl d)
let alloc brk struct-book o
do        copy struct-book-next  o book
let struct-book-name o name
do  token-copy struct-name-token name token
do  store struct-name-decl name d
do  store book o
    name

pop-book (book)
copy book load struct-book-next book

try-lookup (book token)
let 0 r
do  for load book i
    if  token-equal token struct-name-token struct-book-name i
        load struct-book-next i
        do  store addr r struct-book-name i
            0
    r

lookup (book token)
or  try-lookup book token
    err 3 "lookup failed"

# semantics #

sem--book  (x)                          x
sem--brk   (x) add (sem--book  x) struct
sem--out   (x) add (sem--brk   x) struct
sem--token (x) add (sem--out   x) struct
sem--type  (x) add (sem--token x) struct-token
sem--val   (x) add (sem--type  x) struct
sem--isc   (x) add (sem--val   x) struct
sem--impl  (x) add (sem--isc   x) struct
struct-sem ( )      sem--impl     struct

sem-set-type (x t) store sem--type x t
sem-set-val  (x t) store sem--val  x t
sem-set-isc  (x t) store sem--isc  x t

sem-type (x) load sem--type x
sem-val  (x) load sem--val  x
sem-isc  (x) load sem--isc  x

struct-decl-type  (o)                          o
struct-decl-impl  (o) add (struct-decl-type    o) struct
struct-decl-isdef (o) add (struct-decl-impl    o) struct
struct-decl       ( )      struct-decl-isdef      struct

ebrew-sem-lit (impl (out s) x)
do  impl (sem--out x) (token--span (sem--token x))
    sem-set-type x (type-new-unit (sem--brk x))

ebrew-sem-addr-id (impl (out s y z) x o t)
do  impl (sem--out x) (token--span (sem--token x)) (load (struct-decl-impl (load (struct-name-decl o)))) (load (sem--impl x))
    sem-set-type x t

ebrew-sem-addr (impl (out s y z) x o) ebrew-sem-addr-id impl x o (type-new-unit (sem--brk x))
ebrew-sem-id   (impl (out s y z) x o) ebrew-sem-addr-id impl x o (load (struct-decl-type (load (struct-name-decl o))))

ebrew-sem-do     (impl (out  ) x  ) impl sem--out x 
ebrew-sem-label  (impl (out n) x n) impl sem--out x n

ebrew-sem-else (impl-jmp (out) impl-label (out n) x n)
let impl-jmp   sem--out x m
do  impl-label sem--out x n
    m

ebrew-sem-vardecl (x k)
let (alloc (sem--brk x) struct-decl) d
do  store struct-decl-type  d (sem-type x)
do  copy  struct-decl-impl  d (sem--impl x)
do  store struct-decl-isdef d 0
	push-book
		(sem--brk   x)
		(sem--book  x)
		k
		(sem-type   x)
		(sem--impl  x)
		d

ebrew-sem-var-in (impl (out y) x)
let impl sem--out x sem--impl x n
do  ebrew-sem-vardecl x (sem--token x)
    n

ebrew-sem-var-end (impl (out y n) x n)
do  impl sem--out x sem--impl x n
    pop-book (sem--book x)

ebrew-sem-uncall (impl (out y z arity) x z arity)
do  impl (sem--out x) (sem--impl x) z arity
    sem-set-type x (type-new-unit (sem--brk x))

# another shit table #

ebrew-sem-impl-pre      (x  ) ebrew-sem-do      x86_64-pre   x
ebrew-sem-impl-lit      (x  ) ebrew-sem-lit     x86_64-lit   x
ebrew-sem-impl-str      (x  ) ebrew-sem-lit     x86_64-str   x
ebrew-sem-impl-addr     (x d) ebrew-sem-addr    x86_64-addr  x d
ebrew-sem-impl-id       (x d) ebrew-sem-id      x86_64-id    x d
ebrew-sem-impl-let-in   (x  ) ebrew-sem-var-in  x86_64-let   x
ebrew-sem-impl-let-end  (x n) ebrew-sem-var-end x86_64-unlet x n
ebrew-sem-impl-for-in   (x  ) ebrew-sem-var-in  x86_64-for   x
ebrew-sem-impl-for-end  (x n) ebrew-sem-var-end x86_64-unfor x n
ebrew-sem-impl-do-then  (x  ) ebrew-sem-do      x86_64-do    x
ebrew-sem-impl-do-end   (x n) ebrew-sem-label   x86_64-label x n
ebrew-sem-impl-and-then (x  ) ebrew-sem-do      x86_64-and   x
ebrew-sem-impl-and-end  (x n) ebrew-sem-label   x86_64-label x n
ebrew-sem-impl-or-else  (x  ) ebrew-sem-do      x86_64-or    x
ebrew-sem-impl-or-end   (x n) ebrew-sem-label   x86_64-label x n
ebrew-sem-impl-if-then  (x  ) ebrew-sem-do      x86_64-and   x
ebrew-sem-impl-if-else  (x n) ebrew-sem-else    x86_64-else
                                                x86_64-label x n
ebrew-sem-impl-if-end   (x n) ebrew-sem-label   x86_64-label x n

ebrew-sem-impl-call   (x arity)
do  x86_64-fpush (sem--out x) (sem--impl x) arity
    x86_64-push  (sem--out x) (sem--impl x) x86_64-string-rax

ebrew-sem-impl-call-arg (x i)
do  put-seq    (sem--out x) x86_64-string-mov
do  put-list   (sem--out x) x86_64-string-rax
do  put-number (sem--out x) (shl 3 i)
    put-line   (sem--out x) x86_64-string-stack-top

ebrew-sem-impl-call-end (x z arity) ebrew-sem-uncall x86_64-uncall x z arity

# ebrew's character classes #

ebrew-char-class-nz (a) a

ebrew-char-class-lf (a)     char-range-lf a
ebrew-char-class-hm (a)     char-range-hm a
ebrew-char-class-bs (a)     char-range-bs a
ebrew-char-class-sq (a)     char-range-sq a
ebrew-char-class-dq (a)     char-range-dq a
ebrew-char-class-09 (a)     char-range-09 a

ebrew-char-class-ws (a) or  char-range-sp a
                        or  char-range-tb a
                        or  char-range-lf a
                            char-range-cr a
ebrew-char-class-id (a) or  char-range-AZ a
                        or  char-range-az a
                        or  char-range-09 a
                        or  char-range-en a
                            char-range-us a
ebrew-char-class-im (a) or  char-range-09 a
                            char-range-sq a
ebrew-char-class-pt (a) or  char-range-lp a
                        or  char-range-rp a
                            char-range-qm a

# ebrew's lexer #

ebrew-lex-normal (char-class (a) c)
and char-class caret-peek c
    caret-adv c

ebrew-lex-escape (char-class (a) c)
if  ebrew-lex-normal ebrew-char-class-bs c
    ebrew-lex-normal ebrew-char-class-nz c
    ebrew-lex-normal char-class c

ebrew-lex-hm (c) ebrew-lex-normal ebrew-char-class-hm c
ebrew-lex-dq (c) ebrew-lex-normal ebrew-char-class-dq c
ebrew-lex-sq (c) ebrew-lex-normal ebrew-char-class-sq c
ebrew-lex-09 (c) ebrew-lex-normal ebrew-char-class-09 c
ebrew-lex-pt (c) ebrew-lex-normal ebrew-char-class-pt c
ebrew-lex-ws (c) ebrew-lex-normal ebrew-char-class-ws c
ebrew-lex-id (c) ebrew-lex-escape ebrew-char-class-id c
ebrew-lex-sb (c) ebrew-lex-escape ebrew-char-class-nz c

# ebrew's token helpers #

ebrew-eat-bunch (body (c) c) 
and body c
for 1 _
    body c

ebrew-eat-pchar (delim (c) c)
and delim c
    ebrew-lex-sb c

ebrew-eat-group (delim (c) c)
and delim c
for 1 _
and not (delim c)
    ebrew-lex-sb c

# ebrew's tokens #

ebrew-eat-pt (c)                 ebrew-lex-pt c
ebrew-eat-id (c) ebrew-eat-bunch ebrew-lex-id c
ebrew-eat-09 (c) ebrew-eat-bunch ebrew-lex-09 c
ebrew-eat-ws (c) ebrew-eat-bunch ebrew-lex-ws c
ebrew-eat-sq (c) ebrew-eat-pchar ebrew-lex-sq c
ebrew-eat-dq (c) ebrew-eat-group ebrew-lex-dq c
ebrew-eat-nt (c) ebrew-eat-group ebrew-lex-hm c

# ebrew's tokenizer #

ebrew-tokenize-nontext (c)
for 1 -
or  ebrew-eat-ws c
    ebrew-eat-nt c

ebrew-tokenize-text (c)
or  ebrew-eat-id c
or  ebrew-eat-pt c
or  ebrew-eat-09 c
or  ebrew-eat-sq c
    ebrew-eat-dq c

ebrew-token-read (token-read (nontext (c) text (c) k) k)
token-read ebrew-tokenize-nontext
           ebrew-tokenize-text
           k

ebrew-token-init (k in) token-init ebrew-token-read k in
ebrew-token-adv  (k   ) token-adv  ebrew-token-read k

ebrew-token-class-do   (k) token-is "do"   k
ebrew-token-class-if   (k) token-is "if"   k
ebrew-token-class-or   (k) token-is "or"   k
ebrew-token-class-and  (k) token-is "and"  k
ebrew-token-class-let  (k) token-is "let"  k
ebrew-token-class-for  (k) token-is "for"  k
ebrew-token-class-addr (k) token-is "addr" k

ebrew-token-class-qm   (k) token-is "?" k
ebrew-token-class-lp   (k) token-is "(" k
ebrew-token-class-rp   (k) token-is ")" k

ebrew-token-class-lit  (k) token-match ebrew-char-class-im k
ebrew-token-class-str  (k) token-match ebrew-char-class-dq k
ebrew-token-class-id   (k) token-match ebrew-char-class-id k

# ebrew's parsers #

ebrew-syn-expr-lit (sem (x) x)
do  sem x
    ebrew-token-adv (sem--token x)

ebrew-syn-expr-id (sem (x o) x)
let lookup sem--book x (sem--token x) o
do  sem x o
do  ebrew-token-adv (sem--token x)
    o

ebrew-syn-expr-var (sem-in (x) sem-end (x n) syn (x t) x t)
do  syn      x (type-new-unit (sem--brk x))
let sem-in   x   n
do  ebrew-token-adv (sem--token x)
do  syn      x t
    sem-end  x n

ebrew-syn-expr-seq (sem-then (x) sem-end (x n) syn (x t) x t)
do  syn      x t
let sem-then x   a
do  syn      x t
    sem-end  x a

ebrew-syn-expr-if (sem-then (x) sem-else (x n) sem-end (x n) syn (x t) x t)
do  syn      x (type-new-unit (sem--brk x))
let sem-then x   a
=======
# character classes #

char-class-nz (a)     char-range-nz a

char-class-lf (a)     char-range-lf a
char-class-hm (a)     char-range-hm a
char-class-bs (a)     char-range-bs a
char-class-sq (a)     char-range-sq a
char-class-dq (a)     char-range-dq a
char-class-09 (a)     char-range-09 a

char-class-ws (a) or  char-range-sp a
                  or  char-range-tb a
                  or  char-range-lf a
                      char-range-cr a
char-class-id (a) or  char-range-AZ a
                  or  char-range-az a
                  or  char-range-09 a
                  or  char-range-en a
                      char-range-us a
char-class-im (a) or  char-range-09 a
                      char-range-sq a
char-class-un (a) or  char-range-09 a
                  or  char-range-sq a
                  or  char-range-AZ a
                  or  char-range-az a
                  or  char-range-09 a
                  or  char-range-en a
                  or  char-range-us a
                      char-range-dq a
char-class-pt (a) or  char-range-lp a
                  or  char-range-rp a
                      char-range-qm a

char-negclass (char-class (a) a)
and char-class-nz a
not char-class    a

char-class-sb (a) char-negclass char-class-dq a
char-class-cb (a) char-negclass char-class-hm a

# lexer #

lex-hm (c) lex-normal char-class-hm c
lex-dq (c) lex-normal char-class-dq c
lex-sq (c) lex-normal char-class-sq c
lex-09 (c) lex-normal char-class-09 c
lex-pt (c) lex-normal char-class-pt c
lex-ws (c) lex-normal char-class-ws c
lex-id (c) lex-escape char-class-bs char-class-id char-class-nz c
lex-sb (c) lex-escape char-class-bs char-class-sb char-class-nz c
lex-cb (c) lex-escape char-class-bs char-class-cb char-class-nz c

# tokenizer #

eat-user (c)
for 0 _
or  eat-bunch lex-ws        c
    eat-group lex-hm lex-cb c

eat-text (c)
or  eat-bunch lex-id        c
or            lex-pt        c
or  eat-grou  lex-sq lex-sb c
or  eat-group lex-dq lex-sb c
    eat-bunch lex-09        c

eat (-caret -span)
do  eat-user -caret
let (load -caret) a
    pair-set -span a (if eat-text -caret (load -caret) a)

# semantics #

sem-impl-pre (impl (-out) -book -out)
do  store -book 0
    impl  -out

sem-impl-flake (-flake) inc -flake

sem-impl-lit (impl (span -out) -mem -type span -out)
do  impl span -out
    store -type (type-new-unit -mem)

sem-impl-str (impl (span flake -out) -mem -type span flake -out)
do  impl span flake -out
    store -type (type-new-unit -mem)

sem-impl-ref (impl (span detail-old detail-new -out) -type book span detail -out)
let try-var-lookup book span var
if  var
do  impl span (pair-get-b var) detail -out
    store -type (pair-get-a var)
    err 2 "undefined identifier"

sem-impl-var-in (impl (-detail flake -out) -mem -book -detail flake span type -out)
do  impl -detail flake -out
    store -book (var-push -mem (load -book) span type (load -detail))

sem-impl-var-end (impl (-detail flake -out) -mem -book -detail flake -out)
do  impl -detail flake -out
    store -book (pair-get-a (load -book))

sem-impl-call-arg  (impl (index -out) type-param type-arg index -out)
if  type-equal type-param type-arg
    impl index -out
    err 3 "illegal argument type"

sem-impl-call-end  (impl (detail-old detail-new arity -out) -mem -type detail-old detail-new arity -out)
do  impl detail-old detail-new arity -out
    store -type (type-new-unit -mem)

# expression parsers #

parse-builtin (token-class (k) syn (syn (x t) x t) syn-syn (x t) x t)
and token-class (sem-get-token x)
do  eat (token--caret sem-get-token x) (token-get-span sem-get-token x)
    syn syn-syn x t

parse-skip (token-class (k) x)
and token-class (sem-get-token x)
    eat (token--caret sem-get-token x) (token-get-span sem-get-token x)

parse-atom (token-class (k) syn (syn (x t) x t) syn-syn (x t) x t)
and token-class (sem-get-token x)
do  syn syn-syn x t
    parse-skip token-class x

parse-decl (token-class (k) syn (x) x)
and token-class (sem-get-token x)
    syn x

token-class-do   (k) token-is "do"   k
token-class-if   (k) token-is "if"   k
token-class-or   (k) token-is "or"   k
token-class-and  (k) token-is "and"  k
token-class-let  (k) token-is "let"  k
token-class-for  (k) token-is "for"  k

token-class-qm   (k) token-is "?" k
token-class-lp   (k) token-is "(" k
token-class-rp   (k) token-is ")" k

token-class-unit (k) token-match char-class-un k
token-class-str  (k) token-match char-class-dq k
token-class-lit  (k) token-match char-class-im k
token-class-id   (k) token-match char-class-id k

parse-lit  (x) parse-skip token-class-lit  x
parse-str  (x) parse-skip token-class-str  x
parse-id   (x) parse-skip token-class-id   x
parse-lp   (x) parse-skip token-class-lp   x
parse-rp   (x) parse-skip token-class-rp   x
parse-qm   (x) parse-skip token-class-qm   x

# here we connect the syntaxes to their semantics #

syn-sem-pre  (sem (x) x)
    sem      x

syn-sem-unit (sem (x) x)
    sem      x

syn-sem-str (sem (x) sem-end (x a) x)
let sem      x a
    sem-end  x a

syn-sem-var (sem (x) sem-in (x a) sem-end (x a) syn (x t) syn-id (x) x t)
let sem      x a
do  syn      x 0
do  sem-in   x a
do  syn-id   x
do  syn      x t
    sem-end  x a

syn-sem-seq (sem (x) sem-then (x a) sem-end (x a) syn (x t) x t)
let sem      x a
do  syn      x t
do  sem-then x a
do  syn      x t
    sem-end  x a

syn-sem-if (sem (x) sem-then (x a) sem-else (x a) sem-end (x a) syn (x t) x t)
let sem      x a
do  syn      x 0
do  sem-then x a
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7
do  syn      x t
let sem-else x a b
do  syn      x t
    sem-end  x b

<<<<<<< HEAD
ebrew-syn-sem-expr-lit  (expr (x t) x t) ebrew-syn-expr-lit ebrew-sem-impl-lit           x
ebrew-syn-sem-expr-str  (expr (x t) x t) ebrew-syn-expr-lit ebrew-sem-impl-str           x
ebrew-syn-sem-expr-addr (expr (x t) x t) ebrew-syn-expr-id  ebrew-sem-impl-addr          x
ebrew-syn-sem-expr-id   (expr (x t) x t) ebrew-syn-expr-id  ebrew-sem-impl-id            x
ebrew-syn-sem-expr-let  (expr (x t) x t) ebrew-syn-expr-var ebrew-sem-impl-let-in
                                            	            ebrew-sem-impl-let-end  expr x t
ebrew-syn-sem-expr-for  (expr (x t) x t) ebrew-syn-expr-var ebrew-sem-impl-for-in
                                                            ebrew-sem-impl-for-end  expr x t
ebrew-syn-sem-expr-do   (expr (x t) x t) ebrew-syn-expr-seq ebrew-sem-impl-do-then
                                                            ebrew-sem-impl-do-end   expr x t
ebrew-syn-sem-expr-and  (expr (x t) x t) ebrew-syn-expr-seq ebrew-sem-impl-and-then 
                                                            ebrew-sem-impl-and-end  expr x t
ebrew-syn-sem-expr-or   (expr (x t) x t) ebrew-syn-expr-seq ebrew-sem-impl-or-else
                                                            ebrew-sem-impl-or-end   expr x t
ebrew-syn-sem-expr-if   (expr (x t) x t) ebrew-syn-expr-if  ebrew-sem-impl-if-then
                                                            ebrew-sem-impl-if-else
                                                            ebrew-sem-impl-if-end   expr x t

ebrew-syn-expr-predef (is (k) syn (expr (x t) x t) expr (x t) x t)
and is (sem--token x)
do  ebrew-token-adv (sem--token x)
    syn expr x t

ebrew-syn-expr-atom (is (k) syn (expr (x t) x t) expr (x t) x t)
and is (sem--token x)
    syn expr x t

ebrew-syn-expr-punct (is (k) x)
and is (sem--token x)
    ebrew-token-adv (sem--token x)

ebrew-syn-expr-term (syn (x t) x t)
or  ebrew-syn-expr-predef ebrew-token-class-do   ebrew-syn-sem-expr-do   syn x t
or  ebrew-syn-expr-predef ebrew-token-class-if   ebrew-syn-sem-expr-if   syn x t
or  ebrew-syn-expr-predef ebrew-token-class-or   ebrew-syn-sem-expr-or   syn x t
or  ebrew-syn-expr-predef ebrew-token-class-and  ebrew-syn-sem-expr-and  syn x t
or  ebrew-syn-expr-predef ebrew-token-class-let  ebrew-syn-sem-expr-let  syn x t
or  ebrew-syn-expr-predef ebrew-token-class-for  ebrew-syn-sem-expr-for  syn x t
or  ebrew-syn-expr-predef ebrew-token-class-addr ebrew-syn-sem-expr-addr syn x t
or  ebrew-syn-expr-atom   ebrew-token-class-lit  ebrew-syn-sem-expr-lit  syn x t
or  ebrew-syn-expr-atom   ebrew-token-class-str  ebrew-syn-sem-expr-str  syn x t
    ebrew-syn-expr-atom   ebrew-token-class-id   ebrew-syn-sem-expr-id   syn x t

ebrew-syn-expr-args (syn (x t) x y t)
let (type-arity t) arity
do  ebrew-sem-impl-call x arity
do  let 1 i
    and t
    for t u
    do  syn x u
    do  or  type-equal u (sem-type x)
            err 4 "wrong"
    do  ebrew-sem-impl-call-arg x i
    do  inc addr i
        load u
    ebrew-sem-impl-call-end x y arity

ebrew-syn-expr-call (syn (x t) x t)
or  type-equal t (sem-type x)
for 1 _
and type-kind (sem-type x)
	ebrew-syn-expr-args syn x (load (sem--impl x)) (load (type--arg (sem-type x)))

ebrew-syn-expr-lp (x) ebrew-syn-expr-punct ebrew-token-class-lp x
ebrew-syn-expr-rp (x) ebrew-syn-expr-punct ebrew-token-class-rp x

ebrew-syn-expr-nest (syn (x t) x t)
if  ebrew-syn-expr-lp x
do  ebrew-syn-expr-term syn x t
or  ebrew-syn-expr-rp x
do  ebrew-syn-expr-call syn x t
or  ebrew-syn-expr-rp x
	err 5 "missing paren"
if  ebrew-syn-expr-term syn x t
	ebrew-syn-expr-call syn x t
	err 6 "missing expression"

ebrew-syn-expr (x t) ebrew-syn-expr-nest ebrew-syn-expr x t

# the ugliest code follows
#

# ebrew's type syntax #

ebrew-syn-param (syn (x) x t)
do  store t alloc sem--brk x struct-type
do  store type--token load t alloc sem--brk x struct-token
do  token-copy load type--token load t sem--token x
do  ebrew-token-adv sem--token x
let (syn x) u
do  copy type--next load t type--next u
do  copy type--arg  load t type--arg  u
    copy type--kind load t type--kind u

ebrew-syn-type (x)
if  token-eat-lit ebrew-token-adv (sem--token x) "("
    let (type-new-function (sem--brk x)) t
    do  for (type--arg t) u
        and not (token-eat-lit ebrew-token-adv (sem--token x) ")")
        do  ebrew-syn-param ebrew-syn-type x u
            type--next (load u)
        t
    type-new-unit (sem--brk x)

=======
syn-sem-arg (sem (x t i) syn (x t) x t i)
do  syn      x t
    sem      x t i

syn-sem-args (sem (x t i) syn (x t) x o i)
and o
do  syn-sem-arg  sem syn x (pair-get-b pair-get-b o)      i
    syn-sem-args sem syn x (              pair-get-a o) (suc i)

syn-sem-call (sem (x n) sem-arg (x o i) sem-end (x n y) syn (x t) x t)
let (book-count (pair-get-a t)) n
let sem x n y
do  syn-sem-args sem-arg syn x (pair-get-a t) 1
    sem-end  x n y

# here we say what implementation to use #

sem-pre            (x    ) sem-impl-pre       x86_64-pre        (sem--book x) (sem--out   x)

sem-expr-lit       (x    ) sem-impl-lit       x86_64-lit        (sem--mem   x) (sem--type x) (token-get-span sem-get-token x) (sem--out  x)
sem-expr-str       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-str-end   (x a  ) sem-impl-str       x86_64-str        (sem--mem   x) (sem--type x) (token-get-span sem-get-token x) a (sem--out  x)
sem-expr-id        (x    ) sem-impl-ref       x86_64-id         (sem--type x) (sem-get-book x) (token-get-span sem-get-token x) (sem-get-impl x) (sem--out   x)
sem-expr-let       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-let-in    (x a  ) sem-impl-var-in    x86_64-let-in     (sem--mem   x) (sem--book x) (sem--impl x) a (token-get-span sem-get-token x) (sem-get-type x) (sem--out  x)
sem-expr-let-end   (x a  ) sem-impl-var-end   x86_64-let-end    (sem--mem   x) (sem--book x) (sem--impl x) a (sem--out  x)
sem-expr-for       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-for-in    (x a  ) sem-impl-var-in    x86_64-for-in     (sem--mem   x) (sem--book x) (sem--impl x) a (token-get-span sem-get-token x) (sem-get-type x) (sem--out  x)
sem-expr-for-end   (x a  ) sem-impl-var-end   x86_64-for-end    (sem--mem   x) (sem--book x) (sem--impl x) a (sem--out  x)
sem-expr-do        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-do-then   (x a  )                    x86_64-do         a (sem--out   x)
sem-expr-do-end    (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-and       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-and-then  (x a  )                    x86_64-je         a (sem--out   x)
sem-expr-and-end   (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-or        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-or-else   (x a  )                    x86_64-jne        a (sem--out   x)
sem-expr-or-end    (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-if        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-if-then   (x a  )                    x86_64-je         a (sem--out   x)
sem-expr-if-else   (x a  )                    x86_64-jmp        a (sem--out   x)
sem-expr-if-end    (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-call-with (x n  )                    x86_64-call-with  (sem--impl x) n (sem--out   x)
sem-expr-call-arg  (x t i) sem-impl-call-arg  x86_64-call-arg   (sem-get-type x) t i (sem--out   x)
sem-expr-call-end  (x n y) sem-impl-call-end  x86_64-call-end   (sem--mem   x) (sem--type x) (sem--impl x) y n (sem--out x)

# here we say what semantics to use for each expression #

syn-pre       (          x  ) syn-sem-pre  sem-pre                x

syn-expr-lit  (syn (x t) x t) syn-sem-unit sem-expr-lit           x
syn-expr-str  (syn (x t) x t) syn-sem-str  sem-expr-str
                                           sem-expr-str-end       x
syn-expr-id   (syn (x t) x t) syn-sem-unit sem-expr-id            x
syn-expr-let  (syn (x t) x t) syn-sem-var  sem-expr-let
                                           sem-expr-let-in
                                           sem-expr-let-end
										   syn
										   parse-id               x t
syn-expr-for  (syn (x t) x t) syn-sem-var  sem-expr-for
                                           sem-expr-for-in
                                           sem-expr-for-end
										   syn
										   parse-id               x t
syn-expr-do   (syn (x t) x t) syn-sem-seq  sem-expr-do
                                           sem-expr-do-then
                                           sem-expr-do-end    syn x t
syn-expr-and  (syn (x t) x t) syn-sem-seq  sem-expr-and
                                           sem-expr-and-then 
                                           sem-expr-and-end   syn x t
syn-expr-or   (syn (x t) x t) syn-sem-seq  sem-expr-or
                                           sem-expr-or-else
                                           sem-expr-or-end    syn x t
syn-expr-if   (syn (x t) x t) syn-sem-if   sem-expr-if
                                           sem-expr-if-then
                                           sem-expr-if-else
                                           sem-expr-if-end    syn x t
syn-expr-call (syn (x t) x t) syn-sem-call sem-expr-call-with
                                           sem-expr-call-arg
                                           sem-expr-call-end  syn x t

syn-expr-term (syn (x t) x t)
or  parse-builtin token-class-do  syn-expr-do  syn x t
or  parse-builtin token-class-if  syn-expr-if  syn x t
or  parse-builtin token-class-or  syn-expr-or  syn x t
or  parse-builtin token-class-and syn-expr-and syn x t
or  parse-builtin token-class-let syn-expr-let syn x t
or  parse-builtin token-class-for syn-expr-for syn x t
or  parse-atom    token-class-lit syn-expr-lit syn x t
or  parse-atom    token-class-str syn-expr-str syn x t
    parse-atom    token-class-id  syn-expr-id  syn x t

syn-expr-juxt (syn (x t) x t)
let (sem-get-type x)    u
and not type-equal t    u
and pair-get-b       u
    syn-expr-call syn x u

syn-expr-nest (syn (x t) x t)
if  parse-lp x
do  syn-expr-term syn x t
or  parse-rp x
do  syn-expr-juxt syn x t
or  parse-rp x
    err 4 "expected `)`"
if  syn-expr-term syn x t
    syn-expr-juxt syn x t
    err 5 "expected expression"

syn-expr (x t) syn-expr-nest syn-expr x t

>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7
# ebrew's declaration syntax #

params (ebrew-token-adv (x t g) x t g)
if  t
    ebrew-token-adv x t g
    do  ebrew-syn-expr x type-new-unit (sem--brk x)
        0

<<<<<<< HEAD
param-push-book (x t)
ebrew-sem-vardecl x (load (type--token t))

params-next (ebrew-token-adv (x t g) x t g)
let params ebrew-token-adv x (load t) g h
do  pop-book (sem--book x)
    h

register (ebrew-token-adv (x t g) x t reg g)
do  x86_64-push (sem--out x) (sem--impl x) reg
do  sem-set-type x t
do  param-push-book x t
    add 1 (params-next ebrew-token-adv x t g)

stack (x t g)
do  sem-set-type x t
do  let param-push-book x t o
        store struct-decl-impl load struct-name-decl o g
    params-next stack x t add 1 g

register-seq (ebrew-token-adv (x t g) reg x t g)
register ebrew-token-adv x t reg add 1 g

register5 (x t g) register-seq     stack "%r9"  x t 0
register4 (x t g) register-seq register5 "%r8"  x t g
register3 (x t g) register-seq register4 "%rcx" x t g
register2 (x t g) register-seq register3 "%rdx" x t g
register1 (x t g) register-seq register2 "%rsi" x t g
register0 (x t g) register-seq register1 "%rdi" x t g

decl-first (x) ebrew-sem-vardecl x (sem--token x)

decl-rest (x)
if	try-lookup (sem--book x) (sem--token x)
    err 7 "duplicate"
	decl-first x

parse-decls (which (x) x)
and token-caret-peek (sem--token x)
do  store (sem--impl x) 0
let (which x) o
do  ebrew-syn-param ebrew-syn-type x (struct-decl-type (load (struct-name-decl o)))
do  store struct-decl-isdef (load (struct-name-decl o)) not (token-eat-lit ebrew-token-adv sem--token x "?")
do  and load (struct-decl-isdef (load (struct-name-decl o)))
    do  put-string (sem--out x) x86_64-string-section-text
    do  x86_64-mangle-span  (sem--out x)  (token--span (struct-name-token o))
    do  put-lf (sem--out x)
    do  x86_64-mangle-span  (sem--out x)  (token--span (struct-name-token o))
    do  x86_64-label-suf (sem--out x)
    do  store (sem--impl x) (shl 63 1)
    do  x86_64-fpop (sem--out x) (sem--impl x) (params register0 x (load (type--arg (load (struct-decl-type (load (struct-name-decl o)))))) 0)
        put-line (sem--out x) "ret"
    parse-decls decl-rest x

parse-ebrew (x)
do  ebrew-sem-impl-pre x
    parse-decls decl-first x

main (in out brk)
let (alloc addr brk struct-sem) x
do  store (sem--book x) 0
do  store (sem--out  x) out
do  store (sem--brk  x) brk
do  ebrew-token-init (sem--token x) in
do  parse-ebrew x
    load (sem--out x)

pow2 (n) shl n 1
=======
params-next (next (x o y) x o y)
let params next x (pair-get-a o) y h
do  store (sem--book x) (pair-get-a sem-get-book x)
    h

param-name-push (x o y)
let (pair-get-b o) d
    store (sem--book x) (var-push (sem--mem x) (sem-get-book x) (token-get-span pair-get-a d) (pair-get-b d) y)

register (next (x o y) x o reg y)
do  x86_64-push (sem--impl x) reg (sem--out x)
do  param-name-push x o (sem-get-impl x)
    suc (params-next next x o y)

stack (x o y)
do  param-name-push   x o y
    params-next stack x o (suc y)

register-seq (next (x o y) reg x o y) register next x o reg (suc y)

register5 (x o y) register-seq     stack "%r9"  x o 0
register4 (x o y) register-seq register5 "%r8"  x o y
register3 (x o y) register-seq register4 "%rcx" x o y
register2 (x o y) register-seq register3 "%rdx" x o y
register1 (x o y) register-seq register2 "%rsi" x o y
register0 (x o y) register-seq register1 "%rdi" x o y

syn-body (x d)
if  try-name-lookup (sem-get-book x) (token-get-span pair-get-a d)
    err 6 "redefinition"
do  store (sem--book x) (var-push (sem--mem x) (sem-get-book x) (token-get-span pair-get-a d) (pair-get-b d) 0)
do  pair-get-b sem-get-book x
or  parse-qm x
do  x86_64-decl-in  (sem--impl x) (token-get-span pair-get-a d) (sem--out x)
let (params register0 x (pair-get-a pair-get-b d) 0) y
	x86_64-decl-end (sem--impl x) y (sem--out x)

syn-decl-seq (syn (x) x)
and token-class-id (sem-get-token x)
let (             syn x) d
let (syn-decl-seq syn x) o
	pair-new (sem--mem x) o d

syn-decl-type (syn (x) x)
if  parse-lp x
let (syn-decl-seq syn x) o
if  parse-rp x
    type-new-function (sem--mem x) o
    err 7 "expected `)`"
    type-new-unit     (sem--mem x)

syn-decl (x)
let token-clone (sem--mem x) (sem-get-token x) k
do  parse-id x
    pair-new (sem--mem x) k (syn-decl-type syn-decl x)

syn-def (x) syn-body x (syn-decl x)

syn-defs (x) for 0 _ parse-decl token-class-id syn-def x

syn (x) do syn-pre x syn-defs x

main (in out x)
do  store (sem--mem x) add x struct-sem
do  store (sem--out x) out
do  store (token--caret sem-get-token x) in
do  eat (token--caret sem-get-token x) (token-get-span sem-get-token x)
do  syn x
    (sem-get-out x)
>>>>>>> 84c90983828d5c2a6bfa5f87ff3df627402675e7

_start ()
runtime main
    pow2 24
    pow2 20
    pow2 23
