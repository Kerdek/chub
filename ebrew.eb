type
  Type {
    s      @Type
    a      @Type
    kp     @byte
    kn      byte
    kind    byte
    size    byte
    offset  byte
    align   byte
  }

  T @Type

  Ctx {
    s       @Ctx
    t       @Type
    line     nat
    col      nat
    c        nat
    pline   @byte
    p       @byte
    q       @byte
    curbrk  @byte
    kp      @byte
    kn       byte
    l        byte
    is_type  byte
    is_def   byte
    is_local byte
  }

  X @Ctx
;

type iofn (p @byte n nat) nat;

ioread  iofn = read p n
iowrite iofn = write p n
ioretry (p @byte q @byte io @iofn) none = { p for i io@ i (q - i) is n n then &i^n }

initbrk (n nat) nat = { brk 0 is i brk (i + n) i }

xcpy (xa X xb X it nat il nat id nat) none = {
  memcpy cast @byte xa cast @byte xb sizeof Ctx
  (xa.s = xb.s)
  (xb.s = xa )
  (xb.s.is_type  = cast byte it)
  (xb.s.is_local = cast byte il)
  (xb.s.is_def   = cast byte id)
}

try_lookup (x X) X = {
  cast X 0 is xb
  { x.s then
    x.s for s
    (s.kn != x.kn or not strncmp s.kp x.kp cast nat x.kn) ?
      s.s
      { (xb = s)
        cast X 0 } }
  xb
}

xpush (x X it nat il nat id nat f @(x X o X) none) none = {
  try_lookup x is o
  some Ctx xb
  xcpy &xb x it il id
  f@ x o
}

xalloc (x X n nat) @none = alloc n &x.curbrk

oglf(x X       c @(x X c byte) none) none = c@ x '\n'
ogn1(x X n nat c @(x X c byte) none) none = { n then ogn1 x (n / 10) c c@ x cast byte ('0' + n % 10) }
ogn (x X n nat c @(x X c byte) none) none = { n ? ogn1 x n c c@ x '0' }

gc (x X c byte ) none = { (x.q@ = c) (x.q = &x.q^1) }
gs (x X s @byte) none = { s for p p@ then gc x p@ &p^1 }
gsn(x X xb X) none = { 0 for m (m < xb.kn) then gc x xb.kp^m (m + 1) }
glf (x X      ) none = oglf x   &gc
gn  (x X n nat) none = ogn  x n &gc

oc (x X c byte       ) none = err &c 1
os (x X s @byte      ) none = err s strlen s
osn(x X s @byte n nat) none = err s n
olf (x X      ) none = oglf x   &oc
on  (x X n nat) none = ogn  x n &oc

diag (x X s @byte) none = {
  { x.kp for q (q@ and q@ != '\n') then (&q^1) } is end_line
  oc x '(' on x x.line oc x ',' on x x.col os x "): " osn x x.pline (end_line - x.pline)
  os x s olf x
  exit 1
}

lookup (x X) X = {
  try_lookup x else
  diag x "lookup failed"
}

make_type(x X size nat align nat kind nat) T = {
  cast T xalloc x sizeof Type is t
  (t.s = 0)
  (t.size  = size  )
  (t.align = align )
  (t.kind = cast byte kind)
  t
}

make_type_a(x X size nat align nat kind nat a T) T = {
  make_type x size align kind is t
  (t.a = a)
  t
}

nnone (x X    ) T = make_type   x 0 0 0
nbyte (x X    ) T = make_type   x 1 1 1
nnat  (x X    ) T = make_type   x 8 8 2
nstct (x X    ) T = make_type   x 0 1 3
nptr  (x X a T) T = make_type_a x 8 8 4 a
nfunc (x X a T) T = make_type_a x 1 1 5 a

type_equal(t T u T) nat = {
  t then
  u then
  (t == u) else
  { (t.kind == u.kind) then
    (t.kind == 0) else
    (t.kind == 1) else
    (t.kind == 2) else
    (t.kind == 4) ? type_equal t.a u.a
    (t.kind == 6) ? type_equal t.a u.a
    (t.kind == 7) ? type_equal t.a u.a
      { (t.kind == 5 ) then
        t.a is p
        u.a is q
        { 1 for _
          type_equal p q then
          (p = p.s)
          (q = q.s)
          1 }
        (p == q) } }
}

issp (c byte    ) nat = (c == ' ' )
istb (c byte    ) nat = (c == '\t')
islf (c byte    ) nat = (c == '\n')
iscr (c byte    ) nat = (c == '\r')
is_  (c byte    ) nat = (c == '_' )

isin (c byte a byte b byte) nat = (a <= c and c <= b)

isAZ (c byte    ) nat = isin c 'A' 'Z'
isaz (c byte    ) nat = isin c 'a' 'z'
is09 (c byte    ) nat = isin c '0' '9'
isaf (c byte    ) nat = isin c 'a' 'f'
isws (c byte    ) nat = { issp c else
                          istb c else
                          islf c else
                          iscr c      }
is0f (c byte    ) nat = { is09 c else
                          isaf c      }
isid (c byte    ) nat = { isAZ c else
                          isaz c else
                          is09 c else
                          is_  c      }

caret_is      (x X c byte) nat  = (x.p@ == c)
caret_next_is (x X c byte) nat  = { (x.p@ or diag x "unexpected end of file") (x.p^1 == c) }

caret_advance (x X) none = {
  (x.p@ or diag x "unexpected end of file")
  (x.p = &x.p^1)
  caret_is x '\n' ? {
    (x.col = 1)
    (x.line = x.line + 1)
    (x.pline = &x.p^1)
  } (x.col = x.col + 1)
}

comment(x X) nat = {
  (caret_is x '/' and caret_next_is x '*') then
  caret_advance x
  caret_advance x
  { 1 for _
    (caret_is x '*' and caret_next_is x '/') ?
      { caret_advance x caret_advance x 0 }
      { caret_advance x        1 } }
  1
}

number(x X) nat = {
  x.p is q
  { 1 for _ is09 x.p@ then caret_advance x 1 }
  (x.p != q) then
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

string(x X) nat = {
  caret_is x '"' then
  x.p is q
  caret_advance x
  { 1 for _
    { 1 for _ caret_is x '\\' then caret_advance x caret_advance x 1}
    (caret_is x '\n' and diag x "newline in string literal")
    not caret_is x '"' then
    caret_advance x
    1
  }
  caret_advance x
  (x.kp = q)
  (x.kn = x.p - q)
  gs x ".section .text..s" gn x (x.line * 10000 + x.col) glf x
  gs x ".s" gn x (x.line * 10000 + x.col) gc x ':' gs x ".string \""
  { &x.kp^1 for i (i < &x.kp^(x.kn - 1)) then gc x i@ &i^1 }
  gc x '\"' glf x
  gs x ".previous" glf x
  1
}

char(x X) nat = {
  caret_is x '\'' then
  x.p is q
  caret_advance x
  { caret_is x '\\' then
    caret_advance x }
  caret_advance x
  (caret_is x '\'' or diag x "expected '")
  caret_advance x
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

id (x X) nat = {
  x.p is q
  { 1 for _ isid x.p@ then caret_advance x 1 }
  (x.p != q) then
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

sw1 (x X a byte       ) nat = { caret_is x a then caret_advance x 1 }
sw2 (x X a byte b byte) nat = { caret_is x a then caret_next_is x b then caret_advance x caret_advance x 1 }

punct (x X) nat = {
  x.p is q
  { sw2 x '=' '=' else
    sw2 x '!' '=' else
    sw2 x '<' '=' else
    sw2 x '>' '=' else
    sw2 x '<' '-' else
    sw2 x '-' '>' else
    sw2 x '<' '<' else
    sw2 x '>' '>' else
    sw2 x '/' '/' else
    sw1 x '='     else
    sw1 x '<'     else
    sw1 x '>'     else
    sw1 x '+'     else
    sw1 x '-'     else
    sw1 x '*'     else
    sw1 x '/'     else
    sw1 x '&'     else
    sw1 x '|'     else
    sw1 x '@'     else
    sw1 x '#'     else
    sw1 x '{'     else
    sw1 x '}'     else
    sw1 x '('     else
    sw1 x ')'     else
    sw1 x '['     else
    sw1 x ']'     else
    sw1 x '!'     else
    sw1 x '?'     else
    sw1 x ':'     else
    sw1 x ';'     else
    sw1 x ','     else
    sw1 x '.'     else
    sw1 x '~'     else
    sw1 x '^'     else
    sw1 x '$'     else
    sw1 x '`'     else
    sw1 x '%'
  }
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

eof (x X) nat = {
  not x.p@ then
  (x.kp = cast @byte 0)
  1
}

ws (x X) nat = {
  1 for _
  comment x else
  isws x.p@ then
  caret_advance x
  1
}

token (x X) none = {
  ws     x
  eof    x else
  number x else
  string x else
  char   x else
  id     x else
  punct  x else
  diag x "invalid token"
}

token_advance (x X        ) none = { (x.kp or diag x "unexpected end of tokens") token x }
token_is      (x X c @byte) nat  = { x.kp then memcmp c x.kp cast nat x.kn then not c^x.kn }
token_expect  (x X c @byte) none = { { not token_is x c then diag x "unexpected" } token_advance x }
token_eat     (x X c @byte) nat  = { token_is x c is r { r then token_advance x } r }

argreg (d nat) @byte = {
  (d == 0) ? "rdi"
  (d == 1) ? "rsi"
  (d == 2) ? "rdx"
  (d == 3) ? "rcx"
  (d == 4) ? "r8"
             "r9"
}

gtreg (x X s @byte                ) none = { gc x '%' gs x s }
gt0   (x X s @byte                ) none = { gs x s glf x  }
gt1   (x X s @byte a @byte        ) none = { gs x s gc x ' ' gtreg x a glf x }
gt2   (x X s @byte a @byte b @byte) none = { gs x s gc x ' ' gtreg x a gc x ',' gtreg x b glf x }

gtz  (x X a @byte) none = gt2 x "xor"  a a
gtcz (x X a @byte) none = gt2 x "test" a a

gtlit (x X l nat a @byte) none = (l ? { gs x "mov $" gn x l gc x ',' gtreg x a glf x } gtz x a)

gtnot (x X a @byte) none = gt1 x "not" a
gtneg (x X a @byte) none = gt1 x "neg" a
gmul  (x X a @byte) none = gt1 x "mul" a
gdiv  (x X        ) none = { gtz x "edx" gt1 x "div" "rdi" }
gmod  (x X        ) none = { gdiv x gt2 x "mov" "rdx" "rax" }
gshx  (x X k byte ) none = { gt2 x "mov" "dil" "cl" gs x "sh" gc x k gs x " %cl,%rax" glf x }

gadd (x X a @byte b @byte) none = gt2 x "add" a b
gsub (x X a @byte b @byte) none = gt2 x "sub" a b
gand (x X a @byte b @byte) none = gt2 x "and" a b
gor  (x X a @byte b @byte) none = gt2 x "or"  a b
gxor (x X a @byte b @byte) none = gt2 x "xor" a b
gcmp (x X a @byte b @byte) none = gt2 x "cmp" a b
gshr (x X ) none = gshx x 'r'
gshl (x X ) none = gshx x 'l'

gpromote(x X b @byte) none = gt2 x "movzbl" "al" b

gsetf     (x X s @byte         b @byte        ) none = { gs x "set" gs x s gc x ' ' gtreg x "al" glf x gpromote x b }
gcmp_setf (x X s @byte a @byte b @byte c @byte) none = { gcmp x a b gsetf x s c }
gcmpz_setf(x X s @byte a @byte b @byte        ) none = { gtcz x a   gsetf x s b }
glnot     (x X         a @byte b @byte        ) none = { gcmpz_setf x "e" a b }

gj        (x X n nat l @byte        ) none = { gs x "jmp " gs x l gn x n gc x '$' glf x }
gjc       (x X n nat l @byte s @byte) none = { gs x "j" gs x s gc x ' ' gs x l gn x n gc x '$' glf x }
glabel    (x X n nat l @byte        ) none = { gs x l gn x n gs x "$:" glf x }

gje  (x X n nat l @byte) none = gjc x n l "e"
gjne (x X n nat l @byte) none = gjc x n l "ne"
gjb  (x X n nat l @byte) none = gjc x n l "b"
gjbe (x X n nat l @byte) none = gjc x n l "be"
gja  (x X n nat l @byte) none = gjc x n l "a"
gjae (x X n nat l @byte) none = gjc x n l "ae"

gegcmp(x X s @byte) none = gcmp_setf x s "rdi" "rax" "eax"

gfpop (x X l nat  ) none = { l then gs x "add $" gn x (l << 3) gc x ',' gtreg x "rsp" glf x (x.c = x.c + l) }
gfpush(x X l nat  ) none = gfpop x -l

gpush (x X d @byte) none = { gt1 x "push" d (x.c = x.c - 1) }
gpop  (x X s @byte) none = { gt1 x "pop"  s (x.c = x.c + 1) }

gindex(x X l nat) none = { l then gs x "add $" gn x l gc x ',' gtreg x "rax" glf x }

gcast (x X) none = {
  (x.t.kind == 0) ?
    gtz x "eax"
    { (x.t.kind == 1) then
      gpromote x "eax" }
}

gaddr (x X t T n nat s @byte d @byte) none = {
  (n or not strcmp s d) then
  gs x "lea " { n then gn x n } gs x "(%" gs x s gs x "),%" gs x d glf x
}

gload (x X t T n nat s @byte d @byte) none = {
  (t.kind == 1) ?
    { gs x  "movzbq " gn x n gs x "(%" gs x s gs x "),%" gs x  d glf x }
    { gs x  "mov "    gn x n gs x "(%" gs x s gs x "),%" gs x  d glf x }
}

gstore (x X t T d @byte) none = {
  (t.kind == 1) ?
    { gs x "mov %al,(%"  gs x d gc x ')' glf x }
    { gs x "mov %rax,(%" gs x d gc x ')' glf x }
}

geval (x X l nat) none = {
  x.l for l2
  (l2 > l) then
  (l2 == 1 and l == 0) ?
    (x.t.kind == 5 or x.t.kind == 3 or gload x x.t 0 "rax" "rax")
    { gt0 x "mov (%rax),%rax" }
  (l2 - 1)
}

geret (x X t T l nat) nat = {
  (x.t = t)
  (x.l = l)
  1
}

g1ops (x X p@ (x X) nat) nat = {
  p@ x
  geval x 0
  geret x nnat x 0
}

g2ops (x X p@ (x X) nat) nat = {
  geval x 0
  gpush x "rax"
  p@ x
  geval x 0
  gt0 x "mov %rax,%rdi"
  gpop x "rax"
  geret x nnat x 0
}

xhash (x X) nat = (x.line * 10000 + x.col)

ge  (x X) nat = gegcmp x "e" 
gne (x X) nat = gegcmp x "ne"
gb  (x X) nat = gegcmp x "b" 
gbe (x X) nat = gegcmp x "be"
ga  (x X) nat = gegcmp x "a" 
gae (x X) nat = gegcmp x "ae"

glocal (x X p@ (x X) nat) none = {
  some Ctx xb
  xcpy &xb x 0 1 0
  token_advance x
  p@ x
  (x.s = x.s.s)
}

gss (x X gjc@ (x X n nat c @byte) none p@ (x X) nat) none = {
  xhash x is n
  geval x 0
  gtcz x "rax"
  gjc@ x n "a"
  gpush x "rax"
  p@ x
  geval x 0
  gpop x (x.t.kind ? "rdx" "rax")
  glabel x n "a"
}

gpt (x X t T) nat = {
  gs x "mov $" gsn x x gs x ",%rax" glf x
  token_advance x
  geret x t 0
}

ptype (x X) T
p2 (x X) nat
p3 (x X) nat
p4 (x X) nat
p5 (x X) nat
p8 (x X) nat

gsys3 (x X fd nat id nat) nat = {
  p3 x
  geval x 0
  gpush x "rax"
  p3 x
  geval x 0
  gpop x "rsi"
  gt2 x "mov" "rax" "rdx"
  gtlit x fd "rdi"
  gtlit x id "rax"
  gt0 x "syscall"
  geret x nnat x 0
}

align(n nat a nat) nat = ((n + a - 1) / a * a)

param (x X t @@Type) none = {
  (t@ = cast @Type xalloc x sizeof Type)
  (t.kp = x.kp)
  (t.kn = x.kn)
  token_advance x
  ptype x is u
  (t.a = u.a)
  (t.kind = u.kind)
  (t.size = u.size)
  (t.align = u.align)
  (t.offset = u.offset)
}

pstruct (x X) @Type = {
  nstct x is t
  &t.a is u
  { 1 for _
    not token_eat x "}" then
    param x u
    (u = &u.s) }
  0 is bits
  { t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

pfunc (x X) @Type = {
  cast T 0 is params
  &params is u
  { 1 for _
    not token_is x ")" then
    param x u
    (u = &u.s)
    1 }
  token_advance x
  ptype x is ret
  nfunc x cast @Type xalloc x sizeof Type is t
  memcpy cast @byte t.a cast @byte ret sizeof Type
  (t.a.s = params)
  t
}

ptype (x X) @Type = {
  token_eat x "none"   ? nnone       x
  token_eat x "byte"   ? nbyte       x
  token_eat x "nat"    ? nnat        x
  token_eat x "@"      ? nptr        x ptype x
  token_eat x "("      ? pfunc x
  token_eat x "{"      ? pstruct x
  { lookup x is xb
    (xb.is_type or diag x "not a type")
    token_advance x
    xb.t }
}

token_is_id     (x X) nat = (isaz x.kp@ or isAZ x.kp@)
token_is_string (x X) nat = (x.kp@ == '\"')
token_is_byte   (x X) nat = (x.kp@ == '\'')
token_is_number (x X) nat = is09 x.kp@

p1 (x X) nat = {
  { token_is_number x then gpt x nnat  x } else
  { token_is_byte   x then gpt x nbyte x } else
  { token_is_string x then
    gs x "mov .s" gn x xhash x gs x "@GOTPCREL(%rip),%rax" glf x
    token_advance x
    geret x nptr x nbyte x 0 } else
  { token_eat x "("       then p8 x ret token_expect x ")" } else
  { token_eat x "{"       then p5 x ret token_expect x "}" } else
  { token_eat x "&"       then p2 x geret x nptr x x.t (x.l - 1) 1 } else
  { token_eat x "-"       then g1ops x &p3 ret gtneg x "rax"       } else
  { token_eat x "not"     then g1ops x &p3 ret glnot x "rax" "eax" } else
  { token_eat x "read"    then gsys3 x 0 0 } else
  { token_eat x "write"   then gsys3 x 1 1 } else
  { token_eat x "err"     then gsys3 x 2 1 } else
  { token_eat x "cast" then
    ptype x is t
    p4 x
    geval x 0
    gcast x
    geret x t 0 } else
  { token_eat x "sizeof" then
    ptype x is t
    gtlit x cast nat t.size "rax"
    geret x nnat x 0 } else
  { token_eat x "exit" then
    p3 x
    geval x 0
    gt2 x "mov" "rax" "rdi"
    gtlit x 60 "rax"
    gt0 x "syscall"
    geret x nnone x 0 } else
  { token_eat x "gettime" then
    p3 x
    geval x 0
    gpush x "rax"
    p3 x
    geval x 0
    gt2 x "mov" "rax" "rsi"
    gpop x "rdi"
    gtlit x 228 "rax"
    gt0 x "syscall"
    geret x nnat x 0 } else
  { token_eat x "brk" then
    p3 x
    geval x 0
    gt0 x "mov %rax,%rdi"
    gtlit x 12 "rax"
    gt0 x "syscall"
    geret x nptr x nbyte x 0 } else
  { token_eat x "some" then
    (x.t = ptype x)
    (x.t.size + 7 >> 3) is d
    gfpush x d
    some Ctx xb
    xcpy &xb x 0 1 0
    token_advance x
    p5 x
    (x.s = x.s.s)
    geval x 0
    gfpop x d
    geret x x.t 0 } else
  { token_is_id x then
    lookup x is xb
    (xb.is_type and diag x "not a variable")
    geret x xb.t 1
    xb.is_local ?
      { gaddr x x.t (xb.c - x.c << 3) "rsp" "rax" }
      { gs x "mov " gsn x x gs x "@GOTPCREL(%rip),%rax" glf x }
    token_advance x } else
  diag x "expected an expression"
}

p2 (x X) nat = {
  p1 x for _
  { token_eat x "@" then geret x x.t.a (x.l + 1) } else
  { token_eat x "^" then
    x.t is t
    geval x 0
    gpush x "rax"
    p3 x
    geval x 0
    gpop x "rdi"
    gs x "lea (%rdi,%rax," gn x cast nat t.a.size gs x "),%rax" glf x
    geret x t.a 1 } else
  { token_eat x "." then
    geval x 0
    { x.t for t
      { (t.kind == 4) then
        (t.a.kind == 3) ?
          { gs x "lea (%rax),%rax" glf x }
          { gs x "mov (%rax),%rax" glf x }
        t.a } else
      { (t.kind == 6) then
        (t.a.kind == 3) ?
          { gs x "lea " gn x -(x.c << 3) gs x "(%rsp,%rax),%rax" glf x }
          { gs x "mov " gn x -(x.c << 3) gs x "(%rsp,%rax),%rax" glf x }
        t.a }
    } is t
    (t.kind != 3 and diag x "not a struct")
    cast T 0 is g
    { t.a for a
      { (a.kn == x.kn) then strncmp a.kp x.kp cast nat x.kn }
      ? { (g = a) cast T 0 }
        a.s }
    (g or diag x "no such member")
    token_advance x
    gindex x cast nat g.offset
    geret x g 1 }
}

p3 (x X) nat = {
  p2 x for _
  (x.t.kind == 5) then
  geval x 0
  x.c is c
  0 is d
  x.t is t
  { t.a.s then
    t.a.s for u
    (d = d + 1)
    u.s }
  gfpush x d
  gpush x "rax"
  8 is off
  { t.a.s then
    t.a.s for u
    p3 x
    (type_equal x.t u or diag x "asymmetric argument")
    geval x 0
    { (u.kind == 6) then
      gs x "add $" gn x ((-c + ((d > 6) ? (d - 5) 1)) << 3) gs x ",%rax" glf x }
    gs x "mov %rax," gn x off gs x "(%rsp)" glf x
    (off = off + 8)
    u.s }
  gpop x "rax"
  { 0 for i
    (i < d and i < 6) then
    gpop x argreg i
    (i + 1) }
  gt0 x "call *%rax"
  (x.c = c)
  geret x t.a 0
}

p4 (x X) nat = {
  p3 x for _
  { token_eat x "?" then
    xhash x is n
    geval x 0
    gtcz x "rax"
    gje x n "a"
    p4 x
    geval x 0
    gj x n "b"
    glabel x n "a"
    p4 x
    geval x 0
    glabel x n "b"
    geret x x.t 0 }
}

p5 (x X) nat = {
  p4 x for _
  { token_eat x "ret" then
    x.t is t
    geval x 0
    gpush x "rax"
    p5 x
    gpop x "rax"
    geret x t 0 } else
  { token_eat x "is" then
    geval x 0
    gpush x "rax"
    glocal x &p5
    geval x 0
    gpop x "rdx"
    geret x x.t 0
    1 } else
  { token_eat x "for" then
    xhash x is n
    geval x 0
    gpush x "rax"
    gj x n "b"
    glabel x n "a"
    gstore x x.t "rsp"
    glabel x n "b"
    glocal x &p5
    geval x 0
    gtcz x "rax"
    gjne x n "a"
    gpop x "rax"
    geret x x.t 0 } else
  { token_eat x "then" then
    gss x &gje &p5
    geret x x.t 0 } else
  { token_eat x "else" then
    x.t is t
    gss x &gjne &p5
    geret x t 0 } else
  { not token_is x "}" then
    p5 x }
}

pmul (x X) nat = {
  p4 x for _
  { token_eat x "*" then g2ops x &p4 gmul x "rdi" 1 } else
  { token_eat x "/" then g2ops x &p4 gdiv x       1 } else
  { token_eat x "%" then g2ops x &p4 gmod x       1 }
}

padd  (x X) nat = {
  pmul x for _
  { token_eat x "+" then g2ops x &pmul gadd x "rdi" "rax" 1 } else
  { token_eat x "-" then g2ops x &pmul gsub x "rdi" "rax" 1 }
}

psh (x X) nat = {
  padd x for _
  { token_eat x "<<" then g2ops x &padd gshl x 1 } else
  { token_eat x ">>" then g2ops x &padd gshr x 1 }
}

pcmp (x X) nat = {
  psh x for _
  { token_eat x "<"  then g2ops x &psh gb  x 1 } else
  { token_eat x ">"  then g2ops x &psh ga  x 1 } else
  { token_eat x "<=" then g2ops x &psh gbe x 1 } else
  { token_eat x ">=" then g2ops x &psh gae x 1 } else
  { token_eat x "==" then g2ops x &psh ge  x 1 } else
  { token_eat x "!=" then g2ops x &psh gne x 1 }
}

pland (x X) nat = {
  pcmp x for _
  token_eat x "and" then
  gss x &gje &pcmp
  geret x x.t 0
}

plor (x X) nat = {
  pland x for _
  token_eat x "or" then
  x.t is t
  gss x &gjne &pland
  geret x t 0
}

p7 (x X) nat = {
  plor x for _
  token_eat x "as" then
  geval x 0
  gcast x
  geret x ptype x 0
}

p8 (x X) nat = {
  p7 x for _
  token_eat x "=" then
  x.t is t
  geval x 1
  gpush x "rax"
  p7 x
  geval x 0
  gpop x "rdx"
  gstore x t "rdx"
  geret x nnone x 0
  1
}

stack_params(x X t T g nat) nat = {
  not t ? { p4 x geval x 0 0 }
    { some Ctx xb
      xcpy &xb x 0 1 0
      (x.s.kp = t.kp)
      (x.s.kn = t.kn)
      (x.s.c  = g)
      (x.s.t   = t)
      stack_params x t.s (g + 1) ret
      (x.s = x.s.s) }
}

register_params (x X t T g nat) nat = {
  not t ? { p4 x geval x 0 0 }
    { gpush x argreg g
      some Ctx xb
      xcpy &xb x 0 1 0
      (x.s.kp = t.kp)
      (x.s.kn = t.kn)
      (x.s.t = t)
      (((g == 5) ? &stack_params &register_params)@ x t.s (g + 1) + 1) ret
      (x.s = x.s.s) }
}

maybe (x X next @(x X) none) none = { next then next@ x }

type_declaration     (x X) none
function_declaration (x X) none

decl (x X) @(x X) none = { x.kp then token_eat x "type" ? &type_declaration &function_declaration }

maybedecl (x X) none = maybe x decl x

function_declaration2 (x X o X) none = {
  param x &x.s.t
  (x.s.is_def = token_is x "=")
  (not o or not o.is_type and not o.is_def and x.s.is_def or diag x "remention")
  { x.s.is_def then
    gs x ".section .text." gsn x x.s glf x
    gsn x x.s gc x ':' glf x
    token_advance x
    (x.c = 0)
    x.curbrk is brka
    register_params x x.s.t.a.s 0 is stack
    /* free everything we used for that */
    (x.curbrk = brka)
    gfpop x stack
    gt0 x "ret" }
  maybedecl x
}

type_declaration2 (x X o X) none = {
  param x &x.s.t
  (o and diag x "remention")
  token_eat x ";" ? maybedecl x type_declaration x
}

function_declaration (x X) none = xpush x 0 0 0 &function_declaration2
type_declaration     (x X) none = xpush x 1 0 0 &type_declaration2

compile (x X) none = {
  gs x ".globl _start\n"
  token x
  maybedecl x
}

type
  Time {
    s nat
    n nat
  }
;

milliseconds (ta @Time tb @Time) nat = ((tb.s - ta.s) * 1000000 + (tb.n - ta.n) / 1000)

bench (x X f @(x X) none) none = {
  some Time ta
  gettime 1 &ta
  x.curbrk is brka

  f@ x

  some Time tb
  gettime 1 &tb
  x.curbrk is brkb

  on x (brkb - brka) os x " heap" os x " / " on x milliseconds &ta &tb os x " us" olf x
}

chat (x X) none = {
  ioretry x.p &x.p^(1 << 20) &ioread
  x.q is iq
  bench x &compile
  ioretry iq x.q &iowrite
}

init_context(x X inbuf nat outbuf nat heap nat) none = {
  (x.curbrk = initbrk          (  (1 << inbuf )
                                + (1 << outbuf)
                                + (1 << heap  )))
  (x.s      = 0                                 )
  (x.p      = cast @byte xalloc x (1 << inbuf ) )
  (x.q      = cast @byte xalloc x (1 << outbuf) )
  (x.pline  = x.p                               )
  (x.line   = 1                                 )
  (x.col    = 1                                 )
}

main (x X) none = { init_context x 20 23 16  chat x }

_start ()    none = { some Ctx x  main &x  exit 0 }