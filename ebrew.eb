# external data functions #

(word) ?

(peek -byte) ?
(load -word) ?

(poke  -byte byte) ?
(store -word word) ?

# external arithmetic functions #

(neg n) ?
(not n) ?

(add  a b) ?
(sub  a b) ?
(mul  a b) ?
(div  a b) ?
(mod  a b) ?
(shl  a b) ?
(cmpa a b) ?
(cmpe a b) ?

# external io #

(linux rdi rsi rdx rcx r8 r9 rax) ?

# basic math #

(cmpex n a b) or (cmpa n a) (cmpa b n)
(cmpin n a b) not (cmpex n a b)

(suc n) add 1 n
(prd n) sub 1 n

(pow2 n) shl n 1

(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)

(inc -n) to -n add 1
(dec -n) to -n sub 1

# strings #

(strlen s) and (peek s) (suc (strlen (suc s)))

(memcmp a b n)
or  not n
and cmpe (peek a) (peek b)
    memcmp (suc a) (suc b) (prd n)

# basic io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (cmpe i error-key)
let byte-count (io i (sub i end))
and byte-count
if  cmpe byte-count error-key
    byte-count
    add i byte-count

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code out end) do (retry-mem stdout out end) (exit code)

(runtime (main (exit code out end) in out mem top) inbuf outbuf membuf)
let in  (brk 0)
let out (add in  inbuf )
let mem (add out outbuf)
let top (brk add mem membuf)
do  retry-string-read stdin in out
    main runtime-exit in out mem top

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# basic data #

(dword) add word word

(pair--a pair)     pair
(pair--b pair) add pair word
(set-a pair a) do (store (pair--a pair) a) pair
(set-b pair b) do (store (pair--b pair) b) pair
(get-a pair) load (pair--a pair)
(get-b pair) load (pair--b pair)
(set-pair pair a b) set-b (set-a pair a) b
(pair-new -mem a b) set-pair (to -mem add dword) a b
(pair-clone -mem span) pair-new -mem (get-a span) (get-b span)

# basic formatting #

(put c out)
let p load out
do  poke p c
do  store out (add 1 p)
    out

(put-digit-16 n out) put (add n (if (cmpa n 10) '0 '7)) out
(put-digit-10 n out) put (add n                 '0    ) out

(put-digits (put-digit n out) base n out)
if  n
    put-digit                 (mod base n)
    put-digits put-digit base (div base n)
    out
    out

(put-number (put-digit n out) base n out)
if  n 
    put-digits put-digit base n out
    put '0 out

(put-dec n out) put-number put-digit-10 10 n out
(put-hex n out) put-number put-digit-16 16 n out

(vput-mem (put a out) a b out)
do  for i a
    and cmpa i b
    do  put (peek i) out
        suc i
    out

(vput-string (put a out) s out)
do  for p s
    let a (peek p)
    and a
    do  put a out
        suc p
    out

(put-string s out) vput-string put s out

# basic scanning #

(eat-bunch (body -caret) -caret) 
for _ 0 body -caret

(eat-grou  (delim -caret) (body -caret) -caret)
and delim -caret
    body  -caret

(eat-group (delim -caret) (body -caret) -caret)
and delim -caret
do  eat-bunch body -caret
    delim -caret

# basic lexing #

(lex-normal (char-class byte) -caret)
and char-class (peek (load -caret))
    store -caret (suc (load -caret))

(lex-escape (class byte) (class-normal byte) (class-alternate byte) -caret)
if  lex-normal class           -caret
    lex-normal class-alternate -caret
    lex-normal class-normal    -caret

# character classification #

(char-negclass (class byte) (except byte) byte)
and except byte
not class  byte

# spans #

(span-equal a b)
let ap (get-a a)
let bp (get-a b)
let an (sub ap (get-b a))
let bn (sub bp (get-b b))
and cmpe an bn
    memcmp ap bp bn

(span-strcmp s lit)
let start (get-a s)
let n (sub start (get-b s))
and memcmp lit start n
    not (peek (add lit n))

(span-set span a b) set-pair span a b
(span-new -mem a b) pair-new -mem a b
(span-clone -mem span) pair-clone -mem span
(vput-span (vput a out) s out) vput-mem vput (get-a s) (get-b s) out
(put-span s out) vput-span put s out

# bookkeeping #

(book-lookup (line-match hay needle) book needle)
and book
let line (get-a book)
if  line-match (get-a line) needle
    get-b line
    book-lookup line-match (get-b book) needle

(book-equal (line-equal a b) a b)
or  cmpe a b
and line-equal (get-b get-a a) (get-b get-a b)
    book-equal line-equal (get-b a) (get-b b)

(book-new -mem next line) pair-new -mem line next
(book-count book) and book (suc (book-count (get-b book)))
(book-pop -book) store -book (get-b (load -book))

# tokens #

(token-take (token-class k) (eat -caret span) -mem token)
and token-class token
let span (span-clone -mem (get-a token))
do  eat (pair--b token) (get-a token)
    span

(token-eat (eat -caret span) token) eat (pair--b token) (get-a token)

(token-init (eat -caret span) -mem -in -token)
let token (to -mem add dword)
do  set-pair token pair-new -mem 0 0 -in
do  token-eat eat token
    store -token token

(token-skip (token-class k) (eat -caret span) token) and (token-class token) token-eat eat token
(token-clone -mem token) pair-new -mem (span-clone -mem (get-a token)) (get-b token)
(token-match (lex c) token) lex (peek (get-a (get-a token)))
(token-is s token) span-strcmp (get-a token) s
(token-read (text -caret) -caret span) let caret (load -caret) (span-set span caret (if text -caret (load -caret) caret))

# vars #

(var-new -mem type detail) pair-new -mem type detail

# names #

(name-new -mem span var) pair-new -mem (pair-new -mem (get-a span) (get-b span)) var 
(name-push -mem -book span type detail) store -book (book-new -mem (load -book) (name-new -mem span (var-new -mem type detail)))
(name-lookup book span) book-lookup span-equal book span

# typing #

(type-equal a b) or (cmpe a b) (and (and a b) (and (cmpe (get-b a) (get-b b)) (book-equal type-equal (get-a a) (get-a b))))
(type-new -mem book kind) pair-new -mem book kind
(type-unit-new -mem) type-new -mem 0 0
(type-func-new -mem book) type-new -mem book 1

# x86_64 implementation #

(x86_64-str-mov         ) "mov "
(x86_64-str-add         ) "add "
(x86_64-str-test        ) "test "
(x86_64-str-je          ) "je "
(x86_64-str-jne         ) "jne "
(x86_64-str-jmp         ) "jmp "
(x86_64-str-push        ) "push "
(x86_64-str-pop         ) "pop "
(x86_64-str-call        ) "call "
(x86_64-str-ret         ) "ret\n"
(x86_64-str-entry       ) "_start"
(x86_64-str-str-pre     ) ".s"
(x86_64-str-globl       ) ".globl "
(x86_64-str-equ         ) "\n.equ "
(x86_64-str-section-text) ".section .text."
(x86_64-str-section-data) ".section .data."
(x86_64-str-string      ) ".string,"
(x86_64-str-previous    ) ".previous\n"
(x86_64-str-rip-relative) "@GOTPCREL(%rip)"
(x86_64-str-stack-top   ) "(%rsp)"
(x86_64-str-stack-ptr   ) ",%rsp\n"
(x86_64-str-rax         ) "%rax"
(x86_64-str-rdi         ) "%rdi"
(x86_64-str-rsi         ) "%rsi"
(x86_64-str-rdx         ) "%rdx"
(x86_64-str-rcx         ) "%rcx"
(x86_64-str-r8          ) "%r8"
(x86_64-str-r9          ) "%r9"

(x86_64-mangle (vput (put a -out) s -out) s -out) vput put-hex s put 'f -out
(x86_64-mangle-span   s -out) x86_64-mangle vput-span   s -out
(x86_64-mangle-string s -out) x86_64-mangle vput-string s -out

(x86_64-label-suf -out) put '\n put ': -out

(x86_64-section-header (vput name -out) name -out)
    x86_64-label-suf vput name put '\n vput name put-string x86_64-str-section-text -out

(x86_64-predef name body -out)
    put-string x86_64-str-ret
    put '\n
    put-string body
    x86_64-section-header x86_64-mangle-string name
    -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put '$ put '  put-string x86_64-str-add -out
do  and sign (put '- -out)
do  put-string x86_64-str-stack-ptr put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  put '\n put-string reg put-string sign -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  x86_64-str-pop
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  x86_64-str-push

(x86_64-label-id flake -out) put '$ put-dec flake put '. -out
(x86_64-str-label flake -out) put-dec flake put-string x86_64-str-str-pre -out
(x86_64-to-rax -out) put '\n put-string x86_64-str-rax put ', -out
(x86_64-from-rax -out) put ', put-string x86_64-str-rax -out
(x86_64-cz -out) x86_64-to-rax put-string x86_64-str-rax put-string x86_64-str-test -out
(x86_64-jc flake s -out) put '\n x86_64-label-id flake put-string s -out
(x86_64-czjc flake s -out) x86_64-jc flake s x86_64-cz -out

(x86_64-pre -out out)
do  store -out out
    x86_64-predef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-predef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-predef "cmpe"  "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "cmpa"  "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-predef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-predef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-predef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-predef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-predef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-predef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-predef "poke"  "movb %sil,(%rdi)"
    x86_64-predef "peek"  "movzb (%rdi),%eax"
    x86_64-predef "store" "mov %rsi,(%rdi)\nmov %rdi,%rax"
    x86_64-predef "load"  "mov (%rdi),%rax"
    x86_64-predef "word"  "mov $8,%rax"
    put '\n
    x86_64-mangle-string  x86_64-str-entry
    put ',
    put-string x86_64-str-entry
    put-string x86_64-str-equ
    put-string x86_64-str-entry
    put-string x86_64-str-globl
    -out

(x86_64-flake -flake) inc -flake

(x86_64-je  flake -out) x86_64-czjc flake x86_64-str-je  -out
(x86_64-jne flake -out) x86_64-czjc flake x86_64-str-jne -out
(x86_64-jmp flake -out) x86_64-jc   flake x86_64-str-jmp -out

(x86_64-ref text offset depth -out)
do  put-string x86_64-str-mov -out
    x86_64-to-rax
    if  offset
        put-string x86_64-str-stack-top
        put-dec (shl 3 (sub depth offset))
        -out
        put-string x86_64-str-rip-relative
        x86_64-mangle-span text
        -out

(x86_64-lit text -out)
    x86_64-to-rax
    put-span text
    put '$
    put-string x86_64-str-mov
    -out

(x86_64-str text -flake -out)
let flake (x86_64-flake -flake)
    x86_64-to-rax
    put-string x86_64-str-rip-relative
    x86_64-str-label flake
    put-string x86_64-str-mov
    put-string x86_64-str-previous
    put '\n
    put-span text
    put-string x86_64-str-string
    x86_64-label-suf
    x86_64-str-label flake
    put '\n
    x86_64-str-label flake
    put-string x86_64-str-section-data
    -out

(x86_64-do flake -out) 0

(x86_64-label flake -out)
    x86_64-label-suf
    x86_64-label-id  flake
    -out

(x86_64-var -detail -out)
do  x86_64-fpush -detail -out 1
    load -detail

(x86_64-var-in flake -out)
    put '\n
    put-string x86_64-str-stack-top
    x86_64-from-rax
    put-string x86_64-str-mov
    x86_64-label flake
    -out

(x86_64-let-end -depth flake -out) x86_64-fpop -depth -out 1

(x86_64-for-end -depth flake -out)
do  x86_64-jne flake -out
    x86_64-pop -depth -out x86_64-str-rax

(x86_64-call-with -depth arity -out)
do  x86_64-fpush -depth -out arity
    x86_64-push  -depth -out x86_64-str-rax

(x86_64-call-arg index -out)
    put '\n
    put-string x86_64-str-stack-top
    put-dec (shl 3 index)
    x86_64-from-rax
    put-string x86_64-str-mov
    -out

(x86_64-call-end-pop index arity -depth reg -out)
do  and cmpa index arity
    x86_64-pop -depth -out reg
    -out

(x86_64-call-end -depth arity -out)
do  x86_64-pop -depth -out x86_64-str-rax
do  put '\n
    put-string x86_64-str-rax
    put '*
    put-string x86_64-str-call
    x86_64-call-end-pop 5 arity -depth x86_64-str-r9
    x86_64-call-end-pop 4 arity -depth x86_64-str-r8
    x86_64-call-end-pop 3 arity -depth x86_64-str-rcx
    x86_64-call-end-pop 2 arity -depth x86_64-str-rdx
    x86_64-call-end-pop 1 arity -depth x86_64-str-rsi
    x86_64-call-end-pop 0 arity -depth x86_64-str-rdi
	-out
and (cmpa 6 arity)
    x86_64-fpop -depth -out (sub 6 arity)

(x86_64-decl-in -detail span -out)
do  x86_64-section-header x86_64-mangle-span span -out
    store -detail (shl (sub 1 (shl 3 word)) 1)

(x86_64-decl-end -detail arity -out)
do  x86_64-fpop -detail -out arity
    put-string x86_64-str-ret -out

# character ranges #

(char-range-nz byte) byte

(char-range-sq byte) cmpe  byte '\'
(char-range-dq byte) cmpe  byte '\"
(char-range-bs byte) cmpe  byte '\\
(char-range-hm byte) cmpe  byte '#
(char-range-qm byte) cmpe  byte '?
(char-range-lp byte) cmpe  byte '(
(char-range-rp byte) cmpe  byte ')
(char-range-us byte) cmpe  byte '_
(char-range-en byte) cmpe  byte '-
(char-range-sp byte) cmpe  byte ' 
(char-range-tb byte) cmpe  byte '\t
(char-range-lf byte) cmpe  byte '\n
(char-range-cr byte) cmpe  byte '\r

(char-range-09 byte) cmpin byte '0 '9
(char-range-AZ byte) cmpin byte 'A 'Z
(char-range-az byte) cmpin byte 'a 'z

# character classes #

(char-class-nz byte)     char-range-nz byte
(char-class-hm byte)     char-range-hm byte
(char-class-bs byte)     char-range-bs byte
(char-class-sq byte)     char-range-sq byte
(char-class-dq byte)     char-range-dq byte
(char-class-09 byte)     char-range-09 byte
(char-class-qm byte)     char-range-qm byte
(char-class-lp byte)     char-range-lp byte
(char-class-rp byte)     char-range-rp byte

(char-class-ws byte) or  char-range-sp byte
                     or  char-range-tb byte
                     or  char-range-lf byte
                         char-range-cr byte
(char-class-id byte) or  char-range-AZ byte
                     or  char-range-az byte
                     or  char-range-09 byte
                     or  char-range-en byte
                         char-range-us byte
(char-class-im byte) or  char-range-09 byte
                         char-range-sq byte
(char-class-pt byte) or  char-range-lp byte
                     or  char-range-rp byte
                         char-range-qm byte

(char-class-sb byte) char-negclass char-class-dq char-class-nz byte
(char-class-cb byte) char-negclass char-class-hm char-class-nz byte

# token classes #

(token-class-do  -token) token-is "do"  -token
(token-class-if  -token) token-is "if"  -token
(token-class-or  -token) token-is "or"  -token
(token-class-and -token) token-is "and" -token
(token-class-let -token) token-is "let" -token
(token-class-for -token) token-is "for" -token

(token-class-lp  -token) token-match char-class-lp -token
(token-class-rp  -token) token-match char-class-rp -token
(token-class-qm  -token) token-match char-class-qm -token
(token-class-str -token) token-match char-class-dq -token
(token-class-lit -token) token-match char-class-im -token
(token-class-id  -token) token-match char-class-id -token

# lexical units #

(lex-hm -caret) lex-normal char-class-hm -caret
(lex-dq -caret) lex-normal char-class-dq -caret
(lex-sq -caret) lex-normal char-class-sq -caret
(lex-09 -caret) lex-normal char-class-09 -caret
(lex-pt -caret) lex-normal char-class-pt -caret
(lex-ws -caret) lex-normal char-class-ws -caret
(lex-id -caret) lex-escape char-class-bs char-class-id char-class-nz -caret
(lex-sb -caret) lex-escape char-class-bs char-class-sb char-class-nz -caret
(lex-cb -caret) lex-escape char-class-bs char-class-cb char-class-nz -caret

# tokenizer #

(eat-user -caret)
for _ 0
or  eat-bunch lex-ws        -caret
    eat-group lex-hm lex-cb -caret

(eat-text -caret)
or  eat-bunch lex-id        -caret
or            lex-pt        -caret
or  eat-grou  lex-sq lex-sb -caret
or  eat-group lex-dq lex-sb -caret
    eat-bunch lex-09        -caret

(eat -caret -span)
do  eat-user -caret
    token-read eat-text -caret -span

# semantics #

(impl-pre (impl -out out) -book -out out)
do  store -book 0
    load impl -out out

(impl-lit (impl span -out) -mem -type span -out)
do  impl span -out
    type-unit-new -mem

(impl-str (impl span -flake -out) -mem -type span -flake -out)
do  impl span -flake -out
    type-unit-new -mem

(impl-ref (impl span offset -depth -out) -type book span -depth -out)
let var name-lookup book span
if  var
do  impl span (get-b var) -depth -out
    get-a var
    error 2 "undefined identifier"

(impl-var (impl -detail -out) -flake -mem -book -detail span type -out)
let flake x86_64-flake -flake
do  name-push -mem -book span (type-unit-new -mem) (impl -detail -out)
    flake

(impl-var-end (impl -detail flake -out) -mem -book -detail flake -out)
do  impl -detail flake -out
    book-pop -book

(impl-call-arg  (impl index -out) type-param type-arg index -out)
if  type-equal type-param type-arg
    impl index -out
    error 3 "illegal argument"

(impl-call-end  (impl depth arity -out) -mem -type depth arity -out) store -type
do  impl depth arity -out
    (type-unit-new -mem)

# sem type #

(impl--mem   -sem)                 -sem
(impl--book  -sem) add (impl--mem   -sem) word
(impl--out   -sem) add (impl--book  -sem) word
(impl--impl  -sem) add (impl--out   -sem) word
(impl--token -sem) add (impl--impl  -sem) word
(impl--type  -sem) add (impl--token -sem) word
(impl--val   -sem) add (impl--type  -sem) word
(impl--fixed -sem) add (impl--val   -sem) word
(impl--flake -sem) add (impl--fixed -sem) word
(word-sem       )      impl--flake       word

(impl-set-book  -sem book ) store (impl--book  -sem) book
(impl-set-mem   -sem mem  ) store (impl--mem   -sem) mem
(impl-set-out   -sem out  ) store (impl--out   -sem) out
(impl-set-type  -sem type ) store (impl--type  -sem) type
(impl-set-token -sem token) store (impl--token -sem) token
(impl-set-val   -sem val  ) store (impl--val   -sem) val
(impl-set-fixed -sem fixed) store (impl--fixed -sem) fixed
(impl-set-flake -sem flake) store (impl--flake -sem) flake

(impl-get-book  -sem) load  (impl--book  -sem)
(impl-get-mem   -sem) load  (impl--mem   -sem)
(impl-get-out   -sem) load  (impl--out   -sem)
(impl-get-type  -sem) load  (impl--type  -sem)
(impl-get-token -sem) load  (impl--token -sem)
(impl-get-val   -sem) load  (impl--val   -sem)
(impl-get-fixed -sem) load  (impl--fixed -sem)
(impl-get-flake -sem) load  (impl--flake -sem)
(impl-get-impl  -sem) load  (impl--impl  -sem)

# expression parsers #

(parse-builtin (token-class k) (syn (syn x t) x t) (syn-syn x t) x t)
and token-skip token-class eat (impl-get-token x)
    syn syn-syn x t

# instead of allocating a span here we could call back with two sem-param #
(parse-term (token-class k) (syn-term (syn x t) x span) (syn x t) x)
let span (token-take token-class eat (impl--mem x) (impl-get-token x))
and span
    syn-term syn x span

(parse-id x) token-skip token-class-id eat (impl-get-token x)
(parse-lp x) token-skip token-class-lp eat (impl-get-token x)
(parse-rp x) token-skip token-class-rp eat (impl-get-token x)
(parse-qm x) token-skip token-class-qm eat (impl-get-token x)

# term syntax #

(parse-init (sem x -out) x -mem in -out -token)
do  store -mem (add -mem word-sem)
do  token-init eat -mem in -token
    sem x -out

(asyn-unit (sem x span) x span) store (impl--type x) sem x span

(asyn-var (sem x) (impl-in x a) (impl-end x a) (syn x t) x t)
let a
    sem      x
do  parse-id   x
do  syn      x 0
do  impl-in   x a
do  syn      x t
    impl-end  x a

(asyn-seq (sem x) (impl-then x a) (impl-end x a) (syn x t) x t)
let a
    sem      x
do  syn      x t
do  impl-then x a
do  syn      x t
    impl-end  x a

(asyn-if (sem x) (impl-then x a) (impl-else x a) (impl-end x a) (syn x t) x t)
let a
    sem      x
do  syn      x 0
do  impl-then x a
do  syn      x t
let b
    sem      x
do  impl-else x b
do  impl-end  x a
do  syn      x t
    impl-end  x b

(parse-arg (sem x t i) (syn x t) x t i)
do  syn      x t
    sem      x t i

(parse-args (sem x t i) (syn x t) x book i)
and book
do  parse-arg  sem syn x (get-b get-a book)      i
    parse-args sem syn x (      get-b book) (suc i)

(asyn-call (sem x arity) (impl-arg x book index) (impl-end x arity) (syn x type) x type)
let arity (book-count (get-a type))
do  sem x arity
do  parse-args impl-arg syn x (get-a type) 1
    impl-end x arity

# here we say what implementation to use #

(sem-pre       x out        ) impl-pre       x86_64-pre              (impl--book  x) (impl--out   x) out
(sem-lit       x span       ) impl-lit       x86_64-lit              (impl--mem   x) (impl--type x) span (impl--out  x)
(sem-str       x span       ) impl-str       x86_64-str              (impl--mem   x) (impl--type x) span (impl--flake x) (impl--out  x)
(sem-ref       x span       ) impl-ref       x86_64-ref              (impl--type  x) (impl-get-book x) span (impl-get-impl x) (impl--out   x)
(sem-let       x            ) impl-var       x86_64-var              (impl--flake x) (impl--mem   x) (impl--book x) (impl--impl x) (get-a impl-get-token x) (impl-get-type x) (impl--out x)
(sem-let-in    x flake      )                x86_64-var-in     flake (impl--out   x)
(sem-let-end   x flake      ) impl-var-end   x86_64-let-end          (impl--mem   x) (impl--book x) (impl--impl x) flake (impl--out  x)
(sem-for       x            ) impl-var       x86_64-var              (impl--flake x) (impl--mem   x) (impl--book x) (impl--impl x) (get-a impl-get-token x) (impl-get-type x) (impl--out x)
(sem-for-in    x flake      )                x86_64-var-in     flake (impl--out   x)
(sem-for-end   x flake      ) impl-var-end   x86_64-for-end          (impl--mem   x) (impl--book x) (impl--impl x) flake (impl--out  x)
(sem-do        x            )                x86_64-flake            (impl--flake x)
(sem-do-then   x flake      )                x86_64-do         flake (impl--out   x)
(sem-do-end    x flake      )                x86_64-label      flake (impl--out   x)
(sem-and       x            )                x86_64-flake            (impl--flake x)
(sem-and-then  x flake      )                x86_64-je         flake (impl--out   x)
(sem-and-end   x flake      )                x86_64-label      flake (impl--out   x)
(sem-or        x            )                x86_64-flake            (impl--flake x)
(sem-or-else   x flake      )                x86_64-jne        flake (impl--out   x)
(sem-or-end    x flake      )                x86_64-label      flake (impl--out   x)
(sem-if        x            )                x86_64-flake            (impl--flake x)
(sem-if-then   x flake      )                x86_64-je         flake (impl--out   x)
(sem-if-else   x flake      )                x86_64-jmp        flake (impl--out   x)
(sem-if-end    x flake      )                x86_64-label      flake (impl--out   x)
(sem-call-with x arity      )                x86_64-call-with        (impl--impl  x) arity (impl--out   x)
(sem-call-arg  x type  index) impl-call-arg  x86_64-call-arg         (impl-get-type x) type index (impl--out   x)
(sem-call-end  x arity      ) impl-call-end  x86_64-call-end         (impl--mem   x) (impl--type x) (impl--impl x) arity (impl--out x)

# expression syntax #

(syn-init x -in -out) parse-init sem-pre x (impl--mem x) -in -out (impl--token x)

(syn-lit  (syn x type) x span) asyn-unit sem-lit x span
(syn-str  (syn x type) x span) asyn-unit sem-str x span
(syn-ref  (syn x type) x span) asyn-unit sem-ref x span
(syn-let  (syn x type) x type) asyn-var  sem-let sem-let-in sem-let-end syn x type
(syn-for  (syn x type) x type) asyn-var  sem-for sem-for-in sem-for-end syn x type
(syn-do   (syn x type) x type) asyn-seq  sem-do sem-do-then sem-do-end syn x type
(syn-and  (syn x type) x type) asyn-seq  sem-and sem-and-then sem-and-end syn x type
(syn-or   (syn x type) x type) asyn-seq  sem-or sem-or-else sem-or-end syn x type
(syn-if   (syn x type) x type) asyn-if   sem-if sem-if-then sem-if-else sem-if-end syn x type
(syn-call (syn x type) x type) asyn-call sem-call-with sem-call-arg sem-call-end syn x type

(parse-terms (syn x type) x type)
or  parse-builtin token-class-do  syn-do  syn x type
or  parse-builtin token-class-if  syn-if  syn x type
or  parse-builtin token-class-or  syn-or  syn x type
or  parse-builtin token-class-and syn-and syn x type
or  parse-builtin token-class-let syn-let syn x type
or  parse-builtin token-class-for syn-for syn x type
or  parse-term    token-class-lit syn-lit syn x
or  parse-term    token-class-str syn-str syn x
or  parse-term    token-class-id  syn-ref syn x
    error 4 "expected term"

(syn-juxt (syn x t) x t)
let u (impl-get-type x)   
and not type-equal t u
and get-b u
    syn-call syn x u

(syn-nest (syn x t) x t)
if  parse-lp x
do  parse-terms syn x t
or  parse-rp x
do  syn-juxt syn x t
or  parse-rp x
    error 5 "expected `)`"
do  parse-terms syn x t
    syn-juxt syn x t

(syn-expr x t) syn-nest syn-expr x t

# declaration syntax #

(sem-param (impl x o y) x o y)
if  o
    impl x o y
do  syn-expr x (type-unit-new (impl--mem x))
    0

(sem-param-next (impl x o y) x o y offset)
let d (get-a o)
do  name-push (impl--mem x) (impl--book x) (get-a get-a d) (get-b d) offset
let h (sem-param impl x (get-b o) y)
do  book-pop (impl--book x)
    h

(x86_64-param-reg (impl x o y) reg x o y) 
do  x86_64-push (impl--impl x) (impl--out x) reg 
    suc (sem-param-next impl x o (suc y) (impl-get-impl x))

(x86_64-stack     x o y) sem-param-next   x86_64-stack                    x o (suc y) y
(x86_64-register5 x o y) x86_64-param-reg x86_64-stack     x86_64-str-r9  x o 0
(x86_64-register4 x o y) x86_64-param-reg x86_64-register5 x86_64-str-r8  x o y
(x86_64-register3 x o y) x86_64-param-reg x86_64-register4 x86_64-str-rcx x o y
(x86_64-register2 x o y) x86_64-param-reg x86_64-register3 x86_64-str-rdx x o y
(x86_64-register1 x o y) x86_64-param-reg x86_64-register2 x86_64-str-rsi x o y
(x86_64-register0 x o y) x86_64-param-reg x86_64-register1 x86_64-str-rdi x o y

(syn-body x d)
if  name-lookup (impl-get-book x) (get-a get-a d)
    error 6 "redefinition"
do  name-push (impl--mem x) (impl--book x) (get-a get-a d) (get-b d) 0
or  parse-qm x
do  x86_64-decl-in  (impl--impl x) (get-a get-a d) (impl--out x)
let y (sem-param x86_64-register0 x (get-a get-b d) 0)
    load x86_64-decl-end (impl--impl x) y (impl--out x)

(syn-params (syn x) x)
and not (parse-rp x)
let decl (syn x)
    book-new (impl--mem x) (syn-params syn x) decl

(syn-type-unit (syn x) x) type-unit-new (impl--mem x)
(syn-type-func (syn x) x) type-func-new (impl--mem x) (syn-params syn x)

(syn-decl (syn-type (syn x) x) (syn x) x)
let token (token-clone (impl--mem x) (impl-get-token x))
do  parse-id x
    pair-new (impl--mem x) token syn-type syn x

(syn-type x) syn-decl (if (parse-lp x) syn-type-func syn-type-unit) syn-type x

(syn x in out)
do  syn-init x in out
for _ 0
and parse-lp x
let t (syn-decl syn-type-func syn-type x)
and t
    syn-body x t

(main (return code out end) in out mem top) return 0 out (syn mem in out)
(_start) runtime main (pow2 20) (pow2 20) (pow2 20)
