# external functions #

(word) ?
(peek -a) ? (poke -a a) ?
(load -a) ? (store -a a) ?

(neg n) ? (not n) ?
(add a b) ? (mul a b) ? (mod a b) ? (cmpe a b) ?
(sub a b) ? (div a b) ? (shl a b) ? (cmpa a b) ?

(linux rdi rsi rdx rcx r8 r9 rax) ?

# math #

(cmpex n a b) or (cmpa n a) (cmpa b n)
(cmpin n a b) not (cmpex n a b)
(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)
(pow2 n) shl n 1
(suc n) add 1 n
(prd n) sub 1 n
(inc -n) to -n add 1
(dec -n) to -n sub 1

# strings #

(strlen s) and (peek s) (suc (strlen (suc s)))

(memcmp a b n)
or  not n
and cmpe (peek a) (peek b)
    memcmp (suc a) (suc b) (prd n)

(strncmp a b an bn)
and cmpe an bn
    memcmp a b bn

(vcmp aa ab ba bb)
    strncmp aa ba (sub aa ab) (sub ba bb)

# io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (cmpe i error-key)
let byte-count (io i (sub i end))
and byte-count
if  cmpe byte-count error-key
    byte-count
    add i byte-count

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code out end) do (retry-mem stdout out end) (exit code)

(runtime (main (exit code out end) in out mem) inbuf outbuf membuf)
let in  (brk 0)
let out (add in  inbuf )
let mem (add out outbuf)
do  brk (add mem membuf)
do  store mem (add mem word)
do  retry-string-read stdin in out
    main runtime-exit in out mem

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# data #

(Node) add word word

(A node)     node
(B node) add node word

(node -mem a b)
let x (to -mem add Node)
do  store (A x) a
do  store (B x) b
    x

# lexing #

(lex-one (class byte) -in)
and class (peek (load -in))
    inc -in

(lex-esc (class byte) (class-lex byte) (class-esc byte) -in)
if  lex-one class     -in
    lex-one class-esc -in
    lex-one class-lex -in

(vlex-bunch (body -in) -in) 
for _ 0 body -in

(vlex-lgroup (delim -in) (body -in) -in)
and delim -in
    body  -in

(vlex-group (delim -in) (body -in) -in)
and delim -in
do  vlex-bunch body -in
    delim -in

# putting #

(vput-mem (put a -out) a b -out)
do  for i a
    and cmpa i b
    do  put (peek i) -out
        suc i
    -out

(vput-string (put a -out) s -out)
do  for p s
    let a (peek p)
    and a
    do  put a -out
        suc p
    -out

(put byte -out)
do  poke (load -out) byte
do  inc -out
    -out

(putlf -out) put '\n -out

(put-digits (put-digit a -out) base a -out)
if  a
    put-digit                 (mod base a)
    put-digits put-digit base (div base a)
    -out
    -out

(put-number (put-digit a -out) base a -out)
if  a 
    put-digits put-digit base a -out
    put '0 -out

(put-digit-16 a -out) put (add a (if (cmpa a 10) '0 '7)) -out
(put-digit-10 a -out) put (add a                 '0    ) -out

(put-dec a -out) put-number put-digit-10 10 a -out
(put-hex a -out) put-number put-digit-16 16 a -out

(put-string s -out) vput-string put s -out
(put-mem a b -out) vput-mem put a b -out

# x86_64 implementation #

(x86_64-str-mov  ) "mov "
(x86_64-str-ret  ) "ret\n"
(x86_64-str-entry) "_start"
(x86_64-str-rip  ) "@GOTPCREL(%rip)"
(x86_64-str-rsp  ) "(%rsp)"
(x86_64-str-rax  ) "%rax"
(x86_64-str-rdi  ) "%rdi"
(x86_64-str-rsi  ) "%rsi"
(x86_64-str-rdx  ) "%rdx"
(x86_64-str-rcx  ) "%rcx"
(x86_64-str-r8   ) "%r8"
(x86_64-str-r9   ) "%r9"

(x86_64-mangle (vput (put a -out) s -out) s -out) vput put-hex s put 'f -out
(x86_64-mangle-mem a b -out) vput-mem put-hex a b put 'f -out
(x86_64-mangle-string s -out) vput-string put-hex s put 'f -out

(x86_64-label-suf -out) putlf put ': -out

(x86_64-section-header (vput a b -out) a b -out)
    x86_64-label-suf vput a b putlf vput a b put-string ".section .text." -out

(x86_64-initdef name body -out)
    put-string x86_64-str-ret
    putlf
    put-string body
    x86_64-section-header x86_64-mangle-mem name (add name strlen name)
    -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put-string "add $" -out
do  and sign (put '- -out)
do  put-string ",%rsp\n" put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  putlf put-string reg put-string sign -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  "pop "
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  "push "

(x86_64-label-id flake -out) put '$ put-dec flake put '. -out
(x86_64-str-label flake -out) put-dec flake put-string ".s" -out
(x86_64-to-rax -out) putlf put-string x86_64-str-rax put ', -out
(x86_64-from-rax -out) put ', put-string x86_64-str-rax -out
(x86_64-jc flake s -out) putlf x86_64-label-id flake put-string s -out
(x86_64-czjc flake s -out) x86_64-jc flake s x86_64-to-rax put-string x86_64-str-rax put-string "test " -out

(x86_64-argreg index)
if  cmpe index 0 x86_64-str-rdi
if  cmpe index 1 x86_64-str-rsi
if  cmpe index 2 x86_64-str-rdx
if  cmpe index 3 x86_64-str-rcx
if  cmpe index 4 x86_64-str-r8
                 x86_64-str-r9

(x86_64-argpop index arity -depth reg -out)
do  and cmpa index arity
    x86_64-pop -depth -out reg
    -out

(Out   impl)            impl
(Depth impl) add (Out   impl) word
(Flake impl) add (Depth impl) word
(X86_64    )      Flake       word

(x86_64-init -mem out)
let impl (to -mem add X86_64)
do  store (Out impl) out
do  store (Depth impl) (shl (sub 1 (shl 3 word)) 1)
do  store (Flake impl) 0
do  x86_64-initdef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-initdef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-initdef "cmpe"  "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "cmpa"  "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-initdef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-initdef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-initdef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-initdef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-initdef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-initdef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-initdef "poke"  "movb %sil,(%rdi)"
    x86_64-initdef "peek"  "movzb (%rdi),%eax"
    x86_64-initdef "store" "mov %rsi,(%rdi)\nmov %rdi,%rax"
    x86_64-initdef "load"  "mov (%rdi),%rax"
    x86_64-initdef "word"  "mov $8,%rax"
    putlf
    x86_64-mangle-string  x86_64-str-entry
    put ',
    put-string x86_64-str-entry
    put-string "\n.equ "
    put-string x86_64-str-entry
    put-string ".globl "
    (Out impl)
    impl

(x86_64-flake impl) inc (Flake impl)

(x86_64-do  impl flake) 0
(x86_64-je  impl flake) x86_64-czjc flake "je "  (Out impl)
(x86_64-jne impl flake) x86_64-czjc flake "jne " (Out impl)
(x86_64-jmp impl flake) x86_64-jc   flake "jmp " (Out impl)

(x86_64-ref impl a b offset)
do  put-string x86_64-str-mov (Out impl)
    x86_64-to-rax
    if  offset
        put-string x86_64-str-rsp
        put-dec (shl 3 (sub load (Depth impl) offset))
        (Out impl)
        put-string x86_64-str-rip
        x86_64-mangle-mem a b
        (Out impl)

(x86_64-lit impl a b)
    x86_64-to-rax
    put-mem a b
    put '$
    put-string x86_64-str-mov
    (Out impl)

(x86_64-str impl a b)
let flake (x86_64-flake impl)
    x86_64-to-rax
    put-string x86_64-str-rip
    x86_64-str-label flake
    put-string x86_64-str-mov
    put-string ".previous\n"
    putlf
    put-mem a b
    put-string ".string,"
    x86_64-label-suf
    x86_64-str-label flake
    putlf
    x86_64-str-label flake
    put-string ".section .data."
    (Out impl)

(x86_64-label impl flake)
    x86_64-label-suf
    x86_64-label-id flake
    (Out impl)

(x86_64-var-is impl flake)
do  x86_64-fpush (Depth impl) (Out impl) 1
    load (Depth impl)

(x86_64-var-in impl flake)
do  x86_64-label impl flake
    putlf
    put-string x86_64-str-rsp
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-let-end impl flake) x86_64-fpop (Depth impl) (Out impl) 1

(x86_64-for-end impl flake)
do  x86_64-jne impl flake
    x86_64-pop (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-with impl arity)
do  x86_64-fpush (Depth impl) (Out impl) arity
    x86_64-push  (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-arg impl index)
    putlf
    put-string x86_64-str-rsp
    put-dec (shl 3 index)
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-call-end impl arity)
do  x86_64-pop (Depth impl) (Out impl) x86_64-str-rax
do  putlf
    put-string x86_64-str-rax
    put '*
    put-string "call "
    x86_64-argpop 5 arity (Depth impl) x86_64-str-r9
    x86_64-argpop 4 arity (Depth impl) x86_64-str-r8
    x86_64-argpop 3 arity (Depth impl) x86_64-str-rcx
    x86_64-argpop 2 arity (Depth impl) x86_64-str-rdx
    x86_64-argpop 1 arity (Depth impl) x86_64-str-rsi
    x86_64-argpop 0 arity (Depth impl) x86_64-str-rdi
	(Out impl)
and cmpa 6 arity
    x86_64-fpop (Depth impl) (Out impl) (sub 6 arity)

(x86_64-decl-in impl a b)
    x86_64-section-header x86_64-mangle-mem a b (Out impl)
    
(x86_64-decl       impl flake      ) 0

(x86_64-decl-param impl index)
if  cmpa index 6
do  x86_64-push (Depth impl) (Out impl) (x86_64-argreg index)
    load (Depth impl)
    sub 5 index

(x86_64-decl-end impl arity)
do  x86_64-fpop (Depth impl) (Out impl) (if cmpa arity 6 arity 6)
    put-string x86_64-str-ret (Out impl)

(x86_64-end impl) load (Out impl)

# semantics #

(stack-equal (hay-equal a b) a b)
or  cmpe a b
and hay-equal (load B load A a) (load B load A b)
    stack-equal hay-equal (load B a) (load B b)

(type-equal a b) or (cmpe a b) (and (and a b) (and (cmpe (load B a) (load B b)) (stack-equal type-equal (load A a) (load A b))))

(count stack) and stack (suc (count (load B stack)))

(lookup stack a b)
and stack
let hay (load A stack)
if  vcmp (load A load A hay) (load B load A hay) a b
    load B hay
    lookup (load B stack) a b

(Mem  sem)           sem
(Book sem) add (Mem  sem) word
(Impl sem) add (Book sem) word
(struct-Sem)    Impl      word

(asem-init (gen -mem out) -mem -stack -impl out)
do  store -stack 0
    store -impl (gen -mem out)

(asem-unit (gen impl a b) sem a b)
do  gen (load Impl sem) a b
    0

(asem-flake (gen impl) sem) gen (load Impl sem)
(asem-label (gen impl flake) sem flake) gen (load Impl sem) flake

(asem-ref (gen impl a b offset) sem a b)
let var (lookup (load Book sem) a b)
if  not var
    error 1 "unknown reference"
do  gen (load Impl sem) a b (load B var)
    load A var

(asem-var-def (gen impl flake) sem a b result flake)
if  lookup (load Book sem) a b
    error 2 "redefinition" 
    store (Book sem) (node (Mem sem) (node (Mem sem) (node (Mem sem) a b) (node (Mem sem) result (gen (load Impl sem) flake))) (load Book sem))

(asem-var-end (gen impl flake) sem flake)
do  gen (load Impl sem) flake
    store (Book sem) (load B (load (Book sem))) 

(asem-call-with (gen impl arity) sem result)
let arity (count (load A result))
do  gen (load Impl sem) arity
    arity

(asem-call-arg (gen impl index) sem expect result index)
if  type-equal expect result
    gen (load Impl sem) index
    error 3 "illegal argument"

(asem-call-end (gen impl arity) sem arity)
do  gen (load Impl sem) arity
    0

(asem-decl (gen impl flake) sem a b type)
do  gen (load Impl sem) 0
    node (Mem sem) node (Mem sem) a b type

(asem-param (gen impl flake) sem decl stack)
do  gen (load Impl sem) 0
    node (Mem sem) decl stack

(asem-type-func sem stack) node (Mem sem) stack 1
(asem-type-unit            ) 0

(asem-end (gen impl) -impl)
    gen (load -impl)

# character classes #

(char-negclass (class byte) (except byte) byte)
and except byte
not class  byte

(char-class-nz byte)       byte
(char-class-hm byte) cmpe  byte '#
(char-class-bs byte) cmpe  byte '\\
(char-class-sq byte) cmpe  byte '\'
(char-class-dq byte) cmpe  byte '\"
(char-class-09 byte) cmpin byte '0 '9
(char-class-qm byte) cmpe  byte '?
(char-class-lp byte) cmpe  byte '(
(char-class-rp byte) cmpe  byte ')

(char-class-ws byte) or  cmpe  byte ' 
                     or  cmpe  byte '\t
                     or  cmpe  byte '\n
                         cmpe  byte '\r
(char-class-id byte) or  cmpin byte 'A 'Z
                     or  cmpin byte 'a 'z
                     or  cmpin byte '0 '9
                     or  cmpe  byte '-
                         cmpe  byte '_
(char-class-im byte) or  cmpin byte '0 '9
                         cmpe  byte '\'
(char-class-pt byte) or  cmpe  byte '(
                     or  cmpe  byte ')
                         cmpe  byte '?

(char-class-sb byte) char-negclass char-class-dq char-class-nz byte
(char-class-cb byte) char-negclass char-class-hm char-class-nz byte

# lexical units #

(lex-bs-esc (char-class c) -in) lex-esc char-class-bs char-class char-class-nz -in

(lex-hm -in) lex-one    char-class-hm -in
(lex-dq -in) lex-one    char-class-dq -in
(lex-sq -in) lex-one    char-class-sq -in
(lex-09 -in) lex-one    char-class-09 -in
(lex-pt -in) lex-one    char-class-pt -in
(lex-ws -in) lex-one    char-class-ws -in
(lex-id -in) lex-bs-esc char-class-id -in
(lex-sb -in) lex-bs-esc char-class-sb -in
(lex-cb -in) lex-bs-esc char-class-cb -in

# tokenizer #

(lex-user -in)
for _ 0
or  vlex-bunch lex-ws        -in
    vlex-group lex-hm lex-cb -in

(lex-text -in)
or  vlex-bunch  lex-id        -in
or              lex-pt        -in
or  vlex-lgroup lex-sq lex-sb -in
or  vlex-group  lex-dq lex-sb -in
    vlex-bunch  lex-09        -in

# parsers #

(Sem    syn)             syn
(In     syn) add (Sem    syn) word
(Span   syn) add (In     syn) word
(Result syn) add (Span   syn) word
(struct-Syn)      Result      word

(parse -in span)
do  lex-user -in
let caret (load -in)
do  store (A span) caret
    store (B span) (if (lex-text -in) (load -in) caret)

(parse-with (syn-with (syn-expr syn expect) syn expect) (syn-expr syn expect) lit syn expect)
let start (load A (load Span syn))
let n (sub start (load B (load Span syn)))
and memcmp lit start n
and not (peek (add lit n))
do  parse (In syn) (load Span syn)
do  syn-with syn-expr syn expect
    1

(parse-term (char-class byte) (sem syn a b) syn)
and char-class (peek (load A (load Span syn)))
let a (load A load Span syn)
let b (load B load Span syn)
do  parse (In syn) (load Span syn)
do  store (Result syn) sem load Sem syn a b
    1

(parse-exact syn (char-class byte))
and char-class (peek (load A (load Span syn)))
    parse (In syn) (load Span syn)

# abstract syntax #

(asyn-init (sem -mem -out) -mem -in -span -impl in -out)
do  store -span node -mem 0 0
do  store -in in
do  parse -in (load -span)
    store -impl sem -mem -out
(asyn-end (sem sem) -sem) sem (load -sem)

(asyn-var (sem syn) (sem-is syn flake a b) (sem-in syn flake) (sem-end syn flake) (syn-expr syn expect) syn expect)
let flake (sem load Sem syn)
do  sem-is load Sem syn flake (load A load Span syn) (load B load Span syn)
do  parse-exact syn char-class-id
do  syn-expr syn 0
do  sem-in load Sem syn flake
let result (syn-expr syn expect)
do  sem-end load Sem syn flake
    result

(asyn-seq (sem syn) (sem-then syn flake) (sem-end syn flake) (syn-expr syn expect) syn expect)
let flake (sem load Sem syn)
let result-a (syn-expr syn expect)
do  sem-then load Sem syn flake
let result-b (syn-expr syn expect)
do  sem-end load Sem syn flake
    result-b

(asyn-cond (sem syn) (sem-then syn flake) (sem-else syn flake) (sem-end syn flake) (syn-expr syn expect) syn expect)
let flake-a (sem load Sem syn)
let result-a (syn-expr syn 0)
do  sem-then load Sem syn flake-a
let result-b (syn-expr syn expect)
let flake-b (sem load Sem syn)
do  sem-else load Sem syn flake-b
do  sem-end  load Sem syn flake-a
let result-c (syn-expr syn expect)
do  sem-end  load Sem syn flake-b
    result-c

(asyn-term
(syn-do  (syn-expr syn expect) syn expect)
(syn-if  (syn-expr syn expect) syn expect)
(syn-or  (syn-expr syn expect) syn expect)
(syn-and (syn-expr syn expect) syn expect)
(syn-let (syn-expr syn expect) syn expect)
(syn-for (syn-expr syn expect) syn expect)
(syn-lit (syn-expr syn expect) syn expect)
(syn-str (syn-expr syn expect) syn expect)
(syn-id  (syn-expr syn expect) syn expect)
(syn-expr syn expect) syn expect)
or  syn-do  syn-expr syn expect
or  syn-if  syn-expr syn expect
or  syn-or  syn-expr syn expect
or  syn-and syn-expr syn expect
or  syn-let syn-expr syn expect
or  syn-for syn-expr syn expect
or  syn-lit syn-expr syn expect
or  syn-str syn-expr syn expect
or  syn-id  syn-expr syn expect
    error 5 "expected term"

(asyn-do  (syn-do  (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-do  syn-expr "do"  syn expect
(asyn-if  (syn-if  (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-if  syn-expr "if"  syn expect
(asyn-or  (syn-or  (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-or  syn-expr "or"  syn expect
(asyn-and (syn-and (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-and syn-expr "and" syn expect
(asyn-let (syn-let (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-let syn-expr "let" syn expect
(asyn-for (syn-for (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-for syn-expr "for" syn expect

(asyn-lit (sem syn a b) syn) parse-term char-class-im sem syn
(asyn-str (sem syn a b) syn) parse-term char-class-dq sem syn
(asyn-id  (sem syn a b) syn) parse-term char-class-id sem syn

(asyn-arg (sem syn expect result index) (syn-expr syn expect) syn expect index)
do  syn-expr syn expect
    sem load Sem syn expect (load Result syn) index

(asyn-args (sem syn expect result index) (syn-expr syn expect) syn stack index)
and stack
do  asyn-arg  sem syn-expr syn (load B load A stack)      index
    asyn-args sem syn-expr syn (  load B stack) (suc index)

(asyn-call (sem syn type) (sem-arg syn expect result index) (sem-end syn arity) (syn-expr syn expect) syn result)
and load B result
let arity (sem load Sem syn result)
do  asyn-args sem-arg syn-expr syn (load A result) 1
    store (Result syn) sem-end load Sem syn arity

(asyn-juxt (syn-call (syn-expr syn expect) syn result) (syn-expr syn expect) syn expect result)
and not (type-equal expect result)
    syn-call syn-expr syn result

(asyn-expr (syn-term (syn-expr syn type) syn expect) (syn-juxt (syn-expr syn type) syn expect result) (syn-call (syn-expr syn expect) syn type) (syn-expr syn expect) syn expect)
if  parse-exact syn char-class-lp
do  syn-term syn-expr syn expect
or  parse-exact syn char-class-rp
if  syn-juxt syn-expr syn expect (load Result syn)
    parse-exact syn char-class-rp
    error 4 "expected )"
do  syn-term syn-expr syn expect
    syn-juxt syn-expr syn expect (load Result syn)

(asyn-body (sem syn) (sem-is syn flake decl) (sem-in syn flake decl) (sem-end syn flake decl) (syn-param (syn-expr syn type) syn haystack index) (syn-expr syn type) syn decl)
and decl
let flake (sem load Sem syn)
do  sem-is load Sem syn flake decl
or  parse-exact syn char-class-qm
do  sem-in load Sem syn flake decl
do  syn-param syn-expr syn (load A load B decl) 0
    sem-end load Sem syn flake decl

(asyn-param (sem syn decl index) (sem-end syn flake) (syn-expr syn type) syn stack index)
if  stack
let decl (load A stack)
let offset (sem (load Sem syn) decl index)
do  asyn-param sem sem-end syn-expr syn (load B stack) (suc index)
    sem-end load Sem syn offset
    syn-expr syn 0

(asyn-decl (sem sem a b type) (syn-type-which (syn-type syn) syn) (syn-type syn) syn)
let a (load A load Span syn)
let b (load B load Span syn)
and parse-exact syn char-class-id
    sem (load Sem syn) a b (syn-type-which syn-type syn)

(asyn-type-params (sem sem decl type) (syn-type-params (syn-type syn) syn) (syn-type syn) syn)
and not (parse-exact syn char-class-rp)
let decl (syn-type syn)
    sem (load Sem syn) decl (syn-type-params syn-type syn)

(asyn-type (sem sem a b type) (syn-decl (sem sem a b type) (syn-type-which (syn-type syn) syn) (syn-type syn) syn) (syn-type-func (syn-type syn) syn) (syn-type-unit (syn-type syn) syn) (syn-type syn) syn)
    syn-decl sem (if (parse-exact syn char-class-lp) syn-type-func syn-type-unit) syn-type syn

# tables #

(sem-init -mem out)
let sem (to -mem add struct-Sem)
do  store (Mem sem) (load -mem)
do  asem-init x86_64-init (Mem sem) (Book sem) (Impl sem) out
    sem
(sem-end sem) asem-end x86_64-end (Impl sem)

(sem-lit        sem a b                ) asem-unit      x86_64-lit        sem a b
(sem-str        sem a b                ) asem-unit      x86_64-str        sem a b
(sem-ref        sem a b                ) asem-ref       x86_64-ref        sem a b
(sem-do         sem                    ) asem-flake     x86_64-flake      sem
(sem-do-then    sem label              ) asem-label     x86_64-do         sem label
(sem-do-end     sem label              ) asem-label     x86_64-label      sem label
(sem-if         sem                    ) asem-flake     x86_64-flake      sem
(sem-if-then    sem label              ) asem-label     x86_64-je         sem label
(sem-if-else    sem label              ) asem-label     x86_64-jmp        sem label
(sem-if-end     sem label              ) asem-label     x86_64-label      sem label
(sem-or         sem                    ) asem-flake     x86_64-flake      sem
(sem-or-else    sem label              ) asem-label     x86_64-jne        sem label
(sem-or-end     sem label              ) asem-label     x86_64-label      sem label
(sem-and        sem                    ) asem-flake     x86_64-flake      sem
(sem-and-then   sem label              ) asem-label     x86_64-je         sem label
(sem-and-end    sem label              ) asem-label     x86_64-label      sem label
(sem-let        sem                    ) asem-flake     x86_64-flake      sem 
(sem-let-is     sem label a b          ) asem-var-def   x86_64-var-is     sem a b 0 label
(sem-let-in     sem label              ) asem-label     x86_64-var-in     sem label
(sem-let-end    sem label              ) asem-var-end   x86_64-let-end    sem label
(sem-for        sem                    ) asem-flake     x86_64-flake      sem
(sem-for-is     sem label a b          ) asem-var-def   x86_64-var-is     sem a b 0 label
(sem-for-in     sem label              ) asem-label     x86_64-var-in     sem label
(sem-for-end    sem label              ) asem-var-end   x86_64-for-end    sem label
(sem-call-with  sem result             ) asem-call-with x86_64-call-with  sem result
(sem-call-arg   sem expect result index) asem-call-arg  x86_64-call-arg   sem expect result index
(sem-call-end   sem arity              ) asem-call-end  x86_64-call-end   sem arity
(sem-param      sem decl index         ) asem-var-def   x86_64-decl-param sem                         (load A load A decl) (load B load A decl) (load B decl) index
(sem-param-end  sem label              ) asem-var-end   x86_64-do         sem label
(sem-decl       sem a b type           ) asem-decl      x86_64-do         sem a b type
(sem-type-func  sem stack              ) asem-type-func                   sem stack
(sem-type-unit  sem                    ) asem-type-unit
(sem-type-param sem decl stack         ) asem-param     x86_64-do         sem decl stack
(sem-body       sem                    ) asem-flake     x86_64-flake      sem 
(sem-body-is    sem label decl         ) asem-var-def   x86_64-decl       sem                         (load A load A decl) (load B load A decl) (load B decl) label
(sem-body-in    sem label decl         )                x86_64-decl-in    (load Impl sem)             (load A load A decl) (load B load A decl)
(sem-body-end   sem label decl         )                x86_64-decl-end   (load Impl sem) count (load A load B decl)

(syn-init -mem -in -out) let syn (to -mem add struct-Syn) do (asyn-init sem-init -mem (In syn) (Span syn) (Sem syn) -in -out) syn
(syn-end syn) asyn-end sem-end (Sem syn)

(syn-do   (syn-expr syn expect) syn expect) asyn-seq  sem-do sem-do-then sem-do-end syn-expr syn expect
(syn-if   (syn-expr syn expect) syn expect) asyn-cond sem-if sem-if-then sem-if-else sem-if-end syn-expr syn expect
(syn-or   (syn-expr syn expect) syn expect) asyn-seq  sem-or sem-or-else sem-or-end syn-expr syn expect
(syn-let  (syn-expr syn expect) syn expect) asyn-var  sem-let sem-let-is sem-let-in sem-let-end syn-expr syn expect
(syn-for  (syn-expr syn expect) syn expect) asyn-var  sem-for sem-for-is sem-for-in sem-for-end syn-expr syn expect
(syn-and  (syn-expr syn expect) syn expect) asyn-seq  sem-and sem-and-then sem-and-end syn-expr syn expect
(syn-call (syn-expr syn expect) syn expect) asyn-call sem-call-with sem-call-arg sem-call-end syn-expr syn expect

(syn-term-do  (syn-expr syn expect) syn expect) asyn-do  syn-do  syn-expr syn expect
(syn-term-if  (syn-expr syn expect) syn expect) asyn-if  syn-if  syn-expr syn expect
(syn-term-or  (syn-expr syn expect) syn expect) asyn-or  syn-or  syn-expr syn expect
(syn-term-and (syn-expr syn expect) syn expect) asyn-and syn-and syn-expr syn expect
(syn-term-let (syn-expr syn expect) syn expect) asyn-let syn-let syn-expr syn expect
(syn-term-for (syn-expr syn expect) syn expect) asyn-for syn-for syn-expr syn expect
(syn-term-lit (syn-expr syn expect) syn expect) asyn-lit sem-lit syn
(syn-term-str (syn-expr syn expect) syn expect) asyn-str sem-str syn
(syn-term-id  (syn-expr syn expect) syn expect) asyn-id  sem-ref syn

(syn-type-params (syn-type syn) syn) asyn-type-params sem-type-param syn-type-params syn-type syn
(syn-type-func (syn-type syn) syn) sem-type-func (load Sem syn) (syn-type-params syn-type syn)
(syn-type-unit (syn-type syn) syn) sem-type-unit (load Sem syn)

(syn-term (syn-expr syn expect) syn expect) asyn-term syn-term-do syn-term-if syn-term-or syn-term-and syn-term-let syn-term-for syn-term-lit syn-term-str syn-term-id syn-expr syn expect
(syn-juxt (syn-expr syn expect) syn expect result) asyn-juxt syn-call syn-expr syn expect result
(syn-param (syn-expr syn expect) syn haystack index) asyn-param sem-param sem-param-end syn-expr syn haystack index
(syn-body (syn-expr syn expect) syn decl) asyn-body sem-body sem-body-is sem-body-in sem-body-end syn-param syn-expr syn decl
(syn-expr syn expect) asyn-expr syn-term syn-juxt syn-call syn-expr syn expect
(syn-type syn) asyn-type sem-decl asyn-decl syn-type-func syn-type-unit syn-type syn

(main (return code out end) in out -mem)
let syn (syn-init -mem in out)
do  for _ 0 syn-body syn-expr syn (syn-type syn)
    return 0 out (syn-end syn)

(_start) runtime main (pow2 15) (pow2 18) (pow2 18)