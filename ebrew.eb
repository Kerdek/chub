type
  X @#
  T @#
  LineNo       @#
  ColNo        @#
  StackDepth   @#
  LinePtr      @#
  TokenCaret   @#
  TokenLength  @#
  Category     @#
  IsType       @#
  IsDef        @#
  IsVar        @#
  TypeKind     @#
  Parser       (x X) $
;

set_ctx          (a @X           b X          ) $ __set a b
set_type         (a @T           b T          ) $ __set a b
set_line_no      (a @LineNo      b LineNo     ) $ __set a b
set_col_no       (a @ColNo       b ColNo      ) $ __set a b
set_stack_depth  (a @StackDepth  b StackDepth ) $ __set a b
set_line_ptr     (a @LinePtr     b LinePtr    ) $ __set a b
set_in_buffer    (a @InBuffer    b InBuffer   ) $ __set a b
set_out_buffer   (a @OutBuffer   b OutBuffer  ) $ __set a b
set_token_caret  (a @TokenCaret  b TokenCaret ) $ __set a b
set_token_length (a @TokenLength b TokenLength) $ __set a b
set_category     (a @Category    b Category   ) $ __set a b
set_is_type      (a @IsType      b IsType     ) $ __set a b
set_is_def       (a @IsDef       b IsDef      ) $ __set a b
set_is_var       (a @IsVar       b IsVar      ) $ __set a b
set_type_kind    (a @TypeKind    b TypeKind   ) $ __set a b

ctx_alloc_size () AllocSize alloc_size 120

ctx_successor  (x X) @ X            __cast @ X              (x +   0)
ctx_type       (x X) @ T            __cast @ T              (x +   8)
ctx_line_no    (x X) @ LineNo       __cast @ LineNo         (x +  16)
ctx_col_no     (x X) @ ColNo        __cast @ ColNo          (x +  24)
ctx_depth      (x X) @ StackDepth   __cast @ StackDepth     (x +  32)
ctx_line_ptr   (x X) @ LinePtr      __cast @ LinePtr        (x +  40)
ctx_inbuf      (x X) @ InBuffer     __cast @ InBuffer       (x +  48)
ctx_outbuf     (x X) @ OutBuffer    __cast @ OutBuffer      (x +  56)
ctx_curbrk     (x X) @ ProgramBreak __cast @ ProgramBreak   (x +  64)
ctx_token      (x X) @ TokenCaret   __cast @ TokenCaret     (x +  72)
ctx_token_len  (x X) @ TokenLength  __cast @ TokenLength    (x +  80)
ctx_category   (x X) @ Category     __cast @ Category       (x +  88)
ctx_is_type    (x X) @ IsType       __cast @ IsType         (x +  96)
ctx_is_def     (x X) @ IsDef        __cast @ IsDef          (x + 104)
ctx_is_var     (x X) @ IsVar        __cast @ IsVar          (x + 112)

ctx_offset     (x X o X) $ (__the ctx_depth o - __the ctx_depth x)

type_alloc_size () AllocSize alloc_size 40

type_successor (t T) @ T  __cast @ T (t +  0)
type_argument  (t T) @ T  __cast @ T (t +  8)
type_token     (t T) @ TokenCaret   __cast @ TokenCaret  (t + 16)
type_token_len (t T) @ TokenLength  __cast @ TokenLength (t + 24)
type_kind      (t T) @ TypeKind     __cast @ TypeKind    (t + 32)

ctx_copy (a X b X it IsType il IsVar) $ {
  memcpy __cast $ a __cast $ b __cast $ ctx_alloc_size
  set_ctx ctx_successor a __the ctx_successor b
  set_ctx ctx_successor b a
  set_is_type ctx_is_type __the ctx_successor b it
  set_is_var  ctx_is_var  __the ctx_successor b il
  set_is_def  ctx_is_def  __the ctx_successor b __cast IsDef 0
}

try_lookup (x X) X {
  __cast X 0 is o
  __the ctx_successor x is s0
  { s0 then s0 for s
    __cond (__the ctx_token_len s != __the ctx_token_len x or (__not strncmp __cast $ __the ctx_token s __cast $ __the ctx_token x __cast $ __the ctx_token_len x))
      (__the ctx_successor s)
      { __set __addr o s
        __cast X 0 } }
  o
}

alloc (x X n AllocSize) ProgramBreak { __the ctx_curbrk x is r __set ctx_curbrk x (__the ctx_curbrk x + n) r }

oglf (x X     c (x X c $) $) $ c x '\n
ogn1 (x X n $ c (x X c $) $) $ { n then ogn1 x (n / 10) c c x ('0 + n % 10) }
ogn  (x X n $ c (x X c $) $) $ { __cond n ogn1 x n c c x '0 }

gc  (x X c $) $ { (__poke __the ctx_outbuf x c) __set ctx_outbuf x (__the ctx_outbuf x + 1) }
gs  (x X s $) $ { s for p __peek p then gc x __peek p (p + 1) }
gsn (x X o X) $ { 0 for m (__a m __the ctx_token_len o) then gc x __peek (__the ctx_token o + m) (m + 1) }
glf (x X    ) $ oglf x   gc
gn  (x X n $) $ ogn  x n gc

oc  (x X c $       ) $ __syscall 1 2 __addr c 1 0 0 0
os  (x X s $       ) $ __syscall 1 2  s strlen s 0 0 0
osn (x X s $ n $) $ __syscall 1 2  s n 0 0 0
olf (x X              ) $ oglf x   oc
on  (x X        n $) $ ogn  x n oc

diag (x X s $) $ {
  oc x '( on x __cast $ __the ctx_line_no x oc x ', on x __cast $ __the ctx_col_no x os x "): " os x s olf x
  exit 1
}

lookup (x X) X {
  try_lookup x else
  diag x "lookup failed"
}

make_type (x X kind $) T {
  __cast T alloc x type_alloc_size is t
  __set type_successor t __cast T 0
  __set type_kind      t kind
  t
}

make_type_a (x X kind $ arg T) T {
  make_type x kind is t
  __set type_argument t arg
  t
}

typeid_none () $ 0
typeid_unit () $ 1
typeid_name () $ 2
typeid_ptr  () $ 3
typeid_func () $ 4

nnone (x X      ) T make_type   x typeid_none
nunit (x X      ) T make_type   x typeid_unit
nname (x X arg T) T make_type_a x typeid_name arg
nptr  (x X arg T) T make_type_a x typeid_ptr  arg
nfunc (x X arg T) T make_type_a x typeid_func arg

type_equal (ta T tb T) $ {
  ta then
  tb then
  (ta == tb) else
  __the type_kind ta is tk
  (tk == __the type_kind tb) then
  (tk != typeid_unit) then
  (tk == typeid_none) else
  __cond (tk == typeid_ptr or tk == typeid_name) type_equal __the type_argument ta __the type_argument tb
  { (tk == typeid_func) then
    __the type_argument ta is aa
    __the type_argument tb is ab
    { 1 for _
      type_equal aa ab then
      __set __addr aa __the type_successor aa
      __set __addr ab __the type_successor ab
      1 }
    (aa == ab) }
}

issp (c $) $ (c == '  )
istb (c $) $ (c == '\t)
islf (c $) $ (c == '\n)
iscr (c $) $ (c == '\r)
is_  (c $) $ (c == '_ )

isin (c $ a $ b $) $ (__ae a c and __ae c b)

isAZ (c $) $ isin c 'A 'Z
isaz (c $) $ isin c 'a 'z
is09 (c $) $ isin c '0 '9
isaf (c $) $ isin c 'a 'f

isws (c $) $ ( issp c or
                      istb c or
                      islf c or
                      iscr c    )
is0f (c $) $ ( is09 c or
                      isaf c    )
isid (c $) $ ( isAZ c or
                      isaz c or
                      is09 c or
                      is_  c    )

caret_is      (x X c $) $    (__peek __the ctx_inbuf x == c)
caret_next_is (x X c $) $  { (__peek __the ctx_inbuf x or diag x "unexpected end of file") (__peek (__the ctx_inbuf x + 1) == c) }

caret_advance Parser {
  (__peek __the ctx_inbuf x or diag x "unexpected end of file")
  __set ctx_inbuf x (__the ctx_inbuf x + 1)
  __cond caret_is x '\n
    { __set ctx_col_no x 1
      __set ctx_line_no  x (__the ctx_line_no x + 1)
      __set ctx_line_ptr x (__the ctx_inbuf   x + 1) }
    __set ctx_col_no x (__the ctx_col_no x + 1)
}

caret Parser (100 * __the ctx_line_no x * 1000000 + __the ctx_col_no x)

comment Parser {
  (caret_is x '/ and caret_next_is x '*) then
  caret_advance x
  caret_advance x
  { 1 for _
    __cond (caret_is x '* and caret_next_is x '/)
      { caret_advance x caret_advance x 0 }
      { caret_advance x        1 } }
  1
}

number Parser {
  __the ctx_inbuf x is q
  { 1 for _ is09 __peek __the ctx_inbuf x then caret_advance x 1 }
  (__the ctx_inbuf x != q) then
  __set ctx_token x q
  __set ctx_token_len x (__the ctx_inbuf x - q)
  1
}

string Parser {
  caret_is x '" then
  __the ctx_inbuf x is q
  caret_advance x
  { 1 for _
    { 1 for _ caret_is x '\\ then caret_advance x caret_advance x 1}
    (caret_is x '\n and diag x "newline in string literal")
    __not caret_is x '" then
    caret_advance x
    1
  }
  caret_advance x
  __set ctx_token x q
  __set ctx_token_len x (__the ctx_inbuf x - q)
  gs x ".section .text..s" gn x caret x glf x
  gs x ".s" gn x caret x gc x ': gs x ".string \""
  { (__the ctx_token x + 1) for i __a i (__the ctx_token x + __the ctx_token_len x - 1) then gc x __peek i (i + 1) }
  gc x '\" glf x
  gs x ".previous" glf x
  1
}

char Parser {
  caret_is x '\' then
  __the ctx_inbuf x is q
  caret_advance x
  { caret_is x '\\ then
    caret_advance x }
  caret_advance x
  { caret_is x '\' then
    caret_advance x }
  __set ctx_token x q
  __set ctx_token_len x (__the ctx_inbuf x - q)
  1
}

id Parser {
  __the ctx_inbuf x is q
  { 1 for _ isid __peek __the ctx_inbuf x then caret_advance x 1 }
  (__the ctx_inbuf x != q) then
  __set ctx_token x q
  __set ctx_token_len x (__the ctx_inbuf x - q)
  1
}

sw1 (x X a $       ) $ { caret_is x a then caret_advance x 1 }
sw2 (x X a $ b $) $ { caret_is x a then caret_next_is x b then caret_advance x caret_advance x 1 }

punct Parser {
  __the ctx_inbuf x is q
  { sw2 x '= '= else
    sw2 x '! '= else
    sw2 x '< '= else
    sw2 x '> '= else
    sw2 x '< '- else
    sw2 x '- '> else
    sw2 x '< '< else
    sw2 x '> '> else
    sw2 x '/ '/ else
    sw1 x '=    else
    sw1 x '<    else
    sw1 x '>    else
    sw1 x '+    else
    sw1 x '-    else
    sw1 x '*    else
    sw1 x '/    else
    sw1 x '&    else
    sw1 x '|    else
    sw1 x '@    else
    sw1 x '#    else
    sw1 x '{    else
    sw1 x '}    else
    sw1 x '(    else
    sw1 x ')    else
    sw1 x '[    else
    sw1 x ']    else
    sw1 x '!    else
    sw1 x '?    else
    sw1 x ':    else
    sw1 x ';    else
    sw1 x ',    else
    sw1 x '.    else
    sw1 x '~    else
    sw1 x '^    else
    sw1 x '$    else
    sw1 x '`    else
    sw1 x '%
  }
  __set ctx_token x q
  __set ctx_token_len x (__the ctx_inbuf x - q)
  1
}

eof Parser {
  __not __peek __the ctx_inbuf x then
  __set ctx_token x 0
  1
}

ws Parser {
  1 for _
  comment x else
  isws __peek __the ctx_inbuf x then
  caret_advance x
  1
}

token Parser {
  ws     x
  eof    x else
  number x else
  string x else
  char   x else
  id     x else
  punct  x else
  diag x "invalid token"
}

token_advance Parser { (__the ctx_token x or diag x "unexpected end of tokens") token x }

have (x X c $) $ {  __the ctx_token x then memcmp c __cast $ __the ctx_token x __cast $ __the ctx_token_len x then __not __peek (c + __the ctx_token_len x) }
need (x X c $) $ { (have x c or diag x "unexpected") token_advance x }
eat  (x X c $) $ {  have x c is r { r then token_advance x } r }

gtreg (x X s $            ) $ { gc x '% gs x s }
gt0   (x X s $            ) $ { gs x s glf x  }
gt1   (x X s $ a $      ) $ { gs x s gc x '  gtreg x a glf x }
gt2   (x X s $ a $ b $) $ { gs x s gc x '  gtreg x a gc x ', gtreg x b glf x }

zero (x X a $) $ gt2 x "xor"  a a
cz   (x X a $) $ gt2 x "test" a a

gshx  (x X k $) $ { gs x "sh" gc x k gs x " %cl,%rax" glf x }

gadd Parser gt2    x "add" "rcx" "rax"
gsub Parser gt2    x "sub" "rcx" "rax"
gcmp Parser gt2    x "cmp" "rcx" "rax"
gshr Parser gshx   x 'r
gshl Parser gshx   x 'l

gpromote (x X b $) $ gt2 x "movzbl" "al" b

setc   (x X s $) $ { gs x "set" gs x s gc x '  gtreg x "al" glf x gpromote x "eax" }
cmpset (x X s $) $ { gcmp x setc x s "eax" }

glnot Parser { cz x "rax" setc x "e" "eax" }
gneg  Parser gt1 x "neg" "rax"
gmul  Parser gt1 x "mul" "rcx"
gdiv  Parser { zero x "edx" gt1 x "div" "rcx" }
gmod  Parser { gdiv x gt2 x "mov" "rdx" "rax" }
ge    Parser cmpset x "e"
gne   Parser cmpset x "ne"
gb    Parser cmpset x "b"
gbe   Parser cmpset x "be"
ga    Parser cmpset x "a"
gae   Parser cmpset x "ae"

local_symbol (x X n $        ) $ { gc x 'l gn x n gc x '$ }

label(x X n $       ) $ {                        local_symbol x n gc x ': glf x }
jc   (x X n $ s $) $ { gc x 'j gs x s gc x '  local_symbol x n         glf x }

jmp  (x X n $) $ jc x n "mp"
je   (x X n $) $ jc x n "e"
jne  (x X n $) $ jc x n "ne"
jb   (x X n $) $ jc x n "b"
jbe  (x X n $) $ jc x n "be"
ja   (x X n $) $ jc x n "a"
jae  (x X n $) $ jc x n "ae"

type StackMode () $ ;

stackmode_pop  StackMode "pop"
stackmode_push StackMode "push"

stackdepth_adjust (depth @StackDepth mode StackMode size $) $
  __set depth (__the depth + __cond (mode == stackmode_push) __neg size size)

fpushpop (x X size $ mode StackMode) $ {
  size then
  gs x "add $" { (mode == stackmode_push) then gc x '- } gn x (size << 3) gc x ', gtreg x "rsp" glf x
  stackdepth_adjust ctx_depth x mode size
}
pushpop  (x X register $ mode StackMode) $ {
  gt1 x mode register
  stackdepth_adjust ctx_depth x mode 1
}

fpop (x X size $) $ fpushpop x size stackmode_pop
fpush(x X size $) $ fpushpop x size stackmode_push

pop  (x X source      $) $ pushpop x source      stackmode_pop
push (x X destination $) $ pushpop x destination stackmode_push

load  (x X n $ s $ d $) $ { gs x "mov " gn x n gs x "(%" gs x s gs x "),%" gs x d glf x }
store (x X d $) $ { gs x "mov %rax,(%" gs x d gc x ') glf x }

eval Parser {
  __the ctx_category x then
  __the ctx_category x for l
  load x 0 "rax" "rax"
  (l - 1)
}

note (x X t T l $) $ {
  __set ctx_type     x t
  __set ctx_category x l
}

g1ops (x X p Parser g Parser) $ {
  p x
  eval x
  note x nnone x 0
  g x
}

g2ops (x X p Parser g Parser) $ {
  eval x
  push x "rax"
  p x
  eval x
  gt0 x "mov %rax,%rcx"
  pop x "rax"
  note x nnone x 0
  g x
}

let (x X p Parser) $ {
  __cast X alloc x ctx_alloc_size is o
  ctx_copy o x __cast IsType 0 __cast IsVar 1
  token_advance x
  p x
  __set ctx_successor x __the ctx_successor __the ctx_successor x
}

logic (x X op $ jc(x X n $) $ p Parser) $ {
  eat  x op then
  caret     x is n
  eval       x
  cz         x "rax"
  jc         x n
  p          x
  eval       x
  label      x n
  1
}

comparison (x X op $ pa Parser pb Parser g Parser) $ {
  eat   x op then
  pa    x
  eval  x
  push  x "rax"
  pb    x
  eval  x
  pop   x "rcx"
  g     x
  note  x nnone x 0
  1
}

infix (x X op $ p Parser g Parser) $ {
  eat x op then g2ops x p g 1
}

ptype (x X t @T) $ ;
pterm (x X) $ ;
pseq  (x X) $ ;
plor  (x X) $ ;

pname (x X t @T) $ {
  __set t __cast T alloc x type_alloc_size
  __set type_token     __the t __the ctx_token     x
  __set type_token_len __the t __the ctx_token_len x
  token_advance x
  __cast T 0 is u
  ptype x __addr u
  __set type_argument  __the t __the type_argument  u
  __set type_kind      __the t __the type_kind      u
}

ptype (x X t @T) $ {
  __cond eat x "$" __set t nnone x
  __cond eat x "#" __set t nunit x
  __cond eat x "@" {
    __set t make_type x typeid_ptr
    __set __addr t type_argument __the t
    ptype x t }
  __cond eat x "(" {
    __cast T 0 is params
    __addr params is u
    { 1 for _
      __not eat x ")" then
      pname x u
      __set __addr u type_successor __the u
      1 }
    __cast T 0 is r
    ptype x __addr r
    __set t nfunc x __cast T alloc x type_alloc_size
    memcpy __cast $ __the type_argument __the t __cast $ r __cast $ type_alloc_size
    __set type_successor __the type_argument __the t params
  }
  { lookup x is o
    (__the ctx_is_type o or diag x "not a type")
    token_advance x
    __set t __the ctx_type o }
}

pterm_push Parser { pterm x eval x push x "rax" }

pkey Parser {
  __peek __the ctx_token x is first_byte
  { { is09 first_byte else __e first_byte '\' } then
    gs x "mov $" gsn x x gs x ",%rax" glf x
    token_advance x
    note x nnone x 0
    1 } else
  { __e first_byte '\" then
    gs x "mov .s" gn x caret x gs x "@GOTPCREL(%rip),%rax" glf x
    token_advance x
    note x nnone x 0
    1 } else
  { eat x "("      then plor  x need x ")" 1 } else
  { eat x "{"      then pseq  x need x "}" 1 } else
  { eat x "__neg"  then g1ops x pterm gneg  1 } else
  { eat x "__not"  then g1ops x pterm glnot 1 } else
  { eat x "__addr" then pkey  x note x nptr x __the ctx_type x __cond (__the type_kind __the ctx_type x == typeid_func) __the ctx_category x (__the ctx_category x - 1) 1 } else
  { eat x "__the"  then pterm x { (__the type_kind __the ctx_type x != typeid_ptr) then diag x "not a pointer" } note x __the type_argument __the ctx_type x __cond (__the type_kind __the type_argument __the ctx_type x == typeid_func) __the ctx_category x (__the ctx_category x + 1) 1 } else
  comparison x "__a"  pterm pterm ga  else
  comparison x "__ae" pterm pterm gae else
  comparison x "__b"  pterm pterm gb  else
  comparison x "__be" pterm pterm gbe else
  comparison x "__e"  pterm pterm ge  else
  comparison x "__ne" pterm pterm gne else
  { eat x "__set"  then
    pterm_push x
    pterm      x eval x
    pop        x "rcx"
    store      x "rcx"
    note       x nnone x 0
    1 } else
  { eat       x "__cond" then
    caret     x is n
    (n + 1)     is m
    pterm     x eval x
    cz        x "rax"
    je        x n
    pterm     x eval x
    jmp       x m
    label     x n
    pterm     x eval x
    label     x m
    note      x __the ctx_type x 0
    1 } else
  { eat x "__syscall" then
    pterm_push x
    pterm_push x
    pterm_push x
    pterm_push x
    pterm_push x
    pterm_push x
    pterm x gt2 x "mov" "rax" "r9"
    pop x "r8"
    pop x "r10"
    pop x "rdx"
    pop x "rsi"
    pop x "rdi"
    pop x "rax"
    gt0 x "syscall"
    note x nnone x 0
    1 } else
  { eat x "__poke"  then
    pterm x eval x push x "rax"
    pterm x eval x pop  x "rcx"
    gt0   x "movb %al,(%rcx)"
    note  x nnone x 0
    1 } else
  { eat x "__peek"  then
    pterm x eval x
    gt0 x "movzb (%rax),%eax"
    note x nnone x 0
    1 } else
  { eat x "__cast" then
    __cast T 0 is t
    ptype x __addr t
    pterm x
    eval x
    note x t 0
    1 } else
  { isid first_byte then
    lookup x is o
    (__the ctx_is_type o and diag x "not a variable")
    __cond __the ctx_is_var o
      { gs x "lea " gn x (ctx_offset x o << 3) gs x "(%" gs x "rsp" gs x "),%" gs x "rax" glf x note x __the ctx_type o 1 }
      { gs x "mov " gsn x x gs x "@GOTPCREL(%rip),%rax" glf x note x __the ctx_type o 0 }
    token_advance x
    1 } else
  diag x "expected an expression"
}

parg (x X t T) $ ;

argreg (d $) $ {
  __cond (d == 0) "rdi"
  __cond (d == 1) "rsi"
  __cond (d == 2) "rdx"
  __cond (d == 3) "rcx"
  __cond (d == 4) "r8"
                "r9"
}

pcall (x X t T) $ {
  pkey x
  { t then type_equal t __the ctx_type x } else
  1 for _
  { (__the type_kind __the ctx_type x == typeid_func) then
    eval x
    __the ctx_depth x is c
    0 is d
    __the ctx_type x is t
    __the type_successor __the type_argument t is tsb
    { tsb then
      tsb for u
      __set __addr d (d + 1)
      __the type_successor u }
    fpush x d
    push x "rax"
    8 is off
    { tsb then
      tsb for u
      parg x u
      (type_equal __the ctx_type x u or diag x "asymmetric argument")
      eval x
      gs x "mov %rax," gn x off gs x "(%rsp)" glf x
      __set __addr off (off + 8)
      __the type_successor u }
    pop x "rax"
    { 0 for i
      (__a i d and __a i 6) then
      pop x argreg i
      (i + 1) }
    gt0 x "call *%rax"
    __set ctx_depth x c
    note x __the type_argument t 0
    1 }
}

pterm (x X    ) $ pcall x __cast T 0
parg  (x X t T) $ pcall x t

pseq Parser {
  pterm x
  1 for _
  { eat    x "is" then
    eval   x
    push   x "rax"
    let    x pseq
    eval   x
    pop    x "rdx"
    note   x __the ctx_type x 0
    1 } else
  { eat    x "for" then
    caret  x is n
    (n + 1)  is m
    eval   x
    push   x "rax"
    jmp    x m
    label  x n
    store  x "rsp"
    label  x m
    let    x pseq
    eval   x
    cz     x "rax"
    jne    x n
    pop    x "rax"
    note   x __the ctx_type x 0
    1 } else
  { logic  x "then" je pseq then
    note   x __the ctx_type x 0
    1 } else
  { __the ctx_type x is t
    logic  x "else" jne pseq then
    note   x t 0
    1 } else
  { __not have x "}" then
    pseq   x
    1 }
}

pmul Parser {
  pterm x
  1 for _
  infix x "*" pterm gmul else
  infix x "/" pterm gdiv else
  infix x "%" pterm gmod
}

padd Parser {
  pmul x
  1 for _
  infix x "+" pmul gadd else
  infix x "-" pmul gsub
}

psh Parser {
  padd x
  1 for _
  infix x "<<" padd gshl else
  infix x ">>" padd gshr
}

pcmp Parser {
  psh x
  1 for _
  infix x "==" psh ge  else
  infix x "!=" psh gne
}

pland Parser {
  pcmp x
  1 for _
  { logic x "and" je pcmp then
    note x __the ctx_type x 0
    1 }
}

plor Parser {
  pland x
  1 for _
  { __the ctx_type x is t
    logic x "or" jne pland then
    note x t 0
    1 }
}

stack_params (x X t T g $) $ {
  __cond __not t { pterm x eval x 0 }
    { __cast X alloc x ctx_alloc_size is o
      ctx_copy o x __cast IsType 0 __cast IsVar 1
      __set ctx_token __the ctx_successor x __the type_token t
      __set ctx_token_len __the ctx_successor x __the type_token_len t
      __set ctx_depth __the ctx_successor x g
      __set ctx_type __the ctx_successor x t
      stack_params x __the type_successor t (g + 1) is r
      __set ctx_successor x __the ctx_successor __the ctx_successor x
      r }
}

register_params (x X t T g $) $ {
  __cond __not t { pterm x eval x 0 }
    { push x argreg g
      __cast X alloc x ctx_alloc_size is o
      ctx_copy o x __cast IsType 0 __cast IsVar 1
      __set ctx_token __the ctx_successor x __the type_token t
      __set ctx_token_len __the ctx_successor x __the type_token_len t
      __set ctx_type __the ctx_successor x t
      (__the __cond (__e g 5) __addr stack_params __addr register_params x __the type_successor t (g + 1) + 1) is r
      __set ctx_successor x __the ctx_successor __the ctx_successor x
      r }
}

global (x X it IsType) X {
  try_lookup x else
  __cast X alloc x ctx_alloc_size is o
  ctx_copy o x it __cast IsVar 0
  o
}

declaration Parser ;

function Parser {
  global x __cast IsType 0 is o
  pname x ctx_type o
  (__not __the ctx_is_type o and __not __the ctx_is_def o or diag x "remention")
  __set ctx_is_def o __not eat x ";"
  { __the ctx_is_def o then
    gs x ".section .text." gsn x o glf x
    gsn x o gc x ': glf x
    __set ctx_depth x 0
    register_params x __the type_successor __the type_argument __the ctx_type o 0 is stack
    (type_equal __the type_argument __the ctx_type o __the ctx_type x or diag x "asymmetric return")
    fpop x stack
    gt0 x "ret" }
  declaration x
}

typedef Parser {
  global x __cast IsType 1 is o
  (__the ctx_is_def o and diag x "remention")
  __set ctx_is_def o 1
  pname x ctx_type o
  __cond eat x ";" declaration x typedef x
}

declaration Parser {
  __the ctx_token x then
  __cond eat x "type"
    typedef  x
    function x
}

main Parser {
  retry_in stdin __the ctx_inbuf x __cast InBuffer (__the ctx_inbuf x + (1 << 20)) is a
  { __e a __neg 1 then diag x "read failed" }
  __poke a 0
  __the ctx_outbuf x is q
  gs x ".globl _start\n"
  token x
  declaration x
  retry_out stdout q __the ctx_outbuf x is b
  (__e b __neg 1 and diag x "write failed")
  0
}

initialize (curbrk ProgramBreak inbuf AllocSize outbuf AllocSize) X {
  __cast X curbrk is x
  __set ctx_curbrk    x (curbrk + ctx_alloc_size)
  __set ctx_successor x __cast X 0
  __set ctx_inbuf     x alloc x inbuf
  __set ctx_outbuf    x alloc x outbuf
  __set ctx_line_ptr  x __the ctx_inbuf x
  __set ctx_line_no   x 1
  __set ctx_col_no    x 1
  x
}

_start () $ exit main initialize initbrk alloc_size (1 << 24) alloc_size (1 << 20) alloc_size (1 << 23)