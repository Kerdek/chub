# external functions #

(word) ?
(peek -a) ? (poke -a a) ?
(load -a) ? (store -a a) ?

(neg n) ? (not n) ?
(add a b) ? (mul a b) ? (mod a b) ? (cmpe a b) ?
(sub a b) ? (div a b) ? (shl a b) ? (cmpa a b) ?

(linux rdi rsi rdx rcx r8 r9 rax) ?

# math #

(cmpex n a b) or (cmpa n a) (cmpa b n)
(cmpin n a b) not (cmpex n a b)
(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)
(pow2 n) shl n 1
(suc n) add 1 n
(prd n) sub 1 n
(inc -n) to -n add 1
(dec -n) to -n sub 1

# strings #

(strlen s) and (peek s) (suc (strlen (suc s)))

(memcmp a b n)
or  not n
and cmpe (peek a) (peek b)
    memcmp (suc a) (suc b) (prd n)

(strncmp a b an bn)
and cmpe an bn
    memcmp a b bn

(vcmp aa ab ba bb)
    strncmp aa ba (sub aa ab) (sub ba bb)

# io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(nanosleep -mem sec nsec)
let rqtp (to -mem add 16)
do  store rqtp sec
do  store add 8 rqtp nsec
do  linux rqtp 0 0 0 0 0 35
    (to -mem sub 16)

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (cmpe i error-key)
let byte-count (io i (sub i end))
and byte-count
if  cmpe byte-count error-key
    byte-count
    add i byte-count

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code out end) do (retry-mem stdout out end) (exit code)

(runtime (main (exit code out end) in out mem) inbuf outbuf membuf)
let in  (brk 0)
let out (add in  inbuf )
let mem (add out outbuf)
do  brk (add mem membuf)
do  store mem (add mem word)
do  retry-string-read stdin in out
    main runtime-exit in out mem

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# data #

(Node) add word word

(-A node)     node
(-B node) add node word
(A node) load (-A node)
(B node) load (-B node)
(node -mem a b)
let x (to -mem add Node)
do  store (-A x) a
do  store (-B x) b
    x

# lexing #

(lex-one (class byte) -in)
and class (peek (load -in))
    inc -in

(lex-esc (class byte) (class-lex byte) (class-esc byte) -in)
if  lex-one class     -in
    lex-one class-esc -in
    lex-one class-lex -in

(vlex-bunch (body -in) -in) 
for _ 0 body -in

(vlex-lgroup  (delim -in) (body -in) -in)
and delim -in
    body  -in

(vlex-group (delim -in) (body -in) -in)
and delim -in
do  vlex-bunch body -in
    delim -in

# putting #

(vput-mem (put a -out) a b -out)
do  for i a
    and cmpa i b
    do  put (peek i) -out
        suc i
    -out

(vput-string (put a -out) s -out)
do  for p s
    let a (peek p)
    and a
    do  put a -out
        suc p
    -out

(put byte -out)
do  poke (load -out) byte
do  inc -out
    -out

(putlf -out) put '\n -out

(put-digits (put-digit a -out) base a -out)
if  a
    put-digit                 (mod base a)
    put-digits put-digit base (div base a)
    -out
    -out

(put-number (put-digit a -out) base a -out)
if  a 
    put-digits put-digit base a -out
    put '0 -out

(put-digit-16 a -out) put (add a (if (cmpa a 10) '0 '7)) -out
(put-digit-10 a -out) put (add a                 '0    ) -out

(put-dec a -out) put-number put-digit-10 10 a -out
(put-hex a -out) put-number put-digit-16 16 a -out

(put-string s -out) vput-string put s -out
(put-mem a b -out) vput-mem put a b -out

# spans #

(span-equal a b)
let aa (A a)
let ba (A b)
let an (sub aa (B a))
let bn (sub ba (B b))
    strncmp aa ba an bn

(span-strcmp span lit)
let start (A span)
let n (sub start (B span))
and memcmp lit start n
    not (peek (add lit n))

(span-set span a b)
do  store (-A span) a
    store (-B span) b
(vput-span (vput a out) span out) vput-mem vput (A span) (B span) out
(put-span span out) vput-span put span out

# weird formalities #

(stack-lookup (hay-match hay needle) stack needle)
and stack
let hay (A stack)
if  hay-match (A hay) needle
    B hay
    stack-lookup hay-match (B stack) needle

(stack-equal (hay-equal a b) a b)
or  cmpe a b
and hay-equal (B A a) (B A b)
    stack-equal hay-equal (B a) (B b)

(stack-count stack) and stack (suc (stack-count (B stack)))
(stack-pop -stack) store -stack (B (load -stack))

(name-lookup stack a b)
and stack
let hay (A stack)
if  vcmp (A A hay) (B A hay) a b
    B hay
    name-lookup (B stack) a b

(token-init (eat -in span) -mem in -in -span)
do  store -span node -mem 0 0
do  store -in in
    eat -in (load -span)

(token-match (lex-class c) span) lex-class (peek (A span))
(token-is s span) span-strcmp span s
(token-read (text -in) -in span) let caret (load -in) (span-set span caret (if text -in (load -in) caret))

(type-equal a b) or (cmpe a b) (and (and a b) (and (cmpe (B a) (B b)) (stack-equal type-equal (A a) (A b))))

# x86_64 implementation #

(x86_64-str-mov  ) "mov "
(x86_64-str-ret  ) "ret\n"
(x86_64-str-entry) "_start"
(x86_64-str-rip  ) "@GOTPCREL(%rip)"
(x86_64-str-rsp  ) "(%rsp)"
(x86_64-str-rax  ) "%rax"
(x86_64-str-rdi  ) "%rdi"
(x86_64-str-rsi  ) "%rsi"
(x86_64-str-rdx  ) "%rdx"
(x86_64-str-rcx  ) "%rcx"
(x86_64-str-r8   ) "%r8"
(x86_64-str-r9   ) "%r9"

(x86_64-mangle (vput (put a -out) s -out) s -out) vput put-hex s put 'f -out
(x86_64-mangle-mem a b -out) vput-mem put-hex a b put 'f -out
(x86_64-mangle-span   s -out) x86_64-mangle vput-span   s -out
(x86_64-mangle-string s -out) x86_64-mangle vput-string s -out

(x86_64-label-suf -out) putlf put ': -out

(x86_64-section-header (vput a b -out) a b -out)
    x86_64-label-suf vput a b putlf vput a b put-string ".section .text." -out

(gen-initdef name body -out)
    put-string x86_64-str-ret
    putlf
    put-string body
    x86_64-section-header x86_64-mangle-mem name (add name strlen name)
    -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put-string "add $" -out
do  and sign (put '- -out)
do  put-string ",%rsp\n" put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  putlf put-string reg put-string sign -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  "pop "
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  "push "

(x86_64-label-id flake -out) put '$ put-dec flake put '. -out
(x86_64-str-label flake -out) put-dec flake put-string ".s" -out
(x86_64-to-rax -out) putlf put-string x86_64-str-rax put ', -out
(x86_64-from-rax -out) put ', put-string x86_64-str-rax -out
(x86_64-jc flake s -out) putlf x86_64-label-id flake put-string s -out
(x86_64-czjc flake s -out) x86_64-jc flake s x86_64-to-rax put-string x86_64-str-rax put-string "test " -out

(x86_64-argreg index)
if  cmpe index 0 x86_64-str-rdi
if  cmpe index 1 x86_64-str-rsi
if  cmpe index 2 x86_64-str-rdx
if  cmpe index 3 x86_64-str-rcx
if  cmpe index 4 x86_64-str-r8
                 x86_64-str-r9

(x86_64-argpop index arity -depth reg -out)
do  and cmpa index arity
    x86_64-pop -depth -out reg
    -out

(x86_64-init -out -depth -flake out)
do  store -out out
do  store -depth (shl (sub 1 (shl 3 word)) 1)
do  store -flake 0
    gen-initdef "linux" "mov 8(%rsp),%rax\nsyscall"
    gen-initdef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    gen-initdef "neg"   "mov %rdi,%rax\nneg %rax"
    gen-initdef "cmpe"  "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    gen-initdef "cmpa"  "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    gen-initdef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    gen-initdef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    gen-initdef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    gen-initdef "mul"   "mov %rsi,%rax\nmul %rdi"
    gen-initdef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    gen-initdef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    gen-initdef "poke"  "movb %sil,(%rdi)"
    gen-initdef "peek"  "movzb (%rdi),%eax"
    gen-initdef "store" "mov %rsi,(%rdi)\nmov %rdi,%rax"
    gen-initdef "load"  "mov (%rdi),%rax"
    gen-initdef "word"  "mov $8,%rax"
    putlf
    x86_64-mangle-string  x86_64-str-entry
    put ',
    put-string x86_64-str-entry
    put-string "\n.equ "
    put-string x86_64-str-entry
    put-string ".globl "
    -out

(x86_64-flake -flake) inc -flake

(x86_64-je  -out flake) x86_64-czjc flake "je "  -out
(x86_64-jne -out flake) x86_64-czjc flake "jne " -out
(x86_64-jmp -out flake) x86_64-jc   flake "jmp " -out

(x86_64-ref -out -depth a b offset)
do  put-string x86_64-str-mov -out
    x86_64-to-rax
    if  offset
        put-string x86_64-str-rsp
        put-dec (shl 3 (sub load -depth offset))
        -out
        put-string x86_64-str-rip
        x86_64-mangle-mem a b
        -out

(x86_64-lit -out a b)
    x86_64-to-rax
    put-mem a b
    put '$
    put-string x86_64-str-mov
    -out

(x86_64-str -out -flake a b)
let flake (x86_64-flake -flake)
    x86_64-to-rax
    put-string x86_64-str-rip
    x86_64-str-label flake
    put-string x86_64-str-mov
    put-string ".previous\n"
    putlf
    put-mem a b
    put-string ".string,"
    x86_64-label-suf
    x86_64-str-label flake
    putlf
    x86_64-str-label flake
    put-string ".section .data."
    -out

(x86_64-label -out flake)
    x86_64-label-suf
    x86_64-label-id  flake
    -out

(x86_64-var-is -out -depth flake)
do  x86_64-fpush -depth -out 1
    load -depth

(x86_64-var-in -out flake)
do  x86_64-label -out flake
    putlf
    put-string x86_64-str-rsp
    x86_64-from-rax
    put-string x86_64-str-mov
    -out

(x86_64-let-end -out -depth flake) x86_64-fpop -depth -out 1

(x86_64-for-end -out -depth flake)
do  x86_64-jne -out flake
    x86_64-pop -depth -out x86_64-str-rax

(x86_64-call-with -out -depth arity)
do  x86_64-fpush -depth -out arity
    x86_64-push  -depth -out x86_64-str-rax

(x86_64-call-arg -out index)
    putlf
    put-string x86_64-str-rsp
    put-dec (shl 3 index)
    x86_64-from-rax
    put-string x86_64-str-mov
    -out

(x86_64-call-end -out -depth arity)
do  x86_64-pop -depth -out x86_64-str-rax
do  putlf
    put-string x86_64-str-rax
    put '*
    put-string "call "
    x86_64-argpop 5 arity -depth x86_64-str-r9
    x86_64-argpop 4 arity -depth x86_64-str-r8
    x86_64-argpop 3 arity -depth x86_64-str-rcx
    x86_64-argpop 2 arity -depth x86_64-str-rdx
    x86_64-argpop 1 arity -depth x86_64-str-rsi
    x86_64-argpop 0 arity -depth x86_64-str-rdi
	-out
and cmpa 6 arity
    x86_64-fpop -depth -out (sub 6 arity)

(x86_64-decl-in -out -depth a b)
    x86_64-section-header x86_64-mangle-mem a b -out
    

(x86_64-decl-param -out -depth index)
if  cmpa index 6
do  x86_64-push -depth -out (x86_64-argreg index)
    load -depth
    sub 5 index

(x86_64-decl-end -out -depth arity)
do  x86_64-fpop -depth -out (if cmpa arity 6 arity 6)
    put-string x86_64-str-ret -out

(x86_64-end -out) load -out

# standard semantics #

(asem-init (gen -mem out) -mem -stack -impl out)
do  store -stack 0
    store -impl (gen -mem out)

(asem-unit (gen impl a b) -impl a b)
do  gen (load -impl) a b
    0

(asem-ref (gen impl a b offset) -stack -impl a b)
let var (name-lookup (load -stack) a b)
if  not var
    error 1 "unknown reference"
do  gen (load -impl) a b (B var)
    A var

(asem-var-def (gen impl flake) -mem -stack -impl a b result flake)
if  name-lookup (load -stack) a b
    error 2 "redefinition" 
    store -stack (node -mem (node -mem (node -mem a b) (node -mem result (gen (load -impl) flake))) (load -stack))

(asem-var-end (gen impl flake) -stack -impl flake)
do  gen (load -impl) flake
    stack-pop -stack

(asem-call-with (gen impl arity) -impl result)
let arity (stack-count (A result))
do  gen (load -impl) arity
    arity

(asem-call-arg (gen impl index) -impl expect result index)
if  type-equal expect result
    gen (load -impl) index
    error 3 "illegal argument"

(asem-call-end (gen impl arity) -impl arity)
do  gen (load -impl) arity
    0

(asem-decl (gen impl flake) -mem -impl a b type)
do  gen (load -impl) 0
    node -mem node -mem a b type

(asem-param (gen impl flake) -mem -impl decl stack)
do  gen (load -impl) 0
    node -mem decl stack

(asem-end (gen impl) -impl)
    gen (load -impl)

# character ranges #

(char-range-nz byte) byte

(char-range-sq byte) cmpe  byte '\'
(char-range-dq byte) cmpe  byte '\"
(char-range-bs byte) cmpe  byte '\\
(char-range-hm byte) cmpe  byte '#
(char-range-qm byte) cmpe  byte '?
(char-range-lp byte) cmpe  byte '(
(char-range-rp byte) cmpe  byte ')
(char-range-us byte) cmpe  byte '_
(char-range-en byte) cmpe  byte '-
(char-range-sp byte) cmpe  byte ' 
(char-range-tb byte) cmpe  byte '\t
(char-range-lf byte) cmpe  byte '\n
(char-range-cr byte) cmpe  byte '\r

(char-range-09 byte) cmpin byte '0 '9
(char-range-AZ byte) cmpin byte 'A 'Z
(char-range-az byte) cmpin byte 'a 'z

# character classes #

(char-negclass (class byte) (except byte) byte)
and except byte
not class  byte

(char-class-nz byte)     char-range-nz byte
(char-class-hm byte)     char-range-hm byte
(char-class-bs byte)     char-range-bs byte
(char-class-sq byte)     char-range-sq byte
(char-class-dq byte)     char-range-dq byte
(char-class-09 byte)     char-range-09 byte
(char-class-qm byte)     char-range-qm byte
(char-class-lp byte)     char-range-lp byte
(char-class-rp byte)     char-range-rp byte

(char-class-ws byte) or  char-range-sp byte
                     or  char-range-tb byte
                     or  char-range-lf byte
                         char-range-cr byte
(char-class-id byte) or  char-range-AZ byte
                     or  char-range-az byte
                     or  char-range-09 byte
                     or  char-range-en byte
                         char-range-us byte
(char-class-im byte) or  char-range-09 byte
                         char-range-sq byte
(char-class-pt byte) or  char-range-lp byte
                     or  char-range-rp byte
                         char-range-qm byte

(char-class-sb byte) char-negclass char-class-dq char-class-nz byte
(char-class-cb byte) char-negclass char-class-hm char-class-nz byte

# lexical units #

(lex-bs-esc (char-class c) -in) lex-esc char-class-bs char-class char-class-nz -in

(lex-hm -in) lex-one    char-class-hm -in
(lex-dq -in) lex-one    char-class-dq -in
(lex-sq -in) lex-one    char-class-sq -in
(lex-09 -in) lex-one    char-class-09 -in
(lex-pt -in) lex-one    char-class-pt -in
(lex-ws -in) lex-one    char-class-ws -in
(lex-id -in) lex-bs-esc char-class-id -in
(lex-sb -in) lex-bs-esc char-class-sb -in
(lex-cb -in) lex-bs-esc char-class-cb -in

(lex-user -in)
for _ 0
or  vlex-bunch lex-ws        -in
    vlex-group lex-hm lex-cb -in

(lex-text -in)
or  vlex-bunch  lex-id        -in
or              lex-pt        -in
or  vlex-lgroup lex-sq lex-sb -in
or  vlex-group  lex-dq lex-sb -in
    vlex-bunch  lex-09        -in

# tokenizer #

(eat -in -span)
do  lex-user -in
    token-read lex-text -in -span

# parsers #

(Sem    syn)             syn
(In     syn) add (Sem    syn) word
(Span   syn) add (In     syn) word
(Result syn) add (Span   syn) word
(struct-Syn)      Result      word

(parse-with (syn-with (syn-expr syn expect) syn expect) (syn-expr syn expect) lit syn expect)
and token-is lit (load Span syn)
do  eat (In syn) (load Span syn)
do  syn-with syn-expr syn expect
    1

(parse-term (char-class byte) (sem syn a b) syn)
and token-match char-class (load Span syn)
let a (A load Span syn)
let b (B load Span syn)
do  eat (In syn) (load Span syn)
do  store (Result syn) sem load Sem syn a b
    1

(parse-exact syn (char-class byte))
and token-match char-class (load Span syn)
    eat (In syn) (load Span syn)

# abstract syntax #

(asyn-init (sem -mem -out) -mem -in -span -impl in -out)
do  token-init eat -mem in -in -span
    store -impl sem -mem -out
(asyn-end (sem sem) -sem) sem (load -sem)

(asyn-var (sem syn) (sem-is syn flake a b) (sem-in syn flake) (sem-end syn flake) (syn-expr syn expect) syn expect)
let flake (sem load Sem syn)
do  sem-is load Sem syn flake (A load Span syn) (B load Span syn)
do  parse-exact syn char-class-id
do  syn-expr syn 0
do  sem-in load Sem syn flake
let result (syn-expr syn expect)
do  sem-end load Sem syn flake
    result

(asyn-seq (sem syn) (sem-then syn flake) (sem-end syn flake) (syn-expr syn expect) syn expect)
let flake (sem load Sem syn)
let result-a (syn-expr syn expect)
do  sem-then load Sem syn flake
let result-b (syn-expr syn expect)
do  sem-end load Sem syn flake
    result-b

(asyn-cond (sem syn) (sem-then syn flake) (sem-else syn flake) (sem-end syn flake) (syn-expr syn expect) syn expect)
let flake-a (sem load Sem syn)
let result-a (syn-expr syn 0)
do  sem-then load Sem syn flake-a
let result-b (syn-expr syn expect)
let flake-b (sem load Sem syn)
do  sem-else load Sem syn flake-b
do  sem-end  load Sem syn flake-a
let result-c (syn-expr syn expect)
do  sem-end  load Sem syn flake-b
    result-c

(asyn-term
(syn-do  (syn-expr syn expect) syn expect)
(syn-if  (syn-expr syn expect) syn expect)
(syn-or  (syn-expr syn expect) syn expect)
(syn-and (syn-expr syn expect) syn expect)
(syn-let (syn-expr syn expect) syn expect)
(syn-for (syn-expr syn expect) syn expect)
(syn-lit (syn-expr syn expect) syn expect)
(syn-str (syn-expr syn expect) syn expect)
(syn-id  (syn-expr syn expect) syn expect)
(syn-expr syn expect) syn expect)
or  syn-do  syn-expr syn expect
or  syn-if  syn-expr syn expect
or  syn-or  syn-expr syn expect
or  syn-and syn-expr syn expect
or  syn-let syn-expr syn expect
or  syn-for syn-expr syn expect
or  syn-lit syn-expr syn expect
or  syn-str syn-expr syn expect
or  syn-id  syn-expr syn expect
    error 5 "expected term"

(asyn-do  (syn-do  (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-do  syn-expr "do"  syn expect
(asyn-if  (syn-if  (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-if  syn-expr "if"  syn expect
(asyn-or  (syn-or  (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-or  syn-expr "or"  syn expect
(asyn-and (syn-and (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-and syn-expr "and" syn expect
(asyn-let (syn-let (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-let syn-expr "let" syn expect
(asyn-for (syn-for (syn-expr syn expect) syn expect)  (syn-expr syn expect) syn expect) parse-with syn-for syn-expr "for" syn expect

(asyn-lit (sem syn a b) syn) parse-term char-class-im sem syn
(asyn-str (sem syn a b) syn) parse-term char-class-dq sem syn
(asyn-id  (sem syn a b) syn) parse-term char-class-id sem syn

(asyn-arg (sem syn expect result index) (syn-expr syn expect) syn expect index)
do  syn-expr syn expect
    sem load Sem syn expect (load Result syn) index

(asyn-args (sem syn expect result index) (syn-expr syn expect) syn stack index)
and stack
do  asyn-arg  sem syn-expr syn (B A stack)      index
    asyn-args sem syn-expr syn (  B stack) (suc index)

(asyn-call (sem syn type) (sem-arg syn expect result index) (sem-end syn arity) (syn-expr syn expect) syn result)
and B result
let arity (sem load Sem syn result)
do  asyn-args sem-arg syn-expr syn (A result) 1
    store (Result syn) sem-end load Sem syn arity

(asyn-juxt (syn-call (syn-expr syn expect) syn result) (syn-expr syn expect) syn expect result)
and not (type-equal expect result)
    syn-call syn-expr syn result

(asyn-expr (syn-term (syn-expr syn type) syn expect) (syn-juxt (syn-expr syn type) syn expect result) (syn-call (syn-expr syn expect) syn type) (syn-expr syn expect) syn expect)
if  parse-exact syn char-class-lp
do  syn-term syn-expr syn expect
or  parse-exact syn char-class-rp
if  syn-juxt syn-expr syn expect (load Result syn)
    parse-exact syn char-class-rp
    error 4 "expected )"
do  syn-term syn-expr syn expect
    syn-juxt syn-expr syn expect (load Result syn)

(asyn-body (sem syn) (sem-is syn flake decl) (sem-in syn flake decl) (sem-end syn flake decl) (syn-param (syn-expr syn type) syn haystack index) (syn-expr syn type) syn decl)
and decl
let flake (sem load Sem syn)
do  sem-is load Sem syn flake decl
or  parse-exact syn char-class-qm
do  sem-in load Sem syn flake decl
do  syn-param syn-expr syn (A B decl) 0
    sem-end load Sem syn flake decl

(asyn-param (sem syn decl index) (sem-end syn flake) (syn-expr syn type) syn stack index)
if  stack
let decl (A stack)
let offset (sem (load Sem syn) decl index)
do  asyn-param sem sem-end syn-expr syn (B stack) (suc index)
    sem-end load Sem syn offset
    syn-expr syn 0

(asyn-decl (sem sem a b type) (syn-type-which (syn-type syn) syn) (syn-type syn) syn)
let a (A load Span syn)
let b (B load Span syn)
and parse-exact syn char-class-id
    sem (load Sem syn) a b (syn-type-which syn-type syn)

(asyn-type-params (sem sem decl type) (syn-type-params (syn-type syn) syn) (syn-type syn) syn)
and not (parse-exact syn char-class-rp)
let decl (syn-type syn)
    sem (load Sem syn) decl (syn-type-params syn-type syn)

(asyn-type (sem sem a b type) (syn-decl (sem sem a b type) (syn-type-which (syn-type syn) syn) (syn-type syn) syn) (syn-type-func (syn-type syn) syn) (syn-type-unit (syn-type syn) syn) (syn-type syn) syn)
    syn-decl sem (if (parse-exact syn char-class-lp) syn-type-func syn-type-unit) syn-type syn

# tables #

(Out   impl)            impl
(Depth impl) add (Out   impl) word
(Flake impl) add (Depth impl) word
(X86_64    )      Flake       word

(gen-init -mem out) let impl (to -mem add X86_64) do (x86_64-init (Out impl) (Depth impl) (Flake impl) out) impl
(gen-end impl) x86_64-end (Out impl)

(gen-flake      impl            ) x86_64-flake                              (Flake impl)
(gen-label      impl flake      ) x86_64-label      (Out impl)                           flake
(gen-ref        impl a b offset ) x86_64-ref        (Out impl) (Depth impl)              a b offset
(gen-lit        impl a b        ) x86_64-lit        (Out impl)                           a b
(gen-str        impl a b        ) x86_64-str        (Out impl)              (Flake impl) a b
(gen-do         impl flake      ) 0
(gen-je         impl flake      ) x86_64-je         (Out impl)                           flake
(gen-jne        impl flake      ) x86_64-jne        (Out impl)                           flake
(gen-jmp        impl flake      ) x86_64-jmp        (Out impl)                           flake
(gen-var-is     impl flake      ) x86_64-var-is     (Out impl) (Depth impl)              flake
(gen-var-in     impl flake      ) x86_64-var-in     (Out impl)                           flake
(gen-let-end    impl flake      ) x86_64-let-end    (Out impl) (Depth impl)              flake
(gen-for-end    impl flake      ) x86_64-for-end    (Out impl) (Depth impl)              flake
(gen-call-with  impl arity      ) x86_64-call-with  (Out impl) (Depth impl)              arity
(gen-call-arg   impl index      ) x86_64-call-arg   (Out impl)                           index
(gen-call-end   impl arity      ) x86_64-call-end   (Out impl) (Depth impl)              arity
(gen-decl       impl flake      ) 0
(gen-decl-in    impl a b        ) x86_64-decl-in    (Out impl) (Depth impl)              a b
(gen-decl-param impl index      ) x86_64-decl-param (Out impl) (Depth impl)              index
(gen-decl-end   impl arity      ) x86_64-decl-end   (Out impl) (Depth impl)              arity

(asem-type-func --mem stack) node --mem stack 1
(asem-type-unit            ) 0

(Mem  sem)           sem
(Book sem) add (Mem  sem) word
(Impl sem) add (Book sem) word
(struct-Sem)    Impl      word

(sem-init -mem out)
let sem (to -mem add struct-Sem)
do  store (Mem sem) (load -mem)
do  asem-init gen-init (Mem sem) (Book sem) (Impl sem) out
    sem
(sem-end sem) asem-end gen-end (Impl sem)

(sem-lit        sem a b                ) asem-unit      gen-lit                              (     Impl sem) a b
(sem-str        sem a b                ) asem-unit      gen-str                              (     Impl sem) a b
(sem-ref        sem a b                ) asem-ref       gen-ref                   (Book sem) (     Impl sem) a b
(sem-do         sem                    )                gen-flake                            (load Impl sem)
(sem-do-then    sem flake              )                gen-do                               (load Impl sem) flake
(sem-do-end     sem flake              )                gen-label                            (load Impl sem) flake
(sem-if         sem                    )                gen-flake                            (load Impl sem)
(sem-if-then    sem flake              )                gen-je                               (load Impl sem) flake
(sem-if-else    sem flake              )                gen-jmp                              (load Impl sem) flake
(sem-if-end     sem flake              )                gen-label                            (load Impl sem) flake
(sem-or         sem                    )                gen-flake                            (load Impl sem)
(sem-or-else    sem flake              )                gen-jne                              (load Impl sem) flake
(sem-or-end     sem flake              )                gen-label                            (load Impl sem) flake
(sem-and        sem                    )                gen-flake                            (load Impl sem)
(sem-and-then   sem flake              )                gen-je                               (load Impl sem) flake
(sem-and-end    sem flake              )                gen-label                            (load Impl sem) flake
(sem-let        sem                    )                gen-flake                            (load Impl sem) 
(sem-let-is     sem flake a b          ) asem-var-def   gen-var-is      (Mem sem) (Book sem) (     Impl sem) a b 0 flake
(sem-let-in     sem flake              )                gen-var-in                           (load Impl sem) flake
(sem-let-end    sem flake              ) asem-var-end   gen-let-end               (Book sem) (     Impl sem) flake
(sem-for        sem                    )                gen-flake                            (load Impl sem)
(sem-for-is     sem flake a b          ) asem-var-def   gen-var-is      (Mem sem) (Book sem) (     Impl sem) a b 0 flake
(sem-for-in     sem flake              )                gen-var-in                           (load Impl sem) flake
(sem-for-end    sem flake              ) asem-var-end   gen-for-end               (Book sem) (     Impl sem) flake
(sem-call-with  sem type               ) asem-call-with gen-call-with                        (     Impl sem) type
(sem-call-arg   sem expect result index) asem-call-arg  gen-call-arg                         (     Impl sem) expect result index
(sem-call-end   sem arity              ) asem-call-end  gen-call-end                         (     Impl sem) arity
(sem-param      sem decl index         ) asem-var-def   gen-decl-param  (Mem sem) (Book sem) (     Impl sem) (A A decl) (B A decl) (B decl) index
(sem-param-end  sem flake              ) asem-var-end   gen-do                    (Book sem) (     Impl sem) flake
(sem-decl       sem a b type           ) asem-decl      gen-do          (Mem sem)            (     Impl sem) a b type
(sem-type-func  sem stack              ) asem-type-func                 (Mem sem)                            stack
(sem-type-unit  sem                    ) asem-type-unit
(sem-type-param sem decl stack         ) asem-param     gen-do          (Mem sem) (Impl sem)                 decl stack
(sem-body       sem                    )                gen-flake                            (load Impl sem) 
(sem-body-is    sem flake decl         ) asem-var-def   gen-decl        (Mem sem) (Book sem) (     Impl sem) (A A decl)  (B A decl) (B decl) flake
(sem-body-in    sem flake decl         )                gen-decl-in                          (load Impl sem)             (A A decl) (B A decl)
(sem-body-end   sem flake decl         )                gen-decl-end                         (load Impl sem) stack-count (A B decl)

(syn-init -mem -in -out) let syn (to -mem add struct-Syn) do (asyn-init sem-init -mem (In syn) (Span syn) (Sem syn) -in -out) syn
(syn-end syn) asyn-end sem-end (Sem syn)

(syn-do   (syn-expr syn expect) syn expect) asyn-seq  sem-do sem-do-then sem-do-end syn-expr syn expect
(syn-if   (syn-expr syn expect) syn expect) asyn-cond sem-if sem-if-then sem-if-else sem-if-end syn-expr syn expect
(syn-or   (syn-expr syn expect) syn expect) asyn-seq  sem-or sem-or-else sem-or-end syn-expr syn expect
(syn-let  (syn-expr syn expect) syn expect) asyn-var  sem-let sem-let-is sem-let-in sem-let-end syn-expr syn expect
(syn-for  (syn-expr syn expect) syn expect) asyn-var  sem-for sem-for-is sem-for-in sem-for-end syn-expr syn expect
(syn-and  (syn-expr syn expect) syn expect) asyn-seq  sem-and sem-and-then sem-and-end syn-expr syn expect
(syn-call (syn-expr syn expect) syn expect) asyn-call sem-call-with sem-call-arg sem-call-end syn-expr syn expect

(syn-term-do  (syn-expr syn expect) syn expect) asyn-do  syn-do  syn-expr syn expect
(syn-term-if  (syn-expr syn expect) syn expect) asyn-if  syn-if  syn-expr syn expect
(syn-term-or  (syn-expr syn expect) syn expect) asyn-or  syn-or  syn-expr syn expect
(syn-term-and (syn-expr syn expect) syn expect) asyn-and syn-and syn-expr syn expect
(syn-term-let (syn-expr syn expect) syn expect) asyn-let syn-let syn-expr syn expect
(syn-term-for (syn-expr syn expect) syn expect) asyn-for syn-for syn-expr syn expect
(syn-term-lit (syn-expr syn expect) syn expect) asyn-lit sem-lit syn
(syn-term-str (syn-expr syn expect) syn expect) asyn-str sem-str syn
(syn-term-id  (syn-expr syn expect) syn expect) asyn-id  sem-ref syn

(syn-type-params (syn-type syn) syn) asyn-type-params sem-type-param syn-type-params syn-type syn
(syn-type-func (syn-type syn) syn) sem-type-func (load Sem syn) (syn-type-params syn-type syn)
(syn-type-unit (syn-type syn) syn) sem-type-unit (load Sem syn)

(syn-term (syn-expr syn expect) syn expect) asyn-term syn-term-do syn-term-if syn-term-or syn-term-and syn-term-let syn-term-for syn-term-lit syn-term-str syn-term-id syn-expr syn expect
(syn-juxt (syn-expr syn expect) syn expect result) asyn-juxt syn-call syn-expr syn expect result
(syn-param (syn-expr syn expect) syn haystack index) asyn-param sem-param sem-param-end syn-expr syn haystack index
(syn-body (syn-expr syn expect) syn decl) asyn-body sem-body sem-body-is sem-body-in sem-body-end syn-param syn-expr syn decl
(syn-expr syn expect) asyn-expr syn-term syn-juxt syn-call syn-expr syn expect
(syn-type syn) asyn-type sem-decl asyn-decl syn-type-func syn-type-unit syn-type syn

(main (return code out end) in out -mem)
let syn (syn-init -mem in out)
do  for _ 0 syn-body syn-expr syn (syn-type syn)
    return 0 out (syn-end syn)

(_start) runtime main (pow2 15) (pow2 18) (pow2 18)
