# byte classification #

is_sp (c) cmpe c ' 
is_tb (c) cmpe c '\t
is_lf (c) cmpe c '\n
is_cr (c) cmpe c '\r
is_us (c) cmpe c '_
is_sq (c) cmpe c '\'
is_dq (c) cmpe c '\"

is_in (c a b) not or cmpa c a cmpa b c

is_AZ (c) is_in c 'A 'Z
is_az (c) is_in c 'a 'z
is_09 (c) is_in c '0 '9

is_ws (c)
or  is_sp c
or  is_tb c
or  is_lf c
    is_cr c

is_id (c)
or  is_AZ c
or  is_az c
or  is_09 c
    is_us c

is_lit (c)
or  is_09 c
    is_sq c

# byte input #

klength  (k) add (         k) usize
kline_no (x) add (klength  x) usize
kcol_no  (x) add (kline_no x) usize
kin      (x) add (kcol_no  x) usize
ksize    ( )      kin         usize

caret_byte (k)
peek load kin k

caret_is (is (c) k)
is peek load k

check_eof (k)
or  caret_byte k
	# unexpected eof #
	exit 2

caret_next_is (k c)
do  check_eof k
    cmpe c peek add 1 load kin k

caret_advance (k)
do  check_eof k
do  store kin k add 1 load kin k
    if  cmpe caret_byte k '\n
    do  store kcol_no k  1
        store kline_no k add 1 load kline_no k
        store kcol_no k add 1 load kcol_no k

caret_eat (k a)
and cmpe a caret_byte k
do  caret_advance k
    1

caret_eat_by (is (c) k)
and is caret_byte k
do  caret_advance k
    1

caret_eat_for (is (c) k)
and is caret_byte k
    for 1 _ caret_eat_by is k

# token #

ws (k)
do  for 1 _
    or  and caret_eat k '#
            for 1 _
            and not caret_eat k '#
                caret_advance k
            caret_eat_by is_ws k
    and not caret_byte k
        do  store k 0
        1

id (k)
caret_eat_for is_id k

number (k)
caret_eat_for is_09 k

string (k)
and caret_eat k '"
    do  for 1 _
        do  for 1 _
            and caret_eat k '\\
                caret_advance k
        and not cmpe caret_byte k '"
            caret_advance k
        caret_advance k

char (k)
and caret_eat k '\'
    do  caret_eat k '\\
    do  caret_advance k
    do  caret_eat k '\'
        1

punct (k)
or  caret_eat k '(
or  caret_eat k ')
    caret_eat k '?


# token api #

next (k)
do  or load k
    # no more tokens #
    exit 6
or  ws k
let load kin k q
do  or number k
    or string k
    or char   k
    or id     k
    or punct  k
       # invalid token #
       exit 5
do  store k q
    store klength k sub q load kin k

have (k c)
and load k
and memcmp c load k load klength k
    not peek add c load klength k

have_lit (k)
caret_is is_lit k

have_str (k)
caret_is is_dq k

have_id (k)
caret_is is_id k

eat (k c)
let have k c r
do  and r
    next k r

flake (k)
mul  100 
add  load kcol_no k
mul  1000000
load kline_no k

cmp_token (ka kb)
or  ne load klength ka load klength kb
    not strncmp
        load ka
        load kb
        load klength ka

verbatim (out k)
let add load k load klength k end
for load k in
and cmpa in end
do  put_byte out peek in
    add 1 in

# x86_64 #

ins0 (out s c)
do put_string out s
   put_byte   out c

ins1 (out s)
ins0 out s ' 

mnem0 (out s)
ins0 out s '\n

mnem1 (out s a)
do  ins1  out s
    mnem0 out a

mnem2 (out s a b)
do  ins1  out s
do  ins0 out a ',
    mnem0 out b

cz (out)
mnem2 out "test" "%rax" "%rax"

label_id (out n)
do  put_byte out 'l
do  put_number out n
    put_byte out '$

label (out n)
do  label_id out n 
    put_string out ":\n"

jc (out n s)
do  ins0 out s ' 
do  label_id out n
    put_byte out '\n

jmp (out n)
jc out n "jmp"

je (out n)
jc out n "je"

jne (out n)
jc out n "jne"

rip (out)
put_string out "@GOTPCREL(%rip),%rax\n"

def_str (out n k)
do  put_string out ".section .text..s"
do  put_number out n
do  put_string out "\n.s"
do  put_number out n
do  put_string out ":.string "
do  verbatim   out k
    put_string out "\n.previous\n"

load_str (out n)
do  put_string out "mov .s" 
do  put_number out n
    rip out

# accounting #

xbrk     (x) add (         x) usize
xout     (x) add (xbrk     x) usize
xcaret   (x) add (xout     x) usize
xscalar  (x) add (xcaret   x) ksize
xtype    (x) add (xscalar  x) usize
xdepth   (x) add (xtype    x) usize
xsize    ( )      xdepth      usize

fpushpop (out depth size ins sign (a b))
and size
do  put_string out ins
do  put_number out shl 3 size
do  put_string out ",%rsp\n"
    store depth sign size load depth

pushpop  (out depth reg  ins sign (a b))
do  mnem1 out ins reg
    store depth sign 1 load depth

fpop  (x size)
fpushpop xout x xdepth x size "add $" add

fpush (x size)
fpushpop xout x xdepth x size "add $-" sub

pop   (x reg)
pushpop xout x xdepth x reg "pop"  add

push  (x reg)
pushpop xout x xdepth x reg "push" sub

# nametable #

ocaret   (o) add (         o) usize
otype    (o) add (ocaret   o) ksize
odepth   (o) add (otype    o) usize
oisdef   (o) add (odepth   o) usize
oisvar   (o) add (oisdef   o) usize
osize    ( )      oisvar      usize

targ     (t) add (         t) usize
tcaret   (t) add (targ     t) usize
tkind    (t) add (tcaret   t) ksize
tsize    ( )      tkind       usize

book_var (x o isvar)
do store otype   o load xtype   x
do store ocaret  o load xcaret  x
do store klength ocaret o load klength xcaret x
   store oisvar o isvar

book_fn (x t o)
book_var x o 0

book_let (x t o)
do book_var x o 1
   store odepth o load xdepth x

book_param (x t o)
do store otype   o t
do store odepth  o load xdepth  x
do store ocaret  o load tcaret  t
do store klength ocaret o load klength tcaret t
   store oisvar o 1

push_book (p (x t o) x t)
let alloc xbrk x osize o
do  store o load x
do  p x t o
do  store oisdef o 0
do  store x o
    o

pop_book (x)
store x load load x

try_lookup (x)
let 0 o
let load x head
do  and head
    for head s
    if  cmp_token xcaret x ocaret s
        load s
        do  store addr o s
            0
o

lookup (x)
or  try_lookup x
    # lookup failed #
    exit 1

# types #

new_type (x kind)
let alloc xbrk x tsize t
do  store t 0
do  store tcaret t xcaret x
do  store tkind t kind
    t

type_arity (t)
let 0 d
do  and t
    for t u
    do store addr d add 1 d
       load u
    d

type_equal (a b)
and a
and b
or  cmpe a b
let load tkind a ka
let load tkind b kb
and cmpe ka kb
do  store addr a load targ a
do  store addr b load targ b
do  for 1 _
    and type_equal a b
    do  store addr a load a
    do  store addr b load b
        1
    cmpe a b

# x86 implementation #

stack_offset (x o)
sub load xdepth x
    load odepth o

letvar (p (x t) x t)
let push_book book_let x 0 o
do  next xcaret x
do  p x t
    pop_book x

logic (p (x t) g (c n) x t)
let flake xcaret x n
do  cz xout x
do  g xout x n
do  p x t
do  label xout x n
    1

gen_addr (p (x t) x t)
do  put_string xout x "lea "
do  put_number xout x shl 3 stack_offset x lookup x
do  put_string xout x "(%rsp),%rax\n"
do  store xtype x load xscalar x
    next xcaret x

gen_do (p (x t) x t)
do p x 0
   p x t

gen_let (p (x t) x t)
do  p x 0
do  push x "%rax"
do  letvar p x t 
    fpop x 1

gen_for (p (x t) x t)
let flake xcaret x n
let add 1 n m
do  p  x t
do  push  x "%rax"
do  jmp   xout x m
do  label xout x n
do  mnem2 xout x "mov" "%rax" "(%rsp)"
do  label xout x m
do  letvar p x t
do  cz    xout x
do  jne   xout x n
    pop   x "%rax"

gen_and (p (x t) x t)
do  p x 0
    logic p je x t

gen_or (p (x t) x t)
do  p x t
let load xtype x u
do  logic p jne x t
    store xtype x u

gen_if (p (x t) x t)
let flake xcaret x n
let add 1 n m
do  p x 0
do  cz xout x
do  je xout x n
do  p x t
do  jmp xout x m
do  label xout x n
let load xtype x u
do  p x t
    label xout x m

gen_lit (p (x t) x t)
do  put_string xout x "mov $"
do  verbatim xout x xcaret x
do  put_string xout x ",%rax\n"
do  next xcaret x
    store xtype x load xscalar x

gen_str (p (x t) x t)
do  def_str xout x flake xcaret x xcaret x
do  load_str    xout x flake xcaret x
do  next xcaret x
    store xtype x load xscalar x

gen_id (p (x t) x t)
let lookup x o
do  put_string xout x "mov "
do  if  load oisvar o
    do  put_number xout x shl 3 stack_offset x o
        put_string xout x "(%rsp),%rax\n"
    do  verbatim xout x xcaret x
        rip xout x
do  store xtype x load otype o
    next xcaret x

# we still need this for the funcall impl #

argreg (d)
or and cmpe d 0 "%rdi"
or and cmpe d 1 "%rsi"
or and cmpe d 2 "%rdx"
or and cmpe d 3 "%rcx"
or and cmpe d 4 "%r8"
                "%r9"

gen_arg (x i)
do  put_string xout x "mov %rax,"
do  put_number xout x shl 3 load i
do  put_string xout x "(%rsp)\n"
    store i add 1 load i

# could connect these with a callback #

gen_argreg (x i)
pop x argreg i

gen_args (parse (x t) x parameters)
let 1 depth
and parameters
for parameters u
do  parse x u
do  or  type_equal u load xtype x
        # asymmetric argument #
        exit 12
do  gen_arg x addr depth
    load u

gen_call (parse (x t) x parameters arity)
do  fpush x arity
do  push x "%rax"
do  gen_args parse x parameters
    pop x "%rax"

#
`parse_expr` is the main expression syntax.
It's just polish notation with a bit
of type sensitivity. If a `parse_expr` has
parse_declaration type, the parser expects
appropriate arguments. We need a
syntax for referring to a parse_declaration
without expecting more arguments, for
passing to HOFs sometimes. `parse_arg` is
where parens cancel call parsing.
#

parse_type (x) ?

parse_param (x t)
do  store t alloc xbrk x tsize
do  store tcaret load t load xcaret x
do  store klength tcaret load t load klength xcaret x
do  next xcaret x
let parse_type x u
do  store targ  load t load targ  u
    store tkind load t load tkind u

parse_type (x)
if  eat xcaret x "("
    let new_type x 1 t
    do  for targ t u
        and not eat xcaret x ")"
        do  parse_param x u
            load u
        t
    load xscalar x

parse_nest (parse (x t) x t) ?

kind_expr (c gen (parse (x t) x t) parse (x t) x t)
and eat xcaret x c gen parse x t

parse_primary (parse (x t) x t)
or  parse_nest parse x t
or  kind_expr "addr" gen_addr parse x t
or  kind_expr "do"   gen_do   parse x t
or  kind_expr "let"  gen_let  parse x t
or  kind_expr "for"  gen_for  parse x t
or  kind_expr "and"  gen_and  parse x t
or  kind_expr "or"   gen_or   parse x t
or  kind_expr "if"   gen_if   parse x t
or  and have_lit xcaret x  gen_lit  parse x t
or  and have_str xcaret x  gen_str  parse x t
or  and have_id  xcaret x  gen_id   parse x t
    # expected expression #
    exit 11

parse_call (parse (x t) x t)
or  have xcaret x ")" 
or  and t type_equal t load xtype x
for 1 _
and load tkind load xtype x
let load xdepth x depth
let load xtype x function_type
let load targ function_type parameters
let type_arity parameters arity
do  gen_call parse x parameters arity
do  let if cmpa arity 6 arity 6 regargs
    for 0 i
    and cmpa i regargs
    do  gen_argreg x i
        add 1 i
do  mnem1 xout x "call" "*%rax"
do  fpop x sub load xdepth x depth
do  store xtype x load xscalar x
    1

parse_expr (parse (x t) x t)
do  parse_primary parse x t
    parse_call    parse x t

parse_nest (parse (x t) x t)
and eat xcaret x "(" do parse_expr parse x t eat xcaret x ")"

parse_arg  (x t)
or parse_nest parse_arg x t
   parse_expr parse_arg x t

params        (next (x t g) x t g) if t next x t g do parse_arg x 0 0
params_next   (next (x t g) x t g) let params next x load t g h do pop_book x h
register_then (next (x t g) x t reg g) do push x reg do push_book book_param x t add 1 params_next next x t g
a_register    (next (x t g) x t reg g) register_then next x t reg add 1 g
stack     (x t g) do let push_book book_param x t o store odepth o g params_next stack x t add 1 g
register5 (x t g) register_then stack x t "%r9" 1
register4 (x t g) a_register register5 x t "%r8" g
register3 (x t g) a_register register4 x t "%rcx" g
register2 (x t g) a_register register3 x t "%rdx" g
register1 (x t g) a_register register2 x t "%rsi" g
register0 (x t g) a_register register1 x t "%rdi" g

parse_declaration (x)
and caret_byte xcaret x
do  let or try_lookup x push_book book_fn x 0 o
    do  or 	not load oisdef o
			# remention #
	       	exit 13
    do  parse_param x otype o
    do  store oisdef o not eat xcaret x "?"
        and load oisdef o
        do  put_string xout x ".section .text." 
        do  verbatim xout x ocaret o
        do  put_byte xout x '\n
        do  verbatim xout x ocaret o
        do  put_string xout x ":\n"
        do  store xdepth x 0
        do  fpop x params register0 x load targ load otype o 0
        mnem0 xout x "ret"
parse_declaration x

main (x)
do  mnem0 xout x ".globl _start"
or  ws xcaret x
let load kin xcaret x q
do  or  id xcaret x
        # invalid token #
        exit 5
do  store xcaret x q
do  store klength xcaret x sub q load kin xcaret x
    parse_declaration x

runtime (heap inbuf outbuf)
let initbrk heap x
do  store x 0
do  store xbrk x add x xsize
do  store kin xcaret x alloc xbrk x inbuf
do  store xout x alloc xbrk x outbuf
do  store kline_no xcaret x 1
do  store kcol_no xcaret x 1
do  poke retry stdin load kin xcaret x add load kin xcaret x inbuf 0
do  store xscalar x new_type x 0
let load xout x q
do  main x 
do  retry stdout q load xout x
	# OK #
    exit 0

_start ()
runtime shl 24 1 shl 20 1 shl 23 1