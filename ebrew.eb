# externals #

(word) ?
(peek -a) ? (poke -a a) ?
(load -a) ? (store -a a) ?

(neg n) ? (not n) ?
(add a b) ? (mul a b) ? (mod a b) ? (equal a b) ?
(sub a b) ? (div a b) ? (shl a b) ? (above a b) ?

(linux rdi rsi rdx rcx r8 r9 rax) ?

# math #

(range n a b) not or (above n a) (above b n)
(to -b (op a b) a) let b (load -b) (do (store -b (op a b)) b)
(pow2 n) shl n 1
(suc n) add 1 n
(prd n) sub 1 n
(inc -n) to -n add 1
(dec -n) to -n sub 1

# yes we have this #

(strlen s) and (peek s) (suc (strlen (suc s)))

# io #

(stdin  buffer size) linux 0 buffer size 0 0 0 0
(stdout buffer size) linux 1 buffer size 0 0 0 1
(stderr buffer size) linux 2 buffer size 0 0 0 1

(retry-mem (io buffer size) begin end)
let error-key (neg 1)
for i begin
and not (equal i error-key)
let n-read (io i (sub i end))
and n-read
if  equal n-read error-key
    n-read
    add i n-read

(retry-string-write (out buffer size) s) retry-mem out s (add s (strlen s))
(retry-string-read (in buffer size) a b) poke (retry-mem in a b) 0

# runtime #

(brk address) linux address 0 0 0 0 0 12
(exit code) linux code 0 0 0 0 0 60

(runtime-exit code out end)
do  retry-mem stdout out end
    exit code

(runtime (main (exit code out end) in out mem) inbuf outbuf membuf)
let in  (brk 0)
let out (add in  inbuf )
let mem (add out outbuf)
do  brk (add mem membuf)
do  store mem (add mem word)
do  retry-string-read stdin in out
    main runtime-exit in out mem

(error code message)
do  retry-string-write stderr message
do  retry-string-write stderr "\n"
    exit code

# printing #

(vput-mem (put a -out) a b -out)
do  for i a
    and above i b
    let byte (peek i)
    do  put byte -out
        suc i
    -out

(vput-string (put a -out) s -out)
do  for p s
    let a (peek p)
    and a
    do  put a -out
        suc p
    -out

(put byte -out)
do  poke (load -out) byte
do  inc -out
    -out

(putlf -out)
    put '\n -out

(put-digits (put-digit a -out) base a -out)
if  a
    put-digit                 (mod base a)
    put-digits put-digit base (div base a)
    -out
    -out

(put-number (put-digit a -out) base a -out)
if  a 
    put-digits put-digit base a -out
    put '0 -out

(put-digit-16 a -out) put (add a (if (above a 10) '0 '7)) -out
(put-digit-10 a -out) put (add a                  '0    ) -out

(put-dec a -out) put-number put-digit-10 10 a -out
(put-hex a -out) put-number put-digit-16 16 a -out

(put-string s -out) vput-string put s -out
(put-mem a b -out) vput-mem put a b -out

# x86_64 implementation #

(x86_64-str-mov  ) "mov "
(x86_64-str-ret  ) "ret\n"
(x86_64-str-entry) "_start"
(x86_64-str-rip  ) "@GOTPCREL(%rip)"
(x86_64-str-rsp  ) "(%rsp)"
(x86_64-str-rax  ) "%rax"
(x86_64-str-rdi  ) "%rdi"
(x86_64-str-rsi  ) "%rsi"
(x86_64-str-rdx  ) "%rdx"
(x86_64-str-rcx  ) "%rcx"
(x86_64-str-r8   ) "%r8"
(x86_64-str-r9   ) "%r9"

(x86_64-mangle (vput (put a -out) s -out) s -out)
    vput put-hex s put 'f -out

(x86_64-mangle-mem a b -out)
    vput-mem put-hex a b put 'f -out

(x86_64-mangle-string s -out)
    vput-string put-hex s put 'f -out

(x86_64-label-suf -out)
    putlf put ': -out

(x86_64-section-header (vput a b -out) a b -out)
    x86_64-label-suf vput a b putlf vput a b put-string ".section .text." -out

(x86_64-initdef name body -out)
    put-string x86_64-str-ret
    putlf
    put-string body
    x86_64-section-header x86_64-mangle-mem name (add name strlen name)
    -out

(x86_64-fpushpop (op -depth size) -depth -out size sign)
and size
do  put-string "add $" -out
do  and sign (put '- -out)
do  put-string ",%rsp\n" put-dec (shl 3 size) -out
    to -depth op size

(x86_64-pushpop (op -depth) -depth -out reg sign)
do  putlf put-string reg put-string sign -out
    op -depth

(x86_64-fpop  -depth -out size) x86_64-fpushpop add -depth -out size 0
(x86_64-fpush -depth -out size) x86_64-fpushpop sub -depth -out size 1
(x86_64-pop   -depth -out reg ) x86_64-pushpop  inc -depth -out reg  "pop "
(x86_64-push  -depth -out reg ) x86_64-pushpop  dec -depth -out reg  "push "

(x86_64-label-id flake -out)
    put '$
    put-dec flake
    put '.
    -out

(x86_64-str-label flake -out)
    put-dec flake
    put-string ".s"
    -out

(x86_64-to-rax -out)
    putlf
    put-string
    x86_64-str-rax
    put ',
    -out

(x86_64-from-rax -out)
    put ',
    put-string x86_64-str-rax
    -out

(x86_64-jc flake s -out)
    putlf x86_64-label-id flake put-string s
    -out

(x86_64-czjc flake s -out)
    x86_64-jc flake s
    x86_64-to-rax
    put-string x86_64-str-rax
    put-string "test "
    -out

(x86_64-argreg index)
if  equal index 0 x86_64-str-rdi
if  equal index 1 x86_64-str-rsi
if  equal index 2 x86_64-str-rdx
if  equal index 3 x86_64-str-rcx
if  equal index 4 x86_64-str-r8
                 x86_64-str-r9

(x86_64-argpop index arity -depth reg -out)
do  and above index arity
    x86_64-pop -depth -out reg
    -out

(Out   impl)            impl
(Depth impl) add (Out   impl) word
(Flake impl) add (Depth impl) word
(X86_64    )      Flake       word

(x86_64-new -mem out)
let impl (to -mem add X86_64)
do  store (Out   impl) out
do  store (Depth impl) (shl (sub 1 (shl 3 word)) 1)
do  store (Flake impl) 0
do  x86_64-initdef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-initdef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-initdef "equal" "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-initdef "above" "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-initdef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-initdef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-initdef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-initdef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-initdef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-initdef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-initdef "poke"  "movb %sil,(%rdi)"
    x86_64-initdef "peek"  "movzb (%rdi),%eax"
    x86_64-initdef "store" "mov %rsi,(%rdi)\nmov %rdi,%rax"
    x86_64-initdef "load"  "mov (%rdi),%rax"
    x86_64-initdef "word"  "mov $8,%rax"
    putlf
    x86_64-mangle-string  x86_64-str-entry
    put ',
    put-string x86_64-str-entry
    put-string "\n.equ "
    put-string x86_64-str-entry
    put-string ".globl "
    (Out impl)
    impl

(x86_64-del -mem impl)
let out (load Out impl)
do  to -mem sub X86_64
    out

(x86_64-flake impl)
    inc (Flake impl)

(x86_64-do  impl flake) 0

(x86_64-je  impl flake)
    x86_64-czjc flake "je "  (Out impl)

(x86_64-jne impl flake)
    x86_64-czjc flake "jne " (Out impl)

(x86_64-jmp impl flake)
    x86_64-jc flake "jmp " (Out impl)

(x86_64-ref impl a b offset)
do  put-string x86_64-str-mov (Out impl)
    x86_64-to-rax
    if  offset
        put-string x86_64-str-rsp
        put-dec (shl 3 (sub load (Depth impl) offset))
        (Out impl)
        put-string x86_64-str-rip
        x86_64-mangle-mem a b
        (Out impl)

(x86_64-lit impl a b)
    x86_64-to-rax
    put-mem a b
    put '$
    put-string x86_64-str-mov
    (Out impl)

(x86_64-str impl a b)
let flake (x86_64-flake impl)
    x86_64-to-rax
    put-string x86_64-str-rip
    x86_64-str-label flake
    put-string x86_64-str-mov
    put-string ".previous\n"
    putlf
    put-mem a b
    put-string ".string,"
    x86_64-label-suf
    x86_64-str-label flake
    putlf
    x86_64-str-label flake
    put-string ".section .data."
    (Out impl)

(x86_64-label impl flake)
    x86_64-label-suf
    x86_64-label-id flake
    (Out impl)

(x86_64-var-is impl flake)
do  x86_64-fpush (Depth impl) (Out impl) 1
    load (Depth impl)

(x86_64-var-in impl flake)
do  x86_64-label impl flake
    putlf
    put-string x86_64-str-rsp
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-let-end impl flake)
    x86_64-fpop (Depth impl) (Out impl) 1

(x86_64-for-end impl flake)
do  x86_64-jne impl flake
    x86_64-pop (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-with impl arity)
do  x86_64-fpush (Depth impl) (Out impl) arity
    x86_64-push  (Depth impl) (Out impl) x86_64-str-rax

(x86_64-call-arg impl index)
    putlf
    put-string x86_64-str-rsp
    put-dec (shl 3 (suc index))
    x86_64-from-rax
    put-string x86_64-str-mov
    (Out impl)

(x86_64-call-end impl arity)
do  x86_64-pop (Depth impl) (Out impl) x86_64-str-rax
do  putlf
    put-string x86_64-str-rax
    put '*
    put-string "call "
    x86_64-argpop 5 arity (Depth impl) x86_64-str-r9
    x86_64-argpop 4 arity (Depth impl) x86_64-str-r8
    x86_64-argpop 3 arity (Depth impl) x86_64-str-rcx
    x86_64-argpop 2 arity (Depth impl) x86_64-str-rdx
    x86_64-argpop 1 arity (Depth impl) x86_64-str-rsi
    x86_64-argpop 0 arity (Depth impl) x86_64-str-rdi
	(Out impl)
and above 6 arity
    x86_64-fpop (Depth impl) (Out impl) (sub 6 arity)

(x86_64-def-in impl a b)
    x86_64-section-header x86_64-mangle-mem a b (Out impl)
    
(x86_64-def impl label) 0

(x86_64-decl-param impl index)
if  above index 6
do  x86_64-push (Depth impl) (Out impl) (x86_64-argreg index)
    load (Depth impl)
    sub 5 index

(x86_64-def-end impl arity)
do  x86_64-fpop (Depth impl) (Out impl) (if above arity 6 arity 6)
    put-string x86_64-str-ret (Out impl)

# tree #

(dword) add word word

(A node)     node
(B node) add node word

(node -mem a b)
let x (to -mem add dword)
do  store (A x) a
do  store (B x) b
    x

# operational semantics #

(memcmp a b n)
or  not n
and equal (peek a) (peek b)
    memcmp (suc a) (suc b) (prd n)

(strncmp a b an bn)
and equal an bn
    memcmp a b bn

(lookup list a b)
and list
let decl (load A list)
let span (load A decl)
let src-a (load A span)
if  strncmp src-a a (sub src-a (load B span)) (sub a b)
    load B decl
    lookup (load B list) a b

(book-equal (check type-a type-b) book-a book-b)
or  equal book-a book-b
and check (load B (load A book-a)) (load B (load A book-b))
    book-equal check (load B book-a) (load B book-b)

(check type-a type-b)
or  equal type-a type-b
and type-a
and type-b
and equal (load B type-a) (load B type-b)
    book-equal check (load A type-a) (load A type-b)

(count list)
and list
let n-rest (count (load B list))
    suc n-rest

(Mem  sem)           sem
(Book sem) add (Mem  sem) word
(Impl sem) add (Book sem) word
(Type sem) add (Impl sem) word
(struct-Sem)    Type      word

(op-type-func sem list)
    node (Mem sem) list 1

(op-type-unit) 0

(op-new (gen -mem out) -mem out)
let impl (gen -mem out)
let sem (to -mem add struct-Sem)
do  store (Mem sem) (load -mem)
do  store (Book sem) 0
do  store (Impl sem) impl
    sem

(op-del (gen -mem impl) -mem -impl)
do  to -mem sub struct-Sem
    (gen -mem (load -impl))

(op-unit (gen impl a b) sem a b)
do  gen (load Impl sem) a b
do  store (Type sem) op-type-unit
    0

(op-flake (gen impl) sem)
    gen (load Impl sem)

(op-label (gen impl flake) sem flake)
    gen (load Impl sem) flake

(op-ref (gen impl a b offset) sem a b)
let var (lookup (load Book sem) a b)
if  not var
    error 1 "unknown reference"
do  gen (load Impl sem) a b (load B var)
do  store (Type sem) (load A var)
    load A var

(op-var (gen impl label) sem label a b result)
let list (load Book sem)
if  lookup list a b
    error 2 "redefinition"
let -mem (Mem sem)
    store (Book sem) (node -mem (node -mem (node -mem a b) (node -mem result (gen (load Impl sem) label))) list)

(op-var-end (gen impl flake) sem flake)
do  gen (load Impl sem) flake
    store (Book sem) (load B (load Book sem))

(op-check sem type)
    check type (load Type sem)

(op-call (gen impl arity) sem)
let list (load A (load Type sem))
do  gen (load Impl sem) (count list)
    list

(op-arg sem list)
    load B (load A list)

(op-arg-end (gen impl index) sem index list)
do  gen (load Impl sem) index
    load B list

(op-call-end (gen impl arity) sem arity)
do  gen (load Impl sem) arity
    store (Type sem) op-type-unit

(op-decl (gen impl flake) sem a b type)
do  gen (load Impl sem) 0
    node (Mem sem) (node (Mem sem) a b) type

(op-param (gen impl flake) sem name list)
do  gen (load Impl sem) 0
    node (Mem sem) name list

# denotational semantics #

(denote-new -mem out) op-new x86_64-new -mem out
(denote-del -mem sem) op-del x86_64-del -mem (Impl sem)

(denote-lit        sem       a b     ) op-unit      x86_64-lit        sem a b
(denote-str        sem       a b     ) op-unit      x86_64-str        sem a b
(denote-ref        sem       a b     ) op-ref       x86_64-ref        sem a b
(denote-do         sem               ) op-flake     x86_64-flake      sem
(denote-do-then    sem label         ) op-label     x86_64-do         sem label
(denote-do-end     sem label         ) op-label     x86_64-label      sem label
(denote-if         sem               ) op-flake     x86_64-flake      sem
(denote-if-then    sem label         ) op-label     x86_64-je         sem label
(denote-if-else    sem label         ) op-label     x86_64-jmp        sem label
(denote-if-end     sem label         ) op-label     x86_64-label      sem label
(denote-or         sem               ) op-flake     x86_64-flake      sem
(denote-or-else    sem label         ) op-label     x86_64-jne        sem label
(denote-or-end     sem label         ) op-label     x86_64-label      sem label
(denote-and        sem               ) op-flake     x86_64-flake      sem
(denote-and-then   sem label         ) op-label     x86_64-je         sem label
(denote-and-end    sem label         ) op-label     x86_64-label      sem label
(denote-let        sem               ) op-flake     x86_64-flake      sem 
(denote-let-is     sem label a b     ) op-var       x86_64-var-is     sem label a b 0
(denote-let-in     sem label         ) op-label     x86_64-var-in     sem label
(denote-let-end    sem label         ) op-var-end   x86_64-let-end    sem label
(denote-for        sem               ) op-flake     x86_64-flake      sem
(denote-for-is     sem label a b     ) op-var       x86_64-var-is     sem label a b 0
(denote-for-in     sem label         ) op-label     x86_64-var-in     sem label
(denote-for-end    sem label         ) op-var-end   x86_64-for-end    sem label
(denote-check      sem           type) op-check                       sem type
(denote-call       sem               ) op-call      x86_64-call-with  sem
(denote-call-end   sem arity         ) op-call-end  x86_64-call-end   sem arity
(denote-arg        sem           list) op-arg                         sem list
(denote-arg-end    sem index     list) op-arg-end   x86_64-call-arg   sem index list
(denote-param      sem index a b type) op-var       x86_64-decl-param sem index a b type  
(denote-param-end  sem label         ) op-var-end   x86_64-do         sem label
(denote-type-param sem decl      list) op-param     x86_64-do         sem decl list
(denote-def        sem       a b type) op-var       x86_64-def        sem 0 a b type  
(denote-def-in     sem       a b     )              x86_64-def-in     (load Impl sem) a b
(denote-def-end    sem arity a b     )              x86_64-def-end    (load Impl sem) arity
(denote-decl       sem       a b type) op-decl      x86_64-do         sem a b type  
(denote-type-func  sem           list) op-type-func                   sem list
(denote-type-unit                    ) op-type-unit

# character classes #

(class-nz byte) byte

(negclass (class byte) byte)
and class-nz byte
    not class byte

(class-hm byte) equal byte '#
(class-bs byte) equal byte '\\
(class-sq byte) equal byte '\'
(class-dq byte) equal byte '\"
(class-qm byte) equal byte '?
(class-lp byte) equal byte '(
(class-rp byte) equal byte ')
(class-09 byte) range byte '0 '9

(class-ws byte) or  equal byte ' 
                or  equal byte '\t
                or  equal byte '\n
                    equal byte '\r
(class-id byte) or  range byte 'A 'Z
                or  range byte 'a 'z
                or  range byte '0 '9
                or  equal byte '-
                    equal byte '_
(class-im byte) or  range byte '0 '9
                    equal byte '\'
(class-pt byte) or  equal byte '(
                or  equal byte ')
                    equal byte '?

(class-sb byte) negclass class-dq byte
(class-cb byte) negclass class-hm byte

# lexer #

(lex-one (class byte) -in)
let in (load -in)
let byte (peek in)
and class byte
    inc -in

(lex-esc (class byte) -in)
if  lex-one class-bs -in
    lex-one class-nz -in
    lex-one class    -in

(lex-hm -in) lex-one class-hm -in
(lex-dq -in) lex-one class-dq -in
(lex-sq -in) lex-one class-sq -in
(lex-09 -in) lex-one class-09 -in
(lex-pt -in) lex-one class-pt -in
(lex-ws -in) lex-one class-ws -in
(lex-id -in) lex-esc class-id -in
(lex-sb -in) lex-esc class-sb -in
(lex-cb -in) lex-esc class-cb -in

# tokenizer #

(bunch (body -in) -in) 
for _ 0
    body -in

(prefix (delim -in) (body -in) -in)
and delim -in
    body  -in

(group (delim -in) (body -in) -in)
and delim -in
do  bunch body -in
    delim -in

# parser #

(token -in span)
do  for _ 0
    or  bunch  lex-ws        -in
        group  lex-hm lex-cb -in
let a (load -in)
do  or  bunch  lex-id        -in
    or         lex-pt        -in
    or  prefix lex-sq lex-sb -in
    or  group  lex-dq lex-sb -in
        bunch  lex-09        -in
let b (load -in)
do  store (A span) a
    store (B span) b

(Sem    syn)             syn
(In     syn) add (Sem    syn) word
(Span   syn) add (In     syn) word
(struct-Syn)      Span        word

(parse-init -mem in out)
let syn (to -mem add struct-Syn)
do  store (Span syn) node -mem 0 0
do  store (In syn) in
do  store (Sem syn) denote-new -mem out
do  token (In syn) (load Span syn)
    syn

(parse-del -mem syn)
let end (denote-del -mem (load Sem syn))
do  to -mem sub struct-Syn
    end

(stem lit (syntax-with (expr syn expect) syn expect) (expr syn expect) syn expect)
let span (load Span syn)
let a (load A span)
and strncmp lit a (strlen lit) (sub a (load B span))
do  token (In syn) span
do  syntax-with expr syn expect
    1

(leaf (class byte) (op syn a b) syn)
let span (load Span syn)
let a (load A span)
let b (load B span)
and class (peek a)
do  token (In syn) span
do  op (load Sem syn) a b
    1

(punct (class byte) syn)
let span (load Span syn)
and class (peek (load A span))
    token (In syn) span

# expression syntax #

(expr-seq (den syn) (denote-then syn flake) (denote-end syn flake) (expr syn type) syn type)
let sem (load Sem syn)
let flake (den sem)
do  expr syn type
do  denote-then sem flake
do  expr syn type
    denote-end sem flake

(expr-do  (expr syn type) syn type) expr-seq denote-do  denote-do-then  denote-do-end  expr syn type
(expr-or  (expr syn type) syn type) expr-seq denote-or  denote-or-else  denote-or-end  expr syn type
(expr-and (expr syn type) syn type) expr-seq denote-and denote-and-then denote-and-end expr syn type

(expr-var (den syn) (denote-is syn flake a b) (denote-in syn flake) (denote-end syn flake) (expr syn type) syn type)
let sem (load Sem syn)
let flake (den sem)
let span (load Span syn)
do  denote-is sem flake (load A span) (load B span)
do  punct class-id syn
do  expr syn denote-type-unit
do  denote-in sem flake
do  expr syn type
    denote-end sem flake

(expr-let (expr syn type) syn type) expr-var denote-let denote-let-is denote-let-in denote-let-end expr syn type
(expr-for (expr syn type) syn type) expr-var denote-for denote-for-is denote-for-in denote-for-end expr syn type

(expr-if (expr syn type) syn type)
let sem (load Sem syn)
let flake-a (denote-if sem)
do  expr syn denote-type-unit
do  denote-if-then sem flake-a
do  expr syn type
let flake-b (denote-if sem)
do  denote-if-else sem flake-b
do  denote-if-end sem flake-a
do  expr syn type
    denote-if-end sem flake-b

(arg (expr syn type) syn list index)
if  list
let sem (load Sem syn)
do  expr syn (denote-arg sem list)
    arg expr syn (denote-arg-end sem index list) (suc index)
    index

(call (expr syn type) syn type)
or  stem "do"  expr-do  expr syn type
or  stem "if"  expr-if  expr syn type
or  stem "or"  expr-or  expr syn type
or  stem "and" expr-and expr syn type
or  stem "let" expr-let expr syn type
or  stem "for" expr-for expr syn type
do  or  leaf class-im denote-lit syn
    or  leaf class-id denote-ref syn
    or  leaf class-dq denote-str syn
        error 3 "expected term"
let sem (load Sem syn)
or  denote-check sem type
do  denote-call-end sem (arg expr syn (denote-call sem) 0)
or  denote-check sem type
    error 4 "illegal argument"

(expr syn type)
if  punct class-lp syn
do  call expr syn type
or  punct class-rp syn
    error 5 "expected )"
    call expr syn type

# type syntax #

(syntax-decl (den sem a b type) (syntax-type-which (syntax-type syn) syn) (syntax-type syn) syn)
let span (load Span syn)
let a (load A span)
let b (load B span)
and punct class-id syn
    den (load Sem syn) a b (syntax-type-which syntax-type syn)

(syntax-type-params (syntax-type syn) syn)
and not punct class-rp syn
    denote-type-param (load Sem syn) (syntax-type syn) (syntax-type-params syntax-type syn)

(syntax-type-func (syntax-type syn) syn) denote-type-func (load Sem syn) (syntax-type-params syntax-type syn)
(syntax-type-unit (syntax-type syn) syn) denote-type-unit

(syntax-type syn) syntax-decl denote-decl (if (punct class-lp syn) syntax-type-func syntax-type-unit) syntax-type syn

# declaration syntax #

(param syn list index)
if  list
let decl (load A list)
let sem (load Sem syn)
let span (load A decl)
let offset (denote-param sem index (load A span) (load B span) (load B decl))
let arity (param syn (load B list) (suc index))
do  denote-param-end sem offset
    arity
do  expr syn 0
    index

(def syn)
let decl (syntax-type syn)
and decl
let sem (load Sem syn)
let span (load A decl)
let a (load A span)
let b (load B span)
let type (load B decl)
do  denote-def sem a b type
or  punct class-qm syn
do  denote-def-in sem a b
    denote-def-end sem (param syn (load type) 0) a b

# entry #

(main (return code out end) in out -mem)
let syn (parse-init -mem in out)
do  for _ 0 def syn
let end (parse-del -mem syn)
    return 0 out end

(_start) runtime main (pow2 15) (pow2 18) (pow2 17)