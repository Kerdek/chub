# external data functions #

peek  (-byte) ?
load  (-word) ?
poke  (-byte byte) ?
store (-word word) ?

# external arithmetic functions #

neg   (a  ) ?
not   (a  ) ?
add   (a b) ?
sub   (a b) ?
mul   (a b) ?
div   (a b) ?
mod   (a b) ?
shl   (a b) ?
cmpa  (a b) ?
cmpe  (a b) ?

# external io #

linux (rdi rsi rdx rcx r8 r9 rax) ?

#  #

exit   (exit-code) linux exit-code 0 0 0 0 0 60

brk    (address) linux address 0 0 0 0 0 12

initbrk (size)
let address brk 0
do  brk add size address
    address

stdin  (buffer size) linux 0 buffer size 0 0 0 0
stdout (buffer size) linux 1 buffer size 0 0 0 1
stderr (buffer size) linux 2 buffer size 0 0 0 1

io-retry (io (buffer size) a b)
let err (neg 1)
for i a
and not (cmpe i err)
let n (io i (sub i b))
if  cmpe n err
	err
and n
	add n i

runtime (main (-in -out -brk) heap inbuf outbuf)
let -in  (initbrk heap   )
let -out (add -in  inbuf )
let -brk (add -out outbuf)
do  poke (io-retry stdin -in (add -in inbuf)) 0
do  io-retry stdout -out (main -in -out -brk)
    exit 0

cmpin (a b c) not or (cmpa a b) (cmpa c a)

suc (a) add 1 a
prd (a) sub 1 a

pow2 (n) shl n 1

post (op (a) -a)
let a (load -a)
do  store -a (op a)
    a

inc (-a) post suc -a
dec (-a) post prd -a

to (-b op (a b) a)
let b (load -b)
do  store -b (op a b)
    b

strlen (s)
and peek s
	suc (strlen (suc s))

strncmp (a b n)
or  not n
and cmpe (peek a) (peek b)
    strncmp (suc a) (suc b) (prd n)

put (c out)
let p load out
do  poke p c
do  store out (add 1 p)
    out

put-digit-16  (n out) put (add n (if (cmpa n 10) '0 '7)) out
put-digit-10  (n out) put (add n                 '0    ) out

put-digits-nonzero (put-digits (put-digit (n out) base n out) put-digit (n out) base n out)
    put-digit                 (mod base n)
	put-digits put-digit base (div base n)
	out

put-digits-zero (put-digits (put-digit (n out) base n out) put-digit (n out) base n out)
	out

put-digits (put-digit (n out) base n out)
if  n (put-digits-nonzero) (put-digits-zero) put-digits put-digit base n out

put-number-nonzero (put-digit (n out) base n out)
    put-digit                 (mod base n)
	put-digits put-digit base (div base n)
	out

put-number-zero (put-digit (n out) base n out)
	out

put-number (put-digit (n out) base n out)
if  n (put-number-nonzero) (put-number-zero) put-digit base n out

put-number-10 (n out) put-number put-digit-10 10 n out
put-number-16 (n out) put-number put-digit-16 16 n out

vput-mem (put (a out) a b out)
do  for i a
    and cmpa i b
    do  put (peek i) out
        suc i
	out

vput-string (put (a out) s out)
do  for p s
    let a (peek p)
    and a
    do  put a out
        suc p
	out

put-string (s out) vput-string put s out

err (code s) exit
do  io-retry stderr s (add s (strlen s))
do  stderr "\n" 1
    code

# data functions #

struct ( ) 8

pair--a     (-pair)     -pair
pair--b     (-pair) add -pair 8
struct-pair (     )           16

pair-set-a (-pair a) store (pair--a -pair) a
pair-set-b (-pair b) store (pair--b -pair) b

pair-get-a (-pair) load (pair--a -pair)
pair-get-b (-pair) load (pair--b -pair)

pair-set (-pair a b)
do  pair-set-a -pair a
    pair-set-b -pair b

pair-new  (-mem a b)
let -pair (to -mem add 16)
do  pair-set -pair a b
    -pair

pair-copy (a b) pair-set a (pair-get-a b) (pair-get-b b)

pair-equal (equal-a (a b) equal-b (a b) a b)
and equal-a (pair-get-a a) (pair-get-b a)
    equal-b (pair-get-a b) (pair-get-b b)

# sem type #

sem--book     (-sem      )                      -sem
sem--mem      (-sem      ) add   (sem--book     -sem) struct
sem--out      (-sem      ) add   (sem--mem      -sem) struct
sem-get-token (-sem      ) add   (sem--out      -sem) struct
sem--type     (-sem      ) add   (sem-get-token -sem) struct-pair
sem--val      (-sem      ) add   (sem--type     -sem) struct
sem--fixed    (-sem      ) add   (sem--val      -sem) struct
sem--flake    (-sem      ) add   (sem--fixed    -sem) struct
sem--impl     (-sem      ) add   (sem--flake    -sem) struct
struct-sem    (          )        sem--impl           struct

sem-set-book  (-sem book ) store (sem--book  -sem) book
sem-set-mem   (-sem mem  ) store (sem--mem   -sem) mem
sem-set-out   (-sem out  ) store (sem--out   -sem) out
sem-set-type  (-sem type ) store (sem--type  -sem) type
sem-set-val   (-sem val  ) store (sem--val   -sem) val
sem-set-fixed (-sem fixed) store (sem--fixed -sem) fixed
sem-set-flake (-sem flake) store (sem--flake -sem) flake
sem-set-impl  (-sem impl ) store (sem--impl  -sem) impl 

sem-get-book  (-sem      ) load  (sem--book  -sem)
sem-get-mem   (-sem      ) load  (sem--mem   -sem)
sem-get-out   (-sem      ) load  (sem--out   -sem)
sem-get-type  (-sem      ) load  (sem--type  -sem)
sem-get-val   (-sem      ) load  (sem--val   -sem)
sem-get-fixed (-sem      ) load  (sem--fixed -sem)
sem-get-flake (-sem      ) load  (sem--flake -sem)
sem-get-impl  (-sem      ) load  (sem--impl  -sem)

span-equal-rest (a b n)
or  not n
and cmpe peek a peek b
    span-equal-rest (suc a) (suc b) (prd n)

span-equal (a b)
let ap pair-get-a a
let bp pair-get-a b
let an sub ap pair-get-b a
let bn sub bp pair-get-b b
and cmpe an bn
    span-equal-rest ap bp bn

span-strcmp (s lit)
let start pair-get-a s
let end pair-get-b s
let n sub start end
and strncmp lit start n
    not peek add lit n

vput-span (vput (a out) s out) vput-mem vput (pair-get-a s) (pair-get-b s) out

put-span (s out) vput-span put s out

# bookkeeping #

book-count (-book)
and -book
    suc (book-count (pair-get-a -book))

book-lookup (match (line key) -book key)
and -book
let line pair-get-b -book
if  match line key
    line
    book-lookup match (pair-get-a -book) key

book-equal (line-equal (a b) a b)
or  cmpe a b
and a
and b
and            line-equal (pair-get-b a) (pair-get-b b)
    book-equal line-equal (pair-get-a a) (pair-get-a b)

type-new-unit     (mem     ) pair-new mem 0    0
type-new-function (mem args) pair-new mem args 1

type-decl-equal (arg-equal (a b) a b)
or  cmpe a b
and a
and b
and cmpe                 (pair-get-b a) (pair-get-b b)
    book-equal arg-equal (pair-get-a a) (pair-get-a b)

decl-equal (a b) type-decl-equal decl-equal (pair-get-b a) (pair-get-b b)

type-equal (a b) type-decl-equal decl-equal a b

token-copy (-mem a b)
do  store (pair--a  a) pair-new -mem (pair-get-a pair-get-a b) (pair-get-b pair-get-a  b)
    store (pair--b a) (pair-get-b b)

token-clone (-mem j)
let k (to -mem add struct-pair)
do  token-copy -mem k j
    k

token-match (lex (c) k) lex (peek (pair-get-a (pair-get-a k)))

token-is (lit k) span-strcmp (pair-get-a k) lit

token-equal (a b) span-equal (pair-get-a a) (pair-get-a b)

name-new (-mem span var)
let n (to -mem add struct-pair)
do  store (pair--a n) pair-new -mem (pair-get-a span) (pair-get-b span)
do  pair-set-b n var
    n

name-push (-mem -book span var) pair-new -mem -book (name-new -mem span var)

pair-get-a-equal (n span) span-equal (pair-get-a n) span

try-name-lookup (book span) book-lookup pair-get-a-equal book span

var-push (mem -book span t y) store -book (name-push mem (load -book) span (pair-new mem t y))

try-var-lookup (o span)
let e (try-name-lookup o span)
and e
    pair-get-b e

# token parsers #

eat-bunch (body (c) c) 
for _ 0 body c

eat-grou  (delim (c) body (c) c)
and delim c
    body  c

eat-group (delim (c) body (c) c)
and delim c
delim
do  eat-bunch body c
    c

lex-normal (char-class (a) -caret)
and char-class peek load -caret
    store -caret (suc (load -caret))

lex-escape (class (a) class-normal (a) class-alternate (a) -caret)
if  lex-normal class           -caret
    lex-normal class-alternate -caret
    lex-normal class-normal    -caret

# x86_64 implementation #

x86_64-string-mov              () "mov"
x86_64-string-add              () "add"
x86_64-string-test             () "test"
x86_64-string-je               () "je"
x86_64-string-jne              () "jne"
x86_64-string-jmp              () "jmp"
x86_64-string-push             () "push"
x86_64-string-pop              () "pop"
x86_64-string-call             () "call"
x86_64-string-ret              () "ret"
x86_64-string-entry            () "_start"
x86_64-string-stack-top        () "(%rsp)"
x86_64-string-gotpcrel-rip     () "@GOTPCREL(%rip)"
x86_64-string-str-label-prefix () ".s"
x86_64-string-globl            () ".globl"
x86_64-string-equ              () ".equ"
x86_64-string-section-text     () ".section .text."
x86_64-string-section-data     () ".section .data."
x86_64-string-string           () ".string"
x86_64-string-previous         () ".previous"
x86_64-string-rax              () "%rax"
x86_64-string-rsp              () "%rsp"
x86_64-string-rdi              () "%rdi"
x86_64-string-rsi              () "%rsi"
x86_64-string-rdx              () "%rdx"
x86_64-string-rcx              () "%rcx"
x86_64-string-r8               () "%r8"
x86_64-string-r9               () "%r9"

x86_64-mangle (vput (put (a out) s out) s out)
    vput put-number-16 s
    put 'f
	out

x86_64-mangle-span   (s out) x86_64-mangle vput-span   s out
x86_64-mangle-string (s out) x86_64-mangle vput-string s out

x86_64-label-suf (out)
    put '

    put ':
	out

x86_64-section-header (vput (s out) s out)
    x86_64-label-suf
    vput s
    put '

    vput s
    put-string x86_64-string-section-text
	out

x86_64-predef (string body out)
	put '

    put-string            x86_64-string-ret
	put '

    put-string            body
    x86_64-section-header
    x86_64-mangle-string  string
	put '\n
    put-string            string
	put ' 
    put-string            x86_64-string-globl
	out

x86_64-pre (out)
    x86_64-predef "linux" "mov 8(%rsp),%rax\nsyscall"
    x86_64-predef "not"   "test %rdi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "neg"   "mov %rdi,%rax\nneg %rax"
    x86_64-predef "cmpe"  "cmp %rsi,%rdi\nsete %al\nmovzbl %al,%eax"
    x86_64-predef "cmpa"  "cmp %rdi,%rsi\nseta %al\nmovzbl %al,%eax"
    x86_64-predef "shl"   "mov %rsi,%rax\nmov %rdi,%rcx\nshl %cl,%rax"
    x86_64-predef "mod"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi\nmov %rdx,%rax"
    x86_64-predef "div"   "xor %edx,%edx\nmov %rsi,%rax\ndiv %rdi"
    x86_64-predef "mul"   "mov %rsi,%rax\nmul %rdi"
    x86_64-predef "sub"   "mov %rsi,%rax\nsub %rdi,%rax"
    x86_64-predef "add"   "mov %rsi,%rax\nadd %rdi,%rax"
    x86_64-predef "poke"  "movb %sil,(%rdi)"
    x86_64-predef "peek"  "movzb (%rdi),%eax"
    x86_64-predef "store" "mov %rsi,(%rdi)"
    x86_64-predef "load"  "mov (%rdi),%rax"
    put '\n
    x86_64-mangle-string  x86_64-string-entry
	put ',
    put-string            x86_64-string-entry
	put ' 
    put-string            x86_64-string-equ
	put '\n
    put-string            x86_64-string-entry
	put ' 
    put-string            x86_64-string-globl
	out

x86_64-fpushpop (op (y size) y size sign out)
if  size
do  put        '$
	put ' 
    put-string x86_64-string-add
	out
do  and sign
        put '- out
do  put '\n
    put-string   x86_64-string-rsp
    put ',
    put-number-10 (shl 3 size)
    out
do  to y op size
	out
    out

x86_64-pushpop (op (y) y reg sign out)
do  put '\n
    put-string reg
	put ' 
    put-string (if sign x86_64-string-push x86_64-string-pop)
    out
do  op y
    out

x86_64-fpop  (y size out) x86_64-fpushpop add y size 0 out
x86_64-fpush (y size out) x86_64-fpushpop sub y size 1 out
x86_64-pop   (y reg  out) x86_64-pushpop  inc y reg  0 out
x86_64-push  (y reg  out) x86_64-pushpop  dec y reg  1 out

x86_64-label-id (n out)
    put           '$
    put-number-10 n 
    put           '.
	out

x86_64-cz (out)
	put '\n
    put-string x86_64-string-rax
	put ',
    put-string x86_64-string-rax
	put ' 
    put-string x86_64-string-test
	out

x86_64-jc (n s out)
    put '\n
    x86_64-label-id n
	put ' 
    put-string      s
	out

x86_64-czjc (n s out)
    x86_64-jc n s
    x86_64-cz
	out

x86_64-je  (n out) x86_64-czjc n x86_64-string-je  out
x86_64-jne (n out) x86_64-czjc n x86_64-string-jne out
x86_64-jmp (n out) x86_64-jc   n x86_64-string-jmp out

x86_64-id (s y z out)
do  put ' 
	put-string x86_64-string-mov out
    put '\n
	put-string x86_64-string-rax
    if  y
		put ',
		put-string x86_64-string-stack-top
	    put-number-10 (shl 3 (sub z y))
	    out
		put ',
		put-string x86_64-string-gotpcrel-rip
	    x86_64-mangle-span s
	    out

x86_64-lit (s out)
    put '\n
	put-string x86_64-string-rax
    put ',
    put-span s
    put '$
	put ' 
    put-string x86_64-string-mov
	out

x86_64-str-label (n out)
    put-number-10 n
    put-string x86_64-string-str-label-prefix
	out

x86_64-str (s a out)
    put '\n
	put-string       x86_64-string-rax
	put ',
    put-string       x86_64-string-gotpcrel-rip
    x86_64-str-label a
	put ' 
    put-string       x86_64-string-mov
    put '\n
	put-string       x86_64-string-previous
    put '\n
    put-span         s
	put ',
    put-string       x86_64-string-string
    x86_64-label-suf
    x86_64-str-label a
    put '\n
    x86_64-str-label a
    put-string       x86_64-string-section-data
	out

x86_64-do    (a out) 1

x86_64-label (a out)
    x86_64-label-suf
    x86_64-label-id  a
    out

x86_64-var (-detail -flake -out) load
do x86_64-fpush -detail 1 -out
   -detail

x86_64-let-end (y a out) x86_64-fpop y 1 out

x86_64-var-in (a out)
	put '\n
    put-string    x86_64-string-stack-top
	put ',
    put-string    x86_64-string-rax
	put ' 
    put-string    x86_64-string-mov
    x86_64-label    a
	out

x86_64-for-end (y a out)
    x86_64-pop y x86_64-string-rax
    x86_64-jne a
    out

x86_64-call-with (y a out)
let z (load y)
do  x86_64-push  y x86_64-string-rax
    x86_64-fpush y a
    out
    z

x86_64-call-arg (i out)
	put '\n
    put-string    x86_64-string-stack-top
    put-number-10 (shl 3 i)
	put ',
    put-string    x86_64-string-rax
	put ' 
    put-string    x86_64-string-mov
	out

x86_64-call-end-pop (i n y s out)
if  cmpa i n
    x86_64-pop y s out
	out

x86_64-call-end (y z n out)
do  put '\n
    put-string x86_64-string-rax
    put '*
	put ' 
    put-string x86_64-string-call
	x86_64-call-end-pop 5 n y x86_64-string-r9
    x86_64-call-end-pop 4 n y x86_64-string-r8
    x86_64-call-end-pop 3 n y x86_64-string-rcx
    x86_64-call-end-pop 2 n y x86_64-string-rdx
    x86_64-call-end-pop 1 n y x86_64-string-rsi
    x86_64-call-end-pop 0 n y x86_64-string-rdi
    x86_64-pop   y x86_64-string-rax
    out
    x86_64-fpop y (sub (load y) z)
	out

x86_64-decl-in (y span out)
do  x86_64-section-header x86_64-mangle-span span out
    store y shl 63 1

x86_64-decl-end (y z out)
	put '\n
    put-string x86_64-string-ret
    x86_64-fpop y z
    out

# character ranges #

char-range-nz (a) not not a

char-range-sq (a) cmpe  a '\'
char-range-dq (a) cmpe  a '\"
char-range-bs (a) cmpe  a '\\
char-range-hm (a) cmpe  a '#
char-range-qm (a) cmpe  a '?
char-range-lp (a) cmpe  a '(
char-range-rp (a) cmpe  a ')
char-range-us (a) cmpe  a '_
char-range-en (a) cmpe  a '-
char-range-sp (a) cmpe  a ' 
char-range-tb (a) cmpe  a '\t
char-range-lf (a) cmpe  a '\n
char-range-cr (a) cmpe  a '\r

char-range-09 (a) cmpin a '0 '9
char-range-AZ (a) cmpin a 'A 'Z
char-range-az (a) cmpin a 'a 'z

# character classes #

char-class-nz (a)     char-range-nz a

char-class-lf (a)     char-range-lf a
char-class-hm (a)     char-range-hm a
char-class-bs (a)     char-range-bs a
char-class-sq (a)     char-range-sq a
char-class-dq (a)     char-range-dq a
char-class-09 (a)     char-range-09 a

char-class-ws (a) or  char-range-sp a
                  or  char-range-tb a
                  or  char-range-lf a
                      char-range-cr a
char-class-id (a) or  char-range-AZ a
                  or  char-range-az a
                  or  char-range-09 a
                  or  char-range-en a
                      char-range-us a
char-class-im (a) or  char-range-09 a
                      char-range-sq a
char-class-un (a) or  char-range-09 a
                  or  char-range-sq a
                  or  char-range-AZ a
                  or  char-range-az a
                  or  char-range-09 a
                  or  char-range-en a
                  or  char-range-us a
                      char-range-dq a
char-class-pt (a) or  char-range-lp a
                  or  char-range-rp a
                      char-range-qm a

char-negclass (char-class (a) a)
and char-class-nz a
not char-class    a

char-class-sb (a) char-negclass char-class-dq a
char-class-cb (a) char-negclass char-class-hm a

# lexer #

lex-hm (c) lex-normal char-class-hm c
lex-dq (c) lex-normal char-class-dq c
lex-sq (c) lex-normal char-class-sq c
lex-09 (c) lex-normal char-class-09 c
lex-pt (c) lex-normal char-class-pt c
lex-ws (c) lex-normal char-class-ws c
lex-id (c) lex-escape char-class-bs char-class-id char-class-nz c
lex-sb (c) lex-escape char-class-bs char-class-sb char-class-nz c
lex-cb (c) lex-escape char-class-bs char-class-cb char-class-nz c

# tokenizer #

eat-user (c)
for _ 0
or  eat-bunch lex-ws        c
    eat-group lex-hm lex-cb c

eat-text (c)
or  eat-bunch lex-id        c
or            lex-pt        c
or  eat-grou  lex-sq lex-sb c
or  eat-group lex-dq lex-sb c
    eat-bunch lex-09        c

eat (-caret -span)
do  eat-user -caret
let a (load -caret)
    pair-set -span a (if eat-text -caret (load -caret) a)

# semantics #

sem-impl-pre (impl (-out) -book -out) impl
do  store -book 0
    -out

sem-impl-flake (-flake) inc -flake

sem-impl-lit (impl (span -out) -mem -type span -out) store -type type-new-unit 
do  impl span -out
    -mem

sem-impl-str (impl (span flake -out) -mem -type span flake -out) store -type type-new-unit
do  impl span flake -out
    -mem

sem-impl-ref (impl (span detail-old detail-new -out) -type book span detail -out)
let var try-var-lookup book span
if  var
    store -type pair-get-a 
		do  impl span (pair-get-b var) detail -out
			var
    err 2 "undefined identifier"

sem-impl-var (impl (-detail flake -out) -flake -mem -book -detail span type -out)
let flake sem-impl-flake -flake
do  var-push -mem -book span type (impl -detail flake -out)
    flake

sem-impl-var-end (impl (-detail flake -out) -mem -book -detail flake -out)
do  impl -detail flake -out
    store -book (pair-get-a (load -book))

sem-impl-call-arg  (impl (index -out) type-param type-arg index -out)
if  type-equal type-param type-arg
    impl index -out
    err 3 "illegal argument type"

sem-impl-call-end  (impl (detail-old detail-new arity -out) -mem -type detail-old detail-new arity -out)
do  impl detail-old detail-new arity -out
    store -type (type-new-unit -mem)

# expression parsers #

parse-builtin (token-class (k) syn (syn (x t) x t) syn-syn (x t) x t)
and token-class (sem-get-token x)
do  eat (pair--b sem-get-token x) (pair-get-a sem-get-token x)
    syn syn-syn x t

parse-skip (token-class (k) x)
and token-class (sem-get-token x)
    eat (pair--b sem-get-token x) (pair-get-a sem-get-token x)

parse-atom (token-class (k) syn (syn (x t) x t) syn-syn (x t) x t)
and token-class (sem-get-token x)
do  syn syn-syn x t
    parse-skip token-class x

parse-decl (token-class (k) syn (x) x)
and token-class (sem-get-token x)
    syn x

token-class-do   (k) token-is "do"   k
token-class-if   (k) token-is "if"   k
token-class-or   (k) token-is "or"   k
token-class-and  (k) token-is "and"  k
token-class-for  (k) token-is "for"  k
token-class-let  (k) token-is "let"  k

token-class-qm   (k) token-is "?" k
token-class-lp   (k) token-is "(" k
token-class-rp   (k) token-is ")" k

token-class-unit (k) token-match char-class-un k
token-class-str  (k) token-match char-class-dq k
token-class-lit  (k) token-match char-class-im k
token-class-id   (k) token-match char-class-id k

parse-lit  (x) parse-skip token-class-lit  x
parse-str  (x) parse-skip token-class-str  x
parse-id   (x) parse-skip token-class-id   x
parse-lp   (x) parse-skip token-class-lp   x
parse-rp   (x) parse-skip token-class-rp   x
parse-qm   (x) parse-skip token-class-qm   x

# here we connect the syntaxes to their semantics #

syn-sem-unit (sem (x) x)
    sem      x

syn-sem-str (sem (x) sem-end (x a) x)
let a sem      x
    sem-end  x a

syn-sem-var (sem (x) sem-in (x a) sem-end (x a) syn (x t) syn-id (x) x t)
let a
    sem      x
do  syn      x 0
do  sem-in   x a
do  syn-id   x
do  syn      x t
    sem-end  x a

syn-sem-war (sem (x) sem-in (x a) sem-end (x a) syn (x t) syn-id (x) x t)
let a
    sem      x
do  syn-id   x
do  syn      x 0
do  sem-in   x a
do  syn      x t
    sem-end  x a

syn-sem-seq (sem (x) sem-then (x a) sem-end (x a) syn (x t) x t)
let a
    sem      x
do  syn      x t
do  sem-then x a
do  syn      x t
    sem-end  x a

syn-sem-if (sem (x) sem-then (x a) sem-else (x a) sem-end (x a) syn (x t) x t)
let a sem      x
do  syn      x 0
do  sem-then x a
do  syn      x t
let b sem      x
do  sem-else x b
do  sem-end  x a
do  syn      x t
    sem-end  x b

syn-sem-arg (sem (x t i) syn (x t) x t i)
do  syn      x t
    sem      x t i

syn-sem-args (sem (x t i) syn (x t) x o i)
and o
do  syn-sem-arg  sem syn x (pair-get-b pair-get-b o)      i
    syn-sem-args sem syn x (              pair-get-a o) (suc i)

syn-sem-call (sem (x n) sem-arg (x o i) sem-end (x n y) syn (x t) x t)
let n (book-count (pair-get-a t))
let y sem x n
do  syn-sem-args sem-arg syn x (pair-get-a t) 1
    sem-end  x n y

# here we say what implementation to use #

sem-pre            (x    ) sem-impl-pre       x86_64-pre        (sem--book x) (sem--out   x)

sem-expr-lit       (x    ) sem-impl-lit       x86_64-lit        (sem--mem   x) (sem--type x) (pair-get-a sem-get-token x) (sem--out  x)
sem-expr-str       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-str-end   (x a  ) sem-impl-str       x86_64-str        (sem--mem   x) (sem--type x) (pair-get-a sem-get-token x) a (sem--out  x)
sem-expr-id        (x    ) sem-impl-ref       x86_64-id         (sem--type  x) (sem-get-book x) (pair-get-a sem-get-token x) (sem-get-impl x) (sem--out   x)
sem-expr-let       (x    ) sem-impl-var       x86_64-var        (sem--flake x) (sem--mem   x) (sem--book x) (sem--impl x) (pair-get-a sem-get-token x) (sem-get-type x) (sem--out x)
sem-expr-let-in    (x a  )                    x86_64-var-in     a (sem--out   x)
sem-expr-let-end   (x a  ) sem-impl-var-end   x86_64-let-end    (sem--mem   x) (sem--book x) (sem--impl x) a (sem--out  x)
sem-expr-for       (x    ) sem-impl-var       x86_64-var        (sem--flake x) (sem--mem   x) (sem--book x) (sem--impl x) (pair-get-a sem-get-token x) (sem-get-type x) (sem--out x)
sem-expr-for-in    (x a  )                    x86_64-var-in     a (sem--out  x)
sem-expr-for-end   (x a  ) sem-impl-var-end   x86_64-for-end    (sem--mem   x) (sem--book x) (sem--impl x) a (sem--out  x)
sem-expr-do        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-do-then   (x a  )                    x86_64-do         a (sem--out   x)
sem-expr-do-end    (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-and       (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-and-then  (x a  )                    x86_64-je         a (sem--out   x)
sem-expr-and-end   (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-or        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-or-else   (x a  )                    x86_64-jne        a (sem--out   x)
sem-expr-or-end    (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-if        (x    ) sem-impl-flake                       (sem--flake x)
sem-expr-if-then   (x a  )                    x86_64-je         a (sem--out   x)
sem-expr-if-else   (x a  )                    x86_64-jmp        a (sem--out   x)
sem-expr-if-end    (x a  )                    x86_64-label      a (sem--out   x)
sem-expr-call-with (x n  )                    x86_64-call-with  (sem--impl x) n (sem--out   x)
sem-expr-call-arg  (x t i) sem-impl-call-arg  x86_64-call-arg   (sem-get-type x) t i (sem--out   x)
sem-expr-call-end  (x n y) sem-impl-call-end  x86_64-call-end   (sem--mem   x) (sem--type x) (sem--impl x) y n (sem--out x)

# here we say what semantics to use for each expression #

syn-pre       (          x  ) syn-sem-unit sem-pre                x

syn-expr-lit  (syn (x t) x t) syn-sem-unit sem-expr-lit           x
syn-expr-str  (syn (x t) x t) syn-sem-str  sem-expr-str
                                           sem-expr-str-end       x
syn-expr-id   (syn (x t) x t) syn-sem-unit sem-expr-id            x
syn-expr-let  (syn (x t) x t) syn-sem-war  sem-expr-let
                                           sem-expr-let-in
                                           sem-expr-let-end
										   syn
										   parse-id               x t
syn-expr-for  (syn (x t) x t) syn-sem-war  sem-expr-for
                                           sem-expr-for-in
                                           sem-expr-for-end
										   syn
										   parse-id               x t
syn-expr-do   (syn (x t) x t) syn-sem-seq  sem-expr-do
                                           sem-expr-do-then
                                           sem-expr-do-end    syn x t
syn-expr-and  (syn (x t) x t) syn-sem-seq  sem-expr-and
                                           sem-expr-and-then 
                                           sem-expr-and-end   syn x t
syn-expr-or   (syn (x t) x t) syn-sem-seq  sem-expr-or
                                           sem-expr-or-else
                                           sem-expr-or-end    syn x t
syn-expr-if   (syn (x t) x t) syn-sem-if   sem-expr-if
                                           sem-expr-if-then
                                           sem-expr-if-else
                                           sem-expr-if-end    syn x t
syn-expr-call (syn (x t) x t) syn-sem-call sem-expr-call-with
                                           sem-expr-call-arg
                                           sem-expr-call-end  syn x t

syn-expr-term (syn (x t) x t)
or  parse-builtin token-class-do  syn-expr-do  syn x t
or  parse-builtin token-class-if  syn-expr-if  syn x t
or  parse-builtin token-class-or  syn-expr-or  syn x t
or  parse-builtin token-class-and syn-expr-and syn x t
or  parse-builtin token-class-for syn-expr-for syn x t
or  parse-builtin token-class-let syn-expr-let syn x t
or  parse-atom    token-class-lit syn-expr-lit syn x t
or  parse-atom    token-class-str syn-expr-str syn x t
    parse-atom    token-class-id  syn-expr-id  syn x t

syn-expr-juxt (syn (x t) x t)
let u (sem-get-type x)   
and not type-equal t    u
and pair-get-b       u
    syn-expr-call syn x u

syn-expr-nest (syn (x t) x t)
if  parse-lp x
do  syn-expr-term syn x t
or  parse-rp x
do  syn-expr-juxt syn x t
or  parse-rp x
    err 4 "expected `)`"
if  syn-expr-term syn x t
    syn-expr-juxt syn x t
    err 5 "expected expression"

syn-expr (x t) syn-expr-nest syn-expr x t

# ebrew's declaration syntax #

params (next (x o y) x o y)
if  o
    next x o y
do  syn-expr x (type-new-unit (sem--mem x))
	0

params-next (next (x o y) x o y)
let h params next x (pair-get-a o) y
do  store (sem--book x) (pair-get-a sem-get-book x)
    h

param-name-push (x o y)
let d (pair-get-b o)
    var-push (sem--mem x) (sem--book x) (pair-get-a pair-get-a d) (pair-get-b d) y

register (next (x o y) x o reg y)
do  x86_64-push (sem--impl x) reg (sem--out x)
do  param-name-push x o (sem-get-impl x)
    suc (params-next next x o y)

stack (x o y)
do  param-name-push   x o y
    params-next stack x o (suc y)

register-seq (next (x o y) reg x o y) register next x o reg (suc y)

register5 (x o y) register-seq     stack "%r9"  x o 0
register4 (x o y) register-seq register5 "%r8"  x o y
register3 (x o y) register-seq register4 "%rcx" x o y
register2 (x o y) register-seq register3 "%rdx" x o y
register1 (x o y) register-seq register2 "%rsi" x o y
register0 (x o y) register-seq register1 "%rdi" x o y

syn-body (x d)
if  try-name-lookup (sem-get-book x) (pair-get-a pair-get-a d)
    err 6 "redefinition"
do  var-push (sem--mem x) (sem--book x) (pair-get-a pair-get-a d) (pair-get-b d) 0
do  pair-get-b sem-get-book x
or  parse-qm x
do  x86_64-decl-in  (sem--impl x) (pair-get-a pair-get-a d) (sem--out x)
let y (params register0 x (pair-get-a pair-get-b d) 0)
	x86_64-decl-end (sem--impl x) y (sem--out x)

syn-decl-seq (syn (x) x)
and token-class-id (sem-get-token x)
let d (             syn x)
let o (syn-decl-seq syn x)
	pair-new (sem--mem x) o d

syn-decl-type (syn (x) x)
if  parse-lp x
let o (syn-decl-seq syn x)
if  parse-rp x
    type-new-function (sem--mem x) o
    err 7 "expected `)`"
    type-new-unit     (sem--mem x)

syn-decl (x)
let k token-clone (sem--mem x) (sem-get-token x)
do  parse-id x
    pair-new (sem--mem x) k (syn-decl-type syn-decl x)

syn-def (x) syn-body x (syn-decl x)

syn-defs (x) for _ 0 parse-decl token-class-id syn-def x

syn (x) do syn-pre x syn-defs x

main (in out x)
do  store (sem--mem x) add x struct-sem
do  store (sem--out x) out
do  store (pair--a  sem-get-token x) pair-new (sem--mem x) 0 0
do  store (pair--b sem-get-token x) in
do  eat (pair--b sem-get-token x) (pair-get-a sem-get-token x)
do  syn x
    (sem-get-out x)

_start ()
runtime main
    pow2 24
    pow2 20
    pow2 23
