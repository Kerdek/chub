type
  Type {
    s      @Type
    a      @Type
    kp     @byte
    kn      byte
    kind    byte
    size    byte
    offset  byte
    align   byte
  }

  T @Type

  Context {
    s       @Context
    t       @Type
    line     nat
    col      nat
    c        nat
    pline   @byte
    p       @byte
    q       @byte
    curbrk  @byte
    kp      @byte
    kn       byte
    l        byte
    is_type  byte
    is_def   byte
    is_local byte
  }

  X @Context
;

xcpy (xa X xb X it nat il nat id nat) none = {
  memcpy cast @byte xa cast @byte xb sizeof Context
  (xa.s = xb.s)
  (xb.s = xa )
  (xb.s.is_type  = cast byte it)
  (xb.s.is_local = cast byte il)
  (xb.s.is_def   = cast byte id)
}

try_lookup (x X) X = {
  cast X 0 is xb
  { x.s then
    x.s for s
    (s.kn != x.kn or not strncmp s.kp x.kp cast nat x.kn) ?
      s.s
      { (xb = s)
        cast X 0 } }
  xb
}

push_scope (x X is_type nat is_local nat is_def nat f @(x X) none) none = {
  some Context xb
  xcpy &xb x is_type is_local is_def
  f@ x
}

lookup_push_scope (x X is_type nat is_local nat is_def nat f @(x X o X) none) none = {
  try_lookup x is o
  some Context xb
  xcpy &xb x is_type is_local is_def
  f@ x o
}

xalloc (x X n nat) @none = alloc n &x.curbrk

oglf(x X       c @(x X c byte) none) none = c@ x '\n
ogn1(x X n nat c @(x X c byte) none) none = { n then ogn1 x (n / 10) c c@ x cast byte ('0 + n % 10) }
ogn (x X n nat c @(x X c byte) none) none = { n ? ogn1 x n c c@ x '0 }

gc (x X c byte ) none = { (x.q@ = c) (x.q = &x.q^1) }
gs (x X s @byte) none = { s for p p@ then gc x p@ &p^1 }
gsn(x X xb X) none = { 0 for m (m < xb.kn) then gc x xb.kp^m (m + 1) }
glf (x X      ) none = oglf x   &gc
gn  (x X n nat) none = ogn  x n &gc

oc (x X c byte       ) none = err &c 1
os (x X s @byte      ) none = err s strlen s
osn(x X s @byte n nat) none = err s n
olf (x X      ) none = oglf x   &oc
on  (x X n nat) none = ogn  x n &oc

diag (x X s @byte) none = {
  { x.kp for q (q@ and q@ != '\n) then (&q^1) } is end_line
  oc x '( on x x.line oc x ', on x x.col os x "): " osn x x.pline (end_line - x.pline)
  os x s olf x
  exit 1
}

lookup (x X) X = {
  try_lookup x else
  diag x "lookup failed"
}

make_type(x X size nat align nat kind nat) T = {
  cast T xalloc x sizeof Type is t
  (t.s = 0)
  (t.size  = size  )
  (t.align = align )
  (t.kind = cast byte kind)
  t
}

make_type_a(x X size nat align nat kind nat a T) T = {
  make_type x size align kind is t
  (t.a = a)
  t
}

nnone (x X    ) T = make_type   x 0 0 0
nbyte (x X    ) T = make_type   x 1 1 1
nnat  (x X    ) T = make_type   x 8 8 2
nstct (x X    ) T = make_type   x 0 1 3
nptr  (x X a T) T = make_type_a x 8 8 4 a
nfunc (x X a T) T = make_type_a x 1 1 5 a

type_equal(t T u T) nat = {
  t then
  u then
  (t == u) else
  { (t.kind == u.kind) then
    (t.kind == 0) else
    (t.kind == 1) else
    (t.kind == 2) else
    (t.kind == 4) ? type_equal t.a u.a
    (t.kind == 6) ? type_equal t.a u.a
    (t.kind == 7) ? type_equal t.a u.a
      { (t.kind == 5 ) then
        t.a is p
        u.a is q
        { 1 for _
          type_equal p q then
          (p = p.s)
          (q = q.s)
          1 }
        (p == q) } }
}

issp (c byte    ) nat = (c == '  )
istb (c byte    ) nat = (c == '\t)
islf (c byte    ) nat = (c == '\n)
iscr (c byte    ) nat = (c == '\r)
is_  (c byte    ) nat = (c == '_ )

isin (c byte a byte b byte) nat = (a <= c and c <= b)

isAZ (c byte    ) nat = isin c 'A 'Z
isaz (c byte    ) nat = isin c 'a 'z
is09 (c byte    ) nat = isin c '0 '9
isaf (c byte    ) nat = isin c 'a 'f
isws (c byte    ) nat = { issp c else
                          istb c else
                          islf c else
                          iscr c      }
is0f (c byte    ) nat = { is09 c else
                          isaf c      }
isid (c byte    ) nat = { isAZ c else
                          isaz c else
                          is09 c else
                          is_  c      }

caret_is      (x X c byte) nat  = (x.p@ == c)
caret_next_is (x X c byte) nat  = { (x.p@ or diag x "unexpected end of file") (x.p^1 == c) }

caret_advance (x X) none = {
  (x.p@ or diag x "unexpected end of file")
  (x.p = &x.p^1)
  caret_is x '\n ? {
    (x.col = 1)
    (x.line = x.line + 1)
    (x.pline = &x.p^1)
  } (x.col = x.col + 1)
}

comment (x X) nat = {
  (caret_is x '/ and caret_next_is x '*) then
  caret_advance x
  caret_advance x
  { 1 for _
    (caret_is x '* and caret_next_is x '/) ?
      { caret_advance x caret_advance x 0 }
      { caret_advance x        1 } }
  1
}

number (x X) nat = {
  x.p is q
  { 1 for _ is09 x.p@ then caret_advance x 1 }
  (x.p != q) then
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

string (x X) nat = {
  caret_is x '" then
  x.p is q
  caret_advance x
  { 1 for _
    { 1 for _ caret_is x '\\ then caret_advance x caret_advance x 1}
    (caret_is x '\n and diag x "newline in string literal")
    not caret_is x '" then
    caret_advance x
    1
  }
  caret_advance x
  (x.kp = q)
  (x.kn = x.p - q)
  gs x ".section .text..s" gn x (x.line * 10000 + x.col) glf x
  gs x ".s" gn x (x.line * 10000 + x.col) gc x ': gs x ".string \""
  { &x.kp^1 for i (i < &x.kp^(x.kn - 1)) then gc x i@ &i^1 }
  gc x '\" glf x
  gs x ".previous" glf x
  1
}

char (x X) nat = {
  caret_is x '\' then
  x.p is q
  caret_advance x
  { caret_is x '\\ then
    caret_advance x }
  caret_advance x
  { caret_is x '\' then
    caret_advance x }
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

id (x X) nat = {
  x.p is q
  { 1 for _ isid x.p@ then caret_advance x 1 }
  (x.p != q) then
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

sw1 (x X a byte       ) nat = { caret_is x a then caret_advance x 1 }
sw2 (x X a byte b byte) nat = { caret_is x a then caret_next_is x b then caret_advance x caret_advance x 1 }

punct (x X) nat = {
  x.p is q
  { sw2 x '= '= else
    sw2 x '! '= else
    sw2 x '< '= else
    sw2 x '> '= else
    sw2 x '< '- else
    sw2 x '- '> else
    sw2 x '< '< else
    sw2 x '> '> else
    sw2 x '/ '/ else
    sw1 x '=    else
    sw1 x '<    else
    sw1 x '>    else
    sw1 x '+    else
    sw1 x '-    else
    sw1 x '*    else
    sw1 x '/    else
    sw1 x '&    else
    sw1 x '|    else
    sw1 x '@    else
    sw1 x '#    else
    sw1 x '{    else
    sw1 x '}    else
    sw1 x '(    else
    sw1 x ')    else
    sw1 x '[    else
    sw1 x ']    else
    sw1 x '!    else
    sw1 x '?    else
    sw1 x ':    else
    sw1 x ';    else
    sw1 x ',    else
    sw1 x '.    else
    sw1 x '~    else
    sw1 x '^    else
    sw1 x '$    else
    sw1 x '`    else
    sw1 x '%
  }
  (x.kp = q)
  (x.kn = x.p - q)
  1
}

eof (x X) nat = {
  not x.p@ then
  (x.kp = cast @byte 0)
  1
}

ws (x X) nat = {
  1 for _
  comment x else
  isws x.p@ then
  caret_advance x
  1
}

token (x X) none = {
  ws     x
  eof    x else
  number x else
  string x else
  char   x else
  id     x else
  punct  x else
  diag x "invalid token"
}

token_advance (x X        ) none = { (x.kp or diag x "unexpected end of tokens") token x }
token_is      (x X c @byte) nat  = { x.kp then memcmp c x.kp cast nat x.kn then not c^x.kn }
token_expect  (x X c @byte) none = { { not token_is x c then diag x "unexpected" } token_advance x }
token_eat     (x X c @byte) nat  = { token_is x c is r { r then token_advance x } r }

argreg (d nat) @byte = {
  (d == 0) ? "rdi"
  (d == 1) ? "rsi"
  (d == 2) ? "rdx"
  (d == 3) ? "rcx"
  (d == 4) ? "r8"
             "r9"
}

gtreg (x X s @byte                ) none = { gc x '% gs x s }
gt0   (x X s @byte                ) none = { gs x s glf x  }
gt1   (x X s @byte a @byte        ) none = { gs x s gc x '  gtreg x a glf x }
gt2   (x X s @byte a @byte b @byte) none = { gs x s gc x '  gtreg x a gc x ', gtreg x b glf x }

gtz  (x X a @byte) none = gt2 x "xor"  a a
cz (x X a @byte) none = gt2 x "test" a a

gtlit (x X l nat a @byte) none = (l ? { gs x "mov $" gn x l gc x ', gtreg x a glf x } gtz x a)

gtnot (x X a @byte) none = gt1 x "not" a
gtneg (x X a @byte) none = gt1 x "neg" a
gmul  (x X a @byte) none = gt1 x "mul" a
gdiv  (x X        ) none = { gtz x "edx" gt1 x "div" "rdi" }
gmod  (x X        ) none = { gdiv x gt2 x "mov" "rdx" "rax" }
gshx  (x X k byte ) none = { gt2 x "mov" "dil" "cl" gs x "sh" gc x k gs x " %cl,%rax" glf x }

gadd (x X a @byte b @byte) none = gt2 x "add" a b
gsub (x X a @byte b @byte) none = gt2 x "sub" a b
gand (x X a @byte b @byte) none = gt2 x "and" a b
gor  (x X a @byte b @byte) none = gt2 x "or"  a b
gxor (x X a @byte b @byte) none = gt2 x "xor" a b
gcmp (x X a @byte b @byte) none = gt2 x "cmp" a b
gshr (x X ) none = gshx x 'r
gshl (x X ) none = gshx x 'l

gpromote(x X b @byte) none = gt2 x "movzbl" "al" b

gsetf     (x X s @byte         b @byte        ) none = { gs x "set" gs x s gc x '  gtreg x "al" glf x gpromote x b }
gcmp_setf (x X s @byte a @byte b @byte c @byte) none = { gcmp x a b gsetf x s c }
gcmpz_setf(x X s @byte a @byte b @byte        ) none = { cz x a   gsetf x s b }
glnot     (x X         a @byte b @byte        ) none = { gcmpz_setf x "e" a b }

label(x X n nat        ) none = {                        gc x 'L gn x n gs x "$:" glf x }
jc   (x X n nat s @byte) none = { gc x 'j gs x s gc x '  gc x 'L gn x n gc x '$   glf x }

jmp  (x X n nat) none = jc x n "mp"
je   (x X n nat) none = jc x n "e"
jne  (x X n nat) none = jc x n "ne"
jb   (x X n nat) none = jc x n "b"
jbe  (x X n nat) none = jc x n "be"
ja   (x X n nat) none = jc x n "a"
jae  (x X n nat) none = jc x n "ae"

gegcmp(x X s @byte) none = gcmp_setf x s "rdi" "rax" "eax"

gfpop (x X l nat  ) none = { l then gs x "add $" gn x (l << 3) gc x ', gtreg x "rsp" glf x (x.c = x.c + l) }
gfpush(x X l nat  ) none = gfpop x -l

push (x X d @byte) none = { gt1 x "push" d (x.c = x.c - 1) }
pop  (x X s @byte) none = { gt1 x "pop"  s (x.c = x.c + 1) }

gindex(x X l nat) none = { l then gs x "add $" gn x l gc x ', gtreg x "rax" glf x }

gcast (x X) none = {
  (x.t.kind == 0) ?
    gtz x "eax"
    { (x.t.kind == 1) then
      gpromote x "eax" }
}

gaddr (x X t T n nat s @byte d @byte) none = {
  (n or not strcmp s d) then
  gs x "lea " { n then gn x n } gs x "(%" gs x s gs x "),%" gs x d glf x
}

gload (x X t T n nat s @byte d @byte) none = {
  (t.kind == 1) ?
    { gs x  "movzbq " gn x n gs x "(%" gs x s gs x "),%" gs x  d glf x }
    { gs x  "mov "    gn x n gs x "(%" gs x s gs x "),%" gs x  d glf x }
}

store (x X t T d @byte) none = {
  (t.kind == 1) ?
    { gs x "mov %al,(%"  gs x d gc x ') glf x }
    { gs x "mov %rax,(%" gs x d gc x ') glf x }
}

geval (x X l nat) none = {
  x.l for l2
  (l2 > l) then
  (l2 == 1 and l == 0) ?
    (x.t.kind == 5 or x.t.kind == 3 or gload x x.t 0 "rax" "rax")
    { gt0 x "mov (%rax),%rax" }
  (l2 - 1)
}

note (x X t T l nat) nat = {
  (x.t = t)
  (x.l = l)
}

g1ops (x X p@ (x X) none) nat = {
  p@ x
  geval x 0
  note x nnat x 0
}

g2ops (x X p@ (x X) none) nat = {
  geval x 0
  push x "rax"
  p@ x
  geval x 0
  gt0 x "mov %rax,%rdi"
  pop x "rax"
  note x nnat x 0
  1
}

ge  (x X) none = gegcmp x "e"
gne (x X) none = gegcmp x "ne"
gb  (x X) none = gegcmp x "b"
gbe (x X) none = gegcmp x "be"
ga  (x X) none = gegcmp x "a"
gae (x X) none = gegcmp x "ae"

let (x X p @(x X) none) none = {
  some Context xb
  xcpy &xb x 0 1 0
  token_advance x
  p@ x
  (x.s = x.s.s)
}

gpt (x X t T) none = {
  gs x "mov $" gsn x x gs x ",%rax" glf x
  token_advance x
  note x t 0
  1
}

ptype (x X) T
p2 (x X) none
p3 (x X) none
p4 (x X) none
p5 (x X) none
p8 (x X) none

gsys3 (x X fd nat id nat) none = {
  p3 x
  geval x 0
  push x "rax"
  p3 x
  geval x 0
  pop x "rsi"
  gt2 x "mov" "rax" "rdx"
  gtlit x fd "rdi"
  gtlit x id "rax"
  gt0 x "syscall"
  note x nnat x 0
}

align(n nat a nat) nat = ((n + a - 1) / a * a)

param (x X t @@Type) none = {
  (t@ = cast @Type xalloc x sizeof Type)
  (t.kp = x.kp)
  (t.kn = x.kn)
  token_advance x
  ptype x is u
  (t.a = u.a)
  (t.kind = u.kind)
  (t.size = u.size)
  (t.align = u.align)
  (t.offset = u.offset)
}

pstruct (x X) @Type = {
  nstct x is t
  &t.a is u
  { 1 for _
    not token_eat x "}" then
    param x u
    (u = &u.s) }
  0 is bits
  { t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

pfunc (x X) @Type = {
  cast T 0 is params
  &params is u
  { 1 for _
    not token_is x ")" then
    param x u
    (u = &u.s)
    1 }
  token_advance x
  ptype x is ret
  nfunc x cast @Type xalloc x sizeof Type is t
  memcpy cast @byte t.a cast @byte ret sizeof Type
  (t.a.s = params)
  t
}

ptype (x X) @Type = {
  token_eat x "none"   ? nnone       x
  token_eat x "byte"   ? nbyte       x
  token_eat x "nat"    ? nnat        x
  token_eat x "@"      ? nptr        x ptype x
  token_eat x "("      ? pfunc   x
  token_eat x "{"      ? pstruct x
  { lookup x is xb
    (xb.is_type or diag x "not a type")
    token_advance x
    xb.t }
}

token_is_id     (x X) nat = (isaz x.kp@ or isAZ x.kp@)
token_is_string (x X) nat = (x.kp@ == '\")
token_is_byte   (x X) nat = (x.kp@ == '\')
token_is_number (x X) nat = is09 x.kp@

caret_hash (x X) nat = (x.line * 10000 + x.col)

p1 (x X) nat = {
  { token_is_number x then gpt x nnat  x 1 } else
  { token_is_byte   x then gpt x nbyte x 1 } else
  { token_is_string x then
    gs x "mov .s" gn x caret_hash x gs x "@GOTPCREL(%rip),%rax" glf x
    token_advance x
    note x nptr x nbyte x 0
    1 } else
  { token_eat x "("       then p8 x token_expect x ")" 1 } else
  { token_eat x "{"       then p5 x token_expect x "}" 1 } else
  { token_eat x "&"       then p2 x note x nptr x x.t (x.l - 1) 1 } else
  { token_eat x "-"       then g1ops x &p3 gtneg x "rax"       1 } else
  { token_eat x "not"     then g1ops x &p3 glnot x "rax" "eax" 1 } else
  { token_eat x "read"    then gsys3 x 0 0 1 } else
  { token_eat x "write"   then gsys3 x 1 1 1 } else
  { token_eat x "err"     then gsys3 x 2 1 1 } else
  { token_eat x "cast" then
    ptype x is t
    p4 x
    geval x 0
    gcast x
    note x t 0 
    1 } else
  { token_eat x "sizeof" then
    ptype x is t
    gtlit x cast nat t.size "rax"
    note x nnat x 0
    1 } else
  { token_eat x "exit" then
    p3 x
    geval x 0
    gt2 x "mov" "rax" "rdi"
    gtlit x 60 "rax"
    gt0 x "syscall"
    note x nnone x 0
    1 } else
  { token_eat x "gettime" then
    p3 x
    geval x 0
    push x "rax"
    p3 x
    geval x 0
    gt2 x "mov" "rax" "rsi"
    pop x "rdi"
    gtlit x 228 "rax"
    gt0 x "syscall"
    note x nnat x 0
    1 } else
  { token_eat x "brk" then
    p3 x
    geval x 0
    gt0 x "mov %rax,%rdi"
    gtlit x 12 "rax"
    gt0 x "syscall"
    note x nptr x nbyte x 0
    1 } else
  { token_eat x "some" then
    (x.t = ptype x)
    (x.t.size + 7 >> 3) is d
    gfpush x d
    some Context xb
    xcpy &xb x 0 1 0
    token_advance x
    p5 x
    (x.s = x.s.s)
    geval x 0
    gfpop x d
    note x x.t 0
    1 } else
  { token_is_id x then
    lookup x is xb
    (xb.is_type and diag x "not a variable")
    note x xb.t 1
    xb.is_local ?
      { gaddr x x.t (xb.c - x.c << 3) "rsp" "rax" }
      { gs x "mov " gsn x x gs x "@GOTPCREL(%rip),%rax" glf x }
    token_advance x
    1 } else
  diag x "expected an expression"
}

p2 (x X) none = {
  p1 x
  1 for _
  { token_eat x "@" then note x x.t.a (x.l + 1) } else
  { token_eat x "^" then
    x.t is t
    geval x 0
    push x "rax"
    p3 x
    geval x 0
    pop x "rdi"
    gs x "lea (%rdi,%rax," gn x cast nat t.a.size gs x "),%rax" glf x
    note x t.a 1 } else
  { token_eat x "." then
    geval x 0
    { x.t for t
      { (t.kind == 4) then
        (t.a.kind == 3) ?
          { gs x "lea (%rax),%rax" glf x }
          { gs x "mov (%rax),%rax" glf x }
        t.a } else
      { (t.kind == 6) then
        (t.a.kind == 3) ?
          { gs x "lea " gn x -(x.c << 3) gs x "(%rsp,%rax),%rax" glf x }
          { gs x "mov " gn x -(x.c << 3) gs x "(%rsp,%rax),%rax" glf x }
        t.a }
    } is t
    (t.kind != 3 and diag x "not a struct")
    cast T 0 is g
    { t.a for a
      { (a.kn == x.kn) then strncmp a.kp x.kp cast nat x.kn }
      ? { (g = a) cast T 0 }
        a.s }
    (g or diag x "no such member")
    token_advance x
    gindex x cast nat g.offset
    note x g 1
    1 }
}

p3 (x X) none = {
  p2 x
  1 for _
  (x.t.kind == 5) then
  geval x 0
  x.c is c
  0 is d
  x.t is t
  { t.a.s then
    t.a.s for u
    (d = d + 1)
    u.s }
  gfpush x d
  push x "rax"
  8 is off
  { t.a.s then
    t.a.s for u
    p3 x
    (type_equal x.t u or diag x "asymmetric argument")
    geval x 0
    { (u.kind == 6) then
      gs x "add $" gn x ((-c + ((d > 6) ? (d - 5) 1)) << 3) gs x ",%rax" glf x }
    gs x "mov %rax," gn x off gs x "(%rsp)" glf x
    (off = off + 8)
    u.s }
  pop x "rax"
  { 0 for i
    (i < d and i < 6) then
    pop x argreg i
    (i + 1) }
  gt0 x "call *%rax"
  (x.c = c)
  note x t.a 0
}

p4 (x X) none = {
  p3 x
  1 for _
  { token_eat x "?" then
    caret_hash x is n
    geval x 0
    cz x "rax"
    je x n
    p4 x
    geval x 0
    jmp x (n + 1)
    label x n
    p4 x
    geval x 0
    label x (n + 1)
    note x x.t 0
    1 }
}

logical (x X jc @(x X n nat) none p @(x X) none) none = {
  caret_hash x is n
  geval x 0
  cz x "rax"
  jc@ x n
  push x "rax"
  p@ x
  geval x 0
  pop x (x.t.kind ? "rdx" "rax")
  label x n
}

p5 (x X) none = {
  p4 x
  1 for _
  { token_eat x "ret" then
    x.t is t
    geval x 0
    push x "rax"
    p5 x
    pop x "rax"
    note x t 0
    1 } else
  { token_eat x "is" then
    geval x 0
    push x "rax"
    let x &p5
    geval x 0
    pop x "rdx"
    note x x.t 0
    1 } else
  { token_eat x "for" then
    caret_hash x is n
    geval x 0
    push  x "rax"
    jmp   x (n + 1)
    label x n
    store x x.t "rsp"
    label x (n + 1)
    let   x &p5
    geval x 0
    cz    x "rax"
    jne   x n
    pop   x "rax"
    note  x x.t 0
    1 } else
  { token_eat x "then" then
    logical x &je &p5
    note x x.t 0
    1 } else
  { token_eat x "else" then
    x.t is t
    logical x &jne &p5
    note x t 0 
    1 } else
  { not token_is x "}" then
    p5 x
    1 }
}

pmul (x X) none = {
  p4 x
  1 for _
  { token_eat x "*" then g2ops x &p4 gmul x "rdi" 1 } else
  { token_eat x "/" then g2ops x &p4 gdiv x       1 } else
  { token_eat x "%" then g2ops x &p4 gmod x       1 }
}

padd  (x X) none = {
  pmul x
  1 for _
  { token_eat x "+" then g2ops x &pmul gadd x "rdi" "rax" 1 } else
  { token_eat x "-" then g2ops x &pmul gsub x "rdi" "rax" 1 }
}

psh (x X) none = {
  padd x
  1 for _
  { token_eat x "<<" then g2ops x &padd gshl x 1 } else
  { token_eat x ">>" then g2ops x &padd gshr x 1 }
}

pcmp (x X) none = {
  psh x
  1 for _
  { token_eat x "<"  then g2ops x &psh gb  x 1 } else
  { token_eat x ">"  then g2ops x &psh ga  x 1 } else
  { token_eat x "<=" then g2ops x &psh gbe x 1 } else
  { token_eat x ">=" then g2ops x &psh gae x 1 } else
  { token_eat x "==" then g2ops x &psh ge  x 1 } else
  { token_eat x "!=" then g2ops x &psh gne x 1 }
}

pland (x X) none = {
  pcmp x
  1 for _
  token_eat x "and" then
  logical x &je &pcmp
  note x x.t 0
  1
}

plor (x X) none = {
  pland x
  1 for _
  token_eat x "or" then
  x.t is t
  logical x &jne &pland
  note x t 0
  1
}

p7 (x X) none = {
  plor x
  1 for _
  token_eat x "as" then
  geval x 0
  gcast x
  note x ptype x 0
}

p8 (x X) none = {
  p7 x
  1 for _
  token_eat x "=" then
  x.t is t
  geval x 1
  push x "rax"
  p7 x
  geval x 0
  pop x "rdx"
  store x t "rdx"
  note x nnone x 0
}

stack_params(x X t T g nat) nat = {
  not t ? { p4 x geval x 0 0 }
    { some Context xb
      xcpy &xb x 0 1 0
      (x.s.kp = t.kp)
      (x.s.kn = t.kn)
      (x.s.c  = g)
      (x.s.t  = t)
      stack_params x t.s (g + 1) ret
      (x.s = x.s.s) }
}

register_params (x X t T g nat) nat = {
  not t ? { p4 x geval x 0 0 }
    { push x argreg g
      some Context xb
      xcpy &xb x 0 1 0
      (x.s.kp = t.kp)
      (x.s.kn = t.kn)
      (x.s.t = t)
      (((g == 5) ? &stack_params &register_params)@ x t.s (g + 1) + 1) ret
      (x.s = x.s.s) }
}

maybe (x X next @(x X) none) none = { next then next@ x }

typed    (x X o X) none
function (x X o X) none

function_declaration (x X) none = lookup_push_scope x 0 0 0 &function
type_declaration     (x X) none = lookup_push_scope x 1 0 0 &typed

declaration (x X) @(x X) none = { x.kp then token_eat x "type" ? &type_declaration &function_declaration }

maybe_declaration (x X) none = maybe x declaration x

function (x X o X) none = {
  param x &x.s.t
  (x.s.is_def = token_is x "=")
  (not o or not o.is_type and not o.is_def and x.s.is_def or diag x "remention")
  { x.s.is_def then
    gs x ".section .text." gsn x x.s glf x
    gsn x x.s gc x ': glf x
    token_advance x
    (x.c = 0)
    x.curbrk is brka
    register_params x x.s.t.a.s 0 is stack
    /* free everything we used for that */
    (x.curbrk = brka)
    gfpop x stack
    gt0 x "ret" }
  maybe_declaration x
}

typed (x X o X) none = {
  param x &x.s.t
  (o and diag x "remention")
  token_eat x ";" ? maybe_declaration x type_declaration x
}

compile (x X) none = {
  gs x ".globl _start\n"
  token x
  maybe_declaration x
}

type
  Time {
    s nat
    n nat
  }
;

milliseconds (ta @Time tb @Time) nat = ((tb.s - ta.s) * 1000000 + (tb.n - ta.n) / 1000)

bench (x X f @(x X) none) none = {
  some Time ta
  gettime 1 &ta
  x.curbrk is brka

  f@ x

  some Time tb
  gettime 1 &tb
  x.curbrk is brkb

  on x (brkb - brka) os x " heap" os x " / " on x milliseconds &ta &tb os x " us" olf x
}

chat (x X) none = {
  ioretry x.p &x.p^(1 << 20) &ioread
  x.q is iq
  bench x &compile
  ioretry iq x.q &iowrite
}

init_context(x X inbuf nat outbuf nat heap nat) none = {
  (x.curbrk = initbrk          (  (1 << inbuf )
                                + (1 << outbuf)
                                + (1 << heap  )))
  (x.s      = 0                                 )
  (x.p      = cast @byte xalloc x (1 << inbuf ) )
  (x.q      = cast @byte xalloc x (1 << outbuf) )
  (x.pline  = x.p                               )
  (x.line   = 1                                 )
  (x.col    = 1                                 )
}

main (x X) none = { init_context x 20 23 16  chat x }

_start ()    none = { some Context x  main &x  exit 0 }