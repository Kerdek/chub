// This file implements the C preprocessor.
//
// The preprocessor takes a list of tokens as an input and returns a
// new list of tokens as an output.
//
// The preprocessing language is designed in such a way that that's
// guaranteed to stop even if there is a recursive macro.
// Informally speaking, a macro is applied only once for each token.
// That is, if a macro token T appears in a result of direct or
// indirect macro expansion of T, T won't be expanded any further.
// For example, if T is defined as U, and U is defined as T, then
// token T is expanded to U and then to T and the macro expansion
// stops at that point.
//
// To achieve the above behavior, we attach for each token a set of
// macro names from which the token is expanded. The set is called
// "hideset". is Hidesetinitially empty, and every time we expand a
// macro, the macro name is added to the resulting tokens' hidesets.
//
// The above macro expansion algorithm is explained in this document
// written by Dave Prossor, which is used as a basis for the
// standard's wording:
// https://github.com/rui314/chibicc/wiki/cpp.algo.pdf

#include "chub.hb"

type MacroParam struct MacroParam;
_ struct MacroParam {
  next @MacroParam;
  name @char;
};

type MacroArg struct MacroArg;
_ struct MacroArg {
  next @MacroArg;
  name @char;
  is_va_args bool;
  tok @Token;
};

type macro_handler_fn(_ @Token) @Token;

type Macro struct Macro;
_ struct Macro {
  name @char;
  is_objlike bool; // Object-like or function-like
  params @MacroParam;
  va_args_name @char;
  body @Token;
  handler @macro_handler_fn;
};

// `#if` can be nested, so we use a stack to manage nested `#if`s.
type CondIncl struct CondIncl;
_ struct CondIncl {
  next @CondIncl
  ctx enum  IN_THEN IN_ELIF IN_ELSE ;
  tok @Token
  included bool;
};

 
macros HashMap
cond_incl @CondIncl
pragma_once HashMap
include_next_idx int

preprocess2(tok@Token include_paths@StringArray)@Token
find_macro(tok@Token)@Macro;

is_hash(tok@Token)bool =
  return tok@.at_bol && equal(tok "#");
;

// Some preprocessor directives such as #include allow extraneous
// tokens before newline. This function skips such tokens.
skip_line(tok@Token)@Token =
  if tok@.at_bol
    return tok;
  warn_tok(tok "extra token");
  while tok@.at_bol
    tok = tok@.next;
  return tok;
;

copy_token(tok@Token)@Token =
  let t = calloc(1 sizeof Token)->@Token;
  t@ = tok@;
  t@.next = NULL;
  return t;
;

new_eof(tok@Token)@Token =
  let t = copy_token(tok);
  t@.kind = TK_EOF;
  t@.len = 0;
  return t;
;

new_hideset(name@char)@Hideset =
  let hs = calloc(1 sizeof Hideset)->@Hideset;
  hs@.name = name;
  return hs;
;

hideset_union(hs1@Hideset hs2@Hideset)@Hideset =
  let
    head = (let Hideset){;
    cur = &head;

  for (; hs1; hs1 = hs1@.next)
    cur = cur@.next = new_hideset(hs1@.name);
  cur@.next = hs2;
  return head.next;
;

hideset_contains(hs@Hideset s@char len int)bool =
  for (; hs; hs = hs@.next)
    if strlen(hs@.name) == len && !strncmp(hs@.name s len)
      return true;
  return false;
;

hideset_intersection(hs1@Hideset hs2@Hideset)@Hideset =
  let
    head = (let Hideset){;
    cur = &head;

  for (; hs1; hs1 = hs1@.next)
    if hideset_contains(hs2 hs1@.name strlen(hs1@.name))
      cur = cur@.next = new_hideset(hs1@.name);
  return head.next;
;

add_hideset(tok@Token hs@Hideset)@Token =
  let
    head = (let Token){;
    cur = &head;

  for (; tok; tok = tok@.next) {
    let t = copy_token(tok);
    t@.hideset = hideset_union(t@.hideset hs);
    cur = cur@.next = t;
  ;
  return head.next;
;

// Append tok2 to the end of tok1.
append(tok1@Token tok2@Token)@Token =
  if tok1@.kind == TK_EOF return tok2;

  let
    head = (let Token){;
    cur = &head;

  for (; tok1@.kind != TK_EOF; tok1 = tok1@.next)
    cur = cur@.next = copy_token(tok1);
  cur@.next = tok2;
  return head.next;
;

skip_cond_incl2(tok@Token)@Token =
  while tok@.kind != TK_EOF {
    if is_hash(tok) &&
        (equal(tok@.next "if") || equal(tok@.next "ifdef") ||
         equal(tok@.next "ifndef")) {
      tok = skip_cond_incl2(tok@.next@.next);
      continue;
    ;
    if is_hash(tok) && equal(tok@.next "endif")
      return tok@.next@.next;
    tok = tok@.next;
  ;
  return tok;
;

// Skip until next `#else`, `#elif` or `#endif`.
// Nested `#if` and `#endif` are skipped.
skip_cond_incl(tok@Token)@Token =
  while tok@.kind != TK_EOF {
    if is_hash(tok) &&
        (equal(tok@.next "if") || equal(tok@.next "ifdef") ||
         equal(tok@.next "ifndef")) {
      tok = skip_cond_incl2(tok@.next@.next);
      continue;
    ;

    if is_hash(tok) &&
        (equal(tok@.next "elif") || equal(tok@.next "else") ||
         equal(tok@.next "endif"))
      break;
    tok = tok@.next;
  ;
  return tok;
;

// Double-quote a given string and returns it.
quote_string(str@char)@char =
  let bufsize = 3;
  for (let i int = 0; str[i]; i++) {
    if str[i] == '\\' || str[i] == '"'
      bufsize++;
    bufsize++;
  ;

  let
    buf = calloc(1 bufsize)->@char
    p = buf;
  p++@ = '"';
  for (let i int= 0; str[i]; i++) {
    if str[i] == '\\' || str[i] == '"'
      p++@ = '\\';
    p++@ = str[i];
  ;
  p++@ = '"';
  p++@ = '\0';
  return buf;
;

new_str_token(str@char tmpl@Token)@Token =
  let buf = quote_string(str);
  return tokenize(new_file(tmpl@.file@.name tmpl@.file@.file_no buf));
;

// Copy all tokens until the next newline, terminate them with
// an EOF token and then returns them. This function is used to
// create a new list of tokens for `#if` arguments.
copy_line(rest@@Token tok@Token)@Token =
  let
    head = (let Token){;
    cur = &head;

  for (; !tok@.at_bol; tok = tok@.next)
    cur = cur@.next = copy_token(tok);

  cur@.next = new_eof(tok);
  rest@ = tok;
  return head.next;
;

new_num_token(val int tmpl@Token)@Token =
  let buf = format("%d\n" val);
  return tokenize(new_file(tmpl@.file@.name tmpl@.file@.file_no buf));
;

read_const_expr(rest@@Token tok@Token)@Token =
  tok = copy_line(rest tok);

  let
    head = (let Token){;
    cur = &head;

  while tok@.kind != TK_EOF {
    // "defined(foo)" or "defined foo" becomes "1" if macro "foo"
    // is defined. Otherwise "0".
    if equal(tok "defined") {
      let start = tok;
      let has_paren = consume(&tok tok@.next "(");

      if tok@.kind != TK_IDENT
        error_tok(start "macro name must be an identifier");
      let m = find_macro(tok);
      tok = tok@.next;

      if has_paren
        tok = skip(tok ")");

      cur = cur@.next = new_num_token(m ? 1 : 0 start);
      continue;
    ;

    cur = cur@.next = tok;
    tok = tok@.next;
  ;

  cur@.next = tok;
  return head.next;
;

// Read and evaluate a constant expression.
eval_const_expr(rest@@Token tok@Token include_paths@StringArray) long =
  let start = tok;
  let expr = read_const_expr(rest tok@.next);
  expr = preprocess2(expr include_paths);

  if expr@.kind == TK_EOF
    error_tok(start "no expression");

  // [https://www.sigbus.info/n1570#6.10.1p4] The standard requires
  // we replace remaining non-macro identifiers with "0" before
  // evaluating a constant expression. For example, `#if foo` is
  // equivalent to `#if 0` if foo is not defined.
  for (let t @Token= expr; t@.kind != TK_EOF; t = t@.next) {
    if t@.kind == TK_IDENT {
      let next = t@.next;
      t@ = new_num_token(0 t)@;
      t@.next = next;
    ;
  ;

  // Convert pp-numbers to regular numbers
  convert_pp_tokens(expr);

  let rest2 = 0->@Token;
  let val = const_expr(&rest2 expr);
  if rest2@.kind != TK_EOF
    error_tok(rest2 "extra token");
  return val;
;

push_cond_incl(tok@Token included bool)@CondIncl =
  let ci = calloc(1 sizeof CondIncl)->@CondIncl;
  ci@.next = cond_incl;
  ci@.ctx = IN_THEN;
  ci@.tok = tok;
  ci@.included = included;
  cond_incl = ci;
  return ci;
;

find_macro(tok@Token)@Macro =
  if tok@.kind != TK_IDENT
    return NULL;
  return hashmap_get2(&macros tok@.loc tok@.len);
;

add_macro(name@char is_objlike bool body@Token)@Macro =
  let m = calloc(1 sizeof Macro)->@Macro;
  m@.name = name;
  m@.is_objlike = is_objlike;
  m@.body = body;
  hashmap_put(&macros name m);
  return m;
;

read_macro_params(rest@@ Token tok@ Token va_args_name@@ char)@ MacroParam =
  let
    head = (let MacroParam){;
    cur = &head;

  while !equal(tok ")") {
    if cur != &head
      tok = skip(tok ",");

    if equal(tok "...") {
      va_args_name@ = "__VA_ARGS__";
      rest@ = skip(tok@.next ")");
      return head.next;
    ;

    if tok@.kind != TK_IDENT
      error_tok(tok "expected an identifier");

    if equal(tok@.next "...") {
      va_args_name@ = strndup(tok@.loc tok@.len);
      rest@ = skip(tok@.next@.next ")");
      return head.next;
    ;

    let m = calloc(1 sizeof MacroParam)->@MacroParam;
    m@.name = strndup(tok@.loc tok@.len);
    cur = cur@.next = m;
    tok = tok@.next;
  ;

  rest@ = tok@.next;
  return head.next;
;

read_macro_definition(rest@@Token tok@Token)  =
  if tok@.kind != TK_IDENT
    error_tok(tok "macro name must be an identifier");
  let name = strndup(tok@.loc tok@.len);
  tok = tok@.next;

  if !tok@.has_space && equal(tok "(") {
    // Function-like macro
    let va_args_name = 0->@char;
    let b = &va_args_name;
    let params = read_macro_params(&tok tok@.next b);

    let m = add_macro(name false copy_line(rest tok));
    m@.params = params;
    m@.va_args_name = va_args_name;
  ; else {
    // Object-like macro
    add_macro(name true copy_line(rest tok));
  ;
;

read_macro_arg_one(rest@@Token tok@Token read_rest bool) @MacroArg =
  let
    head = (let Token){;
    cur = &head
    level = 0;

  for (;;) {
    if level == 0 && equal(tok ")")
      break;
    if level == 0 && !read_rest && equal(tok ",")
      break;

    if tok@.kind == TK_EOF
      error_tok(tok "premature end of input");

    if equal(tok "(")
      level++;
    else if equal(tok ")")
      level--;

    cur = cur@.next = copy_token(tok);
    tok = tok@.next;
  ;

  cur@.next = new_eof(tok);

  let arg = calloc(1 sizeof MacroArg)->@MacroArg;
  arg@.tok = head.next;
  rest@ = tok;
  return arg;
;

read_macro_args(rest@@Token tok@Token params @MacroParam va_args_name@char)@MacroArg =
  let start = tok;
  tok = tok@.next@.next;

  let
    head = (let MacroArg){;
    cur = &head
    pp = params;

  for (; pp; pp = pp@.next) {
    if cur != &head
      expect(&tok ",");
    cur = cur@.next = read_macro_arg_one(&tok tok false);
    cur@.name = pp@.name;
  ;

  if va_args_name {
    let arg = 0->@MacroArg;
    if equal(tok ")") {
      arg = calloc(1 sizeof MacroArg);
      arg@.tok = new_eof(tok);
    ; else {
      if pp != params
        tok = skip(tok ",");
      arg = read_macro_arg_one(&tok tok true);
    ;
    arg@.name = va_args_name;
    arg@.is_va_args = true;
    cur = cur@.next = arg;
  ; else if pp {
    error_tok(start "too many arguments");
  ;

  skip(tok ")");
  rest@ = tok;
  return head.next;
;

find_arg(args @MacroArg tok@Token)@MacroArg =
  for (let ap @MacroArg = args; ap; ap = ap@.next)
    if tok@.len == strlen(ap@.name) && !strncmp(tok@.loc ap@.name tok@.len)
      return ap;
  return NULL;
;

// Concatenates all tokens in `tok` and returns a new string.
join_tokens(tok@Token end@Token)@char =
  // Compute the length of the resulting token.
  let len = 1;
  for (let t @Token= tok; t != end && t@.kind != TK_EOF; t = t@.next) {
    if t != tok && t@.has_space
      len++;
    len += t@.len;
  ;

  let buf = calloc(1 len)->@char;

  // Copy token texts.
  let pos = 0;
  for (let t @Token= tok; t != end && t@.kind != TK_EOF; t = t@.next) {
    if t != tok && t@.has_space
      buf[pos++] = ' ';
    strncpy(buf + pos t@.loc t@.len);
    pos += t@.len;
  ;
  buf[pos] = '\0';
  return buf;
;

// Concatenates all tokens in `arg` and returns a new string token.
// This function is used for the stringizing operator (#).
stringize(hash@Token arg@Token)@Token =
  // Create a new string token. We need to set some value to its
  // source location for error reporting function, so we use a macro
  // name token as a template.
  let s = join_tokens(arg 0);
  return new_str_token(s hash);
;

paste(lhs@Token rhs@Token)@Token =
  // Paste the two tokens.
  let buf = format("%.*s%.*s" lhs@.len lhs@.loc rhs@.len rhs@.loc);

  // Tokenize the resulting string.
  let tok = tokenize(new_file(lhs@.file@.name lhs@.file@.file_no buf));
  if tok@.next@.kind != TK_EOF
    error_tok(lhs "pasting forms '%s', an invalid token" buf);
  return tok;
;

has_varargs(args @MacroArg) bool =
  for (let ap @MacroArg = args; ap; ap = ap@.next)
    if !strcmp(ap@.name "__VA_ARGS__")
      return ap@.tok@.kind != TK_EOF;
  return false;
;

// Replace func-like macro parameters with given arguments.
subst(tok@Token args @MacroArg include_paths@StringArray)@ Token =
  let
    head = (let Token){;
    cur = &head;

  while tok@.kind != TK_EOF {
    // "#" followed by a parameter is replaced with stringized actuals.
    if equal(tok "#") {
      let arg = find_arg(args tok@.next);
      if !arg
        error_tok(tok@.next "'#' is not followed by a macro parameter");
      cur = cur@.next = stringize(tok arg@.tok);
      tok = tok@.next@.next;
      continue;
    ;

    // [GNU] If __VA_ARG__ is empty, `,##__VA_ARGS__` is expanded
    // to the empty token list. Otherwise, its expaned to `,` and
    // __VA_ARGS__.
    if equal(tok ",") && equal(tok@.next "##") {
      let arg = find_arg(args tok@.next@.next);
      if arg && arg@.is_va_args {
        if arg@.tok@.kind == TK_EOF {
          tok = tok@.next@.next@.next;
        ; else {
          cur = cur@.next = copy_token(tok);
          tok = tok@.next@.next;
        ;
        continue;
      ;
    ;

    if equal(tok "##") {
      if cur == &head
        error_tok(tok "'##' cannot appear at start of macro expansion");

      if tok@.next@.kind == TK_EOF
        error_tok(tok "'##' cannot appear at end of macro expansion");

      let arg = find_arg(args tok@.next);
      if arg {
        if arg@.tok@.kind != TK_EOF {
          cur@ = paste(cur arg@.tok)@;
          for (let t @Token= arg@.tok@.next; t@.kind != TK_EOF; t = t@.next)
            cur = cur@.next = copy_token(t);
        ;
        tok = tok@.next@.next;
        continue;
      ;

      cur@ = paste(cur tok@.next)@;
      tok = tok@.next@.next;
      continue;
    ;

    let arg = find_arg(args tok);

    if arg && equal(tok@.next "##") {
      let rhs = tok@.next@.next;

      if arg@.tok@.kind == TK_EOF {
        let arg2 = find_arg(args rhs);
        if arg2 {
          for (let t @Token= arg2@.tok; t@.kind != TK_EOF; t = t@.next)
            cur = cur@.next = copy_token(t);
        ; else {
          cur = cur@.next = copy_token(rhs);
        ;
        tok = rhs@.next;
        continue;
      ;

      for (let t @Token= arg@.tok; t@.kind != TK_EOF; t = t@.next)
        cur = cur@.next = copy_token(t);
      tok = tok@.next;
      continue;
    ;

    // If __VA_ARG__ is empty, __VA_OPT__(x) is expanded to the
    // empty token list. Otherwise, __VA_OPT__(x) is expanded to x.
    if equal(tok "__VA_OPT__") && equal(tok@.next "(") {
      let arg = read_macro_arg_one(&tok tok@.next@.next true);
      if has_varargs(args)
        for (let t @Token= arg@.tok; t@.kind != TK_EOF; t = t@.next)
          cur = cur@.next = t;
      tok = skip(tok ")");
      continue;
    ;

    // Handle a macro token. arguments Macroare completely macro-expanded
    // before they are substituted into a macro body.
    if arg {
      let t = preprocess2(arg@.tok include_paths);
      t@.at_bol = tok@.at_bol;
      t@.has_space = tok@.has_space;
      for (; t@.kind != TK_EOF; t = t@.next)
        cur = cur@.next = copy_token(t);
      tok = tok@.next;
      continue;
    ;

    // Handle a non-macro token.
    cur = cur@.next = copy_token(tok);
    tok = tok@.next;
    continue;
  ;

  cur@.next = tok;
  return head.next;
;

// If tok is a macro, expand it and return true.
// Otherwise, do nothing and return false.
expand_macro(rest@@Token tok@Token include_paths@StringArray)bool =
  if hideset_contains(tok@.hideset tok@.loc tok@.len)
    return false;

  let m = find_macro(tok);
  if !m
    return false;

  // Built-in dynamic macro application such as __LINE__
  if m@.handler {
    rest@ = m@.handler(tok);
    rest@@.next = tok@.next;
    return true;
  ;

  // Object-like macro application
  if m@.is_objlike {
    let hs = hideset_union(tok@.hideset new_hideset(m@.name));
    let body = add_hideset(m@.body hs);
    for (let t @Token= body; t@.kind != TK_EOF; t = t@.next)
      t@.origin = tok;
    rest@ = append(body tok@.next);
    rest@@.at_bol = tok@.at_bol;
    rest@@.has_space = tok@.has_space;
    return true;
  ;

  // If a funclike macro token is not followed by an argument list,
  // treat it as a normal identifier.
  if !equal(tok@.next "(")
    return false;

  // Function-like macro application
  let macro_token = tok;
  let args  = read_macro_args(&tok tok m@.params m@.va_args_name);
  let rparen = tok;

  // Tokens that consist a func-like macro invocation may have different
  // hidesets, and if that's the case, it's not clear what the hideset
  // for the new tokens should be. We take the interesection of the
  // macro token and the closing parenthesis and use it as a new hideset
  // as explained in the Dave Prossor's algorithm.
  let hs = hideset_intersection(macro_token@.hideset rparen@.hideset);
  hs = hideset_union(hs new_hideset(m@.name));

  let body = subst(m@.body args include_paths);
  body = add_hideset(body hs);
  for (let t @Token= body; t@.kind != TK_EOF; t = t@.next)
    t@.origin = macro_token;
  rest@ = append(body tok@.next);
  rest@@.at_bol = macro_token@.at_bol;
  rest@@.has_space = macro_token@.has_space;
  return true;
;

sipcache HashMap;
export search_include_paths(filename@char include_paths@StringArray)@char =
  if filename[0] == '/'
    return filename;

  let cached = hashmap_get(&sipcache filename);
  if cached
    return cached;

  // Search a file from the include paths.
  for (let i int= 0; i < include_paths@.len; i++) {
    let path = format("%s/%s" include_paths@.data[i] filename);
    if !file_exists(path)
      continue;
    hashmap_put(&sipcache filename path);
    include_next_idx = i + 1;
    return path;
  ;
  return NULL;
;

search_include_next(filename@char include_paths @StringArray)@char =
  for (; include_next_idx < include_paths@.len; include_next_idx++) {
    let path = format("%s/%s" include_paths@.data[include_next_idx] filename);
    if file_exists(path)
      return path;
  ;
  return NULL;
;

// Read an #include argument.
read_include_filename(rest@@Token tok@Token is_dquote@bool include_paths @StringArray)@char =
  // Pattern 1: #include "foo.h"
  if tok@.kind == TK_STR {
    // A double-quoted filename for #include is a special kind of
    // token, and we don't want to interpret any escape sequences in it.
    // For example, "\f" in "C:\foo" is not a formfeed character but
    // just two non-control characters, backslash and f.
    // So we don't want to use token@.str.
    is_dquote@ = true;
    rest@ = skip_line(tok@.next);
    return strndup(tok@.loc + 1 tok@.len - 2);
  ;

  // Pattern 2: #include <foo.h>
  if equal(tok "<") {
    // Reconstruct a filename from a sequence of tokens between
    // "<" and ">".
    let start = tok;

    // Find closing ">".
    for (; !equal(tok ">"); tok = tok@.next)
      if tok@.at_bol || tok@.kind == TK_EOF
        error_tok(tok "expected '>'");

    is_dquote@ = false;
    rest@ = skip_line(tok@.next);
    return join_tokens(start@.next tok);
  ;

  // Pattern 3: #include FOO
  // In this case FOO must be macro-expanded to either
  // a single string token or a sequence of "<" ... ">".
  if tok@.kind == TK_IDENT {
    let a = copy_line(rest tok);
    let tok2 = preprocess2(a include_paths);
    return read_include_filename(&tok2 tok2 is_dquote include_paths);
  ;

  error_tok(tok "expected a filename");
;

// Detect the following "include guard" pattern.
//
//   #ifndef FOO_H
//   #define FOO_H
//   ...
//   #endif
detect_include_guard(tok@Token)@char =
  // Detect the first two lines.
  if !is_hash(tok) || !equal(tok@.next "ifndef")
    return NULL;
  tok = tok@.next@.next;

  if tok@.kind != TK_IDENT
    return NULL;

  let macro = strndup(tok@.loc tok@.len);
  tok = tok@.next;

  if !is_hash(tok) || !equal(tok@.next "define") || !equal(tok@.next@.next macro)
    return NULL;

  // Read until the end of the file.
  while tok@.kind != TK_EOF {
    if !is_hash(tok) {
      tok = tok@.next;
      continue;
    ;

    if equal(tok@.next "endif") && tok@.next@.next@.kind == TK_EOF
      return macro;

    if equal(tok "if") || equal(tok "ifdef") || equal(tok "ifndef")
      tok = skip_cond_incl(tok@.next);
    else
      tok = tok@.next;
  ;
  return NULL;
;

ifinclude_guards HashMap;
include_file(tok@Token path@char filename_tok@Token)@Token =
  // Check for "#pragma once"
  if hashmap_get(&pragma_once path)
    return tok;

  // If we read the same file before, and if the file was guarded
  // by the usual #ifndef ... #endif pattern, we may be able to
  // skip the file without opening it.
  let guard_name = hashmap_get(&ifinclude_guards path);
  if guard_name && hashmap_get(&macros guard_name)
    return tok;

  let tok2 = tokenize_file(path);
  if !tok2 error_tok(filename_tok "%s: cannot open file: %s" path strerror(errno));

  guard_name = detect_include_guard(tok2);
  if guard_name
    hashmap_put(&ifinclude_guards path guard_name);

  return append(tok2 tok);
;

// Read #line arguments
read_line_marker(rest@@Token tok@Token include_paths@StringArray)  =
  let start = tok;
  tok = preprocess(copy_line(rest tok) include_paths);

  if tok@.kind != TK_NUM || tok@.ty->@Type@.kind != TY_INT
    error_tok(tok "invalid line marker");
  start@.file@.line_delta = tok@.val - start@.line_no;

  tok = tok@.next;
  if tok@.kind == TK_EOF
    return;

  if tok@.kind != TK_STR
    error_tok(tok "filename expected");
  start@.file@.display_name = tok@.str;
;

preprocess2(tok@Token include_paths@StringArray)@Token =
  let
    head = (let Token){;
    cur = &head
  ;

  while tok@.kind != TK_EOF {
    if expand_macro(&tok tok include_paths)
      continue;

    if !is_hash(tok) {
      tok@.line_delta = tok@.file@.line_delta;
      tok@.filename = tok@.file@.display_name;
      cur = cur@.next = tok;
      tok = tok@.next;
      continue;
    ;

    let start = tok;
    tok = tok@.next;

    if equal(tok "include") {
      let is_dquote  = false->bool;
      let c = &is_dquote;
      let filename = read_include_filename(&tok tok@.next c include_paths);

      if filename[0] != '/' && is_dquote {
        let path = format("%s/%s" dirname(strdup(start@.file@.name)) filename);
        if file_exists(path) {
          tok = include_file(tok path start@.next@.next);
          continue;
        ;
      ;

      let path = search_include_paths(filename include_paths);
      tok = include_file(tok path ? path : filename start@.next@.next);
      continue;
    ;

    if equal(tok "include_next") {
      let ignore = false->bool;
      let c = &ignore;
      let filename = read_include_filename(&tok tok@.next c include_paths);
      let path = search_include_next(filename include_paths);
      tok = include_file(tok path ? path : filename start@.next@.next);
      continue;
    ;

    if equal(tok "define") {
      read_macro_definition(&tok tok@.next);
      continue;
    ;

    if equal(tok "undef") {
      tok = tok@.next;
      if tok@.kind != TK_IDENT
        error_tok(tok "macro name must be an identifier");
      undef_macro(strndup(tok@.loc tok@.len));
      tok = skip_line(tok@.next);
      continue;
    ;

    if equal(tok "if") {
      let val = eval_const_expr(&tok tok include_paths);
      push_cond_incl(start val);
      if !val
        tok = skip_cond_incl(tok);
      continue;
    ;

    if equal(tok "ifdef") {
      let defined = find_macro(tok@.next);
      push_cond_incl(tok defined);
      tok = skip_line(tok@.next@.next);
      if !defined
        tok = skip_cond_incl(tok);
      continue;
    ;

    if equal(tok "ifndef") {
      let defined = find_macro(tok@.next);
      push_cond_incl(tok !defined);
      tok = skip_line(tok@.next@.next);
      if defined
        tok = skip_cond_incl(tok);
      continue;
    ;

    if equal(tok "elif") {
      if !cond_incl || cond_incl@.ctx == IN_ELSE
        error_tok(start "stray #elif");
      cond_incl@.ctx = IN_ELIF;

      if !cond_incl@.included && eval_const_expr(&tok tok include_paths)
        cond_incl@.included = true;
      else
        tok = skip_cond_incl(tok);
      continue;
    ;

    if equal(tok "else") {
      if !cond_incl || cond_incl@.ctx == IN_ELSE
        error_tok(start "stray #else");
      cond_incl@.ctx = IN_ELSE;
      tok = skip_line(tok@.next);

      if cond_incl@.included
        tok = skip_cond_incl(tok);
      continue;
    ;

    if equal(tok "endif") {
      if !cond_incl
        error_tok(start "stray #endif");
      cond_incl = cond_incl@.next;
      tok = skip_line(tok@.next);
      continue;
    ;

    if equal(tok "line") {
      read_line_marker(&tok tok@.next include_paths);
      continue;
    ;

    if tok@.kind == TK_PP_NUM {
      read_line_marker(&tok tok include_paths);
      continue;
    ;

    if equal(tok "pragma") && equal(tok@.next "once") {
      hashmap_put(&pragma_once tok@.file@.name 1->@ );
      tok = skip_line(tok@.next@.next);
      continue;
    ;

    if equal(tok "pragma") {
      do {
        tok = tok@.next;
      ; while (!tok@.at_bol);
      continue;
    ;

    if equal(tok "error")
      error_tok(tok "error");

    // `#`-only line is legal. It's called a null directive.
    if tok@.at_bol
      continue;

    error_tok(tok "invalid preprocessor directive");
  ;

  cur@.next = tok;
  return head.next;
;

export define_macro(name@char buf@char)  =
  let tok = tokenize(new_file("<built-in>" 1 buf));
  add_macro(name true tok);
;

export undef_macro(name@char)  =
  hashmap_delete(&macros name);
;

add_builtin(name@char fn@macro_handler_fn)@Macro =
  let m = add_macro(name true 0);
  m@.handler = fn;
  return m;
;

file_macro(tmpl@Token)@ Token =
  while tmpl@.origin
    tmpl = tmpl@.origin;
  return new_str_token(tmpl@.file@.display_name tmpl);
;

line_macro(tmpl@Token)@ Token =
  while tmpl@.origin
    tmpl = tmpl@.origin;
  let i = tmpl@.line_no + tmpl@.file@.line_delta;
  return new_num_token(i tmpl);
;

cmi int = 0;
counter_macro(tmpl@Token)@Token =
  return new_num_token(cmi++ tmpl);
;

tmbuf[30]char;
timestamp_macro(tmpl@Token)@Token =
  let st = (let struct stat){;;
  let b = &st;
  if stat(tmpl@.file@.name b) != 0
    return new_str_token("??? ??? ?? ??:??:?? ????" tmpl);

  ctime_r(&st.st_mtime tmbuf);
  tmbuf[24] = '\0';
  return new_str_token(tmbuf tmpl);
;

fmmon[][4]char = {
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
;;
format_date(tm@ struct tm)@ char =
  return format("\"%s %2d %d\"" fmmon[tm@.tm_mon] tm@.tm_mday tm@.tm_year + 1900);
;

// __TIME__ is expanded to the current time, e.g. "13:34:03".
format_time(tm@ struct tm)@ char =
  return format("\"%02d:%02d:%02d\"" tm@.tm_hour tm@.tm_min tm@.tm_sec);
;

export init_macros(void)  =
  macros = (let HashMap){;;
  cond_incl = 0;
  pragma_once = (let HashMap){;;
  include_next_idx = 0;
  // Define predefined macros
  define_macro("_LP64" "1");
  define_macro("__C99_MACRO_WITH_VA_ARGS" "1");
  define_macro("__ELF__" "1");
  define_macro("__LP64__" "1");
  define_macro("__SIZEOF_DOUBLE__" "8");
  define_macro("__SIZEOF_FLOAT__" "4");
  define_macro("__SIZEOF_INT__" "4");
  define_macro("__SIZEOF_LONG_DOUBLE__" "8");
  define_macro("__SIZEOF_LONG_LONG__" "8");
  define_macro("__SIZEOF_LONG__" "8");
  define_macro("__SIZEOF_POINTER__" "8");
  define_macro("__SIZEOF_PTRDIFF_T__" "8");
  define_macro("__SIZEOF_SHORT__" "2");
  define_macro("__SIZEOF_SIZE_T__" "8");
  define_macro("__SIZE_TYPE__" "unsigned long");
  define_macro("__STDC_HOSTED__" "1");
  define_macro("__STDC_NO_COMPLEX__" "1");
  define_macro("__STDC_UTF_16__" "1");
  define_macro("__STDC_UTF_32__" "1");
  define_macro("__STDC_VERSION__" "201112L");
  define_macro("__STDC__" "1");
  define_macro("__USER_LABEL_PREFIX__" "");
  define_macro("__alignof__" "_Alignof");
  define_macro("__amd64" "1");
  define_macro("__amd64__" "1");
  define_macro("__chibicc__" "1");
  define_macro("__const__" "const");
  define_macro("__gnu_linux__" "1");
  define_macro("__inline__" "inline");
  define_macro("__linux" "1");
  define_macro("__linux__" "1");
  define_macro("__signed__" "signed");
  define_macro("__typeof__" "typeof");
  define_macro("__unix" "1");
  define_macro("__unix__" "1");
  define_macro("__volatile__" "volatile");
  define_macro("__x86_64" "1");
  define_macro("__x86_64__" "1");
  define_macro("linux" "1");
  define_macro("unix" "1");

  add_builtin("__FILE__" file_macro);
  add_builtin("__LINE__" line_macro);
  add_builtin("__COUNTER__" counter_macro);
  add_builtin("__TIMESTAMP__" timestamp_macro);

  let now = time(NULL);
  let tm = localtime(&now);
  define_macro("__DATE__" format_date(tm));
  define_macro("__TIME__" format_time(tm));
;

type StringKind enum 
  STR_NONE STR_UTF8 STR_UTF16 STR_UTF32 STR_WIDE
;;

getStringKind(tok@Token) StringKind =
  if !strcmp(tok@.loc "u8")
    return STR_UTF8;

  switch (tok@.loc[0]) {
  case '"': return STR_NONE;
  case 'u': return STR_UTF16;
  case 'U': return STR_UTF32;
  case 'L': return STR_WIDE;
  ;
  unreachable();
;

// Entry pofunction intof the preprocessor.
export preprocess(tok@Token include_paths@StringArray)@Token =
  tok = preprocess2(tok include_paths);
  if cond_incl
    error_tok(cond_incl@.tok "unterminated conditional directive");
  convert_pp_tokens(tok);

  for (let t @Token= tok; t; t = t@.next)
    t@.line_no += t@.line_delta;
  return tok;
;
