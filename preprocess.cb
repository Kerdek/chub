#include "chub.hb"

type
  MacroParam struct {
    s @same
    name @char;
  }

  MacroArg struct {
    s @same
    name @char
    is_va_args bool
    j @Token;
  }

  macro_handler_fn(_ @Token) @Token

  Macro struct {
    name @char
    is_objlike bool
    params @MacroParam
    va_args_name @char
    body @Token
    handler @macro_handler_fn;
  }

  CondIncl struct {
    s @same
    ctx enum IN_THEN IN_ELIF IN_ELSE;
    j @Token
    included bool;
  };
 
macros HashMap
cond_incl @CondIncl
pragma_once HashMap
include_next_idx int
preprocess2(j@Token include_paths@StringArray)@Token
find_macro(j@Token)@Macro;

is_hash(j@Token)bool = return j.at_bol && equal j "#";;
skip_line(j@Token)@Token =
  if j.at_bol return j;
  (warn_tok j "extra token");
  while j.at_bol (j = j.s);
  return j;;
copy_token(j@Token)@Token =
  let t = cast @Token calloc 1ul sizeof Token as @Token;
  (t@ = j@);
  (t.s = cast @Token 0);
  return t;;
new_eof(j@Token)@Token =
  let t = copy_token j;
  (t.kind = TK_EOF);
  (t.len = 0);
  return t;;
new_hideset(name@char)@Hideset = return
  cast @Hideset calloc 1ul sizeof Hideset is hs
  (hs.name = name) ;:
  hs;;
hideset_union(hs1@Hideset hs2@Hideset)@Hideset =
  let
    head = new Hideset {;
    cur = &head;
  for (; hs1; hs1 = hs1.s) { (cur.s = new_hideset hs1.name); (cur = cur.s);;
  (cur.s = hs2);
  return head.s;;
hideset_contains(hs@Hideset s@char len int)bool =
  for (; hs; hs = hs.s) if (strlen hs.name == len && ! strncmp cast @ hs.name s cast unsigned long len) return true;
  return false;;
hideset_intersection(hs1@Hideset hs2@Hideset)@Hideset =
  let
    head = new Hideset {;
    cur = &head;
  for (; hs1; hs1 = hs1.s) {
    if hideset_contains hs2 hs1.name cast int strlen hs1.name { (cur.s = new_hideset hs1.name); (cur = cur.s);;;
  return head.s;;
add_hideset(j@Token hs@Hideset)@Token =
  let
    head = new Token {;
    cur = &head;
  for (; j; j = j.s) {
    let t = copy_token j;
    (t.hideset = hideset_union t.hideset hs);
    (cur.s = t);
    (cur = cur.s);;
  return head.s;;
append(tok1@Token tok2@Token)@Token =
  if (tok1.kind == TK_EOF) return tok2;
  let
    head = new Token {;
    cur = &head;
  for (; tok1.kind != TK_EOF; tok1 = tok1.s) { (cur.s = copy_token tok1); (cur = cur.s);;
  (cur.s = tok2);
  return head.s;;
skip_cond_incl2(j@Token)@Token =
  while (j.kind != TK_EOF) {
    if (is_hash j && (equal j.s "if" || equal j.s "ifdef" || equal j.s "ifndef")) (j = skip_cond_incl2 j.s.s);
    else if (is_hash j && equal j.s "endif") return j.s.s;
    else (j = j.s);;
  return j;;
skip_cond_incl(j@Token)@Token =
  while (j.kind != TK_EOF) {
    if (is_hash j && (equal j.s "if" || equal j.s "ifdef" || equal j.s "ifndef")) (j = skip_cond_incl2 j.s.s);
    else if (is_hash j && (equal j.s "elif" || equal j.s "else" || equal j.s "endif")) break;
    else (j = j.s);;
  return j;;

// Double-quote a given string and returns it.
quote_string(str@char)@char =
  let bufsize = 3;
  for (let i int = 0; str[i]; i += 1) {
    if (str[i] == '\\' || str[i] == '"') (bufsize += 1);
    (bufsize += 1);;
  let
    buf = cast @char calloc 1ul cast unsigned long bufsize
    p = buf;
  ((p:;(p+=1))@ = '"' as char);
  for (let i int = 0; str[i]; i += 1) {
    if (str[i] == cast char '\\' || str[i] == cast char '"') ((p:;(p+=1))@ = cast char '\\');
    ((p:;(p+=1))@ = str[i]);;
  ((p:;(p+=1))@ = cast char '"' );
  ((p:;(p+=1))@ = cast char '\0');
  return buf;;
new_str_token(str @char tmpl@Token)@Token =
  let buf = quote_string str;
  return tokenize new_file tmpl.file.name tmpl.file.file_no buf;;
copy_line(rest@@Token j@Token)@Token =
  let
    head = new Token {;
    cur = &head;
  for (; !j.at_bol; j = j.s) { (cur.s = copy_token j); (cur = cur.s);;
  (cur.s = new_eof j);
  (rest@ = j);
  return head.s;;
new_num_token(val int tmpl@Token)@Token =
  let buf = (format "%d\n" val);
  return tokenize new_file tmpl.file.name tmpl.file.file_no buf;;
read_const_expr(rest@@Token j@Token)@Token =
  (j = copy_line rest j);
  let
    head = new Token {;
    cur = &head;
  while (j.kind != TK_EOF) {
    if equal j "defined" {
      let start = j;
      let has_paren = consume &j j.s "(";
      if (j.kind != TK_IDENT) (error_tok start "macro name must be an identifier");
      let m = find_macro j;
      (j = j.s);
      if has_paren (j = skip j ")");
      (cur.s = new_num_token cast int !!m start);
      (cur = cur.s);;
    else {
      (cur.s = j);
      (cur = cur.s);
      (j = j.s);;;
  (cur.s = j);
  return head.s;;
eval_const_expr(rest@@Token j@Token include_paths@StringArray) long =
  let start = j;
  let expr = read_const_expr rest j.s;
  (expr = preprocess2 expr include_paths);
  if (expr.kind == TK_EOF) (error_tok start "no expression");
  for (let t @Token = expr; t.kind != TK_EOF; (t = t.s)) {
    if (t.kind == TK_IDENT) {
      let s = t.s;
      (t@ = (new_num_token 0 t)@);
      (t.s = s);;;
  convert_pp_tokens expr;
  let rest2 = expr;
  let val = const_expr &rest2;
  if (rest2.kind != TK_EOF) (error_tok rest2 "extra token");
  return val;;
push_cond_incl(j@Token included bool)@CondIncl =
  let ci = cast @CondIncl calloc 1ul sizeof CondIncl;
  (ci.s = cond_incl);
  (ci.ctx = IN_THEN);
  (ci.j = j);
  (ci.included = included);
  (cond_incl = ci);
  return ci;;
find_macro(j@Token)@Macro =
  if (j.kind != TK_IDENT) return cast @Macro 0;
  return cast @Macro hashmap_get2 &macros j.loc j.len;;
add_macro(name@char is_objlike bool body@Token)@Macro =
  let m = cast @Macro calloc 1ul sizeof Macro;
  (m.name = name);
  (m.is_objlike = is_objlike);
  (m.body = body);
  hashmap_put &macros name cast @ m;
  return m;;
read_macro_params(rest@@ Token j@ Token va_args_name@@ char)@ MacroParam =
  let
    head = new MacroParam {;
    cur = &head;
  while ! equal j ")" {
    if (cur != &head) (j = skip j ",");
    if equal j "..." {
      (va_args_name@ = "__VA_ARGS__");
      (rest@ = skip j.s ")");
      return head.s;;
    if (j.kind != TK_IDENT) (error_tok j "expected an identifier");
    if equal j.s "..." {
      (va_args_name@ = strndup j.loc cast unsigned long j.len);
      (rest@ = skip j.s.s ")");
      return head.s;;
    let m = (calloc 1ul sizeof MacroParam as @MacroParam);
    (m.name = strndup j.loc cast unsigned long j.len);
    (cur.s = m);
    (cur = cur.s);
    (j = j.s);;
  (rest@ = j.s);
  return head.s;;
read_macro_definition(rest@@Token j@Token)  =
  if (j.kind != TK_IDENT)
    (error_tok j "macro name must be an identifier");
  let name = strndup j.loc cast unsigned long j.len;
  (j = j.s);
  if (!j.has_space && equal j "(") {
    let va_args_name = cast @char 0;
    let params = read_macro_params &j j.s &va_args_name;
    let m = add_macro name false copy_line rest j;
    (m.params = params);
    (m.va_args_name = va_args_name);;
  else add_macro name true copy_line rest j;;
read_macro_arg_one(rest@@Token j@Token read_rest bool) @MacroArg =
  let
    head = new Token {;
    cur = &head
    level = 0;
  while !(!level && (equal j ")" || !read_rest && equal j ",")) {
    if (j.kind == TK_EOF) (error_tok j "premature end of input");
    else if equal j "(" (level += 1);
    else if equal j ")" (level -= 1);
    (cur.s = copy_token j);
    (cur = cur.s);
    (j = j.s);;
  (cur.s = new_eof j);
  let arg = cast @MacroArg calloc 1ul sizeof MacroArg;
  (arg.j = head.s);
  (rest@ = j);
  return arg;;
read_macro_args(rest@@Token j@Token params @MacroParam va_args_name@char)@MacroArg =
  let start = j;
  (j = j.s.s);
  let
    head = new MacroArg {;
    cur = &head
    pp = params;
  for (; pp; pp = pp.s) {
    if (cur != &head)
      expect &j ",";
    (cur.s = read_macro_arg_one &j j false);
    (cur = cur.s);
    (cur.name = pp.name);;
  if va_args_name {
    let arg = cast @MacroArg 0;
    if equal j ")" {
      (arg = cast @MacroArg calloc 1ul sizeof MacroArg);
      (arg.j = new_eof j);;
    else {
      if (pp != params) (j = skip j ",");
      (arg = read_macro_arg_one &j j true);;
    (arg.name = va_args_name);
    (arg.is_va_args = true);
    (cur.s = arg);
    (cur = cur.s);;
  else if pp (error_tok start "too many arguments");
  skip j ")";
  (rest@ = j);
  return head.s;;
find_arg(args @MacroArg j@Token)@MacroArg =
  for (let ap @MacroArg = args; ap; ap = ap.s) if (j.len == strlen ap.name && ! strncmp cast @ j.loc ap.name cast unsigned long j.len) return ap;
  return cast @MacroArg 0;;
join_tokens(j@Token end@Token)@char =
  let len = 1;
  for (let t @Token= j; t != end && t.kind != TK_EOF; t = t.s) {
    if (t != j && t.has_space) (len += 1);
    (len += t.len);;
  let buf = cast @char calloc 1ul cast unsigned long len;
  let pos = 0;
  for (let t @Token = j; t != end && t.kind != TK_EOF; t = t.s) {
    if (t != j && t.has_space) (buf[(pos:;(pos+=1))] = cast char ' ');
    strncpy (buf + pos) t.loc cast unsigned long t.len;
    (pos += t.len);;
  (buf[pos] = '\0' as char);
  return buf;;
stringize(hash@Token arg@Token)@Token =
  let s = join_tokens arg cast @Token 0;
  return new_str_token s hash;;
paste(a@Token b@Token)@Token =
  let buf = (format "%.*s%.*s" a.len a.loc b.len b.loc);
  let j = tokenize new_file a.file.name a.file.file_no buf;
  if (j.s.kind != TK_EOF) (error_tok a "pasting forms '%s', an invalid token" buf);
  return j;;
has_varargs(args @MacroArg) bool =
  for (let a @MacroArg = args; a; a = a.s) if ! strcmp cast @ a.name "__VA_ARGS__" return a.j.kind != TK_EOF;
  return false;;
subst(j@Token args @MacroArg include_paths@StringArray)@ Token =
  let
    head = new Token {;
    cur = &head;
  while (j.kind != TK_EOF) {
    if equal j "#" {
      let arg = find_arg args j.s;
      if !arg (error_tok j.s "'#' is not followed by a macro parameter");
      (cur.s = stringize j arg.j);
      (cur = cur.s);
      (j = j.s.s);;
    else if equal j "##" {
      if (cur == &head) (error_tok j "'##' cannot appear at start of macro expansion");
      if (j.s.kind == TK_EOF) (error_tok j "'##' cannot appear at end of macro expansion");
      let arg = find_arg args j.s;
      if arg {
        if (arg.j.kind != TK_EOF) {
          (cur@ = (paste cur arg.j)@);
          for (let t @Token = arg.j.s; t.kind != TK_EOF; t = t.s) { (cur.s = copy_token t); (cur = cur.s);;;
        (j = j.s.s);;
      else {
        (cur@ = (paste cur j.s)@);
        (j = j.s.s);;;
    else {
      let arg = find_arg args j;
      if (!!arg && equal j.s "##") {
        let b = j.s.s;
        if (arg.j.kind == TK_EOF) {
          let arg2 = find_arg args b;
          if arg2 for (let t @Token= arg2.j; t.kind != TK_EOF; t = t.s) { (cur.s = copy_token t); (cur = cur.s);;
          else { (cur.s = copy_token b); (cur = cur.s);;
          (j = b.s);;
        else {
          for (let t @Token= arg.j; t.kind != TK_EOF; t = t.s) { (cur.s = copy_token t); (cur = cur.s);;
          (j = j.s);;;
      else if (equal j "__VA_OPT__" && equal j.s "(") {
        let arg = read_macro_arg_one &j j.s.s true;
        if has_varargs args for (let t @Token = arg.j; t.kind != TK_EOF; t = t.s) { (cur.s = t); (cur = cur.s);;
        (j = skip j ")");;
      else if arg {
        let t = preprocess2 arg.j include_paths;
        (t.at_bol = j.at_bol);
        (t.has_space = j.has_space);
        for (; t.kind != TK_EOF; t = t.s) { (cur.s = copy_token t); (cur = cur.s);;
        (j = j.s);;
      else {
        (cur.s = copy_token j);
        (cur = cur.s);
        (j = j.s);;;;
  (cur.s = j);
  return head.s;;
expand_macro(rest@@Token j@Token include_paths@StringArray)bool =
  if hideset_contains j.hideset j.loc j.len return false;
  let m = find_macro j;
  if !m return false;
  if m.handler {
    (rest@ = m.handler@ j);
    (rest@.s = j.s);
    return true;;
  if m.is_objlike {
    let hs = hideset_union j.hideset new_hideset m.name;
    let body = add_hideset m.body hs;
    for (let t @Token= body; t.kind != TK_EOF; t = t.s) (t.origin = j);
    (rest@ = append body j.s);
    (rest@.at_bol = j.at_bol);
    (rest@.has_space = j.has_space);
    return true;;
  if !equal j.s "(" return false;
  let macro_token = j;
  let args  = read_macro_args &j j m.params m.va_args_name;
  let rparen = j;
  let hs = hideset_intersection macro_token.hideset rparen.hideset;
  (hs = hideset_union hs new_hideset m.name);
  let body = subst m.body args include_paths;
  (body = add_hideset body hs);
  for (let t @Token= body; t.kind != TK_EOF; t = t.s) (t.origin = macro_token);
  (rest@ = append body j.s);
  (rest@.at_bol = macro_token.at_bol);
  (rest@.has_space = macro_token.has_space);
  return true;;
sipcache HashMap;
export search_include_paths(filename@char include_paths@StringArray)@char =
  if (filename[0] == '/') return filename;
  let cached = hashmap_get &sipcache filename;
  if cached return cast @char cached;
  for (let i int = 0; i < include_paths.len; i += 1) {
    let path = (format "%s/%s" include_paths.data[i] filename);
    if file_exists path {
      hashmap_put &sipcache filename cast @ path;
      (include_next_idx = i + 1);
      return path;;;
  return cast @char 0;;
search_include_next(filename@char include_paths @StringArray)@char =
  for (; include_next_idx < include_paths.len; include_next_idx += 1) {
    let path = (format "%s/%s" include_paths.data[include_next_idx] filename);
    if file_exists path return path;;
  return cast @char 0;;
read_include_filename(rest@@Token j@Token is_dquote@bool include_paths @StringArray) @char =
  if (j.kind == TK_STR) {
    (is_dquote@ = true);
    (rest@ = skip_line j.s);
    return strndup (j.loc + 1) cast unsigned long (j.len - 2);;
  if equal j "<" {
    let start = j;
    for (; ! equal j ">"; j = j.s) if (j.at_bol || j.kind == TK_EOF) (error_tok j "expected '>'");
    (is_dquote@ = false);
    (rest@ = skip_line j.s);
    return join_tokens start.s j;;
  if (j.kind == TK_IDENT) {
    let a = copy_line rest j;
    let tok2 = preprocess2 a include_paths;
    return read_include_filename &tok2 tok2 is_dquote include_paths;;
  (error_tok j "expected a filename");;
detect_include_guard(j@Token)@char =
  if (! is_hash j || ! equal j.s "ifndef") return cast @char 0;
  (j = j.s.s);
  if (j.kind != TK_IDENT) return cast @char 0;
  let macro = strndup j.loc cast unsigned long j.len;
  (j = j.s);
  if (! is_hash j || ! equal j.s "define" || ! equal j.s.s macro) return cast @char 0;
  while (j.kind != TK_EOF) {
    if !is_hash j (j = j.s);
    else if (equal j.s "endif" && j.s.s.kind == TK_EOF) return macro;
    else if (equal j "if" || equal j "ifdef" || equal j "ifndef") (j = skip_cond_incl j.s);
    else (j = j.s);;
  return cast @char 0;;
ifinclude_guards HashMap;
include_file(j@Token path@char filename_tok@Token)@Token =
  if cast bool hashmap_get &pragma_once path return j;
  let guard_name = (hashmap_get &ifinclude_guards path as @char);
  if (!!guard_name && hashmap_get &macros guard_name) return j;
  let tok2 = tokenize_file path;
  if !tok2 (error_tok filename_tok "%s: cannot open file: %s" path strerror errno);
  (guard_name = detect_include_guard tok2);
  if guard_name hashmap_put &ifinclude_guards path cast @ guard_name;
  return append tok2 j;;
read_line_marker(rest@@Token j@Token include_paths@StringArray)  =
  let start = j;
  (j = preprocess copy_line rest j include_paths);
  if (j.kind != TK_NUM || (cast @Type j.t).kind != TY_INT) (error_tok j "invalid line marker");
  (start.file.line_delta = j.val - cast long start.line_no as int);
  (j = j.s);
  if (j.kind == TK_EOF) return;
  if (j.kind != TK_STR) (error_tok j "filename expected");
  (start.file.display_name = j.str);;
preprocess2(j@Token include_paths@StringArray)@Token =
  let
    head = new Token {;
    cur = &head;
  while (j.kind != TK_EOF) {
    let start = j;
    (j = j.s);
    if expand_macro &j start include_paths;
    else if !is_hash start {
      (start.line_delta = start.file.line_delta);
      (start.filename = start.file.display_name);
      (cur.s = start);
      (cur = cur.s);
      (start = start.s);;
    else if equal j "include" {
      let is_dquote = false;
      let c = &is_dquote;
      let filename = read_include_filename &j j.s c include_paths;
      if (filename[0] != '/' && is_dquote) {
        let path = (format"%s/%s" dirname strdup start.file.name filename);
        if file_exists path (j = include_file j path start.s.s);
        else {
          let path = search_include_paths filename include_paths;
          (j = include_file j (path || filename) start.s.s);;;
      else {
        let path = search_include_paths filename include_paths;
        (j = include_file j (path || filename) start.s.s);;;
    else if equal j "include_next" {
      let ignore = false;
      let c = &ignore;
      let filename = read_include_filename &j j.s c include_paths;
      let path = search_include_next filename include_paths;
      (j = include_file j (path || filename) start.s.s);;
    else if equal j "define" read_macro_definition &j j.s;
    else if equal j "undef" {
      (j = j.s);
      if (j.kind != TK_IDENT) (error_tok j "macro name must be an identifier");
      undef_macro strndup j.loc cast unsigned long j.len;
      (j = skip_line j.s);;
    else if equal j "if" {
      let val = eval_const_expr &j j include_paths;
      push_cond_incl start cast bool val;
      if !val (j = skip_cond_incl j);;
    else if equal j "ifdef" {
      let defined = cast bool find_macro j.s;
      push_cond_incl j defined;
      (j = skip_line j.s.s);
      if !defined (j = skip_cond_incl j);;
    else if equal j "ifndef" {
      let ndefined = !find_macro j.s;
      push_cond_incl j ndefined;
      (j = skip_line j.s.s);
      if !ndefined (j = skip_cond_incl j);;
    else if equal j "elif" {
      if (!cond_incl || cond_incl.ctx == IN_ELSE) (error_tok start "stray #elif");
      (cond_incl.ctx = IN_ELIF);
      if (!cond_incl.included && eval_const_expr &j j include_paths) (cond_incl.included = true);
      else (j = skip_cond_incl j);;
    else if equal j "else" {
      if (!cond_incl || cond_incl.ctx == IN_ELSE) (error_tok start "stray #else");
      (cond_incl.ctx = IN_ELSE);
      (j = skip_line j.s);
      if cond_incl.included (j = skip_cond_incl j);;
    else if equal j "endif" {
      if !cond_incl (error_tok start "stray #endif");
      (cond_incl = cond_incl.s);
      (j = skip_line j.s);;
    else if equal j "line" read_line_marker &j j.s include_paths;
    else if (j.kind == TK_PP_NUM) read_line_marker &j j include_paths;
    else if (equal j "pragma" && equal j.s "once") {
      hashmap_put &pragma_once j.file.name cast @ 1;
      (j = skip_line j.s.s);;
    else if equal j "pragma" (j = j for j (!j.at_bol && j.s));
    else if equal j "error" (error_tok j "error");
    else if !j.at_bol (error_tok j "invalid preprocessor directive");;
  (cur.s = j);
  return head.s;;
export define_macro(name@char buf@char)  =
  let j = tokenize new_file "<built-in>" 1 buf;
  add_macro name true j;;
export undef_macro(name@char)  =
  hashmap_delete &macros name;;
add_builtin(name@char fn@macro_handler_fn)@Macro =
  let m = add_macro name true cast @Token 0;
  (m.handler = fn);
  return m;;
file_macro(tmpl@Token)@ Token =
  while tmpl.origin (tmpl = tmpl.origin);
  return new_str_token tmpl.file.display_name tmpl;;
line_macro(tmpl@Token)@ Token =
  while tmpl.origin (tmpl = tmpl.origin);
  return new_num_token (tmpl.line_no + tmpl.file.line_delta) tmpl;;
cmi int = 0;
counter_macro(tmpl@Token)@Token = return new_num_token (cmi :; (cmi += 1)) tmpl;;
tmbuf[30]char;
type stat_type struct stat;;
timestamp_macro(tmpl@Token)@Token =
  let st = new stat_type {;;
  if (stat tmpl.file.name &st != 0) return new_str_token "??? ??? ?? ??:??:?? ????" tmpl;
  ctime_r &st.st_mtime &tmbuf[0];
  (tmbuf[24] = cast char '\0');
  return new_str_token &tmbuf[0] &tmpl[0];;
fmmon[][4]char = {
  "Jan" "Feb" "Mar" "Apr" "May" "Jun"
  "Jul" "Aug" "Sep" "Oct" "Nov" "Dec";;
format_date(tm@ struct tm)@ char = return (format "\"%s %2d %d\"" fmmon[tm.tm_mon] tm.tm_mday (tm.tm_year + 1900));;
format_time(tm@ struct tm)@ char = return (format "\"%02d:%02d:%02d\"" tm.tm_hour tm.tm_min tm.tm_sec);;
export init_macros(void)  =
  (macros = new HashMap {;);
  (cond_incl = 0 as @CondIncl);
  (pragma_once = new HashMap {;);
  (include_next_idx = 0);
  define_macro "_LP64"                     "1"            ;
  define_macro "__C99_MACRO_WITH_VA_ARGS"  "1"            ;
  define_macro "__ELF__"                   "1"            ;
  define_macro "__LP64__"                  "1"            ;
  define_macro "__SIZEOF_DOUBLE__"         "8"            ;
  define_macro "__SIZEOF_FLOAT__"          "4"            ;
  define_macro "__SIZEOF_INT__"            "4"            ;
  define_macro "__SIZEOF_LONG_DOUBLE__"    "8"            ;
  define_macro "__SIZEOF_LONG_LONG__"      "8"            ;
  define_macro "__SIZEOF_LONG__"           "8"            ;
  define_macro "__SIZEOF_POINTER__"        "8"            ;
  define_macro "__SIZEOF_PTRDIFF_T__"      "8"            ;
  define_macro "__SIZEOF_SHORT__"          "2"            ;
  define_macro "__SIZEOF_SIZE_T__"         "8"            ;
  define_macro "__SIZE_TYPE__"             "unsigned long";
  define_macro "__STDC_HOSTED__"           "1"            ;
  define_macro "__STDC_NO_COMPLEX__"       "1"            ;
  define_macro "__STDC_UTF_16__"           "1"            ;
  define_macro "__STDC_UTF_32__"           "1"            ;
  define_macro "__STDC_VERSION__"          "201112L"      ;
  define_macro "__STDC__"                  "1"            ;
  define_macro "__USER_LABEL_PREFIX__"     ""             ;
  define_macro "__alignof__"               "_Alignof"     ;
  define_macro "__amd64"                   "1"            ;
  define_macro "__amd64__"                 "1"            ;
  define_macro "__chibicc__"               "1"            ;
  define_macro "__const__"                 "const"        ;
  define_macro "__gnu_linux__"             "1"            ;
  define_macro "__inline__"                "inline"       ;
  define_macro "__linux"                   "1"            ;
  define_macro "__linux__"                 "1"            ;
  define_macro "__signed__"                "signed"       ;
  define_macro "__typeof__"                "typeof"       ;
  define_macro "__unix"                    "1"            ;
  define_macro "__unix__"                  "1"            ;
  define_macro "__volatile__"              "volatile"     ;
  define_macro "__x86_64"                  "1"            ;
  define_macro "__x86_64__"                "1"            ;
  define_macro "linux"                     "1"            ;
  define_macro "unix"                      "1"            ;
  add_builtin "__FILE__"                   &file_macro     ;
  add_builtin "__LINE__"                   &line_macro     ;
  add_builtin "__COUNTER__"                &counter_macro  ;
  add_builtin "__TIMESTAMP__"              &timestamp_macro;
  let now = time cast @long 0;
  let tm = localtime &now;
  define_macro "__DATE__" format_date tm;
  define_macro "__TIME__" format_time tm;;
type StringKind enum
  STR_NONE
  STR_UTF8
  STR_UTF16
  STR_UTF32
  STR_WIDE;;
getStringKind(j@Token) StringKind = return
  !strcmp cast @ j.loc "u8"      ? STR_UTF8    :
  (j.loc[0] == '"')              ? STR_NONE    :
  (j.loc[0] == 'u')              ? STR_UTF16   :
  (j.loc[0] == 'U')              ? STR_UTF32   :
  (j.loc[0] == 'L')              ? STR_WIDE    :
                                     unreachable ;:
                                     STR_NONE    ;;
export preprocess(j@Token include_paths@StringArray)@Token =
  (j = preprocess2 j include_paths);
  if cond_incl (error_tok cond_incl.j "unterminated conditional directive");
  convert_pp_tokens j;
  for (let t @Token = j; t; t = t.s) (t.line_no += t.line_delta);
  return j;;
