#include "chub.hb"

type
  MacroParam struct {
    next @same
    name @char;
  }

  MacroArg struct {
    next @same
    name @char
    is_va_args bool
    tok @Token;
  }

  macro_handler_fn(_ @Token) @Token

  Macro struct {
    name @char
    is_objlike bool
    params @MacroParam
    va_args_name @char
    body @Token
    handler @macro_handler_fn;
  }

  CondIncl struct {
    next @same
    ctx enum IN_THEN IN_ELIF IN_ELSE;
    tok @Token
    included bool;
  };
 
macros HashMap
cond_incl @CondIncl
pragma_once HashMap
include_next_idx int
preprocess2(tok@Token include_paths@StringArray)@Token
find_macro(tok@Token)@Macro;

is_hash(tok@Token)bool = return tok.at_bol && equal tok "#";;
skip_line(tok@Token)@Token =
  if tok.at_bol return tok;
  warn_tok tok "extra token";
  while tok.at_bol tok = tok.next;
  return tok;;
copy_token(tok@Token)@Token =
  let t = (calloc 1ul sizeof Token as @Token);
  t@ = tok@;
  t.next = 0 as @Token;
  return t;;
new_eof(tok@Token)@Token =
  let t = copy_token tok;
  t.kind = TK_EOF;
  t.len = 0;
  return t;;
new_hideset(name@char)@Hideset =
  let hs = (calloc 1ul sizeof Hideset)->@Hideset;
  hs.name = name;
  return hs;;
hideset_union(hs1@Hideset hs2@Hideset)@Hideset =
  let
    head = (let Hideset){;
    cur = &head;
  for (; hs1; hs1 = hs1.next) { cur.next = new_hideset hs1.name; cur = cur.next;;
  cur.next = hs2;
  return head.next;;
hideset_contains(hs@Hideset s@char len int)bool =
  for (; hs; hs = hs.next) if (strlen hs.name == len && ! strncmp hs.name->@ s len->unsigned long) return true;
  return false;;
hideset_intersection(hs1@Hideset hs2@Hideset)@Hideset =
  let
    head = (let Hideset){;
    cur = &head;
  for (; hs1; hs1 = hs1.next) {
    if hideset_contains hs2 hs1.name (strlen hs1.name)->int { cur.next = new_hideset hs1.name; cur = cur.next;;;
  return head.next;;
add_hideset(tok@Token hs@Hideset)@Token =
  let
    head = (let Token){;
    cur = &head;
  for (; tok; tok = tok.next) {
    let t = copy_token tok;
    t.hideset = hideset_union t.hideset hs;
    cur.next = t;
    cur = cur.next;;
  return head.next;;
append(tok1@Token tok2@Token)@Token =
  if (tok1.kind == TK_EOF) return tok2;
  let
    head = (let Token){;
    cur = &head;
  for (; tok1.kind != TK_EOF; tok1 = tok1.next) { cur.next = copy_token tok1; cur = cur.next;;
  cur.next = tok2;
  return head.next;;
skip_cond_incl2(tok@Token)@Token =
  while (tok.kind != TK_EOF) {
    if (is_hash tok && (equal tok.next "if" || equal tok.next "ifdef" || equal tok.next "ifndef")) tok = skip_cond_incl2 tok.next.next;
    else if (is_hash tok && equal tok.next "endif") return tok.next.next;
    else tok = tok.next;;
  return tok;;
skip_cond_incl(tok@Token)@Token =
  while (tok.kind != TK_EOF) {
    if (is_hash tok && (equal tok.next "if" || equal tok.next "ifdef" || equal tok.next "ifndef")) tok = skip_cond_incl2 tok.next.next;
    else if (is_hash tok && (equal tok.next "elif" || equal tok.next "else" || equal tok.next "endif")) break;
    else tok = tok.next;;
  return tok;;

// Double-quote a given string and returns it.
quote_string(str@char)@char =
  let bufsize = 3;
  for (let i int = 0; str[i]; (i:;i+=1)) {
    if (str[i] == '\\' || str[i] == '"') (bufsize:;bufsize+=1);
    (bufsize:;bufsize+=1);;
  let
    buf = (calloc 1ul bufsize->unsigned long as @char)
    p = buf;
  (p:;p+=1)@ = '"' as char;
  for (let i int= 0; str[i]; (i:;i+=1)) {
    if (str[i] == '\\'->char || str[i] == '"'->char) (p:;p+=1)@ = '\\'->char;
    (p:;p+=1)@ = str[i];;
  (p:;p+=1)@ = '"' as char;
  (p:;p+=1)@ = '\0' as char;
  return buf;;
new_str_token(str @char tmpl@Token)@Token =
  let buf = quote_string str;
  return tokenize new_file tmpl.file.name tmpl.file.file_no buf;;
copy_line(rest@@Token tok@Token)@Token =
  let
    head = (let Token){;
    cur = &head;
  for (; !tok.at_bol; tok = tok.next) { cur.next = copy_token tok; cur = cur.next;;
  cur.next = new_eof tok;
  rest@ = tok;
  return head.next;;
new_num_token(val int tmpl@Token)@Token =
  let buf = format "%d\n" val;
  return tokenize new_file tmpl.file.name tmpl.file.file_no buf;;
read_const_expr(rest@@Token tok@Token)@Token =
  tok = copy_line rest tok;
  let
    head = (let Token){;
    cur = &head;
  while (tok.kind != TK_EOF) {
    if equal tok "defined" {
      let start = tok;
      let has_paren = consume &tok tok.next "(";
      if (tok.kind != TK_IDENT) error_tok start "macro name must be an identifier";
      let m = find_macro tok;
      tok = tok.next;
      if has_paren tok = skip tok ")";
      cur.next = new_num_token (!!m)->int start;
      cur = cur.next;;
    else {
      cur.next = tok;
      cur = cur.next;
      tok = tok.next;;;
  cur.next = tok;
  return head.next;;
eval_const_expr(rest@@Token tok@Token include_paths@StringArray) long =
  let start = tok;
  let expr = read_const_expr rest tok.next;
  expr = preprocess2 expr include_paths;
  if (expr.kind == TK_EOF) error_tok start "no expression";
  for (let t @Token= expr; t.kind != TK_EOF; t = t.next) {
    if (t.kind == TK_IDENT) {
      let next = t.next;
      t@ = (new_num_token 0 t)@;
      t.next = next;;;
  convert_pp_tokens expr;
  let rest2 = expr;
  let val = const_expr &rest2;
  if (rest2.kind != TK_EOF) error_tok rest2 "extra token";
  return val;;
push_cond_incl(tok@Token included bool)@CondIncl =
  let ci = (calloc 1ul sizeof CondIncl)->@CondIncl;
  ci.next = cond_incl;
  ci.ctx = IN_THEN;
  ci.tok = tok;
  ci.included = included;
  cond_incl = ci;
  return ci;;
find_macro(tok@Token)@Macro =
  if (tok.kind != TK_IDENT) return 0->@Macro;
  return (hashmap_get2 &macros tok.loc tok.len)->@Macro;;
add_macro(name@char is_objlike bool body@Token)@Macro =
  let m = (calloc 1ul sizeof Macro)->@Macro;
  m.name = name;
  m.is_objlike = is_objlike;
  m.body = body;
  hashmap_put &macros name m->@;
  return m;;
read_macro_params(rest@@ Token tok@ Token va_args_name@@ char)@ MacroParam =
  let
    head = (let MacroParam){;
    cur = &head;
  while ! equal tok ")" {
    if (cur != &head) tok = skip tok ",";
    if equal tok "..." {
      va_args_name@ = "__VA_ARGS__";
      rest@ = skip tok.next ")";
      return head.next;;
    if (tok.kind != TK_IDENT) error_tok tok "expected an identifier";
    if equal tok.next "..." {
      va_args_name@ = strndup tok.loc tok.len->unsigned long;
      rest@ = skip tok.next.next ")";
      return head.next;;
    let m = (calloc 1ul sizeof MacroParam as @MacroParam);
    m.name = strndup tok.loc tok.len->unsigned long;
    cur.next = m;
    cur = cur.next;
    tok = tok.next;;
  rest@ = tok.next;
  return head.next;;
read_macro_definition(rest@@Token tok@Token)  =
  if (tok.kind != TK_IDENT)
    error_tok tok "macro name must be an identifier";
  let name = strndup tok.loc tok.len->unsigned long;
  tok = tok.next;
  if (!tok.has_space && equal tok "(") {
    let va_args_name = 0->@char;
    let params = read_macro_params &tok tok.next &va_args_name;
    let m = add_macro name false copy_line rest tok;
    m.params = params;
    m.va_args_name = va_args_name;;
  else add_macro name true copy_line rest tok;;
read_macro_arg_one(rest@@Token tok@Token read_rest bool) @MacroArg =
  let
    head = (let Token){;
    cur = &head
    level = 0;
  while !(!level && (equal tok ")" || !read_rest && equal tok ",")) {
    if (tok.kind == TK_EOF) error_tok tok "premature end of input";
    else if equal tok "(" (level:;level+=1);
    else if equal tok ")" (level:;level-=1);
    cur.next = copy_token tok;
    cur = cur.next;
    tok = tok.next;;
  cur.next = new_eof tok;
  let arg = (calloc 1ul sizeof MacroArg)->@MacroArg;
  arg.tok = head.next;
  rest@ = tok;
  return arg;;
read_macro_args(rest@@Token tok@Token params @MacroParam va_args_name@char)@MacroArg =
  let start = tok;
  tok = tok.next.next;
  let
    head = (let MacroArg){;
    cur = &head
    pp = params;
  for (; pp; pp = pp.next) {
    if (cur != &head)
      expect &tok ",";
    cur.next = read_macro_arg_one &tok tok false;
    cur = cur.next;
    cur.name = pp.name;;
  if va_args_name {
    let arg = 0->@MacroArg;
    if equal tok ")" {
      arg = (calloc 1ul sizeof MacroArg)->@MacroArg;
      arg.tok = new_eof tok;;
    else {
      if (pp != params) tok = skip tok ",";
      arg = read_macro_arg_one &tok tok true;;
    arg.name = va_args_name;
    arg.is_va_args = true;
    cur.next = arg;
    cur = cur.next;;
  else if pp error_tok start "too many arguments";
  skip tok ")";
  rest@ = tok;
  return head.next;;
find_arg(args @MacroArg tok@Token)@MacroArg =
  for (let ap @MacroArg = args; ap; ap = ap.next) if (tok.len == strlen ap.name && ! strncmp tok.loc->@ ap.name tok.len->unsigned long) return ap;
  return 0 as @MacroArg;;
join_tokens(tok@Token end@Token)@char =
  let len = 1;
  for (let t @Token= tok; t != end && t.kind != TK_EOF; t = t.next) {
    if (t != tok && t.has_space) (len:;len+=1);
    len += t.len;;
  let buf = (calloc 1ul len->unsigned long as @char);
  let pos = 0;
  for (let t @Token= tok; t != end && t.kind != TK_EOF; t = t.next) {
    if (t != tok && t.has_space) buf[(pos:;pos+=1)] = ' ' as char;
    strncpy (buf + pos) t.loc t.len->unsigned long;
    pos += t.len;;
  buf[pos] = '\0' as char;
  return buf;;
stringize(hash@Token arg@Token)@Token =
  let s = join_tokens arg 0->@Token;
  return new_str_token s hash;;
paste(lhs@Token rhs@Token)@Token =
  let buf = format "%.*s%.*s" lhs.len lhs.loc rhs.len rhs.loc;
  let tok = tokenize new_file lhs.file.name lhs.file.file_no buf;
  if (tok.next.kind != TK_EOF) error_tok lhs "pasting forms '%s', an invalid token" buf;
  return tok;;
has_varargs(args @MacroArg) bool =
  for (let a @MacroArg = args; a; a = a.next) if ! strcmp a.name->@ "__VA_ARGS__" return a.tok.kind != TK_EOF;
  return false;;
subst(tok@Token args @MacroArg include_paths@StringArray)@ Token =
  let
    head = (let Token){;
    cur = &head;
  while (tok.kind != TK_EOF) {
    if equal tok "#" {
      let arg = find_arg args tok.next;
      if !arg error_tok tok.next "'#' is not followed by a macro parameter";
      cur.next = stringize tok arg.tok;
      cur = cur.next;
      tok = tok.next.next;;
    else if equal tok "##" {
      if (cur == &head) error_tok tok "'##' cannot appear at start of macro expansion";
      if (tok.next.kind == TK_EOF) error_tok tok "'##' cannot appear at end of macro expansion";
      let arg = find_arg args tok.next;
      if arg {
        if (arg.tok.kind != TK_EOF) {
          cur@ = (paste cur arg.tok)@;
          for (let t @Token= arg.tok.next; t.kind != TK_EOF; t = t.next) { cur.next = copy_token t; cur = cur.next;;;
        tok = tok.next.next;;
      else {
        cur@ = (paste cur tok.next)@;
        tok = tok.next.next;;;
    else {
      let arg = find_arg args tok;
      if (!!arg && equal tok.next "##") {
        let rhs = tok.next.next;
        if (arg.tok.kind == TK_EOF) {
          let arg2 = find_arg args rhs;
          if arg2 for (let t @Token= arg2.tok; t.kind != TK_EOF; t = t.next) { cur.next = copy_token t; cur = cur.next;;
          else { cur.next = copy_token rhs; cur = cur.next;;
          tok = rhs.next;;
        else {
          for (let t @Token= arg.tok; t.kind != TK_EOF; t = t.next) { cur.next = copy_token t; cur = cur.next;;
          tok = tok.next;;;
      else if (equal tok "__VA_OPT__" && equal tok.next "(") {
        let arg = read_macro_arg_one &tok tok.next.next true;
        if has_varargs args for (let t @Token = arg.tok; t.kind != TK_EOF; t = t.next) { cur.next = t; cur = cur.next;;
        tok = skip tok ")";;
      else if arg {
        let t = preprocess2 arg.tok include_paths;
        t.at_bol = tok.at_bol;
        t.has_space = tok.has_space;
        for (; t.kind != TK_EOF; t = t.next) { cur.next = copy_token t; cur = cur.next;;
        tok = tok.next;;
      else {
        cur.next = copy_token tok;
        cur = cur.next;
        tok = tok.next;;;;
  cur.next = tok;
  return head.next;;
expand_macro(rest@@Token tok@Token include_paths@StringArray)bool =
  if hideset_contains tok.hideset tok.loc tok.len return false;
  let m = find_macro tok;
  if !m return false;
  if m.handler {
    rest@ = m.handler@ tok;
    rest@.next = tok.next;
    return true;;
  if m.is_objlike {
    let hs = hideset_union tok.hideset new_hideset m.name;
    let body = add_hideset m.body hs;
    for (let t @Token= body; t.kind != TK_EOF; t = t.next) t.origin = tok;
    rest@ = append body tok.next;
    rest@.at_bol = tok.at_bol;
    rest@.has_space = tok.has_space;
    return true;;
  if !equal tok.next "(" return false;
  let macro_token = tok;
  let args  = read_macro_args &tok tok m.params m.va_args_name;
  let rparen = tok;
  let hs = hideset_intersection macro_token.hideset rparen.hideset;
  hs = hideset_union hs new_hideset m.name;
  let body = subst m.body args include_paths;
  body = add_hideset body hs;
  for (let t @Token= body; t.kind != TK_EOF; t = t.next) t.origin = macro_token;
  rest@ = append body tok.next;
  rest@.at_bol = macro_token.at_bol;
  rest@.has_space = macro_token.has_space;
  return true;;
sipcache HashMap;
export search_include_paths(filename@char include_paths@StringArray)@char =
  if (filename[0] == '/') return filename;
  let cached = hashmap_get &sipcache filename;
  if cached return cached->@char;
  for (let i int = 0; i < include_paths.len; (i:;i+=1)) {
    let path = format "%s/%s" include_paths.data[i] filename;
    if file_exists path {
      hashmap_put &sipcache filename path->@;
      include_next_idx = i + 1;
      return path;;;
  return 0->@char;;
search_include_next(filename@char include_paths @StringArray)@char =
  for (; include_next_idx < include_paths.len; (include_next_idx:;include_next_idx+=1)) {
    let path = format "%s/%s" include_paths.data[include_next_idx] filename;
    if file_exists path return path;;
  return 0->@char;;
read_include_filename(rest@@Token tok@Token is_dquote@bool include_paths @StringArray)@char =
  if (tok.kind == TK_STR) {
    is_dquote@ = true;
    rest@ = skip_line tok.next;
    return strndup (tok.loc + 1) (tok.len - 2)->unsigned long;;
  if equal tok "<" {
    let start = tok;
    for (; ! equal tok ">"; tok = tok.next) if (tok.at_bol || tok.kind == TK_EOF) error_tok tok "expected '>'";
    is_dquote@ = false;
    rest@ = skip_line tok.next;
    return join_tokens start.next tok;;
  if (tok.kind == TK_IDENT) {
    let a = copy_line rest tok;
    let tok2 = preprocess2 a include_paths;
    return read_include_filename &tok2 tok2 is_dquote include_paths;;
  error_tok tok "expected a filename";;
detect_include_guard(tok@Token)@char =
  if (! is_hash tok || ! equal tok.next "ifndef") return 0->@char;
  tok = tok.next.next;
  if (tok.kind != TK_IDENT) return 0->@char;
  let macro = strndup tok.loc tok.len->unsigned long;
  tok = tok.next;
  if (! is_hash tok || ! equal tok.next "define" || ! equal tok.next.next macro) return 0->@char;
  while (tok.kind != TK_EOF) {
    if !is_hash tok tok = tok.next;
    else if (equal tok.next "endif" && tok.next.next.kind == TK_EOF) return macro;
    else if (equal tok "if" || equal tok "ifdef" || equal tok "ifndef") tok = skip_cond_incl tok.next;
    else tok = tok.next;;
  return 0->@char;;
ifinclude_guards HashMap;
include_file(tok@Token path@char filename_tok@Token)@Token =
  if hashmap_get &pragma_once path return tok;
  let guard_name = (hashmap_get &ifinclude_guards path as @char);
  if (!!guard_name && hashmap_get &macros guard_name) return tok;
  let tok2 = tokenize_file path;
  if !tok2 error_tok filename_tok "%s: cannot open file: %s" path strerror errno;
  guard_name = detect_include_guard tok2;
  if guard_name hashmap_put &ifinclude_guards path guard_name->@;
  return append tok2 tok;;
read_line_marker(rest@@Token tok@Token include_paths@StringArray)  =
  let start = tok;
  tok = preprocess copy_line rest tok include_paths;
  if (tok.kind != TK_NUM || tok.ty->@Type.kind != TY_INT) error_tok tok "invalid line marker";
  start.file.line_delta = tok.val - start.line_no as int;
  tok = tok.next;
  if (tok.kind == TK_EOF) return;
  if (tok.kind != TK_STR) error_tok tok "filename expected";
  start.file.display_name = tok.str;;
preprocess2(tok@Token include_paths@StringArray)@Token =
  let
    head = (let Token){;
    cur = &head;
  while (tok.kind != TK_EOF) {
    let start = tok;
    tok = tok.next;
    if expand_macro &tok start include_paths;
    else if !is_hash start {
      start.line_delta = start.file.line_delta;
      start.filename = start.file.display_name;
      cur.next = start;
      cur = cur.next;
      start = start.next;;
    else if equal tok "include" {
      let is_dquote = false;
      let c = &is_dquote;
      let filename = read_include_filename &tok tok.next c include_paths;
      if (filename[0] != '/' && is_dquote) {
        let path = format"%s/%s" dirname strdup start.file.name filename;
        if file_exists path tok = include_file tok path start.next.next;
        else {
          let path = search_include_paths filename include_paths;
          tok = include_file tok (path || filename) start.next.next;;;
      else {
        let path = search_include_paths filename include_paths;
        tok = include_file tok (path || filename) start.next.next;;;
    else if equal tok "include_next" {
      let ignore = false;
      let c = &ignore;
      let filename = read_include_filename &tok tok.next c include_paths;
      let path = search_include_next filename include_paths;
      tok = include_file tok (path || filename) start.next.next;;
    else if equal tok "define" read_macro_definition &tok tok.next;
    else if equal tok "undef" {
      tok = tok.next;
      if (tok.kind != TK_IDENT) error_tok tok "macro name must be an identifier";
      undef_macro strndup tok.loc tok.len->unsigned long;
      tok = skip_line tok.next;;
    else if equal tok "if" {
      let val = eval_const_expr &tok tok include_paths;
      push_cond_incl start val->bool;
      if !val tok = skip_cond_incl tok;;
    else if equal tok "ifdef" {
      let defined = find_macro tok.next;
      push_cond_incl tok defined->bool;
      tok = skip_line tok.next.next;
      if !defined tok = skip_cond_incl tok;;
    else if equal tok "ifndef" {
      let ndefined = !find_macro tok.next;
      push_cond_incl tok ndefined;
      tok = skip_line tok.next.next;
      if !ndefined tok = skip_cond_incl tok;;
    else if equal tok "elif" {
      if (!cond_incl || cond_incl.ctx == IN_ELSE) error_tok start "stray #elif";
      cond_incl.ctx = IN_ELIF;
      if (!cond_incl.included && eval_const_expr &tok tok include_paths) cond_incl.included = true;
      else tok = skip_cond_incl tok;;
    else if equal tok "else" {
      if (!cond_incl || cond_incl.ctx == IN_ELSE) error_tok start "stray #else";
      cond_incl.ctx = IN_ELSE;
      tok = skip_line tok.next;
      if cond_incl.included tok = skip_cond_incl tok;;
    else if equal tok "endif" {
      if !cond_incl error_tok start "stray #endif";
      cond_incl = cond_incl.next;
      tok = skip_line tok.next;;
    else if equal tok "line" read_line_marker &tok tok.next include_paths;
    else if (tok.kind == TK_PP_NUM) read_line_marker &tok tok include_paths;
    else if (equal tok "pragma" && equal tok.next "once") {
      hashmap_put &pragma_once tok.file.name 1->@;
      tok = skip_line tok.next.next;;
    else if equal tok "pragma" do tok = tok.next; while !tok.at_bol;
    else if equal tok "error" error_tok tok "error";
    else if !tok.at_bol error_tok tok "invalid preprocessor directive";;
  cur.next = tok;
  return head.next;;
export define_macro(name@char buf@char)  =
  let tok = tokenize new_file "<built-in>" 1 buf;
  add_macro name true tok;;
export undef_macro(name@char)  =
  hashmap_delete &macros name;;
add_builtin(name@char fn@macro_handler_fn)@Macro =
  let m = add_macro name true 0->@Token;
  m.handler = fn;
  return m;;
file_macro(tmpl@Token)@ Token =
  while tmpl.origin tmpl = tmpl.origin;
  return new_str_token tmpl.file.display_name tmpl;;
line_macro(tmpl@Token)@ Token =
  while tmpl.origin tmpl = tmpl.origin;
  return new_num_token (tmpl.line_no + tmpl.file.line_delta) tmpl;;
cmi int = 0;
counter_macro(tmpl@Token)@Token = return new_num_token (cmi:;cmi+=1) tmpl;;
tmbuf[30]char;
timestamp_macro(tmpl@Token)@Token =
  let st = (let struct stat){;;
  if (stat tmpl.file.name &st != 0) return new_str_token "??? ??? ?? ??:??:?? ????" tmpl;
  ctime_r &st.st_mtime &tmbuf@;
  tmbuf[24] = '\0' as char;
  return new_str_token &tmbuf@ &tmpl@;;
fmmon[][4]char = {
  "Jan" "Feb" "Mar" "Apr" "May" "Jun"
  "Jul" "Aug" "Sep" "Oct" "Nov" "Dec";;
format_date(tm@ struct tm)@ char = return format "\"%s %2d %d\"" fmmon[tm.tm_mon] tm.tm_mday (tm.tm_year + 1900);;
format_time(tm@ struct tm)@ char = return format "\"%02d:%02d:%02d\"" tm.tm_hour tm.tm_min tm.tm_sec;;
export init_macros(void)  =
  macros = (let HashMap){;;
  cond_incl = 0 as @CondIncl;
  pragma_once = (let HashMap){;;
  include_next_idx = 0;
  define_macro "_LP64"                     "1"            ;
  define_macro "__C99_MACRO_WITH_VA_ARGS"  "1"            ;
  define_macro "__ELF__"                   "1"            ;
  define_macro "__LP64__"                  "1"            ;
  define_macro "__SIZEOF_DOUBLE__"         "8"            ;
  define_macro "__SIZEOF_FLOAT__"          "4"            ;
  define_macro "__SIZEOF_INT__"            "4"            ;
  define_macro "__SIZEOF_LONG_DOUBLE__"    "8"            ;
  define_macro "__SIZEOF_LONG_LONG__"      "8"            ;
  define_macro "__SIZEOF_LONG__"           "8"            ;
  define_macro "__SIZEOF_POINTER__"        "8"            ;
  define_macro "__SIZEOF_PTRDIFF_T__"      "8"            ;
  define_macro "__SIZEOF_SHORT__"          "2"            ;
  define_macro "__SIZEOF_SIZE_T__"         "8"            ;
  define_macro "__SIZE_TYPE__"             "unsigned long";
  define_macro "__STDC_HOSTED__"           "1"            ;
  define_macro "__STDC_NO_COMPLEX__"       "1"            ;
  define_macro "__STDC_UTF_16__"           "1"            ;
  define_macro "__STDC_UTF_32__"           "1"            ;
  define_macro "__STDC_VERSION__"          "201112L"      ;
  define_macro "__STDC__"                  "1"            ;
  define_macro "__USER_LABEL_PREFIX__"     ""             ;
  define_macro "__alignof__"               "_Alignof"     ;
  define_macro "__amd64"                   "1"            ;
  define_macro "__amd64__"                 "1"            ;
  define_macro "__chibicc__"               "1"            ;
  define_macro "__const__"                 "const"        ;
  define_macro "__gnu_linux__"             "1"            ;
  define_macro "__inline__"                "inline"       ;
  define_macro "__linux"                   "1"            ;
  define_macro "__linux__"                 "1"            ;
  define_macro "__signed__"                "signed"       ;
  define_macro "__typeof__"                "typeof"       ;
  define_macro "__unix"                    "1"            ;
  define_macro "__unix__"                  "1"            ;
  define_macro "__volatile__"              "volatile"     ;
  define_macro "__x86_64"                  "1"            ;
  define_macro "__x86_64__"                "1"            ;
  define_macro "linux"                     "1"            ;
  define_macro "unix"                      "1"            ;
  add_builtin "__FILE__"                   &file_macro     ;
  add_builtin "__LINE__"                   &line_macro     ;
  add_builtin "__COUNTER__"                &counter_macro  ;
  add_builtin "__TIMESTAMP__"              &timestamp_macro;
  let now = time 0->@long;
  let tm = localtime &now;
  define_macro "__DATE__" format_date tm;
  define_macro "__TIME__" format_time tm;;
type StringKind enum
  STR_NONE
  STR_UTF8
  STR_UTF16
  STR_UTF32
  STR_WIDE;;
getStringKind(tok@Token) StringKind = return
  !strcmp tok.loc->@ "u8" ? STR_UTF8    :
  tok.loc[0] == '"'              ? STR_NONE    :
  tok.loc[0] == 'u'              ? STR_UTF16   :
  tok.loc[0] == 'U'              ? STR_UTF32   :
  tok.loc[0] == 'L'              ? STR_WIDE    :
                                   unreachable->StringKind ;;
export preprocess(tok@Token include_paths@StringArray)@Token =
  tok = preprocess2 tok include_paths;
  if cond_incl error_tok cond_incl.tok "unterminated conditional directive";
  convert_pp_tokens tok;
  for (let t @Token= tok; t; t = t.next) t.line_no += t.line_delta;
  return tok;;
