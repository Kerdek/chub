#include "chub.hb"

type
  VarScope struct {
    var      @Obj
    type_def @Type
    enum_ty  @Type
    enum_val  int;
  }
  Scope struct {
    next @same
    vars  HashMap
    tags  HashMap;
  }
  VarAttr struct {
    is_type    bool
    is_static  bool
    is_extern  bool
    is_export  bool
    is_inline  bool
    is_tls     bool
    alignment  int;
  }
  Initializer struct {
    next        @same
    ty          @Type
    tok         @Token
    is_flexible  bool
    expr        @Node
    children   @@same
    mem         @Member;
  }
  InitDesg struct {
    next     @same
    idx       int
    member   @Member
    var      @Obj;
  }
;

locals         @Obj
globals        @Obj
scope          @Scope = &(let Scope){;
current_type   @Type
current_fn     @Obj
gotos          @Node
labels         @Node
brk_label      @char
cont_label     @char
current_switch @Node
builtin_alloca @Obj

add                (k @@Token) @Node
compound_stmt      (k @@Token) @Node
expr_stmt          (k @@Token) @Node
assign             (k @@Token) @Node
conditional        (k @@Token) @Node
postfix            (k @@Token) @Node
prefix             (k @@Token) @Node
primary            (k @@Token) @Node

enum_specifier     (k @@Token) @Type
typeof_specifier   (k @@Token) @Type
type_suffix        (k @@Token) @Type
declarator         (k @@Token) @Type
struct_decl        (k @@Token) @Type
union_decl         (k @@Token) @Type

parse_type         (k  @Token) @Token
is_function        (k  @Token) bool

declspec           (k @@Token   attr @VarAttr)
declaration        (k @@Token   attr @VarAttr) @Node
function           (k  @Token   attr @VarAttr) @Token
global_variable    (k  @Token   attr @VarAttr) @Token

funcall            (k @@Token   node @Node) @Node

array_initializer2 (rest @@Token  tok     @Token init@ Initializer i int      )
struct_initializer2(rest @@Token  tok     @Token init@ Initializer mem@ Member)
initializer2       (rest @@Token  tok     @Token init@ Initializer            )
initializer        (rest @@Token  tok     @Token ty   @Type new_ty @@Type     ) @Initializer
lvar_initializer   (rest @@Token  tok     @Token var  @Obj                    ) @Node
gvar_initializer   (rest @@Token  tok     @Token var  @Obj                    )

eval               (node  @Node                                               ) int64_t
eval2              (node  @Node   label @@@char                               ) int64_t
eval_rval          (node  @Node   label @@@char                               ) int64_t
is_const_expr      (node  @Node                                               ) bool
eval_double        (node  @Node                                               ) double
new_add            (lhs   @Node   rhs @Node  tok@ Token                       ) @Node
new_sub            (lhs   @Node   rhs @Node  tok@ Token                       ) @Node
get_struct_member  (ty    @Type   tok @Token                                  ) @Member;

align_down(n int alignment int) int = let a = n - alignment + 1; return align_to(a alignment);;
enter_scope(void) = let sc = calloc(1ul sizeof Scope)->@Scope; sc@.next = scope; scope = sc;;
leave_scope(void) = scope = scope@.next;;
search_scope(tok @Token which(_@ Scope)@HashMap)@ = for (let sc@ Scope = scope; sc; sc = sc@.next) { let sc2 = hashmap_get2(which(sc) tok@.loc tok@.len); if sc2 return sc2; ; return 0->@; ;
scope_vars(s @Scope) @HashMap = return &s@.vars;;
scope_tags(s @Scope) @HashMap = return &s@.tags;;
new_node(c NodeKind k @Token) @Node =
  let e = calloc(1ul sizeof Node)->@Node;
  e@.kind = c; e@.tok = k;
  return e;;
new_binary(c NodeKind a @Node b @Node k @Token) @Node =
  let e = new_node(c k);
  e@.lhs = a; e@.rhs = b;
  return e;;
new_prefix(c NodeKind a @Node k @Token) @Node =
  let e = new_node(c k);
  e@.lhs = a;
  return e;;
new_num(l long k @Token) @Node =
  let e = new_node(ND_NUM->NodeKind k);
  e@.val = l;
  return e;;
new_long(l long k @Token) @Node =
  let e = new_node(ND_NUM->NodeKind k);
  e@.val = l; e@.ty = ty_long;
  return e;;
new_ulong(l long k @Token) @Node =
  let e = new_node(ND_NUM->NodeKind k);
  e@.val = l;
  e@.ty = ty_ulong;
  return e;;
new_bool(l long k @Token) @Node =
  let e = new_node(ND_NUM->NodeKind k);
  e@.val = l;
  e@.ty = ty_bool;
  return e;;
new_var_node(o @Obj k @Token) @Node =
  let e = new_node(ND_VAR->NodeKind k);
  e@.var = o;
  return e;;
s1 [1024]char s2 [1024]char;
export new_cast(a @Node t @Type) @Node =
  add_type(a);
  let e = new_prefix(ND_CAST->NodeKind a a@.tok);
  e@.ty = copy_type(t);
  if is_type_equal(a@.ty e@.ty) {
    s1[0] = 0; s2[0] = 0;
    format_type(a@.ty s1->@char);
    format_type(e@.ty s2->@char);
    warn_tok(a@.tok "needless cast from %s to %s"->@char s1 s2);
  ;
  return e;;
push_scope(name@ char) @VarScope =
  let sc = calloc(1ul sizeof VarScope)->@VarScope;
  let a = &scope@.vars;
  hashmap_put(a name sc->@);
  return sc;;
new_initializer(t @Type is_flexible bool) @Initializer =
  let e = calloc(1ul sizeof Initializer)->@Initializer;
  e@.ty = t;
  if t@.kind == TY_ARRAY {
    if is_flexible && t@.size < 0 {
      e@.is_flexible = true;
      return e;;
    e@.children = calloc(t@.array_len->unsigned long sizeof @Initializer);
    for (let i int = 0; i < t@.array_len; i++) e@.children[i] = new_initializer(t@.base false);
    return e;;
  if t@.kind == TY_STRUCT || t@.kind == TY_UNION {
    let len = 0;
    for (let mem@ Member = t@.members; mem; mem = mem@.next) len++;
    e@.children = calloc(len->unsigned long sizeof @);
    for (let mem@ Member = t@.members; mem; mem = mem@.next) {
      if is_flexible && t@.is_flexible && !mem@.next {
        let child = calloc(1ul sizeof Initializer)->@Initializer;
        child@.ty = mem@.ty;
        child@.is_flexible = true;
        e@.children[mem@.idx] = child;;
      else e@.children[mem@.idx] = new_initializer(mem@.ty->@Type false);    ;
    return e;  ;
  return e;;
new_var(name @char t @Type) @Obj =
  let o = calloc(1ul sizeof Obj)->@Obj;
  o@.name = name;
  o@.ty = t;
  o@.alignment = t@.alignment;
  push_scope(name)@.var = o;
  return o;;
new_lvar(name @char t @Type) @Obj =
  let o = new_var(name t);
  o@.is_local = true;
  o@.next = locals;
  locals = o;
  return o;;
new_gvar(name @char t @Type) @Obj =
  let o = new_var(name t);
  o@.next = globals;
  o@.is_export = false;
  o@.is_definition = true;
  globals = o;
  return o;;
nunid int = 0;
new_unique_name(void) @char = return format(".L..%d"->@char nunid++);;
new_anon_gvar(t @Type) @Obj = return new_gvar(new_unique_name() t);;
new_string_literal(p @char t @Type) @Obj =
  let o = new_anon_gvar(t);
  o@.init_data = p;
  return o;;
get_ident(k@ Token) @char =
  if k@.kind != TK_IDENT error_tok(k "expected an identifier"->@char);
  return strndup(k@.loc k@.len->unsigned long);;
find_type(k @Token) @Type =
  if k@.kind == TK_IDENT {
    let sc = search_scope(k scope_vars->@(sc@Scope)@HashMap)->@VarScope;
    if sc return sc@.type_def;;
  return 0->@Type;;
push_tag_scope(k@ Token t@ Type)  =
  let a = &scope@.tags;
  hashmap_put2(a k@.loc k@.len t->@);;
declspec(k @@Token v@ VarAttr)  =
  for (;;) {
    if equal(k@ "type"->@char) || equal(k@ "static"->@char) || equal(k@ "export"->@char) || equal(k@ "extern"->@char) || equal(k@ "inline"->@char) || equal(k@ "_Thread_local"->@char) || equal(k@ "__thread"->@char) {
      if !v error_tok(k@ "storage class specifier is not allowed in this context"->@char);
      ( equal(k@ "type"  ->@char) ? &v@.is_type   :
        equal(k@ "export"->@char) ? &v@.is_export :
        equal(k@ "static"->@char) ? &v@.is_static :
        equal(k@ "extern"->@char) ? &v@.is_extern :
        equal(k@ "inline"->@char) ? &v@.is_inline :
                             &v@.is_tls      )@ = true;
      if (v@.is_type && v@.is_static + v@.is_export + v@.is_extern + v@.is_inline + v@.is_tls > 1)
        error_tok(k@ "type may not be used together with export, static, extern, inline, __thread or _Thread_local"->@char);
      k@ = k@@.next;
    ; else if equal(k@ "align"->@char) {
      if !v error_tok(k@ "align is not allowed in this context"->@char);
      k@ = k@@.next;
      v@.alignment = const_expr(k k@);
    ; else if consume(k k@ "restrict"->@char)
    ; else return;
  ;
;
type_specifier(k @@Token)@ Type =
  if consume(k k@ "struct"->@char) return struct_decl     (k); else
  if consume(k k@ "union" ->@char) return union_decl      (k); else
  if consume(k k@ "enum"  ->@char) return enum_specifier  (k); else
  if consume(k k@ "typeof"->@char) return typeof_specifier(k); else
  if consume(k k@ "same"  ->@char) {
    if !current_type error_tok(k@ "`same` may not be used outside struct/union definition"->@char);
    return current_type;
  ;
  else {
    let ty2 = find_type(k@);
    if ty2{
      k@ = k@@.next;
      return ty2;
    ;
    else {
      let counter = 0->enum 
        BOOL     = 1 << 2
        CHAR     = 1 << 4
        SHORT    = 1 << 6
        INT      = 1 << 8
        LONG     = 1 << 10
        FLOAT    = 1 << 12
        DOUBLE   = 1 << 14
        SIGNED   = 1 << 17
        UNSIGNED = 1 << 18;;
      for (;;) {
        if equal(k@ "bool"    ->@char) counter += BOOL    ; else
        if equal(k@ "char"    ->@char) counter += CHAR    ; else
        if equal(k@ "short"   ->@char) counter += SHORT   ; else
        if equal(k@ "int"     ->@char) counter += INT     ; else
        if equal(k@ "long"    ->@char) counter += LONG    ; else
        if equal(k@ "float"   ->@char) counter += FLOAT   ; else
        if equal(k@ "double"  ->@char) counter += DOUBLE  ; else
        if equal(k@ "signed"  ->@char) counter |= SIGNED  ; else
        if equal(k@ "unsigned"->@char) counter |= UNSIGNED; else
          break;
        k@ = k@@.next;
      ;
      switch (counter) {
      case 0                            : return ty_void;
      case BOOL                         : return ty_bool;
      case CHAR                         :
      case SIGNED + CHAR                : return ty_char;
      case UNSIGNED + CHAR              : return ty_uchar;
      case SHORT                        :
      case SHORT + INT                  :
      case SIGNED + SHORT               :
      case SIGNED + SHORT + INT         : return ty_short;
      case UNSIGNED + SHORT             :
      case UNSIGNED + SHORT + INT       : return ty_ushort;
      case INT                          :
      case SIGNED                       :
      case SIGNED + INT                 : return ty_int;
      case UNSIGNED                     :
      case UNSIGNED + INT               : return ty_uint;
      case LONG                         :
      case LONG + INT                   :
      case LONG + LONG                  :
      case LONG + LONG + INT            :
      case SIGNED + LONG                :
      case SIGNED + LONG + INT          :
      case SIGNED + LONG + LONG         :
      case SIGNED + LONG + LONG + INT   : return ty_long;
      case UNSIGNED + LONG              :
      case UNSIGNED + LONG + INT        :
      case UNSIGNED + LONG + LONG       :
      case UNSIGNED + LONG + LONG + INT : return ty_ulong;
      case FLOAT                        : return ty_float;
      case DOUBLE                       : return ty_double;
      case LONG + DOUBLE                : return ty_ldouble;
      default                           : error_tok(k@ "invalid type"->@char);
      ;
    ;
  ;
;
func_params(k @@Token) @Type =
  if equal(k@ "void"->@char) && consume(k k@@.next ")"->@char) return func_type(type_suffix(k));
  let
    head = (let Type){;
    cur = &head
    is_variadic = false;
  while !equal(k@ ")"->@char) {
    if consume(k k@ "..."->@char) {
      is_variadic = true;
      break;
    ;
    declspec(k 0->@VarAttr);
    let t = declarator(k);
    let name = t@.name;
   if t@.kind == TY_FUNC {
      t = pointer_to(t);
      t@.name = name;
    ;
    cur = cur@.next = copy_type(t);
  ;
  if cur == &head is_variadic = true;
  k@ = k@@.next;
  let t = func_type(type_suffix(k));
  t@.params = head.next;
  t@.is_variadic = is_variadic;
  return t;
;
array_dimensions(k @@Token)@ Type =
  while equal(k@ "static"->@char) || equal(k@ "restrict"->@char) k@ = k@@.next;
  if consume(k k@ "]"->@char) {
    let t = type_suffix(k);
    let b = -1;
    return array_of(t b);
  ;
  let e = conditional(k);
  expect(k "]"->@char);
  let t = type_suffix(k);
  return array_of(t eval(e)->int);
;
type_suffix(k @@Token)@ Type =
  while consume(k k@ "const"   ->@char) ||
        consume(k k@ "volatile"->@char);
     if consume(k k@ "("       ->@char) return func_params           (k) ;
     if consume(k k@ "["       ->@char) return array_dimensions      (k) ;
     if consume(k k@ "@"       ->@char) return pointer_to(type_suffix(k));
  return type_specifier(k);
;
declarator(k @@Token)@ Type =
  let name = k@;
  k@ = k@@.next;
  let t = type_suffix(k);
  t@.name = name;
  t@.name_pos = name;
  return t;
;
enum_specifier(k @@Token) @Type =
  let t = enum_type();
  let l = 0;
  while !consume(k k@ ";"->@char) {
    let p = get_ident(k@);
    k@ = k@@.next;
    if equal(k@ "="->@char) {
      k@ = k@@.next;
      l = const_expr(k k@);
    ;
    let sc = push_scope(p);
    sc@.enum_ty = t;
    sc@.enum_val = l++;
  ;
  return t;
;
typeof_specifier(k @@Token)@ Type =
  let t = 0->@Type;
  let e = prefix(k);
  add_type(e);
  t = e@.ty;
  return t;
;
declaration(k @@Token v @VarAttr) @Node =
  let
    head = (let Node){;
    cur = &head;
  while !equal(k@ ";"->@char) {
    let t = declarator(k);
    if t@.kind == TY_VOID error_tok(k@ "variable declared void"->@char);
    if !t@.name error_tok(t@.name_pos "variable name omitted"->@char);
    if equal(t@.name "_"->@char) continue;
    if v && v@.is_static {
      let o = new_anon_gvar(t);
      push_scope(get_ident(t@.name))@.var = o;
      if equal(k@ "="->@char) {
        k@ = k@@.next;
        gvar_initializer(k k@ o);
      ;
      continue;
    ;
    let o = new_lvar(get_ident(t@.name) t);
    if v && v@.alignment o@.alignment = v@.alignment;
    if equal(k@ "="->@char) {
      k@ = k@@.next;
      let e = lvar_initializer(k k@ o);
      cur = cur@.next = new_prefix(ND_EXPR_STMT->NodeKind e k@);
    ;
    if o@.ty@.size < 0 error_tok(t@.name "variable has incomplete type"->@char);
    if o@.ty@.kind == TY_VOID error_tok(t@.name "variable declared void"->@char);
  ;
  let e = new_node(ND_BLOCK->NodeKind k@);
  e@.body = head.next;
  k@ = k@@.next;
  return e;
;

string_initializer(rest @@Token tok@ Token init@ Initializer)  =
  if init@.is_flexible
    init@ = new_initializer(array_of(init@.ty@.base tok@.ty->@Type@.array_len) false)@;

  let len = minl(init@.ty@.array_len->long tok@.ty->@Type@.array_len->long);

  switch (init@.ty@.base@.size) {
  case 1: {
    let str = tok@.str;
    for (let i int = 0; i < len; i++)
      init@.children[i]@.expr = new_num(str[i]->long tok);
    break;
  ;
  case 2: {
    let str = tok@.str->@uint16_t;
    for (let i int = 0; i < len; i++)
      init@.children[i]@.expr = new_num(str[i]->long tok);
    break;
  ;
  case 4: {
    let str = tok@.str->@uint32_t;
    for (let i int = 0; i < len; i++)
      init@.children[i]@.expr = new_num(str[i]->long tok);
    break;
  ;
  default:
    unreachable();
  ;

  rest@ = tok@.next;
;

array_designator(rest @@Token tok@ Token ty@ Type begin@ int end@ int)  =
  tok = tok@.next;
  begin@ = const_expr(&tok tok);
  if begin@ >= ty@.array_len
    error_tok(tok "array designator index exceeds array bounds"->@char);

  if equal(tok "..."->@char) {
    end@ = const_expr(&tok tok@.next);
    if end@ >= ty@.array_len
      error_tok(tok "array designator index exceeds array bounds"->@char);
    if end@ < begin@
      error_tok(tok "array designator range [%d, %d] is empty"->@char begin@ end@);
  ; else {
    end@ = begin@;
  ;

  rest@ = skip(tok "]"->@char);
;

struct_designator(rest @@Token tok@ Token ty@ Type)@ Member =
  let start = tok;
  expect(&tok "."->@char);
  if tok@.kind != TK_IDENT
    error_tok(tok "expected a field designator"->@char);

  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    // Anonymous struct member
    if mem@.ty->@Type@.kind == TY_STRUCT && (!mem@.name || equal(mem@.name "_"->@char)) {
      if get_struct_member(mem@.ty->@Type tok) {
        rest@ = start;
        return mem;
      ;
      continue;
    ;

    // Regular struct member
    if mem@.name@.len == tok@.len && !strncmp(mem@.name@.loc->@ tok@.loc tok@.len->unsigned long) {
      rest@ = tok@.next;
      return mem;
    ;
  ;

  error_tok(tok "struct has no such member"->@char);
;

// designation = ("["->@char const-expr "]"->@char | "."->@char ident)* "="->@char? initializer
designation(rest @@Token tok@ Token init@ Initializer)  =
  if equal(tok "["->@char) {
    if init@.ty@.kind != TY_ARRAY
      error_tok(tok "array index in non-array initializer"->@char);

    let
      begin = 0
      end = 0
      a = &begin
      b = &end;
    array_designator(&tok tok init@.ty a b);

    let tok2 = 0->@Token;
    for (let i int = begin; i <= end; i++)
      designation(&tok2 tok init@.children[i]);
    array_initializer2(rest tok2 init begin + 1);
    return;
  ;

  if equal(tok "."->@char) && init@.ty@.kind == TY_STRUCT {
    let mem = struct_designator(&tok tok init@.ty);
    designation(&tok tok init@.children[mem@.idx]);
    init@.expr = 0;
    struct_initializer2(rest tok init mem@.next);
    return;
  ;

  if equal(tok "."->@char) && init@.ty@.kind == TY_UNION {
    let mem = struct_designator(&tok tok init@.ty);
    init@.mem = mem;
    designation(rest tok init@.children[mem@.idx]);
    return;
  ;

  if equal(tok "."->@char)
    error_tok(tok "field name not in struct or union initializer"->@char);

  if equal(tok "="->@char)
    tok = tok@.next;
  initializer2(rest tok init);
;

// An array length can be omitted if an array has an initializer
// (e.g. `x int[] = {1,2,3;`). If it's omitted, count the number
// of initializer elements.
count_array_init_elements(tok@ Token ty@ Type) int =
  let
    dummy = new_initializer(ty@.base true)
    i = 0
    max = 0;

  while !consume(&tok tok ";"->@char) {

    if equal(tok "["->@char) {
      i = const_expr(&tok tok@.next);
      if equal(tok "..."->@char)
        i = const_expr(&tok tok@.next);
      expect(&tok "]"->@char);
      designation(&tok tok dummy);
    ; else {
      initializer2(&tok tok dummy);
    ;

    i++;
    max = maxl(max->long i->long);
  ;
  return max;
;

// array-initializer1 = "{"->@char initializer (","->@char initializer)* ","->@char? ";"->@char
array_initializer1(rest @@Token tok@ Token init@ Initializer)  =
  expect(&tok "{"->@char);

  if init@.is_flexible {
    let len = count_array_init_elements(tok init@.ty);
    init@ = new_initializer(array_of(init@.ty@.base len) false)@;
  ;

  if init@.is_flexible {
    let len = count_array_init_elements(tok init@.ty);
    init@ = new_initializer(array_of(init@.ty@.base len) false)@;
  ;

  for (let i int = 0; !consume(rest tok ";"->@char); i++) {
    if equal(tok "["->@char) {
      let
        begin = 0
        end = 0
        a = &begin
        b = &end;
      array_designator(&tok tok init@.ty a b);

      let tok2 = 0->@Token;
      for (let j int = begin; j <= end; j++)
        designation(&tok2 tok init@.children[j]);
      tok = tok2;
      i = end;
      continue;
    ;

    if i < init@.ty@.array_len initializer2(&tok tok init@.children[i]);
  ;
;

// array-initializer2 = initializer (""->@char initializer)*
array_initializer2(rest @@Token tok@ Token init@ Initializer i int)  =
  if init@.is_flexible {
    let len = count_array_init_elements(tok init@.ty);
    init@ = new_initializer(array_of(init@.ty@.base len) false)@;
  ;

  for (; i < init@.ty@.array_len && !equal(tok ";"->@char); i++) {
    let start = tok;

    if equal(tok "["->@char) || equal(tok "."->@char) {
      rest@ = start;
      return;
    ;

    initializer2(&tok tok init@.children[i]);
  ;
  rest@ = tok;
;

// struct-initializer1 = "{"->@char initializer (","->@char initializer)* ","->@char? ";"->@char
struct_initializer1(rest @@Token tok@ Token init@ Initializer)  =
  expect(&tok "{"->@char);

  let
    mem = init@.ty@.members;

  while !consume(rest tok ";"->@char) {
    if equal(tok "."->@char) {
      mem = struct_designator(&tok tok init@.ty);
      designation(&tok tok init@.children[mem@.idx]);
      mem = mem@.next;
      continue;
    ;

    if mem {
      initializer2(&tok tok init@.children[mem@.idx]);
      mem = mem@.next;;
  ;
;

// struct-initializer2 = initializer (","->@char initializer)*
struct_initializer2(rest @@Token tok@ Token init@ Initializer mem@ Member)  =
  for (; mem && !equal(tok ";"->@char); mem = mem@.next) {
    let start = tok;
    if equal(tok "["->@char) || equal(tok "."->@char) {
      rest@ = start;
      return;
    ;

    initializer2(&tok tok init@.children[mem@.idx]);
  ;
  rest@ = tok;
;

union_initializer(tok @@Token init@ Initializer)  =
  if equal(tok@ "{"->@char) && equal(tok@@.next "."->@char) {
    let mem = struct_designator(tok tok@@.next init@.ty);
    init@.mem = mem;
    designation(tok tok@ init@.children[mem@.idx]);
    return;
  ;

  init@.mem = init@.ty@.members;

  if equal(tok@ "{"->@char) {
    initializer2(tok tok@@.next init@.children[0]);
  ; else {
    initializer2(tok tok@ init@.children[0]);
  ;
;

initializer2(rest @@Token tok@ Token init@ Initializer)  =
  init@.expr = 0;
  if init@.ty@.kind == TY_ARRAY && tok@.kind == TK_STR string_initializer(rest tok init);
  else if init@.ty@.kind == TY_ARRAY {
    if equal(tok "{"->@char) array_initializer1(rest tok init);
    else array_initializer2(rest tok init 0);
  ; else if init@.ty@.kind == TY_STRUCT {
    if equal(tok "{"->@char) struct_initializer1(rest tok init);
    else {
      rest@ = tok;
      let e = prefix(rest);
      add_type(e);
      if e@.ty@.kind == TY_STRUCT {
        init@.expr = e;
      ; else struct_initializer2(rest tok init init@.ty@.members);
    ;
  ; else if init@.ty@.kind == TY_UNION {
    rest@ = tok;
    union_initializer(rest init);
  ; else if equal(tok "{"->@char) {
    initializer2(&tok tok@.next init);
    rest@ = skip(tok ";"->@char);
  ; else {
    rest@ = tok;
    init@.expr = assign(rest);
  ;
;

copy_struct_type(ty@ Type)@ Type =
  ty = copy_type(ty);

  let
    head = (let Member){;
    cur = &head;
  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    let m = calloc(1->unsigned long sizeof Member)->@ Member;
    m@ = mem@;
    cur = cur@.next = m;
  ;

  ty@.members = head.next;
  return ty;
;

initializer(rest @@Token tok@ Token ty@ Type new_ty @@Type)@ Initializer =
  let init = new_initializer(ty true);
  initializer2(rest tok init);

  if ((ty@.kind == TY_STRUCT || ty@.kind == TY_UNION) && ty@.is_flexible) {
    ty = copy_struct_type(ty);

    let mem = ty@.members;
    while mem@.next
      mem = mem@.next;
    mem@.ty = init@.children[mem@.idx]@.ty;
    ty@.size += mem@.ty->@Type@.size;

    new_ty@ = ty;
    return init;
  ;

  new_ty@ = init@.ty;
  return init;
;

init_desg_expr(desg@ InitDesg tok@ Token)@ Node =
  if desg@.var
    return new_var_node(desg@.var tok);

  if desg@.member {
    let node = new_prefix(ND_MEMBER->NodeKind init_desg_expr(desg@.next tok) tok);
    node@.member = desg@.member;
    return node;
  ;

  let lhs = init_desg_expr(desg@.next tok);
  let rhs = new_num(desg@.idx->long tok);
  return new_prefix(ND_DEREF->NodeKind new_add(lhs rhs tok) tok);
;

create_lvar_init(init@ Initializer ty@ Type desg@ InitDesg tok@ Token)@ Node =
  if ty@.kind == TY_ARRAY {
    let node = new_node(ND_NULL_EXPR->NodeKind tok);
    for (let i int = 0; i < ty@.array_len; i++) {
      let
        desg2 = (let InitDesg){desg i;
        c = &desg2
        rhs = create_lvar_init(init@.children[i] ty@.base c tok);
      node = new_binary(ND_COMMA->NodeKind node rhs tok);
    ;
    return node;
  ;

  if ty@.kind == TY_STRUCT && !init@.expr {
    let node = new_node(ND_NULL_EXPR->NodeKind tok);

    for (let mem @Member = ty@.members; mem; mem = mem@.next) {
      let
        desg2 = (let InitDesg){desg 0 mem;
        c = &desg2
        rhs = create_lvar_init(init@.children[mem@.idx] mem@.ty->@Type c tok);
      node = new_binary(ND_COMMA->NodeKind node rhs tok);
    ;
    return node;
  ;

  if ty@.kind == TY_UNION {
    let
      mem = init@.mem ? init@.mem : ty@.members
      desg2 = (let InitDesg){desg 0 mem;
      c = &desg2;
    return create_lvar_init(init@.children[mem@.idx] mem@.ty->@Type c tok);
  ;

  if !init@.expr
    return new_node(ND_NULL_EXPR->NodeKind tok);
  let lhs = init_desg_expr(desg tok);
  add_type(init@.expr);
  add_type(lhs);
  if !is_type_equal(lhs@.ty init@.expr@.ty) {
    s1[0] = 0; s2[0] = 0;
    format_type(init@.expr@.ty s1->@char);
    format_type(lhs@.ty s2->@char);
    error_tok(init@.expr@.tok "asymmetric init from %s to %s"->@char s1 s2);
  ;
  return new_binary(ND_ASSIGN->NodeKind lhs init@.expr tok);
;

// A variable definition with an initializer is a shorthand notation
// for a variable definition followed by assignments. This function
// generates assignment expressions for an initializer. For example,
// `x int[2][2] = {{6, 7;, {8, 9;;` is converted to the following
// expressions:
//
//   x[0][0] = 6;
//   x[0][1] = 7;
//   x[1][0] = 8;
//   x[1][1] = 9;
lvar_initializer(rest @@Token tok@ Token var@ Obj)@ Node =
  let
    d = &var@.ty
    init = initializer(rest tok var@.ty d)
    desg = (let InitDesg){ 0->@InitDesg 0 0->@Member var;

  // If a partial initializer list is given, the standard requires
  // that unspecified elements are set to 0. Here, we simply
  // zero-initialize the entire memory region of a variable before
  // initializing it with user-supplied values.
    lhs = new_node(ND_MEMZERO->NodeKind tok);
  lhs@.var = var;

  let c = &desg;
  let rhs = create_lvar_init(init var@.ty c tok);
  return new_binary(ND_COMMA->NodeKind lhs rhs tok);
;

read_buf(buf@ char sz int) unsigned long = 
  if sz == 1 return buf            @->unsigned long ;
  if sz == 2 return buf->@ uint16_t@->unsigned long ;
  if sz == 4 return buf->@ uint32_t@->unsigned long ;
  if sz == 8 return buf->@ uint64_t@                ;
  unreachable();
;

write_buf(buf@ char val uint64_t sz int) =
  if sz == 1 buf@             = val ; else
  if sz == 2 buf->@ uint16_t@ = val ; else
  if sz == 4 buf->@ uint32_t@ = val ; else
  if sz == 8 buf->@ uint64_t@ = val ; else
  unreachable();
;

write_gvar_data(cur@ Relocation init@ Initializer ty@ Type buf@ char offset int)@ Relocation =
  if ty@.kind == TY_ARRAY {
    let sz = ty@.base@.size;
    for (let i int = 0; i < ty@.array_len; i++)
      cur = write_gvar_data(cur init@.children[i] ty@.base buf offset + sz * i);
    return cur;
  ;

  if ty@.kind == TY_STRUCT {
    for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
      if mem@.is_bitfield {
        let expr = init@.children[mem@.idx]@.expr;
        if !expr
          break;

        let loc = buf + offset + mem@.offset;
        let oldval = read_buf(loc mem@.ty->@Type@.size);
        let newval = eval(expr);
        let mask = (1L << mem@.bit_width) - 1;
        let combined = oldval | ((newval & mask) << mem@.bit_offset);
        write_buf(loc combined mem@.ty->@Type@.size);
      ; else {
        cur = write_gvar_data(cur init@.children[mem@.idx] mem@.ty->@Type buf
                              offset + mem@.offset);
      ;
    ;
    return cur;
  ;

  if ty@.kind == TY_UNION {
    if !init@.mem
      return cur;
    return write_gvar_data(cur init@.children[init@.mem@.idx]
                           init@.mem@.ty->@Type buf offset);
  ;

  if !init@.expr
    return cur;

  if ty@.kind == TY_FLOAT {
    (buf + offset)->@ float@ = eval_double(init@.expr);
    return cur;
  ;

  if ty@.kind == TY_DOUBLE {
    (buf + offset)->@ double@ = eval_double(init@.expr);
    return cur;
  ;

  let label = 0->@@char;
  let b = &label;
  let val = eval2(init@.expr b);

  if !label {
    write_buf(buf + offset val->unsigned long ty@.size);
    return cur;
  ;

  let rel = calloc(1ul sizeof Relocation)->@Relocation;
  rel@.offset = offset;
  rel@.label = label;
  rel@.addend = val;
  cur@.next = rel;
  return cur@.next;
;

// Initializers for global variables are evaluated at compile-time and
// embedded to .data section. This function serializes Initializer
// objects to a flat byte array. It is a compile error if an
// initializer list contains a non-constant expression.
gvar_initializer(rest @@Token tok@ Token var@ Obj)  =
  let
    d = &var@.ty
    init = initializer(rest tok var@.ty d)
    head = (let Relocation){;
    buf = calloc(1->unsigned long var@.ty@.size->unsigned long)->@char;

  write_gvar_data(&head init var@.ty buf 0);
  var@.init_data = buf;
  var@.rel = head.next;
;

// asm-stmt = "asm"->@char ("volatile"->@char | "inline"->@char)* "("->@char string-literal ")"->@char
asm_stmt(rest @@Token tok@ Token)@ Node =
  let node = new_node(ND_ASM->NodeKind tok);
  tok = tok@.next;

  while equal(tok "volatile"->@char) || equal(tok "inline"->@char)
    tok = tok@.next;

  expect(&tok "("->@char);
  if tok@.kind != TK_STR || tok@.ty->@Type@.base@.kind != TY_CHAR
    error_tok(tok "expected string literal"->@char);
  node@.asm_str = tok@.str;
  rest@ = skip(tok@.next ")"->@char);
  return node;
;

stmt(tok @@Token)@ Node =
  if equal(tok@ "return"->@char) {
    let node = new_node(ND_RETURN->NodeKind tok@);
    tok@ = tok@@.next;
    if consume(tok tok@ ";"->@char) return node;
    let exp = assign(tok);
    expect(tok ";"->@char);
    add_type(exp);
    if !is_type_equal(current_fn@.ty@.return_ty exp@.ty) {
      s1[0] = 0; s2[0] = 0;
      format_type(exp@.ty s1->@char);
      format_type(current_fn@.ty@.return_ty s2->@char);
      error_tok(exp@.tok "asymmetric return from %s to %s"->@char s1 s2);
    ;
    node@.lhs = exp;
    return node;
  ;

  if equal(tok@ "if"->@char) {
    let node = new_node(ND_IF->NodeKind tok@);
    tok@ = tok@@.next;
    node@.cond = conditional(tok);
    node@.then = stmt(tok);
    if consume(tok tok@ "else"->@char) node@.els = stmt(tok);
    return node;
  ;

  if equal(tok@ "switch"->@char) {
    let node = new_node(ND_SWITCH->NodeKind tok@);
    tok@ = tok@@.next;
    node@.cond = conditional(tok);
    let sw = current_switch;
    current_switch = node;
    let brk = brk_label;
    brk_label = node@.brk_label = new_unique_name();
    node@.then = stmt(tok);
    current_switch = sw;
    brk_label = brk;
    return node;
  ;

  if equal(tok@ "case"->@char) {
    if !current_switch error_tok(tok@ "stray case"->@char);
    let node = new_node(ND_CASE->NodeKind tok@);
    tok@ = tok@@.next;
    let begin = const_expr(tok tok@);
    let end = begin;
    expect(tok ":"->@char);
    node@.label = new_unique_name();
    node@.lhs = stmt(tok);
    node@.begin = begin;
    node@.end = end;
    node@.case_next = current_switch@.case_next;
    current_switch@.case_next = node;
    return node;
  ;

  if equal(tok@ "default"->@char) {
    if !current_switch error_tok(tok@ "stray default"->@char);
    let node = new_node(ND_CASE->NodeKind tok@);
    tok@ = tok@@.next;
    expect(tok ":"->@char);
    node@.label = new_unique_name();
    node@.lhs = stmt(tok);
    current_switch@.default_case = node;
    return node;
  ;

  if equal(tok@ "for"->@char) {
    let node = new_node(ND_FOR->NodeKind tok@);
    tok@ = tok@@.next;
    expect(tok "("->@char);
    enter_scope();
    let brk = brk_label;
    let cont = cont_label;
    brk_label = node@.brk_label = new_unique_name();
    cont_label = node@.cont_label = new_unique_name();
    if consume(tok tok@ "let"->@char) {
      declspec(tok 0->@VarAttr);
      node@.init = declaration(tok 0->@VarAttr);
    ;
    else node@.init = expr_stmt(tok);
    if !equal(tok@ ";"->@char) node@.cond = assign(tok); expect(tok ";"->@char);
    if !equal(tok@ ")"->@char) node@.inc = assign(tok); expect(tok ")"->@char);
    node@.then = stmt(tok);
    leave_scope();
    brk_label = brk;
    cont_label = cont;
    return node;
  ;

  if equal(tok@ "while"->@char) {
    let node = new_node(ND_FOR->NodeKind tok@);
    tok@ = tok@@.next;
    node@.cond = conditional(tok);
    let brk = brk_label;
    let cont = cont_label;
    brk_label = node@.brk_label = new_unique_name();
    cont_label = node@.cont_label = new_unique_name();
    node@.then = stmt(tok);
    brk_label = brk;
    cont_label = cont;
    return node;
  ;

  if equal(tok@ "do"->@char) {
    let node = new_node(ND_DO->NodeKind tok@);
    let brk = brk_label;
    let cont = cont_label;
    brk_label = node@.brk_label = new_unique_name();
    cont_label = node@.cont_label = new_unique_name();
    tok@ = tok@@.next;
    node@.then = stmt(tok);
    brk_label = brk;
    cont_label = cont;
    expect(tok "while"->@char);
    node@.cond = conditional(tok);
    tok@ = skip(tok@ ";"->@char);
    return node;
  ;

  if equal(tok@ "asm"->@char)
    return asm_stmt(tok tok@);

  if equal(tok@ "break"->@char) {
    if !brk_label error_tok(tok@ "stray break"->@char);
    let node = new_node(ND_GOTO->NodeKind tok@);
    node@.unique_label = brk_label;
    tok@ = tok@@.next;
    tok@ = skip(tok@ ";"->@char);
    return node;
  ;

  if equal(tok@ "continue"->@char) {
    if !cont_label error_tok(tok@ "stray continue"->@char);
    let node = new_node(ND_GOTO->NodeKind tok@);
    node@.unique_label = cont_label;
    tok@ = tok@@.next;
    tok@ = skip(tok@ ";"->@char);
    return node;
  ;

  if equal(tok@ "{"->@char) {
    tok@ = tok@@.next;
    return compound_stmt(tok);
  ;

  return expr_stmt(tok);
;

decl_stmt(rest @@Token) @Node =
  let
    tok = rest@
    head = (let Node){;
    cur = &head;
  while !equal(tok ";"->@char) {
    if equal(tok@.next "="->@char) {
      if tok@.kind != TK_IDENT || equal(tok "_"->@char) error_tok(tok "expected identifer"->@char);
      let name = tok;
      tok = tok@.next@.next;
      let e = assign(&tok);
      add_type(e);
      if e@.ty@.kind == TY_VOID error_tok(tok "variable declared void"->@char);
      let var = new_lvar(get_ident(name) e@.ty);
      cur = cur@.next = new_prefix(ND_EXPR_STMT->NodeKind new_binary(ND_ASSIGN->NodeKind new_var_node(var tok) e tok) tok);
      continue;
    ;
    //warn_tok(tok "deprecated initializer"->@char);
    let ty = declarator(&tok);
    if ty@.kind == TY_VOID error_tok(tok "variable declared void"->@char);
    if !ty@.name error_tok(ty@.name_pos "variable name omitted"->@char);
    if equal(ty@.name "_"->@char) continue;

    let var = new_lvar(get_ident(ty@.name) ty);

    if equal(tok "="->@char) {
      let expr = lvar_initializer(&tok tok@.next var);
      cur = cur@.next = new_prefix(ND_EXPR_STMT->NodeKind expr tok);
    ;

    if var@.ty@.size < 0
      error_tok(ty@.name "variable has incomplete type"->@char);
    if var@.ty@.kind == TY_VOID
      error_tok(ty@.name "variable declared void"->@char);
  ;

  let node = new_node(ND_BLOCK->NodeKind tok);
  node@.body = head.next;
  rest@ = tok@.next;
  return node;
;

compound_stmt(rest @@Token) @Node =
  let tok = rest@;
  let
    node = new_node(ND_BLOCK->NodeKind tok)
    head = (let Node){;
    cur = &head;

  enter_scope();

  while (!equal(tok ";"->@char)) {
    cur = cur@.next = (consume(&tok tok "let"->@char) ? decl_stmt : stmt)(&tok);
    add_type(cur);
  ;

  leave_scope();

  node@.body = head.next;
  rest@ = tok@.next;
  return node;
;

expr_stmt(tok @@Token)@ Node =
  if equal(tok@ ";"->@char) {
    let node = new_node(ND_BLOCK->NodeKind tok@);
    tok@ = tok@@.next;
    return node;
  ;

  let node = new_node(ND_EXPR_STMT->NodeKind tok@);
  node@.lhs = assign(tok);
  expect(tok ";"->@char);
  return node;
;

eval(node@ Node) int64_t = return
  eval2(node 0->@@@char);
;

// Evaluate a given node as a constant expression.
//
// A constant expression is either just a number or ptr+n where ptr
// is a pointer to a global variable and n is a postiive/negative
// number. The latter form is accepted only as an initialization
// expression for a global variable.
eval2(node@ Node label @@@char) int64_t =
  add_type(node);

  if is_flonum(node@.ty)
    return eval_double(node)->long;

  switch (node@.kind) {
  case ND_ADD->NodeKind:
    return eval2(node@.lhs label) + eval(node@.rhs);
  case ND_SUB->NodeKind:
    return eval2(node@.lhs label) - eval(node@.rhs);
  case ND_MUL->NodeKind:
    return eval(node@.lhs) * eval(node@.rhs);
  case ND_DIV->NodeKind:
    if node@.ty@.is_unsigned
      return (eval(node@.lhs)->uint64_t / eval(node@.rhs)->uint64_t)->long;
    return eval(node@.lhs) / eval(node@.rhs);
  case ND_NEG->NodeKind:
    return -eval(node@.lhs);
  case ND_MOD->NodeKind:
    if node@.ty@.is_unsigned
      return (eval(node@.lhs)->uint64_t % eval(node@.rhs)->uint64_t)->long;
    return eval(node@.lhs) % eval(node@.rhs);
  case ND_BITAND->NodeKind:
    return eval(node@.lhs) & eval(node@.rhs);
  case ND_BITOR->NodeKind:
    return eval(node@.lhs) | eval(node@.rhs);
  case ND_BITXOR->NodeKind:
    return eval(node@.lhs) ^ eval(node@.rhs);
  case ND_SHL->NodeKind:
    return eval(node@.lhs) << eval(node@.rhs);
  case ND_SHR->NodeKind:
    if node@.ty@.is_unsigned && node@.ty@.size == 8
      return (eval(node@.lhs)->uint64_t >> eval(node@.rhs)->uint64_t)->long;
    return eval(node@.lhs) >> eval(node@.rhs);
  case ND_EQ->NodeKind:
    return (eval(node@.lhs) == eval(node@.rhs))->long;
  case ND_NE->NodeKind:
    return (eval(node@.lhs) != eval(node@.rhs))->long;
  case ND_LT->NodeKind:
    if node@.lhs@.ty@.is_unsigned
      return (eval(node@.lhs)->uint64_t < eval(node@.rhs))->long;
    return (eval(node@.lhs) < eval(node@.rhs))->long;
  case ND_LE->NodeKind:
    if node@.lhs@.ty@.is_unsigned
      return (eval(node@.lhs)->uint64_t <= eval(node@.rhs))->long;
    return (eval(node@.lhs) <= eval(node@.rhs))->long;
  case ND_GT->NodeKind:
    if node@.lhs@.ty@.is_unsigned
      return (eval(node@.lhs)->uint64_t > eval(node@.rhs))->long;
    return (eval(node@.lhs) > eval(node@.rhs))->long;
  case ND_GE->NodeKind:
    if node@.lhs@.ty@.is_unsigned
      return (eval(node@.lhs)->uint64_t >= eval(node@.rhs))->long;
    return (eval(node@.lhs) >= eval(node@.rhs))->long;
  case ND_COND->NodeKind:
    return eval(node@.cond) ? eval2(node@.then label) : eval2(node@.els label);
  case ND_NOT->NodeKind:
    return (!eval(node@.lhs))->long;
  case ND_BITNOT->NodeKind:
    return ~eval(node@.lhs);
  case ND_LOGAND->NodeKind:
    return eval(node@.lhs) && eval(node@.rhs);
  case ND_LOGOR->NodeKind:
    return eval(node@.lhs) || eval(node@.rhs);
  case ND_CAST->NodeKind: {
    let val = eval2(node@.lhs label);
    if is_integer(node@.ty) {
      switch (node@.ty@.size) {
      case 1: return (node@.ty@.is_unsigned ? val->uint8_t : val->int8_t)->long;
      case 2: return (node@.ty@.is_unsigned ? val->uint16_t : val->int16_t)->long;
      case 4: return (node@.ty@.is_unsigned ? val->uint32_t : val->int32_t)->long;
      ;
    ;
    return val;
  ;
  case ND_ADDR->NodeKind:
    return eval_rval(node@.lhs label);
  case ND_LABEL_VAL->NodeKind:
    label@ = &node@.unique_label;
    return 0->long;
  case ND_MEMBER->NodeKind:
    if !label
      error_tok(node@.tok "not a compile-time constant"->@char);
    if node@.ty@.kind != TY_ARRAY
      error_tok(node@.tok "invalid initializer"->@char);
    return eval_rval(node@.lhs label) + node@.member@.offset;
  case ND_VAR->NodeKind:
    if !label
      error_tok(node@.tok "not a compile-time constant"->@char);
    if node@.var@.ty@.kind != TY_ARRAY && node@.var@.ty@.kind != TY_FUNC
      error_tok(node@.tok "invalid initializer"->@char);
    label@ = &node@.var@.name;
    return 0->long;
  case ND_NUM->NodeKind:
    return node@.val;
  ;

  error_tok(node@.tok "not a compile-time constant"->@char);
;

eval_rval(node@ Node label @@@char) int64_t =
  switch (node@.kind) {
  case ND_VAR->NodeKind:
    if node@.var@.is_local
      error_tok(node@.tok "not a compile-time constant"->@char);
    label@ = &node@.var@.name;
    return 0->long;
  case ND_DEREF->NodeKind:
    return eval2(node@.lhs label);
  case ND_MEMBER->NodeKind:
    return eval_rval(node@.lhs label) + node@.member@.offset;
  ;

  error_tok(node@.tok "invalid initializer"->@char);
;

is_const_expr(node@ Node) bool =
  add_type(node);

  switch (node@.kind) {
  case ND_ADD->NodeKind:
  case ND_SUB->NodeKind:
  case ND_MUL->NodeKind:
  case ND_DIV->NodeKind:
  case ND_BITAND->NodeKind:
  case ND_BITOR->NodeKind:
  case ND_BITXOR->NodeKind:
  case ND_SHL->NodeKind:
  case ND_SHR->NodeKind:
  case ND_EQ->NodeKind:
  case ND_NE->NodeKind:
  case ND_LT->NodeKind:
  case ND_LE->NodeKind:
  case ND_GT->NodeKind:
  case ND_GE->NodeKind:
  case ND_LOGAND->NodeKind:
  case ND_LOGOR->NodeKind:
    return (is_const_expr(node@.lhs) && is_const_expr(node@.rhs))->bool;
  case ND_COND->NodeKind:
    if !is_const_expr(node@.cond)
      return false;
    return is_const_expr(eval(node@.cond) ? node@.then : node@.els);
  case ND_COMMA->NodeKind:
    return false;
  case ND_NEG->NodeKind:
  case ND_NOT->NodeKind:
  case ND_BITNOT->NodeKind:
  case ND_CAST->NodeKind:
    return is_const_expr(node@.lhs);
  case ND_NUM->NodeKind:
    return true;
  ;

  return false;
;

export const_expr(rest@@ Token tok@ Token) int64_t  =
  rest@ = tok;
  let node = conditional(rest);
  return eval(node);
;

eval_double(node@ Node) double =
  add_type(node);

  if is_integer(node@.ty) {
    if node@.ty@.is_unsigned
      return eval(node)->double;
    return eval(node)->double;
  ;

  switch (node@.kind) {
  case ND_ADD->NodeKind:
    return eval_double(node@.lhs) + eval_double(node@.rhs);
  case ND_SUB->NodeKind:
    return eval_double(node@.lhs) - eval_double(node@.rhs);
  case ND_MUL->NodeKind:
    return eval_double(node@.lhs) * eval_double(node@.rhs);
  case ND_DIV->NodeKind:
    return eval_double(node@.lhs) / eval_double(node@.rhs);
  case ND_NEG->NodeKind:
    return -eval_double(node@.lhs);
  case ND_COND->NodeKind:
    return eval_double(node@.cond) ? eval_double(node@.then) : eval_double(node@.els);
  case ND_CAST->NodeKind:
    if is_flonum(node@.lhs@.ty)
      return eval_double(node@.lhs);
    return eval(node@.lhs)->double;
  case ND_NUM->NodeKind:
    return node@.fval->double;
  ;

  error_tok(node@.tok "not a compile-time constant"->@char);
;

id_node(node@ Node)@ Node = return node; ;
to_assign(e@ Node)@ Node = return new_binary( ND_ASSIGN->NodeKind e@.lhs e e@.tok); ;

s1 [1024]char s2 [1024]char;
assign(tok @@Token)@ Node =
  let lhs = conditional(tok);
  let k =
    equal(tok@ "="  ->@char) ? ND_ASSIGN->NodeKind :
    equal(tok@ "+=" ->@char) ? ND_ADD->NodeKind    :
    equal(tok@ "-=" ->@char) ? ND_SUB->NodeKind    :
    equal(tok@ "*=" ->@char) ? ND_MUL->NodeKind    :
    equal(tok@ "/=" ->@char) ? ND_DIV->NodeKind    :
    equal(tok@ "%=" ->@char) ? ND_MOD->NodeKind    :
    equal(tok@ "&=" ->@char) ? ND_BITAND->NodeKind :
    equal(tok@ "|=" ->@char) ? ND_BITOR->NodeKind  :
    equal(tok@ "^=" ->@char) ? ND_BITXOR->NodeKind :
    equal(tok@ "<<="->@char) ? ND_SHL->NodeKind    :
    equal(tok@ ">>="->@char) ? ND_SHR->NodeKind    :
                               0         ;
  if !k return lhs;
  let e = new_node(k tok@);
  tok@ = tok@@.next;
  e@.lhs = lhs;
  let f = e;
  if k != ND_ASSIGN->NodeKind {
    e = new_node(ND_ASSIGN->NodeKind tok@);
    e@.lhs = lhs;
    e@.rhs = f;
  ;
  f@.rhs = assign(tok);
  add_type(f);
  if !is_type_equal(f@.lhs@.ty f@.rhs@.ty) {
    s1[0] = 0; s2[0] = 0;
    format_type(f@.lhs@.ty s1->@char);
    format_type(f@.rhs@.ty s2->@char);
    error_tok(tok@ "asymmetric assignment from %s to %s"->@char s1 s2);
  ;
  return e;
;

type StrNodeKind struct { s@ char k NodeKind ;};;

ab(tok@@ Token n int next@(tok@@ Token)@ Node a@ StrNodeKind lhs@@ Node) bool =
  for (let i int = 0; i < n; ++i) {
    if equal(tok@ a[i].s) {
      let e = new_node(a[i].k tok@);
      tok@ = tok@@.next;
      e@.lhs = lhs@;
      e@.rhs = next(tok);
      lhs@ = e;
      return true;
    ;
  ;
  return false;
;

left_binary(tok@@ Token n int next@(tok@@ Token)@ Node a@ StrNodeKind)@ Node =
  let lhs = next(tok);
  let e = &lhs;
  while ab(tok n next a e);
  return lhs;
;

comma     (l@@ Token)@ Node = let d []StrNodeKind = { {  ","->@char ND_COMMA->NodeKind  ;                                                                                                   ;; return left_binary(l 1 prefix      ->@(k@@Token)@Node d->@StrNodeKind);;
mul       (l@@ Token)@ Node = let d []StrNodeKind = { {  "*"->@char ND_MUL->NodeKind    ; { "/" ->@char ND_DIV->NodeKind ; { "%"->@char  ND_MOD->NodeKind ;                                 ;; return left_binary(l 3 comma     ->@(k@@Token)@Node d->@StrNodeKind);;
shift     (l@@ Token)@ Node = let d []StrNodeKind = { { "<<"->@char ND_SHL->NodeKind    ; { ">>"->@char ND_SHR->NodeKind ;                                                                  ;; return left_binary(l 2 add       ->@(k@@Token)@Node d->@StrNodeKind);;
relational(l@@ Token)@ Node = let d []StrNodeKind = { {  "<"->@char ND_LT->NodeKind     ; { ">" ->@char ND_GT->NodeKind  ; { "<="->@char ND_LE->NodeKind  ; { ">="->@char ND_GE->NodeKind ; ;; return left_binary(l 4 shift     ->@(k@@Token)@Node d->@StrNodeKind);;
equality  (l@@ Token)@ Node = let d []StrNodeKind = { { "=="->@char ND_EQ->NodeKind     ; { "!="->@char ND_NE->NodeKind  ;                                                                  ;; return left_binary(l 2 relational->@(k@@Token)@Node d->@StrNodeKind);;
bitand    (l@@ Token)@ Node = let d []StrNodeKind = { {  "&"->@char ND_BITAND->NodeKind ;                                                                                                   ;; return left_binary(l 1 equality  ->@(k@@Token)@Node d->@StrNodeKind);;
bitxor    (l@@ Token)@ Node = let d []StrNodeKind = { {  "^"->@char ND_BITXOR->NodeKind ;                                                                                                   ;; return left_binary(l 1 bitand    ->@(k@@Token)@Node d->@StrNodeKind);;
bitor     (l@@ Token)@ Node = let d []StrNodeKind = { {  "|"->@char ND_BITOR->NodeKind  ;                                                                                                   ;; return left_binary(l 1 bitxor    ->@(k@@Token)@Node d->@StrNodeKind);;
logand    (l@@ Token)@ Node = let d []StrNodeKind = { { "&&"->@char ND_LOGAND->NodeKind ;                                                                                                   ;; return left_binary(l 1 bitor     ->@(k@@Token)@Node d->@StrNodeKind);;
logor     (l@@ Token)@ Node = let d []StrNodeKind = { { "||"->@char ND_LOGOR->NodeKind  ;                                                                                                   ;; return left_binary(l 1 logand    ->@(k@@Token)@Node d->@StrNodeKind);;

// conditional = logor ("?" expr? ":" conditional)?
conditional(rest @@Token)@ Node =
  let tok = rest@;
  let cond = logor(&tok);

  if !equal(tok "?"->@char) {
    rest@ = tok;
    return cond;
  ;

  let node = new_node(ND_COND->NodeKind tok);
  node@.cond = cond;
  tok = tok@.next;
  node@.then = assign(&tok);
  expect(&tok ":"->@char);
  rest@ = tok;
  node@.els = conditional(rest);
  return node;
;

// In C, `+` operator is overloaded to perform the pointer arithmetic.
// If p is a pointer, p+n adds not n but sizeof(p@)n@ to the value of p,
// so that p+n points to the location n elements (not bytes) ahead of p.
// In other words, we need to scale an integer value before adding to a
// pointer value. This function takes care of the scaling.
new_add(lhs@ Node rhs@ Node tok@ Token)@ Node =
  add_type(lhs);
  add_type(rhs);

  // num + num
  if is_numeric(lhs@.ty) && is_numeric(rhs@.ty)
    return new_binary(ND_ADD->NodeKind lhs rhs tok);

  if lhs@.ty@.base && rhs@.ty@.base
    error_tok(tok "invalid operands"->@char);

  // Canonicalize `num + ptr` to `ptr + num`.
  if !lhs@.ty@.base && rhs@.ty@.base {
    let tmp = lhs;
    lhs = rhs;
    rhs = tmp;
  ;

  // ptr + num
  rhs = new_binary(ND_MUL->NodeKind rhs new_long(lhs@.ty@.base@.size->long tok) tok);
  return new_binary(ND_ADD->NodeKind lhs rhs tok);
;

// Like `+`, `-` is overloaded for the pointer type.
new_sub(lhs@ Node rhs@ Node tok@ Token)@ Node =
  add_type(lhs);
  add_type(rhs);

  // num - num
  if is_numeric(lhs@.ty) && is_numeric(rhs@.ty)
    return new_binary(ND_SUB->NodeKind lhs rhs tok);

  // ptr - num
  if lhs@.ty@.base && is_integer(rhs@.ty) {
    rhs = new_binary(ND_MUL->NodeKind rhs new_long(lhs@.ty@.base@.size->long tok) tok);
    add_type(rhs);
    let node = new_binary(ND_SUB->NodeKind lhs rhs tok);
    node@.ty = lhs@.ty;
    return node;
  ;

  // ptr - ptr, which returns how many elements are between the two.
  if lhs@.ty@.base && rhs@.ty@.base {
    let node = new_binary(ND_SUB->NodeKind lhs rhs tok);
    node@.ty = ty_long;
    return new_binary(ND_DIV->NodeKind node new_num(lhs@.ty@.base@.size->long tok) tok);
  ;

  error_tok(tok "invalid operands"->@char);
;

add(rest @@Token)@ Node =
  let tok = rest@;
  let node = mul(&tok);

  for (;;) {
    let start = tok;

    if equal(tok "+"->@char) {
      tok = tok@.next;
      node = new_add(node mul(&tok) start);
      continue;
    ;

    if equal(tok "-"->@char) {
      tok = tok@.next;
      node = new_sub(node mul(&tok) start);
      continue;
    ;

    rest@ = tok;
    return node;
  ;
;

prefix(rest @@Token)@ Node =
  let tok = rest@;
  if equal(tok "+"->@char) {
    rest@ = tok@.next;
    return prefix(rest);
  ;

  if equal(tok "-"->@char) {
    rest@ = tok@.next;
    return new_prefix(ND_NEG->NodeKind prefix(rest) tok);
  ;

  if equal(tok "&"->@char) {
    rest@ = tok@.next;
    let lhs = prefix(rest);
    add_type(lhs);
    if lhs@.kind == ND_MEMBER->NodeKind && lhs@.member@.is_bitfield
      error_tok(tok "cannot take address of bitfield"->@char);
    return new_prefix(ND_ADDR->NodeKind lhs tok);
  ;

  if equal(tok "!"->@char) {
    rest@ = tok@.next;
    return new_prefix(ND_NOT->NodeKind prefix(rest) tok);
  ;

  if equal(tok "~"->@char) {
    rest@ = tok@.next;
    return new_prefix(ND_BITNOT->NodeKind prefix(rest) tok);
  ;

  // Read ++i as i+=1
  if equal(tok "++"->@char) {
    rest@ = tok@.next;
    return to_assign(new_add(prefix(rest) new_num(1->long tok) tok));
  ;

  // Read --i as i-=1
  if equal(tok "--"->@char) {
    rest@ = tok@.next;
    return to_assign(new_sub(prefix(rest) new_num(1->long tok) tok));
  ;

  rest@ = tok;
  return postfix(rest);
;

struct_members(rest @@Token tok@ Token ty@ Type)  =
  let
    head = (let Member){;
    cur = &head
    idx = 0;

  while !equal(tok "}"->@char) {
    let attr = (let VarAttr){;;
    let c = &attr;
    declspec(&tok c);
    // Regular struct members
    while !consume(&tok tok ";"->@char) {
      let mem = calloc(1->unsigned long sizeof Member)->@Member;
      mem@.ty = declarator(&tok);
      mem@.name = mem@.ty->@Type@.name;
      mem@.idx = idx++;
      mem@.alignment = attr.alignment ? attr.alignment : mem@.ty->@Type@.alignment;

      if consume(&tok tok ":"->@char) {
        mem@.is_bitfield = true;
        mem@.bit_width = const_expr(&tok tok);
      ;

      cur = cur@.next = mem;
    ;
  ;

  // If the last element is an array of incomplete type, it's
  // called a "flexible array member"->@char. It should behave as if
  // if were a zero-sized array.
  if cur != &head && cur@.ty->@Type@.kind == TY_ARRAY && cur@.ty->@Type@.array_len < 0 {
    cur@.ty = array_of(cur@.ty->@Type@.base 0);
    ty@.is_flexible = true;
  ;

  rest@ = tok@.next;
  ty@.members = head.next;
;

// attribute = ("__attribute__"->@char "(" "->@char(" "->@charpacked" "->@char)" "->@char)")*
attribute_list(tok@ Token ty@ Type)@ Token =
  while consume(&tok tok "__attribute__"->@char) {
    expect(&tok "("->@char);
    expect(&tok "("->@char);

    while !consume(&tok tok ")"->@char) {
      if consume(&tok tok "packed"->@char) {
        ty@.is_packed = true;
        continue;
      ;

      if consume(&tok tok "aligned"->@char) {
        expect(&tok "("->@char);
        ty@.alignment = const_expr(&tok tok);
        expect(&tok ")"->@char);
        continue;
      ;

      error_tok(tok "unknown attribute"->@char);
    ;

    expect(&tok ")"->@char);
  ;

  return tok;
;

struct_union_decl(rest @@Token) @Type =
  let tok = rest@;
  let ty = struct_type();
  tok = attribute_list(tok ty);

  // Read a tag.
  let tag = 0->@Token;
  if tok@.kind == TK_IDENT {
    tag = tok;
    tok = tok@.next;
  ;

  if tag && !equal(tok "{"->@char) {
    rest@ = tok;

    let ty2 = search_scope(tag scope_tags->@(sc@Scope)@HashMap);
    if ty2
      return ty2->@Type;

    ty@.size = -1;
    push_tag_scope(tag ty);
    return ty;
  ;

  expect(&tok "{"->@char);
  current_type = ty;

  // Construct a struct object.
  struct_members(&tok tok ty);
  rest@ = attribute_list(tok ty);

  current_type = 0;
  if tag {
    // If this is a redefinition, overwrite a previous type.
    // Otherwise, register the struct type.
    let ty2 = hashmap_get2(&scope@.tags tag@.loc tag@.len)->@Type;
    if ty2 {
      ty2@ = ty@;
      return ty2;
    ;

    push_tag_scope(tag ty);
  ;

  return ty;
;

struct_decl(rest @@Token)@ Type =
  let ty = struct_union_decl(rest);
  ty@.kind = TY_STRUCT;

  if ty@.size < 0
    return ty;

  // Assign offsets within the struct to members.
  let bits = 0;

  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    if mem@.is_bitfield && mem@.bit_width == 0 {
      // Zero-width anonymous bitfield has a special meaning.
      // It affects only alignment.
      bits = align_to(bits mem@.ty->@Type@.size * 8);
    ; else if mem@.is_bitfield {
      let sz = mem@.ty->@Type@.size;
      if bits / (sz * 8) != (bits + mem@.bit_width - 1) / (sz * 8)
        bits = align_to(bits sz * 8);

      mem@.offset = align_down(bits / 8 sz);
      mem@.bit_offset = bits % (sz * 8);
      bits += mem@.bit_width;
    ; else {
      if !ty@.is_packed
        bits = align_to(bits mem@.alignment * 8);
      mem@.offset = bits / 8;
      bits += mem@.ty->@Type@.size * 8;
    ;

    if !ty@.is_packed && ty@.alignment < mem@.alignment
      ty@.alignment = mem@.alignment;
  ;

  ty@.size = align_to(bits ty@.alignment * 8) / 8;
  return ty;
;

// union-decl = struct-union-decl
union_decl(rest @@Token)@ Type =
  let ty = struct_union_decl(rest);
  ty@.kind = TY_UNION;

  if ty@.size < 0
    return ty;

  // If union, we don't have to assign offsets because they
  // are already initialized to zero. We need to compute the
  // alignment and the size though.
  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    if ty@.alignment < mem@.alignment
      ty@.alignment = mem@.alignment;
    if ty@.size < mem@.ty->@Type@.size
      ty@.size = mem@.ty->@Type@.size;
  ;
  ty@.size = align_to(ty@.size ty@.alignment);
  return ty;
;

// Find a struct member by name.
get_struct_member(ty@ Type tok@ Token)@ Member =
  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    // Anonymous struct member
    if ((mem@.ty->@Type@.kind == TY_STRUCT || mem@.ty->@Type@.kind == TY_UNION) &&
        (!mem@.name || equal(mem@.name "_"->@char))) {
      if get_struct_member(mem@.ty->@Type tok)
        return mem;
      continue;
    ;

    // Regular struct member
    if mem@.name@.len == tok@.len &&
        !strncmp(mem@.name@.loc->@ tok@.loc tok@.len->unsigned long)
      return mem;
  ;
  return 0->@Member;
;

// Create a node representing a struct member access, such as foo.bar
// where foo is a struct and bar is a member name.
//
// C has a feature called "anonymous struct"->@char which allows a struct to
// have another unnamed struct as a member like this:
//
//   struct { struct { a int; ;; b int; ; x;
//
// The members of an anonymous struct beto long the outer struct's
// member namespace. Therefore, in the above example, you can access
// member "a"->@char of the anonymous struct as "x.a"->@char.
//
// This function takes care of anonymous structs.
struct_ref(node@ Node tok@ Token)@ Node =
  add_type(node);
  if node@.ty@.kind != TY_STRUCT && node@.ty@.kind != TY_UNION
    error_tok(node@.tok "not a struct nor a union"->@char);

  let ty = node@.ty;

  for (;;) {
    let mem = get_struct_member(ty tok);
    if !mem
      error_tok(tok "no such member"->@char);
    node = new_prefix(ND_MEMBER->NodeKind node tok);
    node@.member = mem;
    if mem@.name
      break;
    ty = mem@.ty;
  ;
  return node;
;

// Convert A++ to `(typeof A)((A += 1) - 1)`
new_inc_dec(node@ Node tok@ Token addend int)@ Node =
  add_type(node);
  let a = -addend;
  let e = new_add(to_assign(new_add(node new_num(addend->long tok) tok)) new_num(a->long tok) tok);
  add_type(e);
  return is_type_equal(node@.ty e@.ty)
    ? e
    : new_cast(e node@.ty);
;

postfix(rest @@Token)@ Node =
  let tok = rest@;
  let start = tok;

  if equal(tok "("->@char) && equal(tok@.next "let"->@char) {
    tok = tok@.next@.next;
    let ty = type_suffix(&tok);
    expect(&tok ")"->@char);

    if !scope@.next {
      let var = new_anon_gvar(ty);
      gvar_initializer(rest tok var);
      return new_var_node(var start);
    ;

    let var = new_lvar(""->@char ty);
    let lhs = lvar_initializer(rest tok var);
    let rhs = new_var_node(var tok);
    return new_binary(ND_COMMA->NodeKind lhs rhs start);
  ;

  let node = primary(&tok);

  for (;;) {
    if equal(tok "("->@char) {
      tok = tok@.next;
      node = funcall(&tok node);
      continue;
    ;

    if equal(tok "["->@char) {
      let start = tok;
      tok = tok@.next;
      let idx = assign(&tok);
      expect(&tok "]"->@char);
      node = new_prefix(ND_DEREF->NodeKind new_add(node idx start) start);
      continue;
    ;

    if equal(tok "."->@char) {
      node = struct_ref(node tok@.next);
      tok = tok@.next@.next;
      continue;
    ;

    if equal(tok "@"->@char) {
      node = new_prefix(ND_DEREF->NodeKind node tok);
      tok = tok@.next;
      continue;
    ;

    if equal(tok "->"->@char) {
      tok = tok@.next;
      let ty = type_suffix(&tok);
      node = new_cast(node ty);
      continue;
    ;

    if equal(tok "++"->@char) {
      node = new_inc_dec(node tok 1);
      tok = tok@.next;
      continue;
    ;

    if equal(tok "--"->@char) {
      node = new_inc_dec(node tok 0-1);
      tok = tok@.next;
      continue;
    ;

    rest@ = tok;
    return node;
  ;
;

funcall(rest @@Token fn@ Node)@ Node =
  add_type(fn);
  let tok = rest@;

  if fn@.ty@.kind != TY_FUNC &&
      !(fn@.ty@.kind == TY_PTR && fn@.ty@.base@.kind == TY_FUNC)
    error_tok(fn@.tok "not a function"->@char);

  let ty = (fn@.ty@.kind == TY_FUNC) ? fn@.ty : fn@.ty@.base;
  let param_ty = ty@.params;

  let
    head = (let Node){;
    cur = &head;

  while !equal(tok ")"->@char) {
    let start = tok;
    let arg = conditional(&tok);
    add_type(arg);

    if !param_ty && !ty@.is_variadic
      error_tok(tok "too many arguments"->@char);

    if param_ty {
      if !is_type_equal(arg@.ty param_ty) {
        s1[0] = 0; s2[0] = 0;
        format_type(arg@.ty s1->@char);
        format_type(param_ty s2->@char);
        error_tok(start "asymmetric argument from %s to %s"->@char s1 s2);
      ;
      param_ty = param_ty@.next;
    ;

    cur = cur@.next = arg;
  ;

  if param_ty error_tok(tok "too few arguments"->@char);

  rest@ = skip(tok ")"->@char);

  let node = new_prefix(ND_FUNCALL->NodeKind fn tok);
  node@.func_ty = ty;
  node@.ty = ty@.return_ty;
  node@.args = head.next;

  // If a function returns a struct, it is caller's responsibility
  // to allocate a space for the return value.
  if node@.ty@.kind == TY_STRUCT || node@.ty@.kind == TY_UNION
    node@.ret_buffer = new_lvar(""->@char node@.ty);
  return node;
;

primary(k @@Token)@ Node =
  if equal(k@ "("->@char) { // ambiguity: looked ahead to by preceding expressions for function calls
    k@ = k@@.next;
    let node = assign(k); // may or may not lookahead to ')'
    expect(k ")"->@char);
    return node;
  ;

  if equal(k@ "sizeof" ->@char) { k@ = k@@.next; return new_ulong(type_suffix(k)@.size     ->long k@);;
  if equal(k@ "alignof"->@char) { k@ = k@@.next; return new_ulong(type_suffix(k)@.alignment->long k@);;
  if equal(k@ "true"   ->@char) { k@ = k@@.next; return new_bool(1l k@);;
  if equal(k@ "false"  ->@char) { k@ = k@@.next; return new_bool(0l k@);;

  if k@@.kind == TK_IDENT {
    let sc = search_scope(k@ scope_vars->@(sc@Scope)@HashMap)->@VarScope;
    k@ = k@@.next;

    // For "static inline"->@char function
    if sc && sc@.var && sc@.var@.is_function {
      if current_fn
        strarray_push(&current_fn@.refs sc@.var@.name);
      else
        sc@.var@.is_root = true;
    ;

    if sc {
      if sc@.var
        return new_var_node(sc@.var k@);
      if sc@.enum_ty
        return new_num(sc@.enum_val->long k@);
    ;

    if equal(k@@.next "("->@char)
      error_tok(k@ "implicit declaration of a function"->@char);
    error_tok(k@ "undefined variable"->@char);
  ;

  if k@@.kind == TK_STR {
    let e = new_var_node(new_string_literal(k@@.str k@@.ty->@Type) k@);
    k@ = k@@.next;
    return e;
  ;

  if k@@.kind == TK_NUM {
    let node = 0->@Node;
    if is_flonum(k@@.ty->@Type) {
      node = new_node(ND_NUM->NodeKind k@);
      node@.fval = k@@.fval;
    ; else node = new_num(k@@.val k@);

    node@.ty = k@@.ty;
    k@ = k@@.next;
    return node;
  ;

  error_tok(k@ "expected an expression"->@char);
;

parse_type(tok@ Token)@ Token =
  while !consume(&tok tok ";"->@char) {
    let ty = declarator(&tok);
    if !ty@.name
      error_tok(ty@.name_pos "type name omitted"->@char);
    if equal(ty@.name "_"->@char)
      continue;
    push_scope(get_ident(ty@.name))@.type_def = ty;
  ;
  return tok;
;

create_param_lvars(param@ Type)  =
  if param {
    create_param_lvars(param@.next);
    if !param@.name || equal(param@.name "_"->@char)
      error_tok(param@.name_pos "parameter name omitted"->@char);
    new_lvar(get_ident(param@.name) param);
  ;
;

// This function matches gotos or labels-as-values with labels.
//
// We cannot resolve gotos as we parse a function because gotos
// can refer a label that appears later in the function.
// So, we need to do this after we parse the entire function.
resolve_goto_labels(void)  =
  for (let x@ Node = gotos; x; x = x@.goto_next) {
    for (let y@ Node = labels; y; y = y@.goto_next) {
      if !strcmp(x@.label->@ y@.label) {
        x@.unique_label = y@.unique_label;
        break;
      ;
    ;

    if !x@.unique_label
      error_tok(x@.tok@.next "use of undeclared label"->@char);
  ;

  gotos = labels = 0;
;

find_func(name@ char)@ Obj =
  let sc = scope;
  while sc@.next
    sc = sc@.next;

  let sc2 = hashmap_get(&sc@.vars name)->@VarScope;
  if sc2 && sc2@.var && sc2@.var@.is_function
    return sc2@.var;
  return 0->@Obj;
;

mark_live(var@ Obj)  =
  if !var@.is_function || var@.is_live
    return;
  var@.is_live = true;

  for (let i int = 0; i < var@.refs.len; i++) {
    let fn = find_func(var@.refs.data[i]);
    if fn
      mark_live(fn);
  ;
;

function(tok@ Token attr@ VarAttr)@ Token =
  let ty = declarator(&tok);
  if !ty@.name || equal(ty@.name "_"->@char)
    error_tok(ty@.name_pos "function name omitted"->@char);
  let name_str = get_ident(ty@.name);

  let fn = find_func(name_str);
  if fn {
    // Redeclaration
    if !fn@.is_function
      error_tok(tok "redeclared as a different kind of symbol"->@char);
    if fn@.is_definition && equal(tok "="->@char)
      error_tok(tok "redefinition of %s"->@char name_str);
    if fn@.is_export != attr@.is_export
      error_tok(tok "mismatched visibility"->@char);
    fn@.is_definition = fn@.is_definition || equal(tok "="->@char);
  ; else {
    fn = new_gvar(name_str ty);
    fn@.is_function = true;
    fn@.is_definition = equal(tok "="->@char);
    fn@.is_export = attr@.is_export;
    fn@.is_inline = attr@.is_inline;
  ;

  fn@.is_root = fn@.is_export || !fn@.is_inline;

  if consume(&tok tok ";"->@char)
    return tok;

  current_fn = fn;
  locals = 0;
  enter_scope();
  create_param_lvars(ty@.params);

  // A buffer for a struct/union return value is passed
  // as the hidden first parameter.
  let rty = ty@.return_ty;
  if ((rty@.kind == TY_STRUCT || rty@.kind == TY_UNION) && rty@.size > 16)
    new_lvar(""->@char pointer_to(rty));

  fn@.params = locals;

  if ty@.is_variadic
    fn@.va_area = new_lvar("__va_area__"->@char array_of(ty_char 136));
  fn@.alloca_bottom = new_lvar("__alloca_size__"->@char pointer_to(ty_char));

  expect(&tok "="->@char);

  fn@.body = compound_stmt(&tok);
  fn@.locals = locals;
  leave_scope();
  resolve_goto_labels();
  return tok;
;

global_variable(tok@ Token attr@ VarAttr)@ Token =
  let first = true;

  while !consume(&tok tok ";"->@char) {
    first = false;

    let ty = declarator(&tok);
    if !ty@.name || equal(ty@.name "_"->@char)
      continue;

    let var = new_gvar(get_ident(ty@.name) ty);
    var@.is_definition = !attr@.is_extern;
    var@.is_export = attr@.is_export;
    var@.is_inline = attr@.is_inline;
    var@.is_tls = attr@.is_tls;
    if attr@.alignment
      var@.alignment = attr@.alignment;

    if equal(tok "="->@char)
      gvar_initializer(&tok tok@.next var);
    else if !attr@.is_extern && !attr@.is_tls
      var@.is_tentative = true;
  ;
  return tok;
;

// Lookahead tokens and returns true if a given token is a start
// of a function definition or declaration.
is_function(tok@ Token) bool =
  if equal(tok ";"->@char)
    return false;

  let ty = declarator(&tok);
  return (ty@.kind == TY_FUNC)->bool;
;

// Remove redundant tentative definitions.
scan_globals(void)  =
  let head = (let Obj){;;
  let cur = &head;

  for (let var@ Obj = globals; var; var = var@.next) {
    if !var@.is_tentative {
      cur = cur@.next = var;
      continue;
    ;

    // Find another definition of the same identifier.
    let var2 = globals;
    for (; var2; var2 = var2@.next)
      if var != var2 && var2@.is_definition && !strcmp(var@.name->@ var2@.name)
        break;

    // If there's another definition, the tentative definition
    // is redundant
    if !var2
      cur = cur@.next = var;
  ;

  cur@.next = 0;
  globals = head.next;
;


declare_builtin_functions(void) =
  let ty = func_type(pointer_to(ty_void));
  ty@.params = copy_type(ty_int);
  builtin_alloca = new_gvar("alloca"->@char ty);
  builtin_alloca@.is_definition = false;
;

export parse(tok@ Token)@ Obj =
  locals = 0;
  globals = 0;
  scope = &(let Scope){;;
  current_type = 0;
  current_fn = 0;
  gotos = 0;
  labels = 0;
  brk_label = 0;
  cont_label = 0;
  current_switch = 0;
  builtin_alloca = 0;
  declare_builtin_functions();

  while tok@.kind != TK_EOF {
    let attr = (let VarAttr){;;
    let c = &attr;
    declspec(&tok c);

    // Typedef
    if attr.is_type {
      tok = parse_type(tok);
      continue;
    ;

    // Function
    if is_function(tok) {
      tok = function(tok c);
      continue;
    ;

    // Global variable
    tok = global_variable(tok c);
  ;

  for (let var@ Obj = globals; var; var = var@.next)
    if var@.is_root
      mark_live(var);

  // Remove redundant tentative definitions.
  scan_globals();
  return globals;
;
