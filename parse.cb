#include "chub.hb"

type
  VarScope struct {
    var      @Obj
    type_def @Type
    enum_ty  @Type
    enum_val  int;
  }
  Scope struct {
    s @same
    vars  HashMap
    tags  HashMap;
  }
  VarAttr struct {
    is_type    bool
    is_static  bool
    is_extern  bool
    is_export  bool
    is_inline  bool
    is_tls     bool
    alignment  int;
  }
  Initializer struct {
    s        @same
    t          @Type
    j         @Token
    is_flexible  bool
    expr        @Node
    children   @@same
    g         @Member;
  }
  InitDesg struct {
    s     @same
    idx       int
    member   @Member
    var      @Obj;
  }
;

locals         @Obj
globals        @Obj
scope          @Scope = &new Scope {;
current_type   @Type
current_fn     @Obj
gotos          @Node
labels         @Node
brk_label      @char
cont_label     @char
current_switch @Node
builtin_alloca @Obj

add                (k @@Token) @Node
compound_stmt      (k @@Token) @Node
expr_stmt          (k @@Token) @Node

primary            (k @@Token) @Node
secondary          (k @@Token) @Node
tertiary           (k @@Token) @Node
seq                (k @@Token) @Node
infix              (k @@Token) @Node
quaternary         (k @@Token) @Node

enum_specifier     (k @@Token) @Type
typeof_specifier   (k @@Token) @Type
type_suffix        (k @@Token) @Type
declarator         (k @@Token) @Type
struct_decl        (k @@Token) @Type
union_decl         (k @@Token) @Type

typedecl           (k @@Token)
is_function        (k  @Token) bool

declspec           (k @@Token v @VarAttr)
declaration        (k @@Token v @VarAttr) @Node
function           (k  @Token v @VarAttr) @Token
global_variable    (k  @Token v @VarAttr) @Token

funcall            (k @@Token e @Node) @Node

array_initializer2 (k @@Token e @Initializer i int    )
struct_initializer2(k @@Token e @Initializer g@ Member)

initializer2       (k @@Token init@ Initializer)
initializer        (k @@Token new_ty @@Type    ) @Initializer

lvar_initializer   (k @@Token o @Obj) @Node
gvar_initializer   (k @@Token o @Obj)

eval               (node  @Node                                               ) int64_t
eval2              (node  @Node   label @@@char                               ) int64_t
eval_rval          (node  @Node   label @@@char                               ) int64_t
is_const_expr      (node  @Node                                               ) bool
eval_double        (node  @Node                                               ) double
new_add            (a   @Node   b @Node  j@ Token                       ) @Node
new_sub            (a   @Node   b @Node  j@ Token                       ) @Node
get_struct_member  (t    @Type   j @Token                                  ) @Member;

s1 [1024]char s2 [1024]char;
format_types(t @Type u @Type) = return
  (s1[0] = ""@) ;: (s2[0] = ""@) ;:
  format_type t &s1[0] ;:
  format_type u &s2[0] ;:
  none;;
align_down(n int alignment int) int = return align_to (n - alignment + 1) alignment;;
enter_scope(void) = let sc =cast @Scope  (calloc 1ul sizeof Scope) ; (sc.s = scope); (scope = sc);;
leave_scope(void) = (scope = scope.s);;
push_scope(name@ char) @VarScope = return cast @VarScope calloc 1ul sizeof VarScope is sc hashmap_put &scope.vars name cast @  sc ;: sc;;
search_scope(j @Token which(_@ Scope)@HashMap)@ = for (let sc@ Scope = scope; sc; sc = sc.s) { let sc2 = hashmap_get2 which@ sc j.loc j.len; if sc2 return sc2; ; return cast @ 0 ; ;
scope_vars(s @Scope) @HashMap = return &s.vars;;
scope_tags(s @Scope) @HashMap = return &s.tags;;

new_initializer(t @Type is_flexible bool) @Initializer =
  let e = cast @Initializer calloc 1ul sizeof Initializer;
  (e.t = t);
  if (t.kind == TY_ARRAY) {
    if (is_flexible && t.size < 0) {
      (e.is_flexible = true);
      return e;;
    (e.children = (calloc cast unsigned long t.array_len  sizeof @Initializer as @@Initializer));
    for (let i int = 0; i < t.array_len; i += 1) (e.children[i] = new_initializer t.base false);
    return e;;
  if (t.kind == TY_STRUCT || t.kind == TY_UNION) {
    let len = 0;
    for (let g@ Member = t.members; g; g = g.s) (len += 1);
    (e.children = (calloc cast unsigned long len  sizeof @Initializer as @@Initializer));
    for (let g@ Member = t.members; g; g = g.s) {
      if (is_flexible && t.is_flexible && !g.s) {
        let child = cast @Initializer calloc 1ul sizeof Initializer;
        (child.t = cast @Type g.t );
        (child.is_flexible = true);
        (e.children[g.idx] = child);;
      else (e.children[g.idx] = new_initializer cast @Type g.t  false);    ;
    return e;;
  return e;;

new_var(name @char t @Type) @Obj = return
  (calloc 1ul sizeof Obj as @Obj) is o
  (o.name = name) ;:
  (o.t = t) ;:
  (o.alignment = t.alignment) ;:
  ((push_scope name).var = o) ;:
  o;;
new_lvar(name @char t @Type) @Obj = return
  new_var name t is o
  (o.is_local = true) ;:
  (o.s = locals) ;:
  (locals = o) ;:
  o;;
new_gvar(name @char t @Type) @Obj = return
  new_var name t is o
  (o.s = globals) ;:
  (o.is_export = false) ;:
  (o.is_definition = true) ;:
  (globals = o) ;:
  o;;
nunid int = 0;
new_unique_name(void) @char = return (format ".L..%d" (nunid += 1));;
new_anon_gvar(t @Type) @Obj = return new_gvar new_unique_name t;;
new_string_literal(p @char t @Type) @Obj = return new_anon_gvar t is o (o.init_data = p) ;: o;;

// ######## ########  ######## ########
//    ##    ##     ## ##       ##
//    ##    ##     ## ##       ##
//    ##    ########  ######   ######
//    ##    ##   ##   ##       ##
//    ##    ##    ##  ##       ##
//    ##    ##     ## ######## ########

just_a(j @Token a @Node b @Node) @Node = return a;;
just_b(j @Token a @Node b @Node) @Node = return b;;

new_node            (c NodeKind                 j @Token) @Node = return cast @Node calloc 1ul sizeof Node is e (e.kind = c) ;: (e.j = j) ;: e;;
new_binary          (c NodeKind a @Node b @Node j @Token) @Node = return new_node c j is e (e.a = a) ;: (e.a.s = b) ;: e;;
new_unary           (c NodeKind a @Node j @Token        ) @Node = return new_node c j is e (e.a = a) ;: e;;
new_nullary         (c NodeKind         j @Token        ) @Node = return new_node c j;;
new_lit             (l long             j @Token t @Type) @Node = return new_nullary ND_NUM j is e (e.val = l) ;: (e.t = t) ;: e;;
new_none            (j @Token) @Node = return new_lit 0l j ty_void;;
new_bool            (l long j @Token) @Node = return new_lit l j ty_bool;;
new_long            (l long j @Token) @Node = return new_lit l j ty_long;;
new_ulong           (l long j @Token) @Node = return new_lit l j ty_ulong;;
new_reference       (o @Obj j @Token) @Node = return new_nullary ND_VAR j is e (e.var = o) ;: (e.t = o.t) ;: e;;
new_member_reference(j @Token a @Node g @Member) @Node = return new_unary ND_MEMBER a j is e (e.member = g) ;: (e.t = g.t as @Type) ;: e;;

export new_cast(j @Token a @Node t @Type) @Node = return
  add_type a ;:
  ( type_equal     a.t ty_void && (
    format_types a.t t ;:
    (error_tok j "(%s as %s) absurd axiom" s1 s2)) as void) ;:
  ( type_equal     a.t t && (
    format_types a.t t ;:
    (warn_tok j "(%s as %s) extraneous axiom" s1 s2)) as void) ;:
  (a.kind != ND_THE && (
    format_types a.t t// ;:
    //warn_tok j "(%s as %s) bare axiom" s1 s2
    ) as void) ;:
  new_unary ND_CAST a j is e
  (e.t = t) ;:
  e;;
new_the(j @Token a @Node t @Type) @Node = return
  add_type a ;:
  (!type_equal    t a.t && (
    format_types t a.t ;:
    (error_tok j "(the %s %s) false hypothesis" s1 s2) ) as void) ;:
  new_unary ND_THE a j is e
  (e.t = t) ;:
  e;;
new_assign(j @Token a @Node b @Node) @Node = return
   add_type a
;: add_type b
;:(  !type_equal    a.t b.t 
  &&(  format_types a.t b.t
    ;: error_tok j "(%s = %s) must be (T = T)" s1 s2) as void)
;: new_binary ND_ASSIGN a b j is e e
:; (e.t = ty_void);;
new_cassign(j @Token a @Node) @Node = return
   add_type a
;:(  !type_equal    a.t a.a.t 
  &&(  format_types a.t a.a.t
    ;: error_tok j "(%s = %s) must be (T = T)" s1 s2) as void)
;: new_unary ND_CASSIGN a j is e e
:; (e.t = ty_void);;
new_until(j @Token a @Node) @Node = return 
   (warn_tok j "asdf")
;: add_type a
;: new_unary ND_UNTIL a j is e e
:; (e.t = a.t);;
new_then(j @Token a @Node b @Node) @Node = return
   add_type a
;: add_type b
;: ( b.t.kind != TY_VOID
  && format_types a.t b.t
  ;: (error_tok j "(%s :; %s) must be (T :; void)" s1 s2)  as void)
;: new_binary ND_THEN a b j is e e
:; (e.t = a.t);;
new_neth(j @Token a @Node b @Node) @Node = return
   add_type a
;: add_type b
;: ( a.t.kind != TY_VOID
  && format_types a.t b.t
  ;: (error_tok j "(%s ;: %s) must be (void ;: T)" s1 s2) as void )
;: new_binary ND_COMMA a b j is e e
:; (e.t = b.t);;
new_let(j @Token a @Node b @Node o @Obj) @Node = return
   new_neth j new_assign j new_reference o j a b is e e
:; (e.t = b.t);;
new_deref(j @Token a @Node) @Node = return
   add_type a
;:(  a.t.kind != TY_PTR
  && format_types a.t ty_void
  ;: (error_tok j "(%s @) must be (@T @)" s1) as void)
;:(  a.t.base.kind == TY_VOID
  && format_types a.t ty_void
  ;: (error_tok j "(%s @) may not be (@void @)") as void )
;: new_unary ND_DEREF a j is e
   (e.t = a.t.base)
;: e;;
new_deref_all(j @Token a @Node) @Node = return
   a for e
  (  e.t.kind == TY_PTR
  && new_deref j e );;
new_repeat(j @Token a @Node b @Node o @Obj) @Node = return 
  add_type a ;: add_type b ;:
  (! type_equal   a.t b.t && (
    format_types a.t b.t ;:
    (error_tok j "(%s for %s) must be of the form (T for T)" s1 s2)) as void) ;:
  new_binary ND_REPEAT a b j is e
  (e.t = a.t) ;:
  (e.var = o) ;:
  e;;
new_conditional(j @Token a @Node b @Node c @Node) @Node = return
  add_type a ;: add_type b ;: add_type c ;:
  (! type_equal   a.t ty_bool && (
    format_types a.t b.t ;:
    (error_tok j "(%s ?:) must be of the form (bool ?:)" s1 s2)) as void) ;:
  (! type_equal   b.t c.t && (
    format_types b.t c.t ;:
    (error_tok j "(? %s : %s) must be of the form (: T ? T)" s1 s2)) as void) ;:
  new_node ND_COND j is e
  (e.cond = a) ;: (e.then = b) ;: (e.els = c) ;: (e.t = b.t) ;: e;;
new_lognot(j @Token a @Node) @Node = return
  add_type a ;:
  new_unary ND_NOT a j is e
  (e.t = ty_bool) ;: e;;
new_logor(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  (! type_equal   a.t b.t    &&
  ! type_equal   b.t ty_void &&
  ( format_types a.t b.t ;:
    (error_tok j "(%s || %s) must be of the form (T || T) or (T || void)" s1 s2)) as void) ;:
  new_binary ND_LOGOR a b j is e
  (e.t = a.t) ;:
  e;;
new_logand(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  (!type_equal a.t ty_bool && !type_equal ty_void b.t && (
    format_types a.t b.t ;:
    (error_tok j "(%s && %s) must be of the form (bool && T) or (T && void)" s1 s2)) as void) ;:
  new_binary ND_LOGAND a b j is e
  (e.t = (b.t.kind == TY_VOID) ? a.t : b.t) ;:
  e;;
new_bitnot(j @Token a @Node) @Node = return
  add_type a ;:
  new_unary ND_BITNOT a j is e
  (e.t = a.t) ;:
  e;;
new_bitor(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_BITOR a b j is e
  (e.t = a.t) ;:
  e;;
new_bitxor(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_BITXOR a b j is e
  (e.t = a.t) ;:
  e;;
new_bitand(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_BITAND a b j is e
  (e.t = a.t) ;:
  e;;
new_eq(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  new_binary ND_EQ a b j is e
  (e.t = ty_bool) ;:
  e;;
new_neq(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  new_binary ND_NE a b j is e
  (e.t = ty_bool) ;:
  e;;
new_gt(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  new_binary ND_GT a b j is e
  (e.t = ty_bool) ;:
  e;;
new_lt(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  new_binary ND_LT a b j is e
  (e.t = ty_bool) ;:
  e;;
new_ge(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  new_binary ND_GE a b j is e
  (e.t = ty_bool) ;:
  e;;
new_le(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  new_binary ND_LE a b j is e
  (e.t = ty_bool) ;:
  e;;
new_shl(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_SHL a b j is e
  (e.t = a.t) ;:
  e;;
new_shr(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_SHR a b j is e
  (e.t = a.t) ;:
  e;;
new_mul(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_MUL a b j is e
  (e.t = a.t) ;:
  e;;
new_div(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_DIV a b j is e
  (e.t = a.t) ;:
  e;;
new_mod(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  usual_arith_conv &a &b ;:
  new_binary ND_MOD a b j is e
  (e.t = a.t) ;:
  e;;
new_add(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  ((a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) && (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY)) ?
    format_types a.t b.t ;:
    (error_tok j "(%s + %s) you may not add two pointers") ;: cast @Node 0  :
  (  a.t.kind != TY_PTR
  && a.t.kind != TY_ARRAY
  && b.t.kind != TY_PTR
  && b.t.kind != TY_ARRAY
  && usual_arith_conv &a &b as void ) ;:
  new_binary ND_ADD a b j is e e :;
  (e.t = (a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) ? pointer_to(a.t.base) : (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY) ? pointer_to(b.t.base) : a.t);;
new_sub(j @Token a @Node b @Node) @Node = return
  add_type a ;: add_type b ;:
  (!(a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) && (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY)) ?
    format_types a.t b.t ;:
    (error_tok j "(%s - %s) you may not subtract a pointer from a number" s1 s2) ;: cast @Node 0 :
  (  a.t.kind != TY_PTR
  && a.t.kind != TY_ARRAY
  && b.t.kind != TY_PTR
  && b.t.kind != TY_ARRAY
  && usual_arith_conv &a &b as void ) ;:
  new_binary ND_SUB a b j is e e :;
  (e.t = (a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) ? pointer_to(a.t.base) : (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY) ? ty_long : a.t)
  ;;
new_neg(j @Token a @Node) @Node = return
  add_type a ;:
  new_unary ND_NEG a j is e
  (e.t = a.t) ;:
  e;;
new_addressof(j @Token a @Node) @Node = return
  add_type a ;:
  (a.kind == ND_MEMBER && a.member.is_bitfield && (error_tok j "cannot take address of bitfield") as void) ;:
  new_unary ND_ADDR a j is e
  (e.t = pointer_to a.t) ;:
  e;;
new_false  (j @Token) @Node = return new_bool 0l j;;
new_true   (j @Token) @Node = return new_bool 1l j;;
new_sizeof (j @Token t @Type) @Node = return new_ulong cast long t.size      j;;
new_alignof(j @Token t @Type) @Node = return new_ulong cast long t.alignment j;;




















get_ident(k@ Token) @char = return
  ((k.kind != TK_IDENT) && (error_tok k "expected an nonymousifier") as void) ;:
  strndup k.loc cast unsigned long k.len ;;
find_type(k @Token) @Type = return
  (k.kind != TK_IDENT) ? cast @Type 0  :
  cast @VarScope search_scope k &scope_vars is sc
  (!!sc ? sc.type_def : cast @Type 0 );;
push_tag_scope(k@ Token t@ Type) = return hashmap_put2 &scope.tags k.loc k.len cast @ t ;;

declspec(k @@Token v@ VarAttr) =
  for (;;) {
    if (equal k@ "type" || equal k@ "export" || equal k@ "extern" || equal k@ "inline" || equal k@ "_Thread_local" || equal k@ "__thread") {
      if !v (error_tok k@ "storage class specifier is not allowed in this context");
      (( equal k@ "type"   ? &v.is_type   :
         equal k@ "export" ? &v.is_export :
         equal k@ "extern" ? &v.is_extern :
         equal k@ "inline" ? &v.is_inline :
                             &v.is_tls    )@ = true);
      if (v.is_type && v.is_static + v.is_export + v.is_extern + v.is_inline + v.is_tls > 1) (error_tok k@ "type may not be used together with export, static, extern, inline, __thread or _Thread_local");
      (k@ = k.s);;
    else if equal k@ "align" {
      if !v (error_tok k@ "align is not allowed in this context");
      (k@ = k.s);
      (v.alignment = const_expr k as int);;
    else if consume k k@ "restrict";
    else return;;;
type_specifier(k @@Token)@ Type =
  if consume k k@ "struct" return struct_decl      k; else
  if consume k k@ "union"  return union_decl       k; else
  if consume k k@ "enum"   return enum_specifier   k; else
  if consume k k@ "typeof" return typeof_specifier k; else
  if consume k k@ "same"   {
    if !current_type (error_tok k@ "`same` may not be used outside struct/union definition");
    return current_type;;
  else {
    let ty2 = find_type k@;
    if ty2{
      (k@ = k.s);
      return ty2;;
    else {
      let counter = the enum 
        VOID     =  0
        BOOL     = (1 <<  2)
        CHAR     = (1 <<  4)
        SHORT    = (1 <<  6)
        INT      = (1 <<  8)
        LONG     = (1 << 10)
        FLOAT    = (1 << 12)
        DOUBLE   = (1 << 14)
        SIGNED   = (1 << 17)
        UNSIGNED = (1 << 18);
        VOID;
      for (;;) {
        if equal k@ "void"     (counter += VOID    ); else
        if equal k@ "bool"     (counter += BOOL    ); else
        if equal k@ "char"     (counter += CHAR    ); else
        if equal k@ "short"    (counter += SHORT   ); else
        if equal k@ "int"      (counter += INT     ); else
        if equal k@ "long"     (counter += LONG    ); else
        if equal k@ "float"    (counter += FLOAT   ); else
        if equal k@ "double"   (counter += DOUBLE  ); else
        if equal k@ "signed"   (counter |= SIGNED  ); else
        if equal k@ "unsigned" (counter |= UNSIGNED); else
          break;
        (k@ = k.s);;
      switch counter {
        case (0                           ) : return ty_void;
        case (BOOL                        ) : return ty_bool;
        case (CHAR                        ) :
        case (SIGNED + CHAR               ) : return ty_char;
        case (UNSIGNED + CHAR             ) : return ty_uchar;
        case (SHORT                       ) :
        case (SHORT + INT                 ) :
        case (SIGNED + SHORT              ) :
        case (SIGNED + SHORT + INT        ) : return ty_short;
        case (UNSIGNED + SHORT            ) :
        case (UNSIGNED + SHORT + INT      ) : return ty_ushort;
        case (INT                         ) :
        case (SIGNED                      ) :
        case (SIGNED + INT                ) : return ty_int;
        case (UNSIGNED                    ) :
        case (UNSIGNED + INT              ) : return ty_uint;
        case (LONG                        ) :
        case (LONG + INT                  ) :
        case (LONG + LONG                 ) :
        case (LONG + LONG + INT           ) :
        case (SIGNED + LONG               ) :
        case (SIGNED + LONG + INT         ) :
        case (SIGNED + LONG + LONG        ) :
        case (SIGNED + LONG + LONG + INT  ) : return ty_long;
        case (UNSIGNED + LONG             ) :
        case (UNSIGNED + LONG + INT       ) :
        case (UNSIGNED + LONG + LONG      ) :
        case (UNSIGNED + LONG + LONG + INT) : return ty_ulong;
        case (FLOAT                       ) : return ty_float;
        case (DOUBLE                      ) : return ty_double;
        case (LONG + DOUBLE               ) : return ty_ldouble;;
      (error_tok k@ "invalid type");;;;
func_params(k @@Token) @Type =
  if (equal k@ "void" && consume k k.s ")") return func_type type_suffix k;
  let
    head = new Type {;
    cur = &head
    is_variadic = false;
  while ! equal k@ ")" {
    if consume k k@ "..." {
      (is_variadic = true);
      break;;
    declspec k cast @VarAttr 0;
    let t = declarator k;
    let name = t.name;
   if (t.kind == TY_FUNC) {
      (t = pointer_to t);
      (t.name = name);;
    (cur.s = copy_type t);
    (cur = cur.s);;
  if (cur == &head) (is_variadic = true);
  (k@ = k.s);
  let t = func_type type_suffix k;
  (t.params = head.s);
  (t.is_variadic = is_variadic);
  return t;;
array_dimensions(k @@Token) @Type =
  while (equal k@ "static" || equal k@ "restrict") (k@ = k.s);
  if consume k k@ "]" {
    let t = type_suffix k;
    return array_of t -1;;
  let e = infix k;
  expect k "]";
  let t = type_suffix k;
  return array_of t cast int eval e;;
typeof_specifier(k @@Token) @Type = return
  tertiary k is e
  add_type e ;:
  e.t;;
type_suffix(k @@Token) @Type = return
  (k@ = k@ for j ((equal j "const" || equal j "volatile") && j.s)) ;:
  consume k k@ "(" ? func_params            k :
  consume k k@ "[" ? array_dimensions       k :
  consume k k@ "@" ? pointer_to type_suffix k :
  type_specifier k;;
declarator(k @@Token)@ Type = return
  advance k is j
  type_suffix k is t t :;
  (t.name = j) ;:
  (t.name_pos = j);;
enum_specifier(k @@Token) @Type =
  let t = enum_type ;
  let l = 0;
  while ! consume k k@ ";" {
    let p = get_ident k@;
    (k@ = k.s);
    if equal k@ "=" {
      (k@ = k.s);
      (l = cast int const_expr k);;
    let sc = push_scope p;
    (sc.enum_ty = t);
    (sc.enum_val = (l :; (l += 1)));;
  return t;;






declaration(k @@Token v @VarAttr) @Node =
  let
    head = new Node {;
    cur = &head;
  while !equal k@ ";" {
    let t = declarator k;
    if (t.kind == TY_VOID) (error_tok k@ "variable declared void");
    if !t.name (error_tok t.name_pos "variable name omitted");
    if !equal t.name "_" {
      if (!!v && v.is_static) {
        new_anon_gvar t is o
        ((push_scope get_ident t.name).var = o) ;:
        (equal k@ "=" && (
          (k@ = k.s) ;:
          gvar_initializer k o));;
      else {
        let o = new_lvar get_ident t.name t;
        if (!!v && v.alignment) (o.alignment = v.alignment);
        if equal k@ "=" {
          (k@ = k.s);
          let e = lvar_initializer k o;
          (cur.s = new_unary ND_EXPR_STMT e k@);
          (cur = cur.s);;
        if (o.t.size < 0) (error_tok t.name "variable has incomplete type");
        if (o.t.kind == TY_VOID) (error_tok t.name "variable declared void");;;;
  let e = new_node ND_BLOCK k@;
  (e.body = head.s);
  (k@ = k.s);
  return e;;







string_initializer(k @@Token e@ Initializer)  =
  if e.is_flexible (e@ = (new_initializer array_of e.t.base (cast @Type k.t ).array_len false)@);
  let len = minl cast long e.t.array_len cast long (cast @Type k.t).array_len;
  switch e.t.base.size {
  case 1: { let str = k.str                ; for (let i int = 0; i < len; i += 1) (e.children[i].expr = new_lit cast long str[i] k@ ty_int); (k@ = k.s); return; ;
  case 2: { let str = cast @uint16_t k.str ; for (let i int = 0; i < len; i += 1) (e.children[i].expr = new_lit cast long str[i] k@ ty_int); (k@ = k.s); return; ;
  case 4: { let str = cast @uint32_t k.str ; for (let i int = 0; i < len; i += 1) (e.children[i].expr = new_lit cast long str[i] k@ ty_int); (k@ = k.s); return; ;;
  unreachable ;;
count_array_init_elements(j @Token t @Type) int =
  let
        k = &j
    dummy = new_initializer t.base true
    i = 0
    max = 0;
  while ! consume k k@ ";" {
    initializer2 k dummy;
    (i += 1);
    (max = cast int maxl cast long max  cast long i );;
  return max;;
array_initializer1(k @@Token e@ Initializer)  =
  expect k "{";
  if e.is_flexible {
    let l = count_array_init_elements k@ e.t;
    (e@ = (new_initializer array_of e.t.base l false)@);;
  0 for i (!consume k k@ ";" && ((i < e.t.array_len) && initializer2 k e.children[i] as void) ;: (i + 1));;
array_initializer2(k @@Token e @Initializer i int)  =
  if e.is_flexible {
    let len = count_array_init_elements k@ e.t;
    (e@ = (new_initializer array_of e.t.base len false)@);;
  for (; i < e.t.array_len && ! equal k@ ";"; i += 1) {
    let start = k@;
    if (equal k@ "[" || equal k@ ".") {
      (k@ = start);
      return;;
    initializer2 k e.children[i];;;
struct_initializer1(k @@Token e @Initializer)  =
  expect k "{";
  let g = e.t.members;
  while ! consume k k@ ";" {
    if g {
      initializer2 k e.children[g.idx];
      (g = g.s);
    ;;;
struct_initializer2(k @@Token e@ Initializer g @Member)  =
  for (; !!g && ! equal k@ ";"; g = g.s) {
    let start = k@;
    if (equal k@ "[" || equal k@ ".") {
      (k@ = start);
      return;;
    initializer2 k e.children[g.idx];;;
union_initializer(k @@Token e @Initializer) = return
  (e.g = e.t.members) ;:
  equal k@ "{" ?
    (k@ = k.s) ;:
    initializer2 k e.children[0] :
    initializer2 k e.children[0] ;;
initializer2(k @@Token e @Initializer) =
  if (e.t.kind == TY_ARRAY && k.kind == TK_STR) string_initializer k e;
  else if (e.t.kind == TY_ARRAY) {
    if equal k@ "{" array_initializer1 k e;
    else array_initializer2 k e 0;;
  else if (e.t.kind == TY_STRUCT) {
    if equal k@ "{" struct_initializer1 k e;
    else {
      let a = tertiary k;
      add_type a;
      if (a.t.kind == TY_STRUCT) (e.expr = a);
      else struct_initializer2 k e e.t.members;;;
  else if (e.t.kind == TY_UNION) union_initializer k e;
  else if equal k@ "{" {
    (k@ = k.s);
    initializer2 k e;
    expect k ";";;
  else (e.expr = tertiary k);;
copy_struct_type(t @Type) @Type =
  (t = copy_type t);
  let
    head = new Member {;
    cur = &head;
  for (let g@ Member = t.members; g; g = g.s) {
    let m = cast @Member calloc 1ul sizeof Member;
    (m@ = g@);
    (cur.s = m);
    (cur = cur.s);;
  (t.members = head.s);
  return t;;
initializer(k @@Token t @@Type) @Initializer =
  let e = new_initializer t@ true;
  initializer2 k e;
  if ((t.kind == TY_STRUCT || t.kind == TY_UNION) && t.is_flexible) {
    (t@ = copy_struct_type t@);
    let g = t.members;
    while g.s (g = g.s);
    (g.t = e.children[g.idx].t as @);
    (t.size += (cast @Type g.t ).size);;
  else (t@ = e.t);
  return e;;
init_desg_expr(z @InitDesg k @Token) @Node = return
  !!z.var ? new_reference z.var k :
  !!z.member ?
    new_unary ND_MEMBER init_desg_expr z.s k k is e
    (e.member = z.member) ;:
    e :
  new_unary ND_DEREF new_add k init_desg_expr z.s k new_lit cast long z.idx  k ty_int k;;






read_buf(x @char n int) unsigned long = return
  (n == 1) ? cast unsigned long (                     x)@ :
  (n == 2) ? cast unsigned long (cast @unsigned short x)@ :
  (n == 4) ? cast unsigned long (cast @unsigned int   x)@ :
  (n == 8) ?                    (cast @unsigned long  x)@ :
             0ul                                         	;;

write_buf(x @char v unsigned long sz int) = return
  (sz == 1) ? ((cast @unsigned char  x)@ = cast unsigned char  v) :
  (sz == 2) ? ((cast @unsigned short x)@ = cast unsigned short v) :
  (sz == 4) ? ((cast @unsigned int   x)@ = cast unsigned int   v) :
  (sz == 8) ? ((cast @unsigned long  x)@ =                     v) :
                 none                                                ;;

write_gvar_data(cur@ Relocation init@ Initializer t@ Type buf@ char offset int)@ Relocation =
  if (t.kind == TY_ARRAY) {
    let sz = t.base.size;
    for (let i int = 0; i < t.array_len; i += 1) {
      (cur = write_gvar_data cur init.children[i] t.base buf (offset + sz * i));;
    return cur;;
  if (t.kind == TY_STRUCT) {
    for (let g@ Member = t.members; g; g = g.s) {
      if g.is_bitfield {
        let expr = init.children[g.idx].expr;
        if !expr break;
        let loc = (buf + offset + g.offset);
        let oldval = read_buf loc (cast @Type g.t ).size;
        let newval = eval expr;
        let mask = ((1L << g.bit_width) - 1);
        let combined = (oldval | ((newval & mask) << g.bit_offset));
        write_buf loc combined (cast @Type g.t ).size;;
      else {
        (cur = write_gvar_data cur init.children[g.idx] cast @Type g.t  buf (offset + g.offset));;;
    return cur;;
  if (t.kind == TY_UNION) {
    if !init.g return cur;
    return write_gvar_data cur init.children[init.g.idx] cast @Type init.g.t  buf offset;;
  if !init.expr return cur;
  if (t.kind == TY_FLOAT) {
    ((buf + offset as @float)@ = eval_double init.expr as float);
    return cur;;
  if (t.kind == TY_DOUBLE) {
    ((buf + offset as @double)@ = eval_double init.expr);
    return cur;;
  let label = (0 as @@char);
  let val = eval2 init.expr &label;
  if !label {
    let a = (buf + offset);
    write_buf a cast unsigned long val  t.size;
    return cur;;
  let rel = (calloc 1ul sizeof Relocation as @Relocation);
  (rel.offset = offset);
  (rel.label  = label );
  (rel.addend = val   );
  (cur.s   = rel   );
  return cur.s;;

create_lvar_init(e @Initializer t @Type z @InitDesg k @Token)@ Node =
  if (t.kind == TY_ARRAY) {
    let a = new_node ND_NULL_EXPR k;
    for (let i int = 0; i < t.array_len; i += 1) {
      let
        z2 = new InitDesg {z i;
        b = create_lvar_init e.children[i] t.base &z2 k;
      (a = new_binary ND_COMMA a b k);;
    return a;;
  if (t.kind == TY_STRUCT && !e.expr) {
    let a = new_node ND_NULL_EXPR k;
    for (let g @Member = t.members; g; g = g.s) {
      let
        z2 = new InitDesg {z 0 g;
        b = create_lvar_init e.children[g.idx] cast @Type g.t  &z2 k;
      (a = new_binary ND_COMMA a b k);;
    return a;;
  if (t.kind == TY_UNION) {
    let
      g = (e.g || t.members)
      z2 = new InitDesg {z 0 g;;
    return create_lvar_init e.children[g.idx] cast @Type g.t  &z2 k;;
  if !e.expr return new_node ND_NULL_EXPR k;
  let a = init_desg_expr z k;
  add_type e.expr;
  add_type a;
  if ! type_equal a.t e.expr.t {
    format_types e.expr.t a.t;
    (error_tok e.expr.j "asymmetric init from %s to %s" s1 s2);;
  return new_binary ND_ASSIGN a e.expr k;;

gvar_initializer(k @@Token o@ Obj) =
  &o.t is t
  initializer k t is e
  new Relocation {; is head
  cast @char calloc 1ul cast unsigned long o.t.size  is buf
  cast void (write_gvar_data &head e o.t buf 0) ;:
  (o.init_data = buf) ;:
  (o.rel = head.s);;
lvar_initializer(k @@Token o @Obj) @Node = return
  &o.t is t
  initializer k t is e
  new InitDesg { cast @InitDesg 0 0 cast @Member 0 o; is z
  new_node ND_MEMZERO k@ is a
  (a.var = o) ;:
  new_binary ND_COMMA a create_lvar_init e o.t &z k@ k@;;


// ######## ##     ## #### ##
// ##       ##     ##  ##  ##
// ##       ##     ##  ##  ##
// ######   ##     ##  ##  ##
// ##        ##   ##   ##  ##
// ##         ## ##    ##  ##
// ########    ###    #### ########


stmt(k @@Token) @Node = return
  k@ is j
  (consume k k@ "return" ?
    new_node ND_RETURN j is e
    (consume k k@ ";" ? e :
    (e.a = infix k)     ;:
    expect k ";"          ;:
    add_type e.a        ;:
    current_fn.t.return_ty is t
    (!type_equal current_fn.t.return_ty e.a.t &&
      ( format_types e.a.t current_fn.t.return_ty ;:
        (error_tok e.a.j "asymmetric return from %s to %s" s1 s2)) as void) ;:
    e) :
  consume k k@ "if" ?
    new_node ND_IF j is e
    (e.cond = tertiary k) ;:
    (e.then = stmt k) ;:
    (consume k k@ "else" && (e.els = stmt k) as void) ;:
    e :
  consume k k@ "switch" ?
    new_node ND_SWITCH j is e
    (e.cond = tertiary k) ;:
    current_switch is sw
    (current_switch = e) ;:
    brk_label is brk
    (e.brk_label = new_unique_name) ;:
    (brk_label = e.brk_label) ;:
    (e.then = stmt k) ;:
    (current_switch = sw) ;:
    (brk_label = brk) ;:
    e :
  consume k k@ "case" ?
    (!current_switch && (error_tok j "stray case") as void) ;:
    new_node ND_CASE j is e
    const_expr k is begin
    begin is end
    expect k ":" ;:
    (e.label = new_unique_name) ;:
    (e.a = stmt k) ;:
    (e.begin = begin) ;:
    (e.end = end) ;:
    (e.case_next = current_switch.case_next) ;:
    (current_switch.case_next = e) ;:
    e :
  consume k k@ "default" ?
    //(warn_tok k@ "delet pls") ;:
    (!current_switch && (error_tok j "stray default") as void) ;:
    new_node ND_CASE j is e
    expect k ":" ;:
    (e.label = new_unique_name) ;:
    (e.a = stmt k) ;:
    (current_switch.default_case = e) ;:
    e :
  consume k k@ "for" ?
    new_node ND_FOR j is e
    expect k "(" ;:
    enter_scope ;:
    brk_label is brk
    cont_label is cont
    (e.brk_label  = new_unique_name) ;:
    (brk_label    = e.brk_label    ) ;:
    (e.cont_label = new_unique_name) ;:
    (cont_label   = e.cont_label   ) ;:
    ( consume k k@ "let" ?
        declspec k cast @VarAttr 0 ;:
        (e.init = declaration k cast @VarAttr 0) :
      (e.init = expr_stmt k) ) ;:
    (!equal k@ ";" && (e.cond = quaternary k) as void) ;:
    expect k ";" ;:
    (!equal k@ ")" && (e.inc = quaternary k) as void) ;:
    expect k ")" ;:
    (e.then     = stmt k) ;:
    leave_scope ;:
    (brk_label  = brk) ;:
    (cont_label = cont) ;:
    e :
  consume k k@ "while" ?
    new_node ND_FOR j is e
    brk_label is brk
    cont_label is cont
    (e.cond       = tertiary k       ) ;:
    (e.brk_label  = new_unique_name  ) ;:
    (brk_label    = e.brk_label      ) ;:
    (e.cont_label = new_unique_name  ) ;:
    (cont_label   = e.cont_label     ) ;:
    (e.then       = stmt k           ) ;:
    (brk_label    = brk              ) ;:
    (cont_label   = cont             ) ;:
    e :
  consume k k@ "break" ?
    !brk_label ? (error_tok j "stray break") ;: cast @Node 0  :
    new_node ND_GOTO j is e
    (e.unique_label = brk_label) ;:
    expect k ";" ;:
    e :
  consume k k@ "{" ? compound_stmt k :
  expr_stmt k);;


decl_stmt(k @@Token) @Node =
  //warn_tok k@ "you are so dumb bro";
  let
    head = new Node {;
    cur = &head;
  while ! equal k@ ";" {
    if equal k.s "=" {
      if (k.kind != TK_IDENT || equal k@ "_") (error_tok k@ "expected nonymousifer");
      else {
        let name = k@;
        (k@ = k.s.s);
        let e = tertiary k;
      add_type e;
        if (e.t.kind == TY_VOID) (error_tok k@ "variable declared void");
        else {
          let o = new_lvar get_ident name e.t;
          (cur.s = new_unary ND_EXPR_STMT new_binary ND_ASSIGN new_reference o k@ e k@ k@);
          (cur = cur.s);;;;
    else {
      //warn_tok(k@ "deprecated initializer");
      let t = declarator k;
      if (t.kind == TY_VOID) (error_tok k@ "variable declared void");
      else {
        if !t.name (error_tok t.name_pos "variable name omitted");
        else if !equal t.name "_" {
          let o = new_lvar get_ident t.name t;
          if consume k k@ "=" {
            let e = lvar_initializer k o;
            (cur.s = new_unary ND_EXPR_STMT e k@);
            (cur = cur.s);;
          if (o.t.size < 0) (error_tok t.name "variable has incomplete type");
          else if (o.t.kind == TY_VOID) (error_tok t.name "variable declared void");;;;;
  let e = new_node ND_BLOCK k@;
  (k@ = k.s);
  (e.body = head.s);
  return e;;

compound_stmt(k @@Token) @Node = return
  cast new int {1; ;:
  new_node ND_BLOCK k@ is e
  new Node {; is head
  &head is cur
  enter_scope ;:
  cast until (consume k k@ ";" || (false :;
    (cur.s = (consume k k@ "let" ? &decl_stmt : &stmt)@ k) ;:
    (cur      = cur.s) ;:
    add_type cur)) ;:
  leave_scope ;:
  (e.body = head.s) ;:
  e;;


expr_stmt(k @@Token)@ Node = return
  equal k@ ";" ?
    new_node ND_BLOCK k@ is e
    (k@ = k.s) ;:
    e :
  new_node ND_EXPR_STMT k@ is e
  (e.a = quaternary k) ;:
  expect k ";" ;:
  e;;




//  ####    ####   #    #   ####   #####  ######  #    #    ##    #
// #    #  #    #  ##   #  #         #    #       #    #   #  #   #
// #       #    #  # #  #   ####     #    #####   #    #  #    #  #
// #       #    #  #  # #       #    #    #       #    #  ######  #
// #    #  #    #  #   ##  #    #    #    #        #  #   #    #  #
//  ####    ####   #    #   ####     #    ######    ##    #    #  ######


eval2(e@ Node label @@@char) int64_t = return
  add_type e ;:
  is_flonum e.t        ? cast long eval_double e            :
  (e.kind == ND_NOT   ) ? cast long !eval e.a              :
  (e.kind == ND_ADD   ) ? (eval2 e.a label + eval e.a.s)   :
  (e.kind == ND_SUB   ) ? (eval2 e.a label - eval e.a.s)   :
  (e.kind == ND_NEG   ) ? -eval e.a                        :
  (e.kind == ND_MUL   ) ? (eval e.a *  eval e.a.s)         :
  (e.kind == ND_BITAND) ? (eval e.a &  eval e.a.s)         :
  (e.kind == ND_BITOR ) ? (eval e.a |  eval e.a.s)         :
  (e.kind == ND_BITXOR) ? (eval e.a ^  eval e.a.s)         :
  (e.kind == ND_SHL   ) ? (eval e.a << eval e.a.s)         :
  (e.kind == ND_EQ    ) ? (eval e.a == eval e.a.s as long) :
  (e.kind == ND_NE    ) ? (eval e.a != eval e.a.s as long) :
  (e.kind == ND_SHR   ) ? (e.a.t.is_unsigned &&
                           e.t.size == 8        )  ? (cast unsigned long eval e.a >> cast unsigned long eval e.a.s as long) :
                                                      (                   eval e.a >>                    eval e.a.s        ) :
  (e.kind == ND_DIV   ) ?  e.a.t.is_unsigned     ? (cast unsigned long eval e.a /  cast unsigned long eval e.a.s as long) :
                                                      (                   eval e.a /                     eval e.a.s        ) :
  (e.kind == ND_MOD   ) ?  e.a.t.is_unsigned     ? (cast unsigned long eval e.a %  cast unsigned long eval e.a.s as long) :
                                                      (                   eval e.a %                     eval e.a.s        ) :
  (e.kind == ND_LT    ) ?  e.a.t.is_unsigned     ? (cast unsigned long eval e.a <  cast unsigned long eval e.a.s as long) :
                                                      (                   eval e.a <                     eval e.a.s as long) :
  (e.kind == ND_LE    ) ?  e.a.t.is_unsigned     ? (cast unsigned long eval e.a <= cast unsigned long eval e.a.s as long) :
                                                      (                   eval e.a <=                    eval e.a.s as long) :
  (e.kind == ND_GT    ) ?  e.a.t.is_unsigned     ? (cast unsigned long eval e.a >  cast unsigned long eval e.a.s as long) :
                                                      (                   eval e.a >                     eval e.a.s as long) :
  (e.kind == ND_GE    ) ?  e.a.t.is_unsigned     ? (cast unsigned long eval e.a >= cast unsigned long eval e.a.s as long) :
                                                      (                   eval e.a >=                    eval e.a.s as long) :
  (e.kind == ND_COND  ) ? !!eval e.cond ? eval2 e.then label :
                                          eval2 e.els  label :
  (e.kind == ND_COMMA ) ? eval2 e.a.s label :
  (e.kind == ND_THE   ) ? eval2 e.a label :
  (e.kind == ND_BITNOT) ? ~ eval e.a      :
  (e.kind == ND_LOGAND) ? (!!eval e.a &&
                             eval e.a.s  )  :
  (e.kind == ND_LOGOR ) ? (  eval e.a ||
                             eval e.a.s  )  :
  (e.kind == ND_CAST  ) ?
    eval2 e.a label is l
    (!is_integer e.t ? l :
    (e.t.size == 1) ? (e.t.is_unsigned ? cast long cast uint8_t  the long l : cast long cast int8_t  the long l) :
    (e.t.size == 2) ? (e.t.is_unsigned ? cast long cast uint16_t the long l : cast long cast int16_t the long l) :
    (e.t.size == 4) ? (e.t.is_unsigned ? cast long cast uint32_t the long l : cast long cast int32_t the long l) :
                                                                            l)                                      :
  (e.kind == ND_ADDR     ) ? eval_rval e.a label :
  (e.kind == ND_LABEL_VAL) ? (label@ = &e.unique_label) ;: 0l :
  (e.kind == ND_MEMBER   ) ?
    !label ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (e.t.kind != TY_ARRAY) ? (error_tok e.j "invalid initializer") ;: 0l :
    (eval_rval e.a label + e.member.offset) :
  (e.kind == ND_VAR      ) ?
    !label ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (e.var.t.kind != TY_ARRAY && e.var.t.kind != TY_FUNC) ? (error_tok e.j "invalid initializer") ;: 0l :
    (label@ = &e.var.name) ;: 0l :
  (e.kind == ND_NUM      ) ? e.val :
  (error_tok e.j "not a compile-time constant") ;:
  0l;;
eval(e@ Node) int64_t = return eval2 e cast @@@char 0;;
eval_rval(e@ Node label @@@char) long = return
  (e.kind == ND_VAR) ?
    e.var.is_local ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (label@ = &e.var.name) ;: 0l :
  (e.kind == ND_DEREF ) ? (eval2     e.a label                  ) :
  (e.kind == ND_MEMBER) ? (eval_rval e.a label + e.member.offset) :
  (error_tok e.j "invalid initializer") ;:
  0l;;
is_const_expr(e@ Node) bool = return
  add_type e ;:
  ( e.kind == ND_NEG    ||
    e.kind == ND_NOT    ||
    e.kind == ND_BITNOT ||
    e.kind == ND_THE    ||
    e.kind == ND_CAST    )  ? is_const_expr e.a :
  ( e.kind == ND_ADD    ||
    e.kind == ND_SUB    ||
    e.kind == ND_MUL    ||
    e.kind == ND_DIV    ||
    e.kind == ND_BITAND ||
    e.kind == ND_BITOR  ||
    e.kind == ND_BITXOR ||
    e.kind == ND_SHL    ||
    e.kind == ND_SHR    ||
    e.kind == ND_EQ     ||
    e.kind == ND_NE     ||
    e.kind == ND_LT     ||
    e.kind == ND_LE     ||
    e.kind == ND_GT     ||
    e.kind == ND_GE     ||
    e.kind == ND_LOGAND ||
    e.kind == ND_LOGOR   )  ? (is_const_expr e.a  && is_const_expr e.a.s                           ) :
  ( e.kind == ND_COND    )  ? (is_const_expr e.cond && is_const_expr (!!eval e.cond ? e.then : e.els)) :
  ( e.kind == ND_NUM     ) ;;
export const_expr(k@@ Token) int64_t = return eval tertiary k;;
eval_double(e@ Node) double = return
  add_type e ;:
  is_integer e.t ? cast double eval e :
  (e.kind == ND_ADD  )  ? (  eval_double e.a  + eval_double      e.a.s ) :
  (e.kind == ND_SUB  )  ? (  eval_double e.a  - eval_double      e.a.s ) :
  (e.kind == ND_MUL  )  ? (  eval_double e.a  * eval_double      e.a.s ) :
  (e.kind == ND_DIV  )  ? (  eval_double e.a  / eval_double      e.a.s ) :
  (e.kind == ND_NEG  )  ?   -eval_double e.a                             :
  (e.kind == ND_NUM  )  ?    cast double e.fval                            :
  (e.kind == ND_COND )  ?  !!eval_double e.cond ? eval_double      e.then  :
                                                  eval_double      e.els   :
  (e.kind == ND_THE ||
   e.kind == ND_CAST )  ?  is_flonum e.a.t   ? eval_double      e.a   :
                                                  cast double eval e.a   :
  (error_tok e.j "not a compile-time constant") ;:
  0.0;;






// ######  #    #  #####   #####   ######   ####    ####   #   ####   #    # 
// #        #  #   #    #  #    #  #       #       #       #  #    #  ##   # 
// #####     ##    #    #  #    #  #####    ####    ####   #  #    #  # #  # 
// #         ##    #####   #####   #            #       #  #  #    #  #  # # 
// #        #  #   #       #   #   #       #    #  #    #  #  #    #  #   ## 
// ######  #    #  #       #    #  ######   ####    ####   #   ####   #    # 

lvar_jack (k @@Token t @Type) @Obj = return cast @Obj 0                   ;;
lvar_anon (k @@Token t @Type) @Obj = return new_lvar new_unique_name     t;;
lvar_non  (k @@Token t @Type) @Obj = return new_lvar get_ident advance k t;;

nullary        (k @@Token          op @char                                 new_@ (j @Token                               ) @Node                        ) @Node = return equal k@ op && (advance k is j                                 new_@ j                             );;
nullary_type   (k @@Token          op @char                                 new_@ (j @Token                 t @Type       ) @Node                        ) @Node = return equal k@ op && (advance k is j type_suffix k is t              new_@ j           t                 );;
unary          (k @@Token          op @char                                 new_@ (j @Token a @Node                       ) @Node s@ (k @@Token) @Node) @Node = return equal k@ op && (advance k is j                                 new_@ j   s@ k                   );;

unary_type     (k @@Token          op @char                                 new_@ (j @Token a @Node         t @Type       ) @Node s@ (k @@Token) @Node) @Node = return equal k@ op && (advance k is j type_suffix k is t              new_@ j   s@ k t                 );;
binary_right   (k @@Token a @@Node op @char                                 new_@ (j @Token a @Node b @Node               ) @Node b @ (k @@Token) @Node) bool  = return equal k@ op && (advance k is j                          (a@ =  new_@ j a@ b@ k) ;: true            );;
binary_left    (k @@Token a @Node  op @char                                 new_@ (j @Token a @Node b @Node               ) @Node s@ (k @@Token) @Node) @Node = return equal k@ op && (advance k is j                                 new_@ j a s@ k                   );;
binary_left_var(k @@Token a @Node  op @char lvar_@ (k @@Token t @Type) @Obj new_@ (j @Token a @Node b @Node         o @Obj) @Node s@ (k @@Token) @Node) @Node = return equal k@ op && (advance k is j enter_scope ;: lvar_@ k a.t is o new_@ j a s@ k   o :; leave_scope);;

left(k @@Token op @char parse_@ (k @@Token) @Node) @Node = return
equal k@ op && parse_@ k;;
right(k @@Token a @Node op @char parse_@ (k @@Token a @Node) @Node) @Node = return
equal k@ op && parse_@ k a;;

array_access(k @@Token a @Node) @Node = return
   advance k is j
   infix k is b
   expect k "]" ;:
   new_unary ND_DEREF new_add j a b j;;

member_access(k @@Token a @Node) @Node = return
   add_type a
;: advance k is j
   (a = new_deref_all j a)
;:(  a.t.kind != TY_STRUCT
  && a.t.kind != TY_UNION
  &&(  format_types a.t ty_void
    ;: error_tok j "(%s . %.*s) must be of the form (@*struct . %.*s)" s1 k.s.len k.s.loc k.s.len k.s.loc ) as void)
;: get_struct_member a.t advance k is g
  (  !g
  &&(  format_types a.t ty_void
    ;: error_tok j "(%s . %.*s) no such member" s1 k.s.len k.s.loc ) as void)
;: new_member_reference j a g;;

nonee      (k @@Token        ) @Node = return advance k is j                                                                                                        new_none        j                      ;;
falsee     (k @@Token        ) @Node = return advance k is j                                                                                                        new_false       j                      ;;
truee      (k @@Token        ) @Node = return advance k is j                                                                                                        new_true        j                      ;;
sizee      (k @@Token        ) @Node = return advance k is j type_suffix k is t                                                                                     new_sizeof      j t                    ;;
aligne     (k @@Token        ) @Node = return advance k is j type_suffix k is t                                                                                     new_alignof     j t                    ;;
deref      (k @@Token a @Node) @Node = return advance k is j                                                                                                        new_deref       j a                    ;;
addressof  (k @@Token        ) @Node = return advance k is j                                                          secondary k is a                              new_addressof   j a                    ;;
theorem    (k @@Token        ) @Node = return advance k is j type_suffix k is t                                        tertiary k is a                              new_the         j a t                  ;;
axiom      (k @@Token        ) @Node = return advance k is j type_suffix k is t                                        tertiary k is a                              new_cast        j a t                  ;;
neg        (k @@Token        ) @Node = return advance k is j                                                           tertiary k is a                              new_neg         j a                    ;;
lognot     (k @@Token        ) @Node = return advance k is j                                                           tertiary k is a                              new_lognot      j a                    ;;
bitnot     (k @@Token        ) @Node = return advance k is j                                                           tertiary k is a                              new_bitnot      j a                    ;;
shitrepeat (k @@Token        ) @Node = return advance k is j                                                           tertiary k is a                              new_until       j a                    ;;
then       (k @@Token a @Node) @Node = return advance k is j                                                                seq k is b                              new_then        j a b                  ;;
neth       (k @@Token a @Node) @Node = return advance k is j                                                                seq k is b                              new_neth        j a b                  ;;
conditional(k @@Token a @Node) @Node = return advance k is j                                                                seq k is b  expect k ":" ;: seq k is c  new_conditional j a b c                ;;
islet      (k @@Token a @Node) @Node = return advance k is j enter_scope ;: new_lvar get_ident advance k a.t is o          seq k is b                              new_let         j a b o :; leave_scope ;;
repeat     (k @@Token a @Node) @Node = return advance k is j enter_scope ;: new_lvar get_ident advance k a.t is o          seq k is b                              new_repeat      j a b o :; leave_scope ;;

secondary(k @@Token) @Node = return
   left    k       "cast"    &axiom
|| left    k       "the"     &theorem
|| left    k       "&"       &addressof
|| left    k       "sizeof"  &sizee
|| left    k       "alignof" &aligne
|| left    k       "none"    &nonee
|| left    k       "false"   &falsee
|| left    k       "true"    &truee
|| primary k for a
(  right   k     a "["       &array_access
|| right   k     a "."       &member_access
|| right   k     a "@"       &deref
 ) ;;

tertiary_left(k @@Token) @Node = return
(  left k "-"     &neg
|| left k "!"     &lognot
|| left k "~"     &bitnot
|| left k "until" &shitrepeat
 ) ;;

seq(k @@Token) @Node = return 
  tertiary k is a
(  right k a ":;"  &then
|| right k a ";:"  &neth
|| right k a "is"  &islet
|| right k a "for" &repeat
|| right k a "?"   &conditional
|| a
 ) ;;

quaternary_right(k @@Token a @@Node) bool = return
&binary_right is f
(  f@ k a  "+=" &new_add    &infix
|| f@ k a  "-=" &new_sub    &infix
|| f@ k a  "*=" &new_mul    &infix
|| f@ k a  "/=" &new_div    &infix
|| f@ k a  "%=" &new_mod    &infix
|| f@ k a  "&=" &new_bitand &infix
|| f@ k a  "|=" &new_bitor  &infix
|| f@ k a  "^=" &new_bitxor &infix
|| f@ k a "||=" &new_logor  &infix
|| f@ k a "&&=" &new_logand &infix
|| f@ k a "<<=" &new_shl    &infix
|| f@ k a ">>=" &new_shr    &infix
 ) ;;

primary(k @@Token) @Node = return
  ( equal k@ "new" ?
      advance k is j
      type_suffix k is t
      (!scope.s ?
        new_anon_gvar t is o
        gvar_initializer k o ;:
        new_reference o j :
      new_lvar "" t is o
      new_binary ND_COMMA lvar_initializer k o new_reference o k@ j) :
    consume k k@ "(" ? quaternary k :; expect k ")" :
    (k.kind == TK_IDENT) ?
      cast @VarScope search_scope k@ &scope_vars is sc
      (k@ = k.s) ;:
      (!!sc ?
        ( !!sc.var && sc.var.is_function &&
          ( &current_fn.refs is a
            (!!current_fn ? strarray_push a sc.var.name :
            ( sc.var.is_root = true ) ) ) as void) ;:
        !!sc.var     ? new_reference sc.var k@                   :
        !!sc.enum_ty ? new_lit cast long sc.enum_val  k@ sc.enum_ty :
        (error_tok k@ "internal compiler error") ;: cast @Node 0   :
      (error_tok k@ "lookup failed") ;: cast @Node 0) :
    (k.kind == TK_STR) ?
      new_string_literal k.str cast @Type k.t  is o
      new_cast k@ new_the k@ new_reference o k@ o.t pointer_to (cast @Type k.t ).base is e
      (k@ = k.s) ;: e :
    (k.kind == TK_NUM) ?
      (  is_flonum cast @Type k.t
        ? new_node ND_NUM k@ is e (e.fval = k.fval) ;: (e.t = k.t as @Type) ;: e
        : new_lit k.val k@ cast @Type k.t) is e (k@ = k.s) ;: e :
    (error_tok k@ "expected an expression") ;: cast @Node 0);;

tertiary(k @@Token) @Node = return
  tertiary_left k ||
  (  secondary k is a
    ( until !(add_type a ;: a.t.kind == TY_FUNC &&
      ( a.t is t
        t.params is u
        new Node {; is head
        &head is cur
        ( cast until !((!!u || t.is_variadic && ! equal k@ ")") &&
          ( tertiary k is b
            add_type b ;:
            ( !!u && (
              ( !type_equal b.t u &&
                ( format_types b.t u ;:
                  ( error_tok k@ "asymmetric argument from %s to %s" s1 s2 ) ) as void) ;:
              (u = u.s) ) as void) ;:
            (cur.s = b) ;:
            (cur = cur.s)))) ;:
        ( !!u && (error_tok k@ "not enough arguments") as void) ;:
        new_unary ND_FUNCALL a k@ is e
        (e.func_ty =    t          ) ;:
        (e.t      =    t.return_ty) ;:
        (e.args    = head.s     ) ;:
        ( (e.t.kind == TY_STRUCT || e.t.kind == TY_UNION) &&
          (e.ret_buffer = new_lvar "" e.t) as void) ;:
        (a = e))) as) ;:
    a);;


mul        (k @@Token) @Node = return seq        k for a (  binary_left k a "*"  &new_mul    &seq
                                                         || binary_left k a "/"  &new_div    &seq
                                                         || binary_left k a "%"  &new_mod    &seq        ) ;;
add        (k @@Token) @Node = return mul        k for a (  binary_left k a "+"  &new_add    &mul
                                                         || binary_left k a "-"  &new_sub    &mul        ) ;;
shift      (k @@Token) @Node = return add        k for a (  binary_left k a "<<" &new_shl    &add
                                                         || binary_left k a ">>" &new_shr    &add        ) ;;
relational (k @@Token) @Node = return shift      k for a (  binary_left k a "<"  &new_lt     &shift
                                                         || binary_left k a ">"  &new_gt     &shift
                                                         || binary_left k a "<=" &new_le     &shift
                                                         || binary_left k a ">=" &new_ge     &shift
                                                         || binary_left k a "==" &new_eq     &shift
                                                         || binary_left k a "!=" &new_neq    &shift      ) ;;
bitand     (k @@Token) @Node = return relational k for a (  binary_left k a "&"  &new_bitand &relational ) ;;
bitxor     (k @@Token) @Node = return bitand     k for a (  binary_left k a "^"  &new_bitxor &bitand     ) ;;
bitor      (k @@Token) @Node = return bitxor     k for a (  binary_left k a "|"  &new_bitor  &bitxor     ) ;;
logand     (k @@Token) @Node = return bitor      k for a (  binary_left k a "&&" &new_logand &bitor      ) ;;
logor      (k @@Token) @Node = return logand     k for a (  binary_left k a "||" &new_logor  &logand     ) ;;

infix(k @@Token) @Node = return
  logor k for a ( equal k@ "as" && ( advance k is j new_cast j a type_suffix k ) ) ;;
quaternary(k @@Token) @Node = return
   infix k is a
        k@ is j
  equal j "=" ? advance k is j new_assign j a infix k :
  (quaternary_right k &a && new_cassign j a || a);;


































struct_members(k @@Token t @Type)  =
  let
    head = new Member{;
    cur = &head
    idx = 0;
  while ! consume k k@ "}" {
    let v = &new VarAttr {;;
    declspec k v;
    while ! consume k k@ ";" {
      let g = (calloc 1ul sizeof Member as @Member);
      (g.t = declarator k as @);
      (g.name = (cast @Type the @ g.t).name);
      (g.idx = (idx :; (idx += 1)));
      (g.alignment = v.alignment || (cast @Type g.t ).alignment);
      if consume k k@ ":" {
        (g.is_bitfield = true);
        (g.bit_width = const_expr k as int);;
      (cur.s = g);
      (cur = cur.s);;;
  if (cur != &head && (cast @Type cur.t ).kind == TY_ARRAY && (cast @Type cur.t ).array_len < 0) {
    (cur.t = array_of (cast @Type cur.t ).base 0 as @);
    (t.is_flexible = true);;
  (t.members = head.s);;

struct_union_decl(k @@Token) @Type = return
  struct_type is t
  cast @Token 0 is tag
  (( k.kind == TK_IDENT &&
    ( (tag = k@    )  ;:
      ( k@ = k.s) ) as void) ;:
  (!!tag && ! equal k@ "{") ?
    cast @Type search_scope tag &scope_tags is t2
    ( t2 ||
      ( (t.size = -1) ;:
        push_tag_scope tag t ;:
        t) ) :
  expect k "{" ;:
  (current_type = t) ;:
  struct_members k t ;:
  (current_type = 0 as @Type) ;:
  !!tag ?
    cast @Type hashmap_get2 &scope.tags tag.loc tag.len is t2
    (!!t2 ? (t2@ = t@) ;: t2 :
    push_tag_scope tag t ;: t) :
  t);;
struct_decl(k @@Token) @Type =
  let t = struct_union_decl k;
  (t.kind = TY_STRUCT);
  if (t.size < 0) return t;
  let bits = 0;
  for (let g@ Member = t.members; g; g = g.s) {
    if (g.is_bitfield && g.bit_width == 0) (bits = align_to bits ((cast @Type g.t ).size * 8));
    else if g.is_bitfield {
      let sz = (cast @Type g.t ).size;
      if (bits / (sz * 8) != (bits + g.bit_width - 1) / (sz * 8)) {
        (bits = align_to bits (sz * 8));;
      (g.offset = align_down (bits / 8) sz);
      (g.bit_offset = bits % (sz * 8));
      (bits += g.bit_width);;
    else {
      if !t.is_packed (bits = align_to bits (g.alignment * 8));
      (g.offset = bits / 8);
      (bits += (cast @Type g.t ).size * 8);;
    if (!t.is_packed && t.alignment < g.alignment)
      (t.alignment = g.alignment);;
  (t.size = align_to bits (t.alignment * 8) / 8);
  return t;;
union_decl(k @@Token) @Type =
  let t = struct_union_decl k;
  (t.kind = TY_UNION);
  if (t.size < 0) return t;
  for (let g@ Member = t.members; g; g = g.s) {
    if (t.alignment < g.alignment) (t.alignment = g.alignment);
    if (t.size < (cast @Type g.t ).size) (t.size = (cast @Type g.t ).size);;
  (t.size = align_to t.size t.alignment);
  return t;;
get_struct_member(t @Type j @Token) @Member =
  for (let g@ Member = t.members; g; g = g.s) {
    if (((cast @Type g.t ).kind == TY_STRUCT || (cast @Type g.t ).kind == TY_UNION) && (!g.name || equal g.name "_")) {
      if get_struct_member cast @Type g.t j return g;;
    else if (g.name.len == j.len && ! strncmp cast @  g.name.loc j.loc cast unsigned long j.len ) return g;;
  return 0 as @Member;;
typedecl(j @Token) @Token = return
  j for j
  (  !equal j ";" &&
    (  declarator &j is t
       (!t.name && (error_tok t.name_pos "type name may not be omitted in type alias declaration") as void)
    ;: ((push_scope get_ident t.name).type_def = t)
    ;: j ) );;
create_param_lvars(param@ Type) = return
  !!param ?
    create_param_lvars param.s ;:
    !param.name ?
      (error_tok param.name_pos "parameter name omitted") :
    (new_lvar get_ident param.name param as) :
  none;;
find_func(name @char) @Obj = return
  cast @VarScope hashmap_get &(scope for s s.s).vars name is s
  (!!s && s.var.is_function && s.var);;
mark_live(o@ Obj) = return
    o.is_function
  && !o.is_live
  && (o.is_live = true)
  :; cast void
    ( 0 for i
      ( i != o.refs.len && (i + 1)
      :; find_func o.refs.data[i] is o2
        (o2 && mark_live o2 as void) ) )
  as void;;
function(k @@Token attr @VarAttr) = return
  declarator k is t
  ((!t.name || equal t.name "_") && (error_tok t.name_pos "function name omitted") as void) ;:
  get_ident t.name is name_str
  find_func name_str is o
  ( !!o ?
      (!o.is_function                  && (error_tok k@ "redeclared as a different kind of symbol") as void) ;:
      (o.is_definition && equal k@ "=" && (error_tok k@ "redefinition of %s" name_str) as void) ;:
      (o.is_export != attr.is_export   && (error_tok k@ "mismatched visibility") as void) ;:
      (o.is_definition = o.is_definition || equal k@ "=") :
    (o = new_gvar name_str t) ;:
    (o.is_function = true) ;:
    (o.is_definition = equal k@ "=") ;:
    (o.is_export = attr.is_export)  ;:
    (o.is_inline = attr.is_inline) ) ;:
  ( o.is_root = o.is_export || !o.is_inline ) ;:
  (equal k@ ";" ? none :
  (current_fn = o) ;:
  (locals = 0 as @Obj) ;:
  enter_scope ;:
  create_param_lvars t.params ;:
  t.return_ty is rty
  (((rty.kind == TY_STRUCT || rty.kind == TY_UNION) && rty.size > 16) && new_lvar "" pointer_to rty as) ;:
  (o.params = locals) ;:
  (t.is_variadic && (o.va_area = new_lvar "__va_area__" array_of ty_char 136) as void) ;:
  (o.alloca_bottom = new_lvar "__alloca_size__" pointer_to ty_char) ;:
  expect k "=" ;:
  (o.body = compound_stmt k as @) ;:
  (o.locals = locals) ;:
  leave_scope ;: none);;
global_variable(j@ Token attr@ VarAttr)@ Token =
  let k = &j;
  let first = true;
  while ! consume k j ";" {
    (first = false);
    let t = declarator k;
    if !(!t.name || equal t.name "_") {
      let var = new_gvar get_ident t.name t;
      (var.is_definition = !attr.is_extern);
      (var.is_export = attr.is_export);
      (var.is_inline = attr.is_inline);
      (var.is_tls = attr.is_tls);
      if attr.alignment (var.alignment = attr.alignment);
      if equal j "=" {
        (j = j.s);
        gvar_initializer k var;;
      else if (!attr.is_extern && !attr.is_tls) (var.is_tentative = true);;;
  return j;;
is_function(j @Token) bool = return
  ! equal j ";" &&
  (declarator &j).kind == TY_FUNC;;
scan_globals(void) =
  let
    head = new Obj{;
    cur = &head;
  for (let o@ Obj = globals; o; o = o.s) {
    if !o.is_tentative {
      (cur.s = o);
      (cur = cur.s);;
    else {
      let o2 = globals;
      for (; o2; o2 = o2.s) if (o != o2 && o2.is_definition && ! strcmp cast @ o.name o2.name) break;
      if !o2 { (cur.s = o); (cur = cur.s);;;;
  (cur.s = 0 as @Obj);
  (globals = head.s);;
export parse(j @Token) @Obj = return
  (locals         = cast @Obj   0) ;:
  (globals        = cast @Obj   0) ;:
  (scope          = &new Scope {;) ;:
  (current_type   = cast @Type  0) ;:
  (current_fn     = cast @Obj   0) ;:
  (gotos          = cast @Node  0) ;:
  (labels         = cast @Node  0) ;:
  (brk_label      = cast @char  0) ;:
  (cont_label     = cast @char  0) ;:
  (current_switch = cast @Node  0) ;:
  (builtin_alloca = cast @Obj   0) ;:
  (j = j for j (j.kind != TK_EOF && 
    new VarAttr {; is v
    declspec &j &v ;:
    v.is_type     ? typedecl j          :
    is_function j ? function &j &v ;: j :
    global_variable j &v)) ;:
  cast void
  ( globals for v
    ( !!v && v.s :; (v.is_root && mark_live v as void) ) ) ;:
  scan_globals ;:
  globals;;