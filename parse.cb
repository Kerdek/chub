#include "chub.hb"

type
  Scope       struct Scope
  Initializer struct Initializer
  InitDesg    struct InitDesg
  VarScope    struct VarScope
  VarAttr     struct VarAttr
;

_ struct VarScope {
  var@ Obj
  type_def@ Type
  enum_ty@ Type
  enum_val int;
}

_ struct Scope {
  next@ Scope
  vars HashMap
  tags HashMap;
}

_ struct VarAttr {
  is_type   bool
  is_static bool
  is_extern bool
  is_export bool
  is_inline bool
  is_tls    bool
  alignment  int;
}

_ struct Initializer {
  next@       Initializer
  ty@                Type
  tok@              Token
  is_flexible        bool
  expr@              Node
  children@@  Initializer
  mem@             Member;
}

_ struct InitDesg {
  next@   InitDesg
  idx          int
  member@   Member
  var@         Obj;
};


// All local variable instances created during parsing are
// accumulated to this list.
locals@ Obj
// Likewise, global variables are accumulated to this list.
globals@ Obj
scope@ Scope = &(let Scope){;

current_type @Type

// Points to the function object the parser is currently parsing.
current_fn@ Obj

// Lists of all goto statements and labels in the curent function.
gotos@ Node
labels@ Node

// Current "goto" and "continue" jump targets.
brk_label@ char
cont_label@ char

// Points to a node representing a switch if we are parsing
// a switch statement. Otherwise, NULL.
current_switch@ Node

builtin_alloca@ Obj

add                (k @@Token) @Node
compound_stmt      (k @@Token) @Node
expr_stmt          (k @@Token) @Node
expr               (k @@Token) @Node
assign             (k @@Token) @Node
conditional        (k @@Token) @Node
postfix            (k @@Token) @Node
unary              (k @@Token) @Node
primary            (k @@Token) @Node
cast               (k @@Token) @Node

enum_specifier     (k @@Token) @Type
typeof_specifier   (k @@Token) @Type
type_suffix        (k @@Token) @Type
declarator         (k @@Token) @Type
struct_decl        (k @@Token) @Type
union_decl         (k @@Token) @Type

parse_type         (k  @Token) @Token
is_function        (k  @Token) bool

declspec           (k @@Token   attr @VarAttr)
declaration        (k @@Token   attr @VarAttr) @Node
function           (k  @Token   attr @VarAttr) @Token
global_variable    (k  @Token   attr @VarAttr) @Token

funcall            (k @@Token   node @Node) @Node

array_initializer2 (rest @@Token  tok     @Token init@ Initializer i int      )
struct_initializer2(rest @@Token  tok     @Token init@ Initializer mem@ Member)
initializer2       (rest @@Token  tok     @Token init@ Initializer            )
initializer        (rest @@Token  tok     @Token ty   @Type new_ty @@Type     ) @Initializer
lvar_initializer   (rest @@Token  tok     @Token var  @Obj                    ) @Node
gvar_initializer   (rest @@Token  tok     @Token var  @Obj                    )

eval               (node  @Node                                               ) int64_t
eval2              (node  @Node   label @@@char                               ) int64_t
eval_rval          (node  @Node   label @@@char                               ) int64_t
is_const_expr      (node  @Node                                               ) bool
eval_double        (node  @Node                                               ) double
new_add            (lhs   @Node   rhs @Node  tok@ Token                       ) @Node
new_sub            (lhs   @Node   rhs @Node  tok@ Token                       ) @Node
get_struct_member  (ty    @Type   tok @Token                                  ) @Member;

align_down(n int alignment int) int = return align_to(
  n - alignment + 1
  alignment);;

enter_scope(void) = let sc = calloc(1 sizeof Scope)->@Scope; sc@.next = scope; scope = sc;;

leave_scope(void) = scope = scope@.next;;

search_scope(tok @Token which(_@ Scope)@ )@  = for (let sc@ Scope = scope; sc; sc = sc@.next) { let sc2 = hashmap_get2(which(sc) tok@.loc tok@.len); if sc2 return sc2; ; return 0; ;

scope_vars(s @Scope) @HashMap = return &s@.vars;;
scope_tags(s @Scope) @HashMap = return &s@.tags;;

new_node(kind NodeKind tok @Token) @Node =
  let node = calloc(1 sizeof Node)->@Node;
  node@.kind = kind;
  node@.tok = tok;
  return node;
;

new_binary(kind NodeKind lhs @Node rhs @Node tok @Token) @Node =
  let node = new_node(kind tok);
  node@.lhs = lhs;
  node@.rhs = rhs;
  return node;
;

new_unary(kind NodeKind expr @Node tok @Token) @Node =
  let node = new_node(kind tok);
  node@.lhs = expr;
  return node;
;

new_num(val int64_t tok @Token) @Node =
  let node = new_node(ND_NUM tok);
  node@.val = val;
  return node;
;

new_long(val int64_t tok @Token) @Node =
  let node = new_node(ND_NUM tok);
  node@.val = val;
  node@.ty = ty_long;
  return node;
;

new_ulong(val long tok @Token) @Node =
  let node = new_node(ND_NUM tok);
  node@.val = val;
  node@.ty = ty_ulong;
  return node;
;

new_var_node(var @Obj tok @Token) @Node =
  let node = new_node(ND_VAR tok);
  node@.var = var;
  return node;
;

export new_cast(expr@ Node ty@ Type)@ Node =
  add_type(expr);

  let node = calloc(1 sizeof Node)->@Node;
  node@.kind = ND_CAST;
  node@.tok = expr@.tok;
  node@.lhs = expr;
  node@.ty = copy_type(ty);
  return node;
;

push_scope(name@ char)@ VarScope =
  let sc = calloc(1 sizeof VarScope)->@VarScope;
  hashmap_put(&scope@.vars name sc);
  return sc;
;

new_initializer(ty@ Type is_flexible bool)@ Initializer =
  let init = calloc(1 sizeof Initializer)->@Initializer;
  init@.ty = ty;

  if ty@.kind == TY_ARRAY {
    if is_flexible && ty@.size < 0 {
      init@.is_flexible = true;
      return init;
    ;

    init@.children = calloc(ty@.array_len sizeof@ Initializer);
    for (let i int = 0; i < ty@.array_len; i++)
      init@.children[i] = new_initializer(ty@.base false);
    return init;
  ;

  if ty@.kind == TY_STRUCT || ty@.kind == TY_UNION {
    // Count the number of struct members.
    let len = 0;
    for (let mem@ Member = ty@.members; mem; mem = mem@.next)
      len++;

    init@.children = calloc(len sizeof@ Initializer);

    for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
      if is_flexible && ty@.is_flexible && !mem@.next {
        let child = calloc(1 sizeof Initializer)->@ Initializer;
        child@.ty = mem@.ty;
        child@.is_flexible = true;
        init@.children[mem@.idx] = child;
      ; else {
        init@.children[mem@.idx] = new_initializer(mem@.ty false);
      ;
    ;
    return init;
  ;

  return init;
;

new_var(name@ char ty@ Type)@ Obj =
  let var = calloc(1 sizeof Obj)->@Obj;
  var@.name = name;
  var@.ty = ty;
  var@.alignment = ty@.alignment;
  push_scope(name)@.var = var;
  return var;
;

new_lvar(name@ char ty@ Type)@ Obj =
  let var = new_var(name ty);
  var@.is_local = true;
  var@.next = locals;
  locals = var;
  return var;
;

new_gvar(name@ char ty@ Type)@ Obj =
  let var = new_var(name ty);
  var@.next = globals;
  var@.is_export = false;
  var@.is_definition = true;
  globals = var;
  return var;
;

nunid int = 0;
new_unique_name(void)@ char =
  return format(".L..%d" nunid++);
;

new_anon_gvar(ty@ Type)@ Obj =
  return new_gvar(new_unique_name() ty);
;

new_string_literal(p@ char ty@ Type)@ Obj =
  let var = new_anon_gvar(ty);
  var@.init_data = p;
  return var;
;

get_ident(tok@ Token)@ char =
  if tok@.kind != TK_IDENT error_tok(tok "expected an identifier");
  return strndup(tok@.loc tok@.len);
;

find_type(tok@ Token)@ Type =
  if tok@.kind == TK_IDENT {
    let sc = search_scope(tok scope_vars)->@VarScope;
    if sc return sc@.type_def;
  ;
  return NULL;
;

push_tag_scope(tok@ Token ty@ Type)  =
  hashmap_put2(&scope@.tags tok@.loc tok@.len ty);
;

declspec(rest @@Token attr@ VarAttr)  =
  let tok = rest@;
  for (;;) {
    if equal(tok "type") || equal(tok "static") || equal(tok "export") || equal(tok "extern") ||
        equal(tok "inline") || equal(tok "_Thread_local") || equal(tok "__thread") {
      if !attr
        error_tok(tok "storage class specifier is not allowed in this context");

      (
        equal(tok "type"  ) ? &attr@.is_type   :
        equal(tok "export") ? &attr@.is_export :
        equal(tok "static") ? &attr@.is_static :
        equal(tok "extern") ? &attr@.is_extern :
        equal(tok "inline") ? &attr@.is_inline :
        &attr@.is_tls
      )@ = true;

      if (attr@.is_type &&
          attr@.is_static + attr@.is_export + attr@.is_extern + attr@.is_inline + attr@.is_tls > 1)
        error_tok(tok "type may not be used together with export, static,"
                  " extern, inline, __thread or _Thread_local");
      tok = tok@.next;
      continue;
    ;

    if equal(tok "align") {
      if !attr
        error_tok(tok "align is not allowed in this context");
      tok = tok@.next;
      attr@.alignment = const_expr(&tok tok);
      continue;
    ;

    if consume(&tok tok "restrict") continue;

    rest@ = tok;
    return;
  ;
;

type_specifier(tok @@Token)@ Type =
  if equal(tok@ "struct") {
    tok@ = tok@@.next;
    return struct_decl(tok);
  ;
  else if equal(tok@ "union") {
    tok@ = tok@@.next;
    return union_decl(tok);
  ;
  else if equal(tok@ "enum") {
    tok@ = tok@@.next;
    return enum_specifier(tok);
  ;
  else if equal(tok@ "typeof") {
    tok@ = tok@@.next;
    return typeof_specifier(tok);
  ;
  else if equal(tok@ "same") {
    tok@ = tok@@.next;
    if !current_type error_tok(tok@ "`same` may not be used outside struct/union definition");
    return current_type;
  ;
  else {
    let ty2 = find_type(tok@);
    if ty2{
      tok@ = tok@@.next;
      return ty2;
    ;
    else {
      let counter = 0->enum 
        BOOL     = 1 << 2
        CHAR     = 1 << 4
        SHORT    = 1 << 6
        INT      = 1 << 8
        LONG     = 1 << 10
        FLOAT    = 1 << 12
        DOUBLE   = 1 << 14
        SIGNED   = 1 << 17
        UNSIGNED = 1 << 18;;

      for (;;) {
        if equal(tok@ "_Bool")
          counter += BOOL;
        else if equal(tok@ "char")
          counter += CHAR;
        else if equal(tok@ "short")
          counter += SHORT;
        else if equal(tok@ "int")
          counter += INT;
        else if equal(tok@ "long")
          counter += LONG;
        else if equal(tok@ "float")
          counter += FLOAT;
        else if equal(tok@ "double")
          counter += DOUBLE;
        else if equal(tok@ "signed")
          counter |= SIGNED;
        else if equal(tok@ "unsigned")
          counter |= UNSIGNED;
        else
          break;
        tok@ = tok@@.next;
      ;
      switch (counter) {
      case 0:
        return ty_void;
      case BOOL:
        return ty_bool;
      case CHAR:
      case SIGNED + CHAR:
        return ty_char;
      case UNSIGNED + CHAR:
        return ty_uchar;
      case SHORT:
      case SHORT + INT:
      case SIGNED + SHORT:
      case SIGNED + SHORT + INT:
        return ty_short;
      case UNSIGNED + SHORT:
      case UNSIGNED + SHORT + INT:
        return ty_ushort;
      case INT:
      case SIGNED:
      case SIGNED + INT:
        return ty_int;
      case UNSIGNED:
      case UNSIGNED + INT:
        return ty_uint;
      case LONG:
      case LONG + INT:
      case LONG + LONG:
      case LONG + LONG + INT:
      case SIGNED + LONG:
      case SIGNED + LONG + INT:
      case SIGNED + LONG + LONG:
      case SIGNED + LONG + LONG + INT:
        return ty_long;
      case UNSIGNED + LONG:
      case UNSIGNED + LONG + INT:
      case UNSIGNED + LONG + LONG:
      case UNSIGNED + LONG + LONG + INT:
        return ty_ulong;
      case FLOAT:
        return ty_float;
      case DOUBLE:
        return ty_double;
      case LONG + DOUBLE:
        return ty_ldouble;
      default:
        error_tok(tok "invalid type");
      ;
    ;
  ;
;

func_params(rest @@Token tok@ Token)@ Type =
  if equal(tok "void") && consume(&tok tok@.next ")") {
    rest@ = tok;
    return func_type(type_suffix(rest));
  ;

  let
    head = (let Type){;
    cur = &head
    is_variadic = false;

  while !equal(tok ")") {

    if consume(&tok tok "...") {
      is_variadic = true;
      break;
    ;

    declspec(&tok 0);
    let ty2 = declarator(&tok);

    let name = ty2@.name;

    if ty2@.kind == TY_ARRAY {
      // "array of T" is converted to "pointer to T" only in the parameter
      // context. For example, argv[]@ is converted to argv@@ by this.
      ty2 = pointer_to(ty2@.base);
      ty2@.name = name;
    ; else if ty2@.kind == TY_FUNC {
      // Likewise, a function is converted to a pointer to a function
      // only in the parameter context.
      ty2 = pointer_to(ty2);
      ty2@.name = name;
    ;

    cur = cur@.next = copy_type(ty2);
  ;

  if cur == &head
    is_variadic = true;

  rest@ = tok@.next;
  let ty = func_type(type_suffix(rest));
  ty@.params = head.next;
  ty@.is_variadic = is_variadic;
  return ty;
;

array_dimensions(rest @@Token tok@ Token)@ Type =
  while equal(tok "static") || equal(tok "restrict")
    tok = tok@.next;

  if consume(&tok tok "]") {
    rest@ = tok;
    let ty = type_suffix(rest);
    return array_of(ty 0-1);
  ;

  let expr = conditional(&tok);
  expect(&tok "]");
  rest@ = tok;
  let ty = type_suffix(rest);

  return array_of(ty eval(expr));
;

type_suffix(rest @@Token)@ Type =
  let tok = rest@;
  while consume(&tok tok "const") || consume(&tok tok "volatile");

  if consume(&tok tok "(")
    return func_params(rest tok);

  if consume(&tok tok "[")
    return array_dimensions(rest tok);

  if consume(&tok tok "@") {
    rest@ = tok;
    return pointer_to(type_suffix(rest));
  ;

  rest@ = tok;
  return type_specifier(rest);
;

declarator(rest @@Token)@ Type =
  let tok = rest@;
  let name = tok;
  rest@ = tok@.next;
  let ty = type_suffix(rest);
  ty@.name = name;
  ty@.name_pos = name;
  return ty;
;

is_end(tok@ Token) bool =
  equal(tok ";");
;

consume_end(rest @@Token tok@ Token) bool =
  if equal(tok ";") {
    rest@ = tok@.next;
    return true;
  ;

  return false;
;

enum_specifier(k @@Token) @Type =
  let ty = enum_type();
  let val = 0;
  while !consume_end(k k@) {
    let name = get_ident(k@);
    k@ = k@@.next;
    if equal(k@ "=") {
      k@ = k@@.next;
      val = const_expr(k k@);
    ;
    let sc = push_scope(name)->@VarScope;
    sc@.enum_ty = ty;
    sc@.enum_val = val++;
  ;
  return ty;
;

// typeof-specifier = "(" (expr | typename) ")"
typeof_specifier(rest @@Token)@ Type =
  let tok = rest@;
  let ty = 0->@Type;
  let node = expr(&tok);
  add_type(node);
  ty = node@.ty;
  rest@ = tok;
  return ty;
;

new_alloca(sz@ Node)@ Node =
  let node = new_unary(ND_FUNCALL new_var_node(builtin_alloca sz@.tok) sz@.tok);
  node@.func_ty = builtin_alloca@.ty;
  node@.ty = builtin_alloca@.ty@.return_ty;
  node@.args = sz;
  add_type(sz);
  return node;
;

declaration(rest @@Token attr@ VarAttr)@ Node =
  let tok = rest@;
  let
    head = (let Node){;
    cur = &head;
  while !equal(tok ";") {
    let ty = declarator(&tok);
    if ty@.kind == TY_VOID error_tok(tok "variable declared void");
    if !ty@.name error_tok(ty@.name_pos "variable name omitted");
    if equal(ty@.name "_") continue;

    if attr && attr@.is_static {
      // static local variable
      let var = new_anon_gvar(ty);
      push_scope(get_ident(ty@.name))@.var = var;
      if equal(tok "=")
        gvar_initializer(&tok tok@.next var);
      continue;
    ;

    let var = new_lvar(get_ident(ty@.name) ty);
    if attr && attr@.alignment
      var@.alignment = attr@.alignment;

    if equal(tok "=") {
      let expr = lvar_initializer(&tok tok@.next var);
      cur = cur@.next = new_unary(ND_EXPR_STMT expr tok);
    ;

    if var@.ty@.size < 0
      error_tok(ty@.name "variable has incomplete type");
    if var@.ty@.kind == TY_VOID
      error_tok(ty@.name "variable declared void");
  ;

  let node = new_node(ND_BLOCK tok);
  node@.body = head.next;
  rest@ = tok@.next;
  return node;
;

skip_excess_element(tok@ Token)@ Token =
  if equal(tok "{") {
    tok = skip_excess_element(tok@.next);
    return skip(tok ";");
  ;

  assign(&tok);
  return tok;
;

string_initializer(rest @@Token tok@ Token init@ Initializer)  =
  if init@.is_flexible
    init@ = new_initializer(array_of(init@.ty@.base tok@.ty->@Type@.array_len) false)@;

  let len = minl(init@.ty@.array_len tok@.ty->@Type@.array_len);

  switch (init@.ty@.base@.size) {
  case 1: {
    let str = tok@.str;
    for (let i int = 0; i < len; i++)
      init@.children[i]@.expr = new_num(str[i] tok);
    break;
  ;
  case 2: {
    let str = tok@.str->@uint16_t;
    for (let i int = 0; i < len; i++)
      init@.children[i]@.expr = new_num(str[i] tok);
    break;
  ;
  case 4: {
    let str = tok@.str->@uint32_t;
    for (let i int = 0; i < len; i++)
      init@.children[i]@.expr = new_num(str[i] tok);
    break;
  ;
  default:
    unreachable();
  ;

  rest@ = tok@.next;
;

array_designator(rest @@Token tok@ Token ty@ Type begin@ int end@ int)  =
  tok = tok@.next;
  begin@ = const_expr(&tok tok);
  if begin@ >= ty@.array_len
    error_tok(tok "array designator index exceeds array bounds");

  if equal(tok "...") {
    end@ = const_expr(&tok tok@.next);
    if end@ >= ty@.array_len
      error_tok(tok "array designator index exceeds array bounds");
    if end@ < begin@
      error_tok(tok "array designator range [%d, %d] is empty" begin@ end@);
  ; else {
    end@ = begin@;
  ;

  rest@ = skip(tok "]");
;

struct_designator(rest @@Token tok@ Token ty@ Type)@ Member =
  let start = tok;
  expect(&tok ".");
  if tok@.kind != TK_IDENT
    error_tok(tok "expected a field designator");

  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    // Anonymous struct member
    if mem@.ty->@Type@.kind == TY_STRUCT && (!mem@.name || equal(mem@.name "_")) {
      if get_struct_member(mem@.ty tok) {
        rest@ = start;
        return mem;
      ;
      continue;
    ;

    // Regular struct member
    if mem@.name@.len == tok@.len && !strncmp(mem@.name@.loc tok@.loc tok@.len) {
      rest@ = tok@.next;
      return mem;
    ;
  ;

  error_tok(tok "struct has no such member");
;

// designation = ("[" const-expr "]" | "." ident)* "="? initializer
designation(rest @@Token tok@ Token init@ Initializer)  =
  if equal(tok "[") {
    if init@.ty@.kind != TY_ARRAY
      error_tok(tok "array index in non-array initializer");

    let
      begin = 0
      end = 0
      a = &begin
      b = &end;
    array_designator(&tok tok init@.ty a b);

    let tok2 = 0->@Token;
    for (let i int = begin; i <= end; i++)
      designation(&tok2 tok init@.children[i]);
    array_initializer2(rest tok2 init begin + 1);
    return;
  ;

  if equal(tok ".") && init@.ty@.kind == TY_STRUCT {
    let mem = struct_designator(&tok tok init@.ty);
    designation(&tok tok init@.children[mem@.idx]);
    init@.expr = NULL;
    struct_initializer2(rest tok init mem@.next);
    return;
  ;

  if equal(tok ".") && init@.ty@.kind == TY_UNION {
    let mem = struct_designator(&tok tok init@.ty);
    init@.mem = mem;
    designation(rest tok init@.children[mem@.idx]);
    return;
  ;

  if equal(tok ".")
    error_tok(tok "field name not in struct or union initializer");

  if equal(tok "=")
    tok = tok@.next;
  initializer2(rest tok init);
;

// An array length can be omitted if an array has an initializer
// (e.g. `x int[] = {1,2,3;`). If it's omitted, count the number
// of initializer elements.
count_array_init_elements(tok@ Token ty@ Type) int =
  let
    first = true
    dummy = new_initializer(ty@.base true)
    i = 0
    max = 0;

  while !consume_end(&tok tok) {
    if !first
      expect(&tok ",");
    first = false;

    if equal(tok "[") {
      i = const_expr(&tok tok@.next);
      if equal(tok "...")
        i = const_expr(&tok tok@.next);
      expect(&tok "]");
      designation(&tok tok dummy);
    ; else {
      initializer2(&tok tok dummy);
    ;

    i++;
    max = maxl(max i);
  ;
  return max;
;

// array-initializer1 = "{" initializer ("," initializer)* ","? ";"
array_initializer1(rest @@Token tok@ Token init@ Initializer)  =
  expect(&tok "{");

  if init@.is_flexible {
    let len = count_array_init_elements(tok init@.ty);
    init@ = new_initializer(array_of(init@.ty@.base len) false)@;
  ;

  let first = true;

  if init@.is_flexible {
    let len = count_array_init_elements(tok init@.ty);
    init@ = new_initializer(array_of(init@.ty@.base len) false)@;
  ;

  for (let i int = 0; !consume_end(rest tok); i++) {
    if !first
      expect(&tok ",");
    first = false;

    if equal(tok "[") {
      let
        begin = 0
        end = 0
        a = &begin
        b = &end;
      array_designator(&tok tok init@.ty a b);

      let tok2 = 0->@Token;
      for (let j int = begin; j <= end; j++)
        designation(&tok2 tok init@.children[j]);
      tok = tok2;
      i = end;
      continue;
    ;

    if i < init@.ty@.array_len
      initializer2(&tok tok init@.children[i]);
    else
      tok = skip_excess_element(tok);
  ;
;

// array-initializer2 = initializer ("" initializer)*
array_initializer2(rest @@Token tok@ Token init@ Initializer i int)  =
  if init@.is_flexible {
    let len = count_array_init_elements(tok init@.ty);
    init@ = new_initializer(array_of(init@.ty@.base len) false)@;
  ;

  for (; i < init@.ty@.array_len && !is_end(tok); i++) {
    let start = tok;
    if i > 0
      expect(&tok ",");

    if equal(tok "[") || equal(tok ".") {
      rest@ = start;
      return;
    ;

    initializer2(&tok tok init@.children[i]);
  ;
  rest@ = tok;
;

// struct-initializer1 = "{" initializer ("," initializer)* ","? ";"
struct_initializer1(rest @@Token tok@ Token init@ Initializer)  =
  expect(&tok "{");

  let
    mem = init@.ty@.members
    first = true;

  while !consume_end(rest tok) {
    if !first
      expect(&tok ",");
    first = false;

    if equal(tok ".") {
      mem = struct_designator(&tok tok init@.ty);
      designation(&tok tok init@.children[mem@.idx]);
      mem = mem@.next;
      continue;
    ;

    if mem {
      initializer2(&tok tok init@.children[mem@.idx]);
      mem = mem@.next;
    ; else {
      tok = skip_excess_element(tok);
    ;
  ;
;

// struct-initializer2 = initializer ("," initializer)*
struct_initializer2(rest @@Token tok@ Token init@ Initializer mem@ Member)  =
  let first = true;

  for (; mem && !is_end(tok); mem = mem@.next) {
    let start = tok;

    if !first
      expect(&tok ",");
    first = false;

    if equal(tok "[") || equal(tok ".") {
      rest@ = start;
      return;
    ;

    initializer2(&tok tok init@.children[mem@.idx]);
  ;
  rest@ = tok;
;

union_initializer(tok @@Token init@ Initializer)  =
  if equal(tok@ "{") && equal(tok@@.next ".") {
    let mem = struct_designator(tok tok@@.next init@.ty);
    init@.mem = mem;
    designation(tok tok@ init@.children[mem@.idx]);
    return;
  ;

  init@.mem = init@.ty@.members;

  if equal(tok@ "{") {
    initializer2(tok tok@@.next init@.children[0]);
  ; else {
    initializer2(tok tok@ init@.children[0]);
  ;
;

// initializer = string-initializer | array-initializer
//             | struct-initializer | union-initializer
//             | assign
initializer2(rest @@Token tok@ Token init@ Initializer)  =
  if init@.ty@.kind == TY_ARRAY && tok@.kind == TK_STR {
    string_initializer(rest tok init);
    return;
  ;

  if init@.ty@.kind == TY_ARRAY {
    if equal(tok "{")
      array_initializer1(rest tok init);
    else
      array_initializer2(rest tok init 0);
    return;
  ;

  if init@.ty@.kind == TY_STRUCT {
    if equal(tok "{") {
      struct_initializer1(rest tok init);
      return;
    ;

    // A struct can be initialized with another struct. E.g.
    // `struct T x = y;` where y is a variable of type `struct T`.
    // Handle that case first.
    rest@ = tok;
    let expr = assign(rest);
    add_type(expr);
    if expr@.ty@.kind == TY_STRUCT {
      init@.expr = expr;
      return;
    ;

    struct_initializer2(rest tok init init@.ty@.members);
    return;
  ;

  if init@.ty@.kind == TY_UNION {
    rest@ = tok;
    union_initializer(rest init);
    return;
  ;

  if equal(tok "{") {
    // An initializer for a scalar variable can be surrounded by
    // braces. E.g. `x int = {3;;`. Handle that case.
    initializer2(&tok tok@.next init);
    rest@ = skip(tok ";");
    return;
  ;

  rest@ = tok;
  init@.expr = assign(rest);
;

copy_struct_type(ty@ Type)@ Type =
  ty = copy_type(ty);

  let
    head = (let Member){;
    cur = &head;
  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    let m = calloc(1 sizeof Member)->@ Member;
    m@ = mem@;
    cur = cur@.next = m;
  ;

  ty@.members = head.next;
  return ty;
;

initializer(rest @@Token tok@ Token ty@ Type new_ty @@Type)@ Initializer =
  let init = new_initializer(ty true);
  initializer2(rest tok init);

  if ((ty@.kind == TY_STRUCT || ty@.kind == TY_UNION) && ty@.is_flexible) {
    ty = copy_struct_type(ty);

    let mem = ty@.members;
    while mem@.next
      mem = mem@.next;
    mem@.ty = init@.children[mem@.idx]@.ty;
    ty@.size += mem@.ty->@Type@.size;

    new_ty@ = ty;
    return init;
  ;

  new_ty@ = init@.ty;
  return init;
;

init_desg_expr(desg@ InitDesg tok@ Token)@ Node =
  if desg@.var
    return new_var_node(desg@.var tok);

  if desg@.member {
    let node = new_unary(ND_MEMBER init_desg_expr(desg@.next tok) tok);
    node@.member = desg@.member;
    return node;
  ;

  let lhs = init_desg_expr(desg@.next tok);
  let rhs = new_num(desg@.idx tok);
  return new_unary(ND_DEREF new_add(lhs rhs tok) tok);
;

create_lvar_init(init@ Initializer ty@ Type desg@ InitDesg tok@ Token)@ Node =
  if ty@.kind == TY_ARRAY {
    let node = new_node(ND_NULL_EXPR tok);
    for (let i int = 0; i < ty@.array_len; i++) {
      let
        desg2 = (let InitDesg){desg, i;
        c = &desg2
        rhs = create_lvar_init(init@.children[i] ty@.base c tok);
      node = new_binary(ND_COMMA node rhs tok);
    ;
    return node;
  ;

  if ty@.kind == TY_STRUCT && !init@.expr {
    let node = new_node(ND_NULL_EXPR tok);

    for (let mem @Member = ty@.members; mem; mem = mem@.next) {
      let
        desg2 = (let InitDesg){desg, 0, mem;
        c = &desg2
        rhs = create_lvar_init(init@.children[mem@.idx] mem@.ty c tok);
      node = new_binary(ND_COMMA node rhs tok);
    ;
    return node;
  ;

  if ty@.kind == TY_UNION {
    let
      mem = init@.mem ? init@.mem : ty@.members
      desg2 = (let InitDesg){desg, 0, mem;
      c = &desg2;
    return create_lvar_init(init@.children[mem@.idx] mem@.ty c tok);
  ;

  if !init@.expr
    return new_node(ND_NULL_EXPR tok);

  let lhs = init_desg_expr(desg tok);
  return new_binary(ND_ASSIGN lhs init@.expr tok);
;

// A variable definition with an initializer is a shorthand notation
// for a variable definition followed by assignments. This function
// generates assignment expressions for an initializer. For example,
// `x int[2][2] = {{6, 7;, {8, 9;;` is converted to the following
// expressions:
//
//   x[0][0] = 6;
//   x[0][1] = 7;
//   x[1][0] = 8;
//   x[1][1] = 9;
lvar_initializer(rest @@Token tok@ Token var@ Obj)@ Node =
  let
    d = &var@.ty
    init = initializer(rest tok var@.ty d)
    desg = (let InitDesg){NULL, 0, NULL, var;

  // If a partial initializer list is given, the standard requires
  // that unspecified elements are set to 0. Here, we simply
  // zero-initialize the entire memory region of a variable before
  // initializing it with user-supplied values.
    lhs = new_node(ND_MEMZERO tok);
  lhs@.var = var;

  let c = &desg;
  let rhs = create_lvar_init(init var@.ty c tok);
  return new_binary(ND_COMMA lhs rhs tok);
;

read_buf(buf@ char sz int) uint64_t = return 
  sz == 1 ? buf@             :
  sz == 2 ? buf->@ uint16_t@ :
  sz == 4 ? buf->@ uint32_t@ :
  sz == 8 ? buf->@ uint64_t@ :
  (unreachable() && 0);
;

write_buf(buf@ char val uint64_t sz int)  =
  sz == 1 ? buf@             = val :
  sz == 2 ? buf->@ uint16_t@ = val :
  sz == 4 ? buf->@ uint32_t@ = val :
  sz == 8 ? buf->@ uint64_t@ = val :
  (unreachable() && 0);
;

write_gvar_data(cur@ Relocation init@ Initializer ty@ Type buf@ char offset int)@ Relocation =
  if ty@.kind == TY_ARRAY {
    let sz = ty@.base@.size;
    for (let i int = 0; i < ty@.array_len; i++)
      cur = write_gvar_data(cur init@.children[i] ty@.base buf offset + sz * i);
    return cur;
  ;

  if ty@.kind == TY_STRUCT {
    for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
      if mem@.is_bitfield {
        let expr = init@.children[mem@.idx]@.expr;
        if !expr
          break;

        let loc = buf + offset + mem@.offset;
        let oldval = read_buf(loc mem@.ty->@Type@.size);
        let newval = eval(expr);
        let mask = (1L << mem@.bit_width) - 1;
        let combined = oldval | ((newval & mask) << mem@.bit_offset);
        write_buf(loc combined mem@.ty->@Type@.size);
      ; else {
        cur = write_gvar_data(cur init@.children[mem@.idx] mem@.ty buf
                              offset + mem@.offset);
      ;
    ;
    return cur;
  ;

  if ty@.kind == TY_UNION {
    if !init@.mem
      return cur;
    return write_gvar_data(cur init@.children[init@.mem@.idx]
                           init@.mem@.ty buf offset);
  ;

  if !init@.expr
    return cur;

  if ty@.kind == TY_FLOAT {
    (buf + offset)->@ float@ = eval_double(init@.expr);
    return cur;
  ;

  if ty@.kind == TY_DOUBLE {
    (buf + offset)->@ double@ = eval_double(init@.expr);
    return cur;
  ;

  let label = 0->@@char;
  let b = &label;
  let val = eval2(init@.expr b);

  if !label {
    write_buf(buf + offset val ty@.size);
    return cur;
  ;

  let rel = calloc(1 sizeof Relocation)->@Relocation;
  rel@.offset = offset;
  rel@.label = label;
  rel@.addend = val;
  cur@.next = rel;
  return cur@.next;
;

// Initializers for global variables are evaluated at compile-time and
// embedded to .data section. This function serializes Initializer
// objects to a flat byte array. It is a compile error if an
// initializer list contains a non-constant expression.
gvar_initializer(rest @@Token tok@ Token var@ Obj)  =
  let
    d = &var@.ty
    init = initializer(rest tok var@.ty d)
    head = (let Relocation){;
    buf = calloc(1 var@.ty@.size)->@char;

  write_gvar_data(&head init var@.ty buf 0);
  var@.init_data = buf;
  var@.rel = head.next;
;

// asm-stmt = "asm" ("volatile" | "inline")* "(" string-literal ")"
asm_stmt(rest @@Token tok@ Token)@ Node =
  let node = new_node(ND_ASM tok);
  tok = tok@.next;

  while equal(tok "volatile") || equal(tok "inline")
    tok = tok@.next;

  expect(&tok "(");
  if tok@.kind != TK_STR || tok@.ty->@Type@.base@.kind != TY_CHAR
    error_tok(tok "expected string literal");
  node@.asm_str = tok@.str;
  rest@ = skip(tok@.next ")");
  return node;
;

stmt(tok @@Token)@ Node =
  if equal(tok@ "return") {
    let node = new_node(ND_RETURN tok@);
    tok@ = tok@@.next;
    if consume(tok tok@ ";") return node;
    let exp = expr(tok);
    expect(tok ";");
    add_type(exp);
    let ty = current_fn@.ty@.return_ty;
    if ty@.kind != TY_STRUCT && ty@.kind != TY_UNION exp = new_cast(exp current_fn@.ty@.return_ty);
    node@.lhs = exp;
    return node;
  ;

  if equal(tok@ "if") {
    let node = new_node(ND_IF tok@);
    tok@ = tok@@.next;
    node@.cond = expr(tok);
    node@.then = stmt(tok);
    if consume(tok tok@ "else") node@.els = stmt(tok);
    return node;
  ;

  if equal(tok@ "switch") {
    let node = new_node(ND_SWITCH tok@);
    tok@ = tok@@.next;
    expect(tok "(");
    node@.cond = expr(tok);
    expect(tok ")");
    let sw = current_switch;
    current_switch = node;
    let brk = brk_label;
    brk_label = node@.brk_label = new_unique_name();
    node@.then = stmt(tok);
    current_switch = sw;
    brk_label = brk;
    return node;
  ;

  if equal(tok@ "case") {
    if !current_switch error_tok(tok@ "stray case");
    let node = new_node(ND_CASE tok@);
    tok@ = tok@@.next;
    let begin = const_expr(tok tok@);
    let end = begin;
    expect(tok ":");
    node@.label = new_unique_name();
    node@.lhs = stmt(tok);
    node@.begin = begin;
    node@.end = end;
    node@.case_next = current_switch@.case_next;
    current_switch@.case_next = node;
    return node;
  ;

  if equal(tok@ "default") {
    if !current_switch error_tok(tok@ "stray default");
    let node = new_node(ND_CASE tok@);
    tok@ = tok@@.next;
    expect(tok ":");
    node@.label = new_unique_name();
    node@.lhs = stmt(tok);
    current_switch@.default_case = node;
    return node;
  ;

  if equal(tok@ "for") {
    let node = new_node(ND_FOR tok@);
    tok@ = tok@@.next;
    expect(tok "(");
    enter_scope();
    let brk = brk_label;
    let cont = cont_label;
    brk_label = node@.brk_label = new_unique_name();
    cont_label = node@.cont_label = new_unique_name();
    if consume(tok tok@ "let") {
      declspec(tok 0);
      node@.init = declaration(tok 0);
    ;
    else node@.init = expr_stmt(tok);
    if !equal(tok@ ";") node@.cond = expr(tok); expect(tok ";");
    if !equal(tok@ ")") node@.inc = expr(tok); expect(tok ")");
    node@.then = stmt(tok);
    leave_scope();
    brk_label = brk;
    cont_label = cont;
    return node;
  ;

  if equal(tok@ "while") {
    let node = new_node(ND_FOR tok@);
    tok@ = tok@@.next;
    node@.cond = expr(tok);
    let brk = brk_label;
    let cont = cont_label;
    brk_label = node@.brk_label = new_unique_name();
    cont_label = node@.cont_label = new_unique_name();
    node@.then = stmt(tok);
    brk_label = brk;
    cont_label = cont;
    return node;
  ;

  if equal(tok@ "do") {
    let node = new_node(ND_DO tok@);
    let brk = brk_label;
    let cont = cont_label;
    brk_label = node@.brk_label = new_unique_name();
    cont_label = node@.cont_label = new_unique_name();
    tok@ = tok@@.next;
    node@.then = stmt(tok);
    brk_label = brk;
    cont_label = cont;
    expect(tok "while");
    expect(tok "(");
    node@.cond = expr(tok);
    expect(tok ")");
    tok@ = skip(tok@ ";");
    return node;
  ;

  if equal(tok@ "asm")
    return asm_stmt(tok tok@);

  if equal(tok@ "goto") {
    let node = new_node(ND_GOTO tok@);
    tok@ = tok@@.next;
    node@.label = get_ident(tok@); 
    tok@ = tok@@.next@.next;
    node@.goto_next = gotos;
    gotos = node;
    expect(tok ";");
    return node;
  ;

  if equal(tok@ "break") {
    if !brk_label error_tok(tok@ "stray break");
    let node = new_node(ND_GOTO tok@);
    node@.unique_label = brk_label;
    tok@ = tok@@.next;
    tok@ = skip(tok@ ";");
    return node;
  ;

  if equal(tok@ "continue") {
    if !cont_label error_tok(tok@ "stray continue");
    let node = new_node(ND_GOTO tok@);
    node@.unique_label = cont_label;
    tok@ = tok@@.next;
    tok@ = skip(tok@ ";");
    return node;
  ;

  if tok@@.kind == TK_IDENT && equal(tok@@.next ":") {
    let node = new_node(ND_LABEL tok@);
    node@.label = strndup(tok@@.loc tok@@.len);
    node@.unique_label = new_unique_name();
    tok@ = tok@@.next@.next;
    node@.lhs = stmt(tok);
    node@.goto_next = labels;
    labels = node;
    return node;
  ;

  if equal(tok@ "{") {
    tok@ = tok@@.next;
    return compound_stmt(tok);
  ;

  return expr_stmt(tok);
;

decl_stmt(rest @@Token) @Node =
  let
    tok = rest@
    head = (let Node){;
    cur = &head;
  while !equal(tok ";") {
    if equal(tok@.next "=") {
      if tok@.kind != TK_IDENT || equal(tok "_") error_tok(tok "expected identifer");
      let name = tok;
      tok = tok@.next@.next;
      let e = expr(&tok);
      add_type(e);
      if e@.ty@.kind == TY_VOID error_tok(tok "variable declared void");
      let var = new_lvar(get_ident(name) e@.ty);
      cur = cur@.next = new_unary(ND_EXPR_STMT new_binary(ND_ASSIGN new_var_node(var tok) e tok) tok);
      continue;
    ;
    //warn_tok(tok "deprecated initializer");
    let ty = declarator(&tok);
    if ty@.kind == TY_VOID error_tok(tok "variable declared void");
    if !ty@.name error_tok(ty@.name_pos "variable name omitted");
    if equal(ty@.name "_") continue;

    let var = new_lvar(get_ident(ty@.name) ty);

    if equal(tok "=") {
      let expr = lvar_initializer(&tok tok@.next var);
      cur = cur@.next = new_unary(ND_EXPR_STMT expr tok);
    ;

    if var@.ty@.size < 0
      error_tok(ty@.name "variable has incomplete type");
    if var@.ty@.kind == TY_VOID
      error_tok(ty@.name "variable declared void");
  ;

  let node = new_node(ND_BLOCK tok);
  node@.body = head.next;
  rest@ = tok@.next;
  return node;
;

compound_stmt(rest @@Token) @Node =
  let tok = rest@;
  let
    node = new_node(ND_BLOCK tok)
    head = (let Node){;
    cur = &head;

  enter_scope();

  while (!equal(tok ";")) {
    cur = cur@.next = (consume(&tok tok "let") ? decl_stmt : stmt)(&tok);
    add_type(cur);
  ;

  leave_scope();

  node@.body = head.next;
  rest@ = tok@.next;
  return node;
;

expr_stmt(tok @@Token)@ Node =
  if equal(tok@ ";") {
    let node = new_node(ND_BLOCK tok@);
    tok@ = tok@@.next;
    return node;
  ;

  let node = new_node(ND_EXPR_STMT tok@);
  node@.lhs = expr(tok);
  expect(tok ";");
  return node;
;

expr(tok@@ Token)@ Node =
  let lhs = assign(tok);
  if equal(tok@ ",") {
    let node = new_node(ND_COMMA tok@);
    tok@ = tok@@.next;
    node@.lhs = lhs;
    node@.rhs = expr(tok);
    return node;
  ;
  return lhs;
;

eval(node@ Node) int64_t = return
  eval2(node 0);
;

// Evaluate a given node as a constant expression.
//
// A constant expression is either just a number or ptr+n where ptr
// is a pointer to a global variable and n is a postiive/negative
// number. The latter form is accepted only as an initialization
// expression for a global variable.
eval2(node@ Node label @@@char) int64_t =
  add_type(node);

  if is_flonum(node@.ty)
    return eval_double(node);

  switch (node@.kind) {
  case ND_ADD:
    return eval2(node@.lhs label) + eval(node@.rhs);
  case ND_SUB:
    return eval2(node@.lhs label) - eval(node@.rhs);
  case ND_MUL:
    return eval(node@.lhs) * eval(node@.rhs);
  case ND_DIV:
    if node@.ty@.is_unsigned
      return eval(node@.lhs)->uint64_t / eval(node@.rhs);
    return eval(node@.lhs) / eval(node@.rhs);
  case ND_NEG:
    return -eval(node@.lhs);
  case ND_MOD:
    if node@.ty@.is_unsigned
      return eval(node@.lhs)->uint64_t % eval(node@.rhs);
    return eval(node@.lhs) % eval(node@.rhs);
  case ND_BITAND:
    return eval(node@.lhs) & eval(node@.rhs);
  case ND_BITOR:
    return eval(node@.lhs) | eval(node@.rhs);
  case ND_BITXOR:
    return eval(node@.lhs) ^ eval(node@.rhs);
  case ND_SHL:
    return eval(node@.lhs) << eval(node@.rhs);
  case ND_SHR:
    if node@.ty@.is_unsigned && node@.ty@.size == 8
      return eval(node@.lhs)->uint64_t >> eval(node@.rhs);
    return eval(node@.lhs) >> eval(node@.rhs);
  case ND_EQ:
    return eval(node@.lhs) == eval(node@.rhs);
  case ND_NE:
    return eval(node@.lhs) != eval(node@.rhs);
  case ND_LT:
    if node@.lhs@.ty@.is_unsigned
      return eval(node@.lhs)->uint64_t < eval(node@.rhs);
    return eval(node@.lhs) < eval(node@.rhs);
  case ND_LE:
    if node@.lhs@.ty@.is_unsigned
      return eval(node@.lhs)->uint64_t <= eval(node@.rhs);
    return eval(node@.lhs) <= eval(node@.rhs);
  case ND_GT:
    if node@.lhs@.ty@.is_unsigned
      return eval(node@.lhs)->uint64_t > eval(node@.rhs);
    return eval(node@.lhs) > eval(node@.rhs);
  case ND_GE:
    if node@.lhs@.ty@.is_unsigned
      return eval(node@.lhs)->uint64_t >= eval(node@.rhs);
    return eval(node@.lhs) >= eval(node@.rhs);
  case ND_COND:
    return eval(node@.cond) ? eval2(node@.then label) : eval2(node@.els label);
  case ND_COMMA:
    return eval2(node@.rhs label);
  case ND_NOT:
    return !eval(node@.lhs);
  case ND_BITNOT:
    return ~eval(node@.lhs);
  case ND_LOGAND:
    return eval(node@.lhs) && eval(node@.rhs);
  case ND_LOGOR:
    return eval(node@.lhs) || eval(node@.rhs);
  case ND_CAST: {
    let val = eval2(node@.lhs label);
    if is_integer(node@.ty) {
      switch (node@.ty@.size) {
      case 1: return node@.ty@.is_unsigned ? val->uint8_t : val->int8_t;
      case 2: return node@.ty@.is_unsigned ? val->uint16_t : val->int16_t;
      case 4: return node@.ty@.is_unsigned ? val->uint32_t : val->int32_t;
      ;
    ;
    return val;
  ;
  case ND_ADDR:
    return eval_rval(node@.lhs label);
  case ND_LABEL_VAL:
    label@ = &node@.unique_label;
    return 0;
  case ND_MEMBER:
    if !label
      error_tok(node@.tok "not a compile-time constant");
    if node@.ty@.kind != TY_ARRAY
      error_tok(node@.tok "invalid initializer");
    return eval_rval(node@.lhs label) + node@.member@.offset;
  case ND_VAR:
    if !label
      error_tok(node@.tok "not a compile-time constant");
    if node@.var@.ty@.kind != TY_ARRAY && node@.var@.ty@.kind != TY_FUNC
      error_tok(node@.tok "invalid initializer");
    label@ = &node@.var@.name;
    return 0;
  case ND_NUM:
    return node@.val;
  ;

  error_tok(node@.tok "not a compile-time constant");
;

eval_rval(node@ Node label @@@char) int64_t =
  switch (node@.kind) {
  case ND_VAR:
    if node@.var@.is_local
      error_tok(node@.tok "not a compile-time constant");
    label@ = &node@.var@.name;
    return 0;
  case ND_DEREF:
    return eval2(node@.lhs label);
  case ND_MEMBER:
    return eval_rval(node@.lhs label) + node@.member@.offset;
  ;

  error_tok(node@.tok "invalid initializer");
;

is_const_expr(node@ Node) bool =
  add_type(node);

  switch (node@.kind) {
  case ND_ADD:
  case ND_SUB:
  case ND_MUL:
  case ND_DIV:
  case ND_BITAND:
  case ND_BITOR:
  case ND_BITXOR:
  case ND_SHL:
  case ND_SHR:
  case ND_EQ:
  case ND_NE:
  case ND_LT:
  case ND_LE:
  case ND_GT:
  case ND_GE:
  case ND_LOGAND:
  case ND_LOGOR:
    return is_const_expr(node@.lhs) && is_const_expr(node@.rhs);
  case ND_COND:
    if !is_const_expr(node@.cond)
      return false;
    return is_const_expr(eval(node@.cond) ? node@.then : node@.els);
  case ND_COMMA:
    return is_const_expr(node@.rhs);
  case ND_NEG:
  case ND_NOT:
  case ND_BITNOT:
  case ND_CAST:
    return is_const_expr(node@.lhs);
  case ND_NUM:
    return true;
  ;

  return false;
;

export const_expr(rest@@ Token tok@ Token) int64_t  =
  rest@ = tok;
  let node = conditional(rest);
  return eval(node);
;

eval_double(node@ Node) double =
  add_type(node);

  if is_integer(node@.ty) {
    if node@.ty@.is_unsigned
      return eval(node)->unsigned long;
    return eval(node);
  ;

  switch (node@.kind) {
  case ND_ADD:
    return eval_double(node@.lhs) + eval_double(node@.rhs);
  case ND_SUB:
    return eval_double(node@.lhs) - eval_double(node@.rhs);
  case ND_MUL:
    return eval_double(node@.lhs) * eval_double(node@.rhs);
  case ND_DIV:
    return eval_double(node@.lhs) / eval_double(node@.rhs);
  case ND_NEG:
    return -eval_double(node@.lhs);
  case ND_COND:
    return eval_double(node@.cond) ? eval_double(node@.then) : eval_double(node@.els);
  case ND_COMMA:
    return eval_double(node@.rhs);
  case ND_CAST:
    if is_flonum(node@.lhs@.ty)
      return eval_double(node@.lhs);
    return eval(node@.lhs);
  case ND_NUM:
    return node@.fval;
  ;

  error_tok(node@.tok "not a compile-time constant");
;

id_node(node@ Node)@ Node = return node; ;
to_assign(e@ Node)@ Node = return new_binary( ND_ASSIGN e@.lhs e e@.tok); ;

assign(tok @@Token)@ Node =
  let lhs = conditional(tok);
  let k =
    equal(tok@ "="  ) ? ND_ASSIGN :
    equal(tok@ "+=" ) ? ND_ADD    :
    equal(tok@ "-=" ) ? ND_SUB    :
    equal(tok@ "*=" ) ? ND_MUL    :
    equal(tok@ "/=" ) ? ND_DIV    :
    equal(tok@ "%=" ) ? ND_MOD    :
    equal(tok@ "&=" ) ? ND_BITAND :
    equal(tok@ "|=" ) ? ND_BITOR  :
    equal(tok@ "^=" ) ? ND_BITXOR :
    equal(tok@ "<<=") ? ND_SHL    :
    equal(tok@ ">>=") ? ND_SHR    :
    0;
  if !k return lhs;
  let e = new_node(k tok@);
  tok@ = tok@@.next;
  e@.lhs = lhs;
  let f = e;
  if k != ND_ASSIGN {
    e = new_node(ND_ASSIGN tok@);
    e@.lhs = lhs;
    e@.rhs = f;
  ;
  f@.rhs = assign(tok);
  add_type(f);
  if !is_compatible(f@.lhs@.ty f@.rhs@.ty) error_tok(tok@ "incompatible assignment");
  return e;
;

type StrNodeKind struct { s@ char k NodeKind ;};;

ab(tok@@ Token n int next@(tok@@ Token)@ Node a@ StrNodeKind lhs@@ Node) bool =
  for (let i int = 0; i < n; ++i) {
    if equal(tok@ a[i].s) {
      let e = new_node(a[i].k tok@);
      tok@ = tok@@.next;
      e@.lhs = lhs@;
      e@.rhs = next(tok);
      lhs@ = e;
      return true;
    ;
  ;
  return false;
;

left_binary(tok@@ Token n int next@(tok@@ Token)@ Node a@ StrNodeKind)@ Node =
  let lhs = next(tok);
  let e = &lhs;
  while ab(tok n next a e);
  return lhs;
;

mul       (l@@ Token)@ Node = let d []StrNodeKind = { { "*" , ND_MUL    ;, { "/" , ND_DIV ;, { "%" , ND_MOD ;                  ;; return left_binary(l 3 cast       d);;
shift     (l@@ Token)@ Node = let d []StrNodeKind = { { "<<", ND_SHL    ;, { ">>", ND_SHR ;                                    ;; return left_binary(l 2 add        d);;
relational(l@@ Token)@ Node = let d []StrNodeKind = { { "<" , ND_LT     ;, { ">" , ND_GT  ;, { "<=", ND_LE  ;, { ">=", ND_GE ; ;; return left_binary(l 4 shift      d);;
equality  (l@@ Token)@ Node = let d []StrNodeKind = { { "==", ND_EQ     ;, { "!=", ND_NE  ;                                    ;; return left_binary(l 2 relational d);;
bitand    (l@@ Token)@ Node = let d []StrNodeKind = { { "&" , ND_BITAND ;                                                      ;; return left_binary(l 1 equality   d);;
bitxor    (l@@ Token)@ Node = let d []StrNodeKind = { { "^" , ND_BITXOR ;                                                      ;; return left_binary(l 1 bitand     d);;
bitor     (l@@ Token)@ Node = let d []StrNodeKind = { { "|" , ND_BITOR  ;                                                      ;; return left_binary(l 1 bitxor     d);;
logand    (l@@ Token)@ Node = let d []StrNodeKind = { { "&&", ND_LOGAND ;                                                      ;; return left_binary(l 1 bitor      d);;
logor     (l@@ Token)@ Node = let d []StrNodeKind = { { "||", ND_LOGOR  ;                                                      ;; return left_binary(l 1 logand     d);;

// conditional = logor ("?" expr? ":" conditional)?
conditional(rest @@Token)@ Node =
  let tok = rest@;
  let cond = logor(&tok);

  if !equal(tok "?") {
    rest@ = tok;
    return cond;
  ;

  if equal(tok@.next ":") {
    // [GNU] Compile `a ?: b` as `tmp = a, tmp ? tmp : b`.
    add_type(cond);
    let var = new_lvar("" cond@.ty);
    let lhs = new_binary(ND_ASSIGN new_var_node(var tok) cond tok);
    let rhs = new_node(ND_COND tok);
    rhs@.cond = new_var_node(var tok);
    rhs@.then = new_var_node(var tok);
    rest@ = tok@.next@.next;
    rhs@.els = conditional(rest);
    return new_binary(ND_COMMA lhs rhs tok);
  ;

  let node = new_node(ND_COND tok);
  node@.cond = cond;
  tok = tok@.next;
  node@.then = expr(&tok);
  expect(&tok ":");
  rest@ = tok;
  node@.els = conditional(rest);
  return node;
;

// In C, `+` operator is overloaded to perform the pointer arithmetic.
// If p is a pointer, p+n adds not n but sizeof(p@)n@ to the value of p,
// so that p+n points to the location n elements (not bytes) ahead of p.
// In other words, we need to scale an integer value before adding to a
// pointer value. This function takes care of the scaling.
new_add(lhs@ Node rhs@ Node tok@ Token)@ Node =
  add_type(lhs);
  add_type(rhs);

  // num + num
  if is_numeric(lhs@.ty) && is_numeric(rhs@.ty)
    return new_binary(ND_ADD lhs rhs tok);

  if lhs@.ty@.base && rhs@.ty@.base
    error_tok(tok "invalid operands");

  // Canonicalize `num + ptr` to `ptr + num`.
  if !lhs@.ty@.base && rhs@.ty@.base {
    let tmp = lhs;
    lhs = rhs;
    rhs = tmp;
  ;

  // ptr + num
  rhs = new_binary(ND_MUL rhs new_long(lhs@.ty@.base@.size tok) tok);
  return new_binary(ND_ADD lhs rhs tok);
;

// Like `+`, `-` is overloaded for the pointer type.
new_sub(lhs@ Node rhs@ Node tok@ Token)@ Node =
  add_type(lhs);
  add_type(rhs);

  // num - num
  if is_numeric(lhs@.ty) && is_numeric(rhs@.ty)
    return new_binary(ND_SUB lhs rhs tok);

  // ptr - num
  if lhs@.ty@.base && is_integer(rhs@.ty) {
    rhs = new_binary(ND_MUL rhs new_long(lhs@.ty@.base@.size tok) tok);
    add_type(rhs);
    let node = new_binary(ND_SUB lhs rhs tok);
    node@.ty = lhs@.ty;
    return node;
  ;

  // ptr - ptr, which returns how many elements are between the two.
  if lhs@.ty@.base && rhs@.ty@.base {
    let node = new_binary(ND_SUB lhs rhs tok);
    node@.ty = ty_long;
    return new_binary(ND_DIV node new_num(lhs@.ty@.base@.size tok) tok);
  ;

  error_tok(tok "invalid operands");
;

add(rest @@Token)@ Node =
  let tok = rest@;
  let node = mul(&tok);

  for (;;) {
    let start = tok;

    if equal(tok "+") {
      tok = tok@.next;
      node = new_add(node mul(&tok) start);
      continue;
    ;

    if equal(tok "-") {
      tok = tok@.next;
      node = new_sub(node mul(&tok) start);
      continue;
    ;

    rest@ = tok;
    return node;
  ;
;

cast(rest @@Token)@ Node =
  let tok = rest@;
  let start = tok;
  if equal(tok "(") && equal(tok@.next "let") {
    tok = tok@.next@.next;
    let ty = type_suffix(&tok);
    expect(&tok ")");

    // compound literal
    if equal(tok "{") {
      //warn_tok(tok "deprecated someshit");
      rest@ = start;
      return unary(rest);
    ;
    error_tok(tok "disallowed cast syntax");
  ;

  rest@ = tok;
  return unary(rest);
;

unary(rest @@Token)@ Node =
  let tok = rest@;
  if equal(tok "+") {
    rest@ = tok@.next;
    return cast(rest);
  ;

  if equal(tok "-") {
    rest@ = tok@.next;
    return new_unary(ND_NEG cast(rest) tok);
  ;

  if equal(tok "&") {
    rest@ = tok@.next;
    let lhs = cast(rest);
    let k = lhs;
    lhs = k;
    add_type(lhs);
    if lhs@.kind == ND_MEMBER && lhs@.member@.is_bitfield
      error_tok(tok "cannot take address of bitfield");
    return new_unary(ND_ADDR lhs tok);
  ;

  if equal(tok "!") {
    rest@ = tok@.next;
    return new_unary(ND_NOT cast(rest) tok);
  ;

  if equal(tok "~") {
    rest@ = tok@.next;
    return new_unary(ND_BITNOT cast(rest) tok);
  ;

  // Read ++i as i+=1
  if equal(tok "++") {
    rest@ = tok@.next;
    return to_assign(new_add(unary(rest) new_num(1 tok) tok));
  ;

  // Read --i as i-=1
  if equal(tok "--") {
    rest@ = tok@.next;
    return to_assign(new_sub(unary(rest) new_num(1 tok) tok));
  ;

  // [GNU] labels-as-values
  if equal(tok "&&") {
    let node = new_node(ND_LABEL_VAL tok);
    node@.label = get_ident(tok@.next);
    node@.goto_next = gotos;
    gotos = node;
    rest@ = tok@.next@.next;
    return node;
  ;

  rest@ = tok;
  return postfix(rest);
;

struct_members(rest @@Token tok@ Token ty@ Type)  =
  let
    head = (let Member){;
    cur = &head
    idx = 0;

  while !equal(tok "}") {
    let attr = (let VarAttr){;;
    let c = &attr;
    declspec(&tok c);
    // Regular struct members
    while !consume(&tok tok ";") {
      let mem = calloc(1 sizeof Member)->@Member;
      mem@.ty = declarator(&tok);
      mem@.name = mem@.ty->@Type@.name;
      mem@.idx = idx++;
      mem@.alignment = attr.alignment ? attr.alignment : mem@.ty->@Type@.alignment;

      if consume(&tok tok ":") {
        mem@.is_bitfield = true;
        mem@.bit_width = const_expr(&tok tok);
      ;

      cur = cur@.next = mem;
    ;
  ;

  // If the last element is an array of incomplete type, it's
  // called a "flexible array member". It should behave as if
  // if were a zero-sized array.
  if cur != &head && cur@.ty->@Type@.kind == TY_ARRAY && cur@.ty->@Type@.array_len < 0 {
    cur@.ty = array_of(cur@.ty->@Type@.base 0);
    ty@.is_flexible = true;
  ;

  rest@ = tok@.next;
  ty@.members = head.next;
;

// attribute = ("__attribute__" "(" "(" "packed" ")" ")")*
attribute_list(tok@ Token ty@ Type)@ Token =
  while consume(&tok tok "__attribute__") {
    expect(&tok "(");
    expect(&tok "(");

    while !consume(&tok tok ")") {
      if consume(&tok tok "packed") {
        ty@.is_packed = true;
        continue;
      ;

      if consume(&tok tok "aligned") {
        expect(&tok "(");
        ty@.alignment = const_expr(&tok tok);
        expect(&tok ")");
        continue;
      ;

      error_tok(tok "unknown attribute");
    ;

    expect(&tok ")");
  ;

  return tok;
;

struct_union_decl(rest @@Token) @Type =
  let tok = rest@;
  let ty = struct_type();
  tok = attribute_list(tok ty);

  // Read a tag.
  let tag = 0->@Token;
  if tok@.kind == TK_IDENT {
    tag = tok;
    tok = tok@.next;
  ;

  if tag && !equal(tok "{") {
    rest@ = tok;

    let ty2 = search_scope(tag scope_tags);
    if ty2
      return ty2;

    ty@.size = -1;
    push_tag_scope(tag ty);
    return ty;
  ;

  expect(&tok "{");
  current_type = ty;

  // Construct a struct object.
  struct_members(&tok tok ty);
  rest@ = attribute_list(tok ty);

  current_type = 0;
  if tag {
    // If this is a redefinition, overwrite a previous type.
    // Otherwise, register the struct type.
    let ty2 = hashmap_get2(&scope@.tags tag@.loc tag@.len)->@Type;
    if ty2 {
      ty2@ = ty@;
      return ty2;
    ;

    push_tag_scope(tag ty);
  ;

  return ty;
;

struct_decl(rest @@Token)@ Type =
  let ty = struct_union_decl(rest);
  ty@.kind = TY_STRUCT;

  if ty@.size < 0
    return ty;

  // Assign offsets within the struct to members.
  let bits = 0;

  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    if mem@.is_bitfield && mem@.bit_width == 0 {
      // Zero-width anonymous bitfield has a special meaning.
      // It affects only alignment.
      bits = align_to(bits mem@.ty->@Type@.size * 8);
    ; else if mem@.is_bitfield {
      let sz = mem@.ty->@Type@.size;
      if bits / (sz * 8) != (bits + mem@.bit_width - 1) / (sz * 8)
        bits = align_to(bits sz * 8);

      mem@.offset = align_down(bits / 8 sz);
      mem@.bit_offset = bits % (sz * 8);
      bits += mem@.bit_width;
    ; else {
      if !ty@.is_packed
        bits = align_to(bits mem@.alignment * 8);
      mem@.offset = bits / 8;
      bits += mem@.ty->@Type@.size * 8;
    ;

    if !ty@.is_packed && ty@.alignment < mem@.alignment
      ty@.alignment = mem@.alignment;
  ;

  ty@.size = align_to(bits ty@.alignment * 8) / 8;
  return ty;
;

// union-decl = struct-union-decl
union_decl(rest @@Token)@ Type =
  let ty = struct_union_decl(rest);
  ty@.kind = TY_UNION;

  if ty@.size < 0
    return ty;

  // If union, we don't have to assign offsets because they
  // are already initialized to zero. We need to compute the
  // alignment and the size though.
  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    if ty@.alignment < mem@.alignment
      ty@.alignment = mem@.alignment;
    if ty@.size < mem@.ty->@Type@.size
      ty@.size = mem@.ty->@Type@.size;
  ;
  ty@.size = align_to(ty@.size ty@.alignment);
  return ty;
;

// Find a struct member by name.
get_struct_member(ty@ Type tok@ Token)@ Member =
  for (let mem@ Member = ty@.members; mem; mem = mem@.next) {
    // Anonymous struct member
    if ((mem@.ty->@Type@.kind == TY_STRUCT || mem@.ty->@Type@.kind == TY_UNION) &&
        (!mem@.name || equal(mem@.name "_"))) {
      if get_struct_member(mem@.ty tok)
        return mem;
      continue;
    ;

    // Regular struct member
    if mem@.name@.len == tok@.len &&
        !strncmp(mem@.name@.loc tok@.loc tok@.len)
      return mem;
  ;
  return NULL;
;

// Create a node representing a struct member access, such as foo.bar
// where foo is a struct and bar is a member name.
//
// C has a feature called "anonymous struct" which allows a struct to
// have another unnamed struct as a member like this:
//
//   struct { struct { a int; ;; b int; ; x;
//
// The members of an anonymous struct beto long the outer struct's
// member namespace. Therefore, in the above example, you can access
// member "a" of the anonymous struct as "x.a".
//
// This function takes care of anonymous structs.
struct_ref(node@ Node tok@ Token)@ Node =
  add_type(node);
  if node@.ty@.kind != TY_STRUCT && node@.ty@.kind != TY_UNION
    error_tok(node@.tok "not a struct nor a union");

  let ty = node@.ty;

  for (;;) {
    let mem = get_struct_member(ty tok);
    if !mem
      error_tok(tok "no such member");
    node = new_unary(ND_MEMBER node tok);
    node@.member = mem;
    if mem@.name
      break;
    ty = mem@.ty;
  ;
  return node;
;

// Convert A++ to `(typeof A)((A += 1) - 1)`
new_inc_dec(node@ Node tok@ Token addend int)@ Node =
  add_type(node);
  return new_cast(new_add(to_assign(new_add(node new_num(addend tok) tok))
                          new_num(-addend tok) tok)
                  node@.ty);
;

postfix(rest @@Token)@ Node =
  let tok = rest@;
  let start = tok;

  if equal(tok "(") && equal(tok@.next "let") {
    tok = tok@.next@.next;
    let ty = type_suffix(&tok);
    expect(&tok ")");

    if scope@.next == NULL {
      let var = new_anon_gvar(ty);
      gvar_initializer(rest tok var);
      return new_var_node(var start);
    ;

    let var = new_lvar("" ty);
    let lhs = lvar_initializer(rest tok var);
    let rhs = new_var_node(var tok);
    return new_binary(ND_COMMA lhs rhs start);
  ;

  let node = primary(&tok);

  for (;;) {
    if equal(tok "(") {
      tok = tok@.next;
      node = funcall(&tok node);
      continue;
    ;

    if equal(tok "[") {
      let start = tok;
      tok = tok@.next;
      let idx = expr(&tok);
      expect(&tok "]");
      node = new_unary(ND_DEREF new_add(node idx start) start);
      continue;
    ;

    if equal(tok ".") {
      node = struct_ref(node tok@.next);
      tok = tok@.next@.next;
      continue;
    ;

    if equal(tok "@") {
      node = new_unary(ND_DEREF node tok);
      tok = tok@.next;
      continue;
    ;

    if equal(tok "->") {
      tok = tok@.next;
      let ty = type_suffix(&tok);
      node = new_cast(node ty);
      continue;
    ;

    if equal(tok "++") {
      node = new_inc_dec(node tok 1);
      tok = tok@.next;
      continue;
    ;

    if equal(tok "--") {
      node = new_inc_dec(node tok 0-1);
      tok = tok@.next;
      continue;
    ;

    rest@ = tok;
    return node;
  ;
;

funcall(rest @@Token fn@ Node)@ Node =
  add_type(fn);
  let tok = rest@;

  if fn@.ty@.kind != TY_FUNC &&
      !(fn@.ty@.kind == TY_PTR && fn@.ty@.base@.kind == TY_FUNC)
    error_tok(fn@.tok "not a function");

  let ty = (fn@.ty@.kind == TY_FUNC) ? fn@.ty : fn@.ty@.base;
  let param_ty = ty@.params;

  let
    head = (let Node){;
    cur = &head;

  while !equal(tok ")") {
    let arg = assign(&tok);
    add_type(arg);

    if !param_ty && !ty@.is_variadic
      error_tok(tok "too many arguments");

    if param_ty {
      if param_ty@.kind != TY_STRUCT && param_ty@.kind != TY_UNION arg = new_cast(arg param_ty);
      if !is_compatible(arg@.ty param_ty) error_tok(tok "incompatible argument");
      param_ty = param_ty@.next;
    ;

    cur = cur@.next = arg;
  ;

  if param_ty error_tok(tok "too few arguments");

  rest@ = skip(tok ")");

  let node = new_unary(ND_FUNCALL fn tok);
  node@.func_ty = ty;
  node@.ty = ty@.return_ty;
  node@.args = head.next;

  // If a function returns a struct, it is caller's responsibility
  // to allocate a space for the return value.
  if node@.ty@.kind == TY_STRUCT || node@.ty@.kind == TY_UNION
    node@.ret_buffer = new_lvar("" node@.ty);
  return node;
;

primary(k @@Token)@ Node =
  if equal(k@ "(") { // ambiguity: looked ahead to by preceding expressions for function calls
    k@ = k@@.next;
    let node = expr(k); // may or may not lookahead to ')'
    expect(k ")");
    return node;
  ;

  if equal(k@ "sizeof" ) { k@ = k@@.next; return new_ulong(type_suffix(k)@.size      k@);;
  if equal(k@ "alignof") { k@ = k@@.next; return new_ulong(type_suffix(k)@.alignment k@);;

  if k@@.kind == TK_IDENT {
    let sc = search_scope(k@ scope_vars)->@VarScope;
    k@ = k@@.next;

    // For "static inline" function
    if sc && sc@.var && sc@.var@.is_function {
      if current_fn
        strarray_push(&current_fn@.refs sc@.var@.name);
      else
        sc@.var@.is_root = true;
    ;

    if sc {
      if sc@.var
        return new_var_node(sc@.var k@);
      if sc@.enum_ty
        return new_num(sc@.enum_val k@);
    ;

    if equal(k@@.next "(")
      error_tok(k@ "implicit declaration of a function");
    error_tok(k@ "undefined variable");
  ;

  if k@@.kind == TK_STR {
    let e = new_var_node(new_string_literal(k@@.str k@@.ty) k@);
    k@ = k@@.next;
    return e;
  ;

  if k@@.kind == TK_NUM {
    let node = 0->@Node;
    if is_flonum(k@@.ty) {
      node = new_node(ND_NUM k@);
      node@.fval = k@@.fval;
    ; else node = new_num(k@@.val k@);

    node@.ty = k@@.ty;
    k@ = k@@.next;
    return node;
  ;

  error_tok(k@ "expected an expression");
;

parse_type(tok@ Token)@ Token =
  while !consume(&tok tok ";") {
    let ty = declarator(&tok);
    if !ty@.name
      error_tok(ty@.name_pos "type name omitted");
    if equal(ty@.name "_")
      continue;
    push_scope(get_ident(ty@.name))@.type_def = ty;
  ;
  return tok;
;

create_param_lvars(param@ Type)  =
  if param {
    create_param_lvars(param@.next);
    if !param@.name || equal(param@.name "_")
      error_tok(param@.name_pos "parameter name omitted");
    new_lvar(get_ident(param@.name) param);
  ;
;

// This function matches gotos or labels-as-values with labels.
//
// We cannot resolve gotos as we parse a function because gotos
// can refer a label that appears later in the function.
// So, we need to do this after we parse the entire function.
resolve_goto_labels(void)  =
  for (let x@ Node = gotos; x; x = x@.goto_next) {
    for (let y@ Node = labels; y; y = y@.goto_next) {
      if !strcmp(x@.label y@.label) {
        x@.unique_label = y@.unique_label;
        break;
      ;
    ;

    if x@.unique_label == NULL
      error_tok(x@.tok@.next "use of undeclared label");
  ;

  gotos = labels = NULL;
;

find_func(name@ char)@ Obj =
  let sc = scope;
  while sc@.next
    sc = sc@.next;

  let sc2 = hashmap_get(&sc@.vars name)->@VarScope;
  if sc2 && sc2@.var && sc2@.var@.is_function
    return sc2@.var;
  return NULL;
;

mark_live(var@ Obj)  =
  if !var@.is_function || var@.is_live
    return;
  var@.is_live = true;

  for (let i int = 0; i < var@.refs.len; i++) {
    let fn = find_func(var@.refs.data[i]);
    if fn
      mark_live(fn);
  ;
;

function(tok@ Token attr@ VarAttr)@ Token =
  let ty = declarator(&tok);
  if !ty@.name || equal(ty@.name "_")
    error_tok(ty@.name_pos "function name omitted");
  let name_str = get_ident(ty@.name);

  let fn = find_func(name_str);
  if fn {
    // Redeclaration
    if !fn@.is_function
      error_tok(tok "redeclared as a different kind of symbol");
    if fn@.is_definition && equal(tok "=")
      error_tok(tok "redefinition of %s" name_str);
    if fn@.is_export != attr@.is_export
      error_tok(tok "mismatched visibility");
    fn@.is_definition = fn@.is_definition || equal(tok "=");
  ; else {
    fn = new_gvar(name_str ty);
    fn@.is_function = true;
    fn@.is_definition = equal(tok "=");
    fn@.is_export = attr@.is_export;
    fn@.is_inline = attr@.is_inline;
  ;

  fn@.is_root = fn@.is_export || !fn@.is_inline;

  if consume(&tok tok ";")
    return tok;

  current_fn = fn;
  locals = NULL;
  enter_scope();
  create_param_lvars(ty@.params);

  // A buffer for a struct/union return value is passed
  // as the hidden first parameter.
  let rty = ty@.return_ty;
  if ((rty@.kind == TY_STRUCT || rty@.kind == TY_UNION) && rty@.size > 16)
    new_lvar("" pointer_to(rty));

  fn@.params = locals;

  if ty@.is_variadic
    fn@.va_area = new_lvar("__va_area__" array_of(ty_char 136));
  fn@.alloca_bottom = new_lvar("__alloca_size__" pointer_to(ty_char));

  expect(&tok "=");

  fn@.body = compound_stmt(&tok);
  fn@.locals = locals;
  leave_scope();
  resolve_goto_labels();
  return tok;
;

global_variable(tok@ Token attr@ VarAttr)@ Token =
  let first = true;

  while !consume(&tok tok ";") {
    first = false;

    let ty = declarator(&tok);
    if !ty@.name || equal(ty@.name "_")
      continue;

    let var = new_gvar(get_ident(ty@.name) ty);
    var@.is_definition = !attr@.is_extern;
    var@.is_export = attr@.is_export;
    var@.is_inline = attr@.is_inline;
    var@.is_tls = attr@.is_tls;
    if attr@.alignment
      var@.alignment = attr@.alignment;

    if equal(tok "=")
      gvar_initializer(&tok tok@.next var);
    else if !attr@.is_extern && !attr@.is_tls
      var@.is_tentative = true;
  ;
  return tok;
;

// Lookahead tokens and returns true if a given token is a start
// of a function definition or declaration.
is_function(tok@ Token) bool =
  if equal(tok ";")
    return false;

  let ty = declarator(&tok);
  return ty@.kind == TY_FUNC;
;

// Remove redundant tentative definitions.
scan_globals(void)  =
  let head = (let Obj){;;
  let cur = &head;

  for (let var@ Obj = globals; var; var = var@.next) {
    if !var@.is_tentative {
      cur = cur@.next = var;
      continue;
    ;

    // Find another definition of the same identifier.
    let var2 = globals;
    for (; var2; var2 = var2@.next)
      if var != var2 && var2@.is_definition && !strcmp(var@.name var2@.name)
        break;

    // If there's another definition, the tentative definition
    // is redundant
    if !var2
      cur = cur@.next = var;
  ;

  cur@.next = NULL;
  globals = head.next;
;


declare_builtin_functions(void) =
  let ty = func_type(pointer_to(ty_void));
  ty@.params = copy_type(ty_int);
  builtin_alloca = new_gvar("alloca" ty);
  builtin_alloca@.is_definition = false;
;

export parse(tok@ Token)@ Obj =
  locals = 0;
  globals = 0;
  scope = &(let Scope){;;
  current_type = 0;
  current_fn = 0;
  gotos = 0;
  labels = 0;
  brk_label = 0;
  cont_label = 0;
  current_switch = 0;
  builtin_alloca = 0;
  declare_builtin_functions();

  while tok@.kind != TK_EOF {
    let attr = (let VarAttr){;;
    let c = &attr;
    declspec(&tok c);

    // Typedef
    if attr.is_type {
      tok = parse_type(tok);
      continue;
    ;

    // Function
    if is_function(tok) {
      tok = function(tok c);
      continue;
    ;

    // Global variable
    tok = global_variable(tok c);
  ;

  for (let var@ Obj = globals; var; var = var@.next)
    if var@.is_root
      mark_live(var);

  // Remove redundant tentative definitions.
  scan_globals();
  return globals;
;
