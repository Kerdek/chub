# "chub.hb"

type
  Name struct {
    o @Obj
    t @Type
    v  i32;
  }

  Scope struct {
    s    @same
    vars  HashMap;
  }

  VarAttr struct {
    is_type    bool
    is_extern  bool
    is_export  bool
    is_inline  bool
    alignment  i32;
  }

  Ctx struct {
    j              @Token
    locals         @Obj
    globals        @Obj
    scope          @Scope
    current_type   @Type
    current_fn     @Obj
    nunid           i32;
  };
;

s1 [1024]i8
s2 [1024]i8

compound_stmt      (k @Ctx) @Node
expr_stmt          (k @Ctx) @Node

primary            (k @Ctx t @Type) @Node
secondary          (k @Ctx t @Type) @Node
tertiary           (k @Ctx t @Type) @Node
seq                (k @Ctx t @Type) @Node
infix              (k @Ctx t @Type) @Node
quaternary         (k @Ctx t @Type) @Node

enum_specifier     (k @Ctx) @Type
typeof_specifier   (k @Ctx) @Type
type_suffix        (k @Ctx) @Type
declarator         (k @Ctx) @Type
struct_decl        (k @Ctx) @Type

eval               (node @Node            ) i64
eval2              (node @Node label @@@i8) i64
eval_rval          (node @Node label @@@i8) i64

get_struct_member  (t @Type j @Token) @Type;

format_types(t @Type u @Type) = return
   (s1[0] = ""@)
;: (s2[0] = ""@) 
;: format_type t &s1[0] 
;: format_type u &s2[0] 
;: none
;;

enter_scope (k @Ctx) = return cast @Scope (calloc 1ul sizeof Scope) is s (s.s = k.scope) ;: (k.scope = s) ;;
leave_scope (k @Ctx) = return k.scope is s (k.scope = s.s) ;: free cast @void s ;;
push_scope  (k @Ctx name@ i8) @Name = return cast @Name calloc 1ul sizeof Name is sc hashmap_put &k.scope.vars name cast @ sc ;: sc;;
search_scope(k @Ctx)@ = let sc = k.scope; for (none; sc; sc = sc.s) { let sc2 = hashmap_get2 &sc.vars k.j.loc k.j.len; if sc2 return sc2; ; return cast @ 0 ; ;

new_var(k @Ctx name @i8 t @Type) @Obj = return
   (calloc 1ul sizeof Obj as @Obj) is o
   (o.name = name) 
;: (o.t = t) 
;: (o.alignment = t.alignment) 
;: ((push_scope k name).o = o) 
;: o
;;
new_lvar(k @Ctx name @i8 t @Type) @Obj = return
   new_var k name t is o
   (o.is_local = true)
;: (o.s = k.locals)
;: (k.locals = o)
;: o
;;
new_gvar(k @Ctx name @i8 t @Type) @Obj = return
   new_var k name t is o
   (o.s = k.globals)
;: (o.is_export = false)
;: (o.is_definition = true)
;: (k.globals = o)
;: o
;;
new_unique_name(k @Ctx) @i8 = return (format ".L..%d" k.nunid) :; (k.nunid = k.nunid + 1) ;;
new_anon_gvar(k @Ctx t @Type) @Obj = return new_gvar k new_unique_name k t;;
new_string_literal(k @Ctx p @i8 t @Type t2 @Type) @Obj = return new_anon_gvar k t2 is o (o.init_data = p) ;: o;;

expect_type(j @Token t @Type u @Type) = return
   !!t
&& !type_equal t u
&& format_types t u
;: (error_tok j "expected %s but found %s" s1 s2) as void
;;

new_node            (j @Token t @Type g NodeKind                        ) @Node = return cast @Node calloc 1ul sizeof Node is e e :; (e.j = j) :; (e.t = t) :; (e.kind = g);;
new_ternary         (j @Token t @Type g NodeKind a @Node b @Node c @Node) @Node = return new_node j t g is e e :; (e.a = a) :; (e.a.s = b) :; (e.a.s.s = c) ;;
new_binary          (j @Token t @Type g NodeKind a @Node b @Node        ) @Node = return new_node j t g is e e :; (e.a = a) :; (e.a.s = b) ;;
new_unary           (j @Token t @Type g NodeKind a @Node                ) @Node = return new_node j t g is e e :; (e.a = a) ;;
new_nullary         (j @Token t @Type g NodeKind                        ) @Node = return new_node j t g ;;

new_lit             (j @Token t @Type t2 @Type l i64        ) @Node = return expect_type j t t2             ;: new_nullary j t2             ND_NUM         is e e :; (e.val    = l) ;;
new_reference       (j @Token t @Type         o @Obj        ) @Node = return expect_type j t o.t            ;: new_nullary j o.t            ND_VAR         is e e :; (e.var    = o) ;;
new_member_reference(j @Token t @Type a @Node g @Type       ) @Node = return expect_type j t g              ;: new_unary   j g              ND_MEMBER  a   is e e :; (e.member = g) ;;
new_lognot          (j @Token t @Type a @Node               ) @Node = return expect_type j t ty_bool        ;: new_unary   j ty_bool        ND_NOT     a   ;;
new_bitnot          (j @Token t @Type a @Node               ) @Node = return expect_type j t a.t            ;: new_unary   j a.t            ND_BITNOT  a   ;;
new_the             (j @Token t @Type a @Node u @Type       ) @Node = return expect_type j t a.t            ;: new_unary   j a.t            ND_THE     a   ;;
new_assign          (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_void        ;: new_binary  j ty_void        ND_ASSIGN  a b ;;
new_bitor           (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_BITOR   a b ;;
new_bitxor          (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_BITXOR  a b ;;
new_bitand          (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_BITAND  a b ;;
new_eq              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_EQ      a b ;;
new_neq             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_NE      a b ;;
new_gt              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_GT      a b ;;
new_lt              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_LT      a b ;;
new_ge              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_GE      a b ;;
new_le              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_LE      a b ;;
new_shl             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_SHL     a b ;;
new_shr             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_SHR     a b ;;
new_mul             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_MUL     a b ;;
new_div             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_DIV     a b ;;
new_mod             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_MOD     a b ;;

new_none            (j @Token t @Type       ) @Node = return new_lit     j t ty_void 0l;;
new_bool            (j @Token t @Type l i64) @Node = return new_lit     j t ty_bool  l;;
new_false           (j @Token t @Type       ) @Node = return new_bool    j t 0l;;
new_true            (j @Token t @Type       ) @Node = return new_bool    j t 1l;;
new_long            (j @Token t @Type l i64) @Node = return new_lit     j t ty_i64  l ;;
new_ulong           (j @Token t @Type l i64) @Node = return new_lit     j t ring_of ty_i64 l ;;


new_cast(j @Token t @Type a @Node t2 @Type) @Node = return
  (  type_equal     a.t ty_void
  && format_types a.t t2
  ;: (error_tok j "(%s as %s) absurd axiom" s1 s2)
  as void )
;:(  type_equal     a.t t2
  && format_types a.t t2
  ;: (error_tok j "(%s as %s) extraneous axiom" s1 s2)
  as void )
;:(  a.kind != ND_THE
  && format_types a.t t2
/*;: (warn_tok j "(%s as %s) bare axiom" s1 s2)*/
  as void )
;: expect_type j t t2
;: new_unary   j   t2 ND_CAST a
;;
new_then(j @Token t @Type a @Node b @Node) @Node = return
   ( b.t.kind != TY_VOID
  && format_types a.t b.t
  ;: (error_tok j "(%s :; %s) must be (T :; void)" s1 s2)  as void)
;: expect_type j t a.t
;: new_binary  j   a.t ND_THEN a b
;;
new_neth(j @Token t @Type a @Node b @Node) @Node = return
   ( a.t.kind != TY_VOID
  && format_types a.t b.t
  ;: (error_tok j "(%s ;: %s) must be (void ;: T)" s1 s2) as void )
;: expect_type j t b.t
;: new_binary  j   b.t ND_COMMA a b
;;
new_deref(j @Token t @Type a @Node) @Node = return
  (  a.t.kind != TY_PTR
  && format_types a.t ty_void
  ;: (error_tok j "(%s @) must be (@T @)" s1) as void)
;:(  a.t.a.kind == TY_VOID
  && format_types a.t ty_void
  ;: (error_tok j "(%s @) may not be (@void @)") as void )
;: expect_type j t a.t.a
;: new_unary   j   a.t.a ND_DEREF a ;;
new_deref_all(j @Token t @Type a @Node) @Node = return
   a for e
  (  e.t.kind == TY_PTR
  && new_deref j t e );;

new_let(j @Token t @Type a @Node b @Node o @Obj) @Node = return
   new_binary  j   b.t ND_LET    a b is e e
:; (e.var = o)
;;
new_repeat(j @Token t @Type a @Node b @Node o @Obj) @Node = return 
   new_binary  j   b.t ND_REPEAT a b is e e
:; (e.var = o)
;;
new_conditional(j @Token t @Type a @Node b @Node c @Node) @Node = return
  (  !type_equal   a.t ty_bool
  &&(  format_types a.t b.t
    ;: (error_tok j "(%s ?:) must be of the form (bool ?:)" s1 s2) )
  as void )
;:(  !type_equal   b.t c.t
  &&(  format_types b.t c.t
    ;: (error_tok j "(? %s : %s) must be of the form (: T ? T)" s1 s2) )
  as void)  
;: expect_type j t ty_bool
;: new_ternary j b.t ND_COND a b c
;;
new_logor(j @Token t @Type a @Node b @Node) @Node = return
  (  !type_equal   a.t b.t
  && !type_equal   b.t ty_void
  &&(  format_types a.t b.t
    ;: (error_tok j "(%s || %s) must be of the form (T || T) or (T || void)" s1 s2) ) as void )
;: expect_type j t a.t
;: new_binary j a.t ND_LOGOR a b
;;
new_logand(j @Token t @Type a @Node b @Node) @Node = return
  (  !type_equal a.t ty_bool
  && !type_equal ty_void b.t
  &&(  format_types a.t b.t
    ;: (error_tok j "(%s && %s) must be of the form (bool && T) or (T && void)" s1 s2) ) as void)
;: expect_type j t ((b.t.kind == TY_VOID) ? ty_bool : b.t)
;: new_binary  j   ((b.t.kind == TY_VOID) ? ty_bool : b.t) ND_LOGAND a b
;;
new_add   (j @Token t @Type a @Node b @Node) @Node = return
  ( ( (     a.t.kind == TY_PTR
      ||    a.t.kind == TY_ARRAY )
    &&(     b.t.kind == TY_PTR 
      ||    b.t.kind == TY_ARRAY )
    ||      a.t.kind != TY_PTR
    &&      a.t.kind != TY_ARRAY
    &&      b.t.kind != TY_PTR
    &&      b.t.kind != TY_ARRAY
    &&     !type_equal a.t b.t
    &&     format_types a.t b.t
    ;: error_tok j "(%s + %s) must be (T + T) or (@T + U) or (T + @U)" s1 s2 ) as void )
;: new_binary j ((a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) ? pointer_to(a.t.a) : (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY) ? pointer_to(b.t.a) : a.t) ND_ADD a b;;
new_sub(j @Token t @Type a @Node b @Node) @Node = return
  (  a.t.kind != TY_PTR 
  && a.t.kind != TY_ARRAY
  &&(  b.t.kind == TY_PTR
    || b.t.kind == TY_ARRAY ) 
  || a.t.kind != TY_PTR
  && a.t.kind != TY_ARRAY
  && b.t.kind != TY_PTR
  && b.t.kind != TY_ARRAY
  && !type_equal a.t b.t
  &&(  format_types a.t b.t
    ;: error_tok j "(%s - %s) must be (T - T) or (@T - U) or (@T - @U)" s1 s2 ) as void )
;: new_binary j ((a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) ? pointer_to(a.t.a) : (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY) ? ty_i64 : a.t) ND_SUB a b
;;
new_neg          (j @Token t @Type a  @Node) @Node = return new_unary j            a.t ND_NEG  a ;;
new_addressof    (j @Token t @Type a  @Node) @Node = return new_unary j pointer_to a.t ND_ADDR a ;;
new_sizeof       (j @Token t @Type t2 @Type) @Node = return new_ulong j t cast i64 t2.size       ;;
new_alignof      (j @Token t @Type t2 @Type) @Node = return new_ulong j t cast i64 t2.alignment  ;;
new_member_access(j @Token t @Type a  @Node) @Node = return
   (a = new_deref_all j t a)
;:(  a.t.kind != TY_STRUCT
  &&(  format_types a.t ty_void
    ;: error_tok j "(%s . %.*s) must be of the form (@*struct . %.*s)" s1 j.s.len j.s.loc j.s.len j.s.loc ) as void)
;: get_struct_member a.t j is g
  (  !g
  &&(  format_types a.t ty_void
    ;: error_tok j "(%s . %.*s) no such member" s1 j.s.len j.s.loc ) as void )
;: new_unary j g ND_MEMBER a is e e
:; (e.member = g)
;;

new_call(j @Token t @Type a @Node) @Node = return
   expect_type j t a.t.a 
;: new_unary j a.t.a ND_FUNCALL a
;;

get_ident(j @Token) @i8 = return
  ((j.kind != TK_ID) && (error_tok j "expected an nonymousifier") as void) ;:
  strndup j.loc cast %i64 j.len ;;

find_type(k @Ctx) @Type = return
  (k.j.kind != TK_ID) ? cast @Type 0 :
  cast @Name search_scope k is sc
  (!!sc ? sc.t : cast @Type 0 );;

declspec(k @Ctx v@ VarAttr) = return
  true for i (
    consume &k.j k.j "type"    && true :; (v.is_type   = true) ||
    consume &k.j k.j "export"  && true :; (v.is_export = true) ||
    consume &k.j k.j "extern"  && true :; (v.is_extern = true) ||
    consume &k.j k.j "inline"  && true :; (v.is_inline = true)  )
  as void
;;

type_specifier(k @Ctx)@ Type = return
   consume &k.j k.j "undefined" ? cast @Type 0
:  consume &k.j k.j "void"      ? ty_void
:  consume &k.j k.j "bool"      ? ty_bool
:  consume &k.j k.j "i8"        ? ty_i8
:  consume &k.j k.j "i32"       ? ty_i32
:  consume &k.j k.j "i64"       ? ty_i64
:  consume &k.j k.j "struct"    ? struct_decl      k
:  consume &k.j k.j "enum"      ? enum_specifier   k
:  consume &k.j k.j "typeof"    ? typeof_specifier k
:  consume &k.j k.j "same"      ? ( k.current_type 
                           || (error_tok k.j "`same` may not be used outside struct definition") ) :
   find_type k is t
   !t ? ty_void : t
:; cast void advance &k.j
;;

func_params(k @Ctx) @Type = return
   new Type is head
   false is is_variadic
   &head is cur
   (true for _ (!token_equal k.j ")" && !(consume &k.j k.j "..."
?  (is_variadic = true)
;: true
:  (cur.s = copy_type declarator k)
;: (cur = cur.s)
;: false))
as void)
;: advance &k.j
;: func_type type_suffix k is t
   (t.params = head.s)
;: (t.is_variadic = is_variadic)
;: t
;;

array_dimensions(k @Ctx) @Type = return
   consume &k.j k.j "]"
?  type_suffix k is t
   array_of t -1
:  infix k ty_i32 is e
   expect &k.j "]"
;: type_suffix k is t
   array_of t cast i32 eval e
;;

typeof_specifier(k @Ctx) @Type = return
   tertiary k cast @Type 0 is e
   e.t
;;

type_suffix(k @Ctx) @Type = return
   (k.j = k.j for j (token_equal j "const" && j.s))
;: consume &k.j k.j "%" ? ring_of    type_suffix k
:  consume &k.j k.j "(" ? func_params            k
:  consume &k.j k.j "[" ? array_dimensions       k
:  consume &k.j k.j "@" ? pointer_to type_suffix k
:  type_specifier k
;;

declarator(k @Ctx)@ Type = return
   advance &k.j is j
   copy_type type_suffix k is t t
:; (t.name = j)
;;

enum_specifier(k @Ctx) @Type =
  let t = enum_type;
  let l = 0;
  while ! consume &k.j k.j ";" {
    let p = get_ident k.j;
    advance &k.j;
    let sc = push_scope k p;
    (sc.t = t);
    (sc.v = l);
    (l = l + 1);;
  return t;;

stmt(k @Ctx) @Node = return
  k.j is j
  (consume &k.j k.j "return" ?
    new_node j cast @Type 0 ND_RETURN is e
    (consume &k.j k.j ";" ? e :
    (e.a = infix k k.current_fn.t.a)     ;:
    expect &k.j ";"          ;:
    k.current_fn.t.a is t
    (!type_equal k.current_fn.t.a e.a.t &&
      ( format_types e.a.t k.current_fn.t.a ;:
        (error_tok e.a.j "asymmetric return from %s to %s" s1 s2)) as void) ;:
    e) :
  consume &k.j k.j "if" ?
    new_node j cast @Type 0 ND_IF is e
    (e.cond = tertiary k ty_bool) ;:
    (e.then = stmt k) ;:
    (consume &k.j k.j "else" && (e.els = stmt k) as void) ;:
    e :
  consume &k.j k.j "for" ?
    new_node j cast @Type 0 ND_FOR is e
    expect &k.j "(" ;:
    enter_scope k ;:
    (e.init = expr_stmt k) ;:
    (!token_equal k.j ";" && (e.cond = quaternary k ty_bool) as void) ;: expect &k.j ";" ;:
    (!token_equal k.j ")" && (e.inc  = quaternary k ty_void) as void) ;: expect &k.j ")" ;:
                            (e.then = stmt k) ;:
    leave_scope k ;:
    e :
  consume &k.j k.j "while" ?
    new_node j cast @Type 0 ND_FOR is e
    (e.cond       = tertiary k       ty_bool) ;:
    (e.then       = stmt k           ) ;:
    e :
  consume &k.j k.j "{" ? compound_stmt k :
  expr_stmt k);;

decl_stmt(k @Ctx) @Node =
  let
    head = new Node
    cur = &head;
  while ! token_equal k.j ";" {
    if token_equal k.j.s "=" {
      if (k.j.kind != TK_ID) (error_tok k.j "expected nonymousifer");
      else {
        let name = k.j;
        advance &k.j;
        advance &k.j;
        let e = tertiary k cast @Type 0;
        if (e.t.kind == TY_VOID) (error_tok k.j "variable declared void");
        else {
          let o = new_lvar k get_ident name e.t;
          (cur.s = new_unary k.j ty_void ND_EXPR_STMT new_assign k.j ty_void new_reference k.j e.t o e);
          (cur = cur.s);;;;
    else {
      let t = declarator k;
      if (t.kind == TY_VOID) (error_tok k.j "variable declared void");
      else {
        if !token_equal t.name "_" {
          let o = new_lvar k get_ident t.name t;
          if consume &k.j k.j "=" {
            let e = (tertiary k o.t is e new_neth k.j ty_void (new_node k.j ty_void ND_MEMZERO is a a :; (a.var = o)) new_assign k.j ty_void new_reference k.j o.t o e);
            (cur.s = new_unary k.j cast @Type 0 ND_EXPR_STMT e);
            (cur = cur.s);;
          if (o.t.size < 0) (error_tok t.name "variable has incomplete type");
          else if (o.t.kind == TY_VOID) (error_tok t.name "variable declared void");;;;;
  let e = new_node k.j cast @Type 0 ND_BLOCK;
  advance &k.j;
  (e.body = head.s);
  return e;;

compound_stmt(k @Ctx) @Node = return
   new_node k.j cast @Type 0 ND_BLOCK is e e
:; enter_scope k
:; cast @Node 0 is head
  (  &e.body for p
    (  !consume &k.j k.j ";"
    && (p@ = (consume &k.j k.j "let" ? &decl_stmt : &stmt)@ k)
    ;: &p.s ) as void )
:; leave_scope k
;;

expr_stmt(k @Ctx)@ Node = return
   new_node k.j cast @Type 0 ND_EXPR_STMT is e
   (e.a = quaternary k ty_void)
;: expect &k.j ";"
;: e
;;

eval2(e@ Node label @@@i8) i64 = return
  (e.kind == ND_NOT   ) ? cast i64 !eval e.a              :
  (e.kind == ND_ADD   ) ? (eval2 e.a label + eval e.a.s)   :
  (e.kind == ND_SUB   ) ? (eval2 e.a label - eval e.a.s)   :
  (e.kind == ND_NEG   ) ? -eval e.a                        :
  (e.kind == ND_MUL   ) ? (eval e.a *  eval e.a.s)         :
  (e.kind == ND_BITAND) ? (eval e.a &  eval e.a.s)         :
  (e.kind == ND_BITOR ) ? (eval e.a |  eval e.a.s)         :
  (e.kind == ND_BITXOR) ? (eval e.a ^  eval e.a.s)         :
  (e.kind == ND_SHL   ) ? (eval e.a << eval e.a.s)         :
  (e.kind == ND_EQ    ) ? (eval e.a == eval e.a.s as i64) :
  (e.kind == ND_NE    ) ? (eval e.a != eval e.a.s as i64) :
  (e.kind == ND_SHR   ) ? ((e.a.t.kind == TY_RING) &&
                           e.t.size == 8        )  ? (cast %i64 eval e.a >> cast %i64 eval e.a.s as i64) :
                                                      (                   eval e.a >>                    eval e.a.s        ) :
  (e.kind == ND_DIV   ) ?  (e.a.t.kind == TY_RING)     ? (cast %i64 eval e.a /  cast %i64 eval e.a.s as i64) :
                                                      (                   eval e.a /                     eval e.a.s        ) :
  (e.kind == ND_MOD   ) ?  (e.a.t.kind == TY_RING)     ? (cast %i64 eval e.a %  cast %i64 eval e.a.s as i64) :
                                                      (                   eval e.a %                     eval e.a.s        ) :
  (e.kind == ND_LT    ) ?  (e.a.t.kind == TY_RING)     ? (cast %i64 eval e.a <  cast %i64 eval e.a.s as i64) :
                                                      (                   eval e.a <                     eval e.a.s as i64) :
  (e.kind == ND_LE    ) ?  (e.a.t.kind == TY_RING)     ? (cast %i64 eval e.a <= cast %i64 eval e.a.s as i64) :
                                                      (                   eval e.a <=                    eval e.a.s as i64) :
  (e.kind == ND_GT    ) ?  (e.a.t.kind == TY_RING)     ? (cast %i64 eval e.a >  cast %i64 eval e.a.s as i64) :
                                                      (                   eval e.a >                     eval e.a.s as i64) :
  (e.kind == ND_GE    ) ?  (e.a.t.kind == TY_RING)     ? (cast %i64 eval e.a >= cast %i64 eval e.a.s as i64) :
                                                      (                   eval e.a >=                    eval e.a.s as i64) :
  (e.kind == ND_COND  ) ? !!eval e.a ? eval2 e.a.s label :
                                          eval2 e.a.s.s  label :
  (e.kind == ND_COMMA ) ? eval2 e.a.s label :
  (e.kind == ND_THE   ) ? eval2 e.a label :
  (e.kind == ND_BITNOT) ? ~ eval e.a      :
  (e.kind == ND_LOGAND) ? (!!eval e.a &&
                             eval e.a.s  )  :
  (e.kind == ND_LOGOR ) ? (  eval e.a ||
                             eval e.a.s  )  :
  (e.kind == ND_CAST  ) ?
    eval2 e.a label is l
    (
    (e.t.size == 1) ? ((e.t.kind == TY_RING) ? cast i64 cast %i8  the i64 l : cast i64 cast  i8  the i64 l) :
    (e.t.size == 4) ? ((e.t.kind == TY_RING) ? cast i64 cast %i32 the i64 l : cast i64 cast i32 the i64 l) :
                                                                            l)                                      :
  (e.kind == ND_ADDR     ) ? eval_rval e.a label :
  (e.kind == ND_MEMBER   ) ?
    !label ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (e.t.kind != TY_ARRAY) ? (error_tok e.j "invalid initializer") ;: 0l :
    (eval_rval e.a label + cast i64 e.member.offset) :
  (e.kind == ND_VAR      ) ?
    !label ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (e.var.t.kind != TY_ARRAY && e.var.t.kind != TY_FUNC) ? (error_tok e.j "invalid initializer") ;: 0l :
    (label@ = &e.var.name) ;: 0l :
  (e.kind == ND_NUM      ) ? e.val :
  (error_tok e.j "not a compile-time constant") ;:
  0l;;

eval(e@ Node) i64 = return eval2 e cast @@@i8 0;;

eval_rval(e@ Node label @@@i8) i64 = return
  (e.kind == ND_VAR) ?
    e.var.is_local ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (label@ = &e.var.name) ;: 0l :
  (e.kind == ND_DEREF ) ? (eval2     e.a label                  ) :
  (e.kind == ND_MEMBER) ? (eval_rval e.a label + cast i64 e.member.offset) :
  (error_tok e.j "invalid initializer") ;:
  0l;;

is_const_expr(e@ Node) bool = return
  ( e.kind == ND_NEG    ||
    e.kind == ND_NOT    ||
    e.kind == ND_BITNOT ||
    e.kind == ND_THE    ||
    e.kind == ND_CAST    )  ? is_const_expr e.a :
  ( e.kind == ND_ADD    ||
    e.kind == ND_SUB    ||
    e.kind == ND_MUL    ||
    e.kind == ND_DIV    ||
    e.kind == ND_BITAND ||
    e.kind == ND_BITOR  ||
    e.kind == ND_BITXOR ||
    e.kind == ND_SHL    ||
    e.kind == ND_SHR    ||
    e.kind == ND_EQ     ||
    e.kind == ND_NE     ||
    e.kind == ND_LT     ||
    e.kind == ND_LE     ||
    e.kind == ND_GT     ||
    e.kind == ND_GE     ||
    e.kind == ND_LOGAND ||
    e.kind == ND_LOGOR   )  ? (is_const_expr e.a  && is_const_expr e.a.s                           ) :
  ( e.kind == ND_COND    )  ? (is_const_expr e.a && is_const_expr (!!eval e.a ? e.a.s : e.a.s.s)) :
  ( e.kind == ND_NUM     ) ;;
export const_expr(k @Ctx) i64 = return eval tertiary k ty_i64;;

left(k @Ctx t @Type op @i8 parse_@ (k @Ctx t @Type) @Node) @Node = return
token_equal k.j op && parse_@ k t ;;
right(k @Ctx t @Type a @Node op @i8 parse_@ (k @Ctx t @Type a @Node) @Node) @Node = return
token_equal k.j op && parse_@ k t a ;;

array_access(k @Ctx t @Type a @Node) @Node = return
   advance &k.j is j
   infix k ty_i32 is b
   expect &k.j "]"
;: new_deref j t new_add j ty_i32 a b
;;
member_access(k @Ctx t @Type a @Node) @Node = return
   cast void advance &k.j
;: new_member_access advance &k.j t a
;;

nonee      (k @Ctx t @Type        ) @Node = return advance &k.j is j                                                                                                                  new_none        j t                      ;;
falsee     (k @Ctx t @Type        ) @Node = return advance &k.j is j                                                                                                                  new_false       j t                      ;;
truee      (k @Ctx t @Type        ) @Node = return advance &k.j is j                                                                                                                  new_true        j t                      ;;
sizee      (k @Ctx t @Type        ) @Node = return advance &k.j is j type_suffix k is t2                                                                                              new_sizeof      j t t2                   ;;
aligne     (k @Ctx t @Type        ) @Node = return advance &k.j is j type_suffix k is t2                                                                                              new_alignof     j t t2                   ;;
deref      (k @Ctx t @Type a @Node) @Node = return advance &k.j is j                                                                                                                  new_unary       j a.t.a ND_DEREF a       ;;
addressof  (k @Ctx t @Type        ) @Node = return advance &k.j is j                                                          secondary k t       is a                                new_addressof   j t a                    ;;
theorem    (k @Ctx t @Type        ) @Node = return advance &k.j is j type_suffix k is t2                                       tertiary k t       is a                                new_the         j t a t2                 ;;
axiom      (k @Ctx t @Type        ) @Node = return advance &k.j is j type_suffix k is t2                                       tertiary k t       is a                                new_cast        j t a t2                 ;;
neg        (k @Ctx t @Type        ) @Node = return advance &k.j is j                                                           tertiary k t       is a                                new_neg         j t a                    ;;
lognot     (k @Ctx t @Type        ) @Node = return advance &k.j is j                                                           tertiary k t       is a                                new_lognot      j t a                    ;;
bitnot     (k @Ctx t @Type        ) @Node = return advance &k.j is j                                                           tertiary k t       is a                                new_bitnot      j t a                    ;;
then       (k @Ctx t @Type a @Node) @Node = return advance &k.j is j                                                                seq k ty_void is b                                new_binary      j a.t ND_THEN  a b       ;;
neth       (k @Ctx t @Type a @Node) @Node = return advance &k.j is j                                                                seq k t       is b                                new_binary      j b.t ND_COMMA a b       ;;
conditional(k @Ctx t @Type a @Node) @Node = return advance &k.j is j                                                                seq k t       is b  expect &k.j ":" ;: seq k t is c  new_conditional j t a b c                ;;
islet      (k @Ctx t @Type a @Node) @Node = return advance &k.j is j enter_scope k ;: new_lvar k get_ident advance &k.j a.t is o           seq k t       is b                                new_let         j t a b o :; leave_scope k ;;
repeat     (k @Ctx t @Type a @Node) @Node = return advance &k.j is j enter_scope k ;: new_lvar k get_ident advance &k.j a.t is o           seq k t       is b                                new_repeat      j t a b o :; leave_scope k ;;

secondary(k @Ctx t @Type) @Node = return
   left    k t       "cast"    &axiom
|| left    k t       "the"     &theorem
|| left    k t       "&"       &addressof
|| left    k t       "sizeof"  &sizee
|| left    k t       "alignof" &aligne
|| left    k t       "none"    &nonee
|| left    k t       "false"   &falsee
|| left    k t       "true"    &truee
|| primary k t for a
(  right   k t     a "["       &array_access
|| right   k t     a "."       &member_access
|| right   k t     a "@"       &deref
 ) ;;

tertiary_left(k @Ctx t @Type) @Node = return
(  left k t "-"     &neg
|| left k t "!"     &lognot
|| left k t "~"     &bitnot
 ) ;;

seq(k @Ctx t @Type) @Node = return 
  tertiary k cast @Type 0 is a
(  right k t a ":;"  &then
|| right k t a ";:"  &neth
|| right k t a "is"  &islet
|| right k t a "for" &repeat
|| right k t a "?"   &conditional
|| a
 ) ;;

primary(k @Ctx t @Type) @Node = return
  ( token_equal k.j "new" ?
      advance &k.j is j
      type_suffix k is t2
      new_lvar k "" t2 is o
      new_node k.j ty_void ND_MEMZERO is b
      (b.var = o) ;:
      new_neth k.j t b new_reference k.j t o :
    consume &k.j k.j "(" ? quaternary k t :; expect &k.j ")" :
    (k.j.kind == TK_ID) ?
      cast @Name search_scope k is sc
      advance &k.j;:
      (!!sc ? !!sc.o ? new_reference k.j t sc.o : new_lit k.j t sc.t cast i64 sc.v :
      (error_tok k.j "lookup failed") ;: cast @Node 0) :
    (k.j.kind == TK_STR) ?
      new_string_literal k k.j.str t cast @Type k.j.t is o
      new_cast k.j t new_the k.j cast @Type k.j.t new_reference k.j cast @Type k.j.t o o.t pointer_to (cast @Type k.j.t).a :;
      cast void advance &k.j :
    (k.j.kind == TK_NUM) ?
      ( new_lit k.j t cast @Type k.j.t k.j.val :; cast void advance &k.j ) :
    (error_tok k.j "expected an expression") ;: cast @Node 0);;

tertiary(k @Ctx t @Type) @Node = return
   tertiary_left k cast @Type 0
|| secondary k cast @Type 0 for a
  (  a.t.kind == TY_FUNC
  && a.t.params is u
    (  a for b
      (  (!!u || a.t.is_variadic && ! token_equal k.j ")")
      && (b.s = tertiary k u)
      ;: (  !!u 
         && (!type_equal b.s.t u && format_types b.s.t u ;: (error_tok k.j "asymmetric argument from %s to %s" s1 s2) as void)
         ;: (u = u.s)
         as void)
      ;: b.s )
    as void )
  ;: (!!u && (error_tok k.j "not enough arguments") as void)
  ;: new_call k.j t a )
;;

mul        (k @Ctx t @Type) @Node = return seq        k t             for a (  token_equal k.j "*"  && advance &k.j is j new_mul    j t a seq        k a.t
                                                                               || token_equal k.j "/"  && advance &k.j is j new_div    j t a seq        k a.t
                                                                               || token_equal k.j "%"  && advance &k.j is j new_mod    j t a seq        k a.t) ;;
add        (k @Ctx t @Type) @Node = return mul        k t             for a (  token_equal k.j "+"  && advance &k.j is j new_add    j t a mul        k a.t
                                                                               || token_equal k.j "-"  && advance &k.j is j new_sub    j t a mul        k a.t) ;;
shift      (k @Ctx t @Type) @Node = return add        k t             for a (  token_equal k.j "<<" && advance &k.j is j new_shl    j t a add        k a.t
                                                                               || token_equal k.j ">>" && advance &k.j is j new_shr    j t a add        k a.t) ;;
relational (k @Ctx t @Type) @Node = return shift      k cast @Type 0  for a (  token_equal k.j "<"  && advance &k.j is j new_lt     j t a shift      k cast @Type 0
                                                                               || token_equal k.j ">"  && advance &k.j is j new_gt     j t a shift      k cast @Type 0
                                                                               || token_equal k.j "<=" && advance &k.j is j new_le     j t a shift      k cast @Type 0
                                                                               || token_equal k.j ">=" && advance &k.j is j new_ge     j t a shift      k cast @Type 0
                                                                               || token_equal k.j "==" && advance &k.j is j new_eq     j t a shift      k cast @Type 0
                                                                               || token_equal k.j "!=" && advance &k.j is j new_neq    j t a shift      k cast @Type 0) ;;
bitand     (k @Ctx t @Type) @Node = return relational k t             for a (  token_equal k.j "&"  && advance &k.j is j new_bitand j t a relational k a.t) ;;
bitxor     (k @Ctx t @Type) @Node = return bitand     k t             for a (  token_equal k.j "^"  && advance &k.j is j new_bitxor j t a bitand     k a.t) ;;
bitor      (k @Ctx t @Type) @Node = return bitxor     k t             for a (  token_equal k.j "|"  && advance &k.j is j new_bitor  j t a bitxor     k a.t) ;;
logand     (k @Ctx t @Type) @Node = return bitor      k cast @Type 0  for a (  token_equal k.j "&&" && advance &k.j is j new_logand j t a bitor      k a.t) ;;
logor      (k @Ctx t @Type) @Node = return logand     k t             for a (  token_equal k.j "||" && advance &k.j is j new_logor  j t a logand     k a.t) ;;

infix(k @Ctx t @Type) @Node = return
   logor k cast @Type 0 for a
  (  token_equal k.j "as"   && advance &k.j is j type_suffix k is u new_cast j u a u :; (t = u)
  || token_equal k.j "from" && advance &k.j is j type_suffix k is u new_the  j u a u :; (t = u) )
;;

quaternary(k @Ctx t @Type) @Node = return
   infix k cast @Type 0 is a
                     k.j is j
   token_equal k.j "="
?  advance &k.j is j new_assign j t a infix k a.t
:  a
;;

struct_members(k @Ctx t @Type)  =
  let
    head = new Type
    cur = &head;
  while ! consume &k.j k.j "}" {
    let v = &new VarAttr;
    declspec k v;
    while ! consume &k.j k.j ";" {
      let g = (calloc 1ul sizeof Type as @Type);
      (g@ = declarator k);
      (g.alignment = v.alignment || g.alignment);
      (cur.s = g);
      (cur = cur.s);;;
  (t.a = head.s);;

struct_union_decl(k @Ctx) @Type = return
   struct_type is t
   expect &k.j "{"
;: (k.current_type = t)
;: struct_members k t
;: (k.current_type = 0 as @Type)
;: t
;;

struct_decl(k @Ctx) @Type =
  let t = struct_union_decl k;
  (t.kind = TY_STRUCT);
  if (t.size < 0) return t;
  let bits = 0 g = t.a;
  for (none; g; g = g.s) {
      (bits = align_to bits (g.alignment * 8));
      (g.offset = bits / 8);
      (bits = bits + g.size * 8);
    if (t.alignment < g.alignment)
      (t.alignment = g.alignment);;
  (t.size = align_to bits (t.alignment * 8) / 8);
  return t;;

get_struct_member(t @Type j @Token) @Type =
  let g = t.a;
  for (none; g; g = g.s) {
    if ((g.kind == TY_STRUCT) && (!g.name || token_equal g.name "_")) {
      if cast bool get_struct_member g j return g;;
    else if (g.name.len == j.len && ! strncmp g.name.loc j.loc cast %i64 j.len ) return g;;
  return
  0 as @Type
;;

typedecl(k @Ctx) @Token = return
  k.j for j
  (  !token_equal k.j ";" &&
    (  declarator k is t
       ((push_scope k get_ident t.name).t = t)
    ;: k.j ) );;

create_param_lvars(k @Ctx param@ Type) = return
  !!param ?
    create_param_lvars k param.s ;:
    (new_lvar k get_ident param.name param as) :
  none;;

find_func(k @Ctx name @i8) @Obj = return
  cast @Name hashmap_get &(k.scope for s s.s).vars name is s
  (!!s && s.o.is_function && s.o);;

function(k @Ctx attr @VarAttr) = return
  declarator k is t
  get_ident t.name is name_str
  find_func k name_str is o
  ( !!o ?
      (!o.is_function                  && (error_tok k.j "redeclared as a different kind of symbol") as void) ;:
      (o.is_definition && token_equal k.j "=" && (error_tok k.j "redefinition of %s" name_str) as void) ;:
      (o.is_export != attr.is_export   && (error_tok k.j "mismatched visibility") as void) ;:
      (o.is_definition = o.is_definition || token_equal k.j "=") :
    (o = new_gvar k name_str t) ;:
    (o.is_function = true) ;:
    (o.is_definition = token_equal k.j "=") ;:
    (o.is_export = attr.is_export)  ;:
    (o.is_inline = attr.is_inline) ) ;:
  (token_equal k.j ";" ? none :
  (k.current_fn = o) ;:
  (k.locals = 0 as @Obj) ;:
  enter_scope k ;:
  create_param_lvars k t.params ;:
  t.a is rty
  (((rty.kind == TY_STRUCT) && rty.size > 16) && new_lvar k "" pointer_to rty as) ;:
  (o.params = k.locals) ;:
  (t.is_variadic && (o.va_area = new_lvar k "__va_area__" array_of ty_i8 136) as void) ;:
  expect &k.j "=" ;:
  (o.body = compound_stmt k as @) ;:
  (o.locals = k.locals) ;:
  leave_scope k);;

global_variable(k @Ctx attr@ VarAttr) =
  while ! consume &k.j k.j ";" {
    let t = declarator k;
    if !(!t.name || token_equal t.name "_") {
      let var = new_gvar k get_ident t.name t;
      (var.is_definition = !attr.is_extern);
      (var.is_export = attr.is_export);
      (var.is_inline = attr.is_inline);
      if attr.alignment (var.alignment = attr.alignment);
      if (!attr.is_extern) (var.is_tentative = true);;;;

scan_globals(k @Ctx) = return
   new Obj is head
   &head is cur
  (  k.globals for o
     o.s
  :; (!o.is_tentative
  ?  (cur.s = o)
  ;: (cur = cur.s)
  : (  k.globals for o2 ((o2 == o || !o2.is_definition || !!strcmp o.name o2.name) && (o2.s || (cur.s = o) ;: (cur = cur.s) ;: cast @Obj 0))
    as void ))
  as void )
;: (cur.s = 0 as @Obj)
;: (k.globals = head.s)
;;

export parse(j @Token) @Obj = return
   new Ctx is k
   (k.j            = j)
;: (k.locals       = cast @Obj   0)
;: (k.globals      = cast @Obj   0)
;: (k.scope        = cast @Scope 0)
;: (k.current_type = cast @Type  0)
;: (k.current_fn   = cast @Obj   0)
;: enter_scope &k
;:( k.j for j
    (  !!j.kind
    && new VarAttr is v
       declspec &k &v
    ;: v.is_type
    ?  typedecl &k
    :  (((k is k1 (declarator &k1).kind) == TY_FUNC) ? function &k &v : global_variable &k &v)
    ;: k.j)
  as void)
;: leave_scope &k
;: scan_globals &k
;: k.globals
;;