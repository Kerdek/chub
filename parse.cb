#include "chub.hb"

type
  VarScope struct {
    var      @Obj
    type_def @Type
    enum_ty  @Type
    enum_val  int;
  }
  Scope struct {
    next @same
    vars  HashMap
    tags  HashMap;
  }
  VarAttr struct {
    is_type    bool
    is_static  bool
    is_extern  bool
    is_export  bool
    is_inline  bool
    is_tls     bool
    alignment  int;
  }
  Initializer struct {
    next        @same
    ty          @Type
    tok         @Token
    is_flexible  bool
    expr        @Node
    children   @@same
    g         @Member;
  }
  InitDesg struct {
    next     @same
    idx       int
    member   @Member
    var      @Obj;
  }
;

locals         @Obj
globals        @Obj
scope          @Scope = &(let Scope){;
current_type   @Type
current_fn     @Obj
gotos          @Node
labels         @Node
brk_label      @char
cont_label     @char
current_switch @Node
builtin_alloca @Obj

add                (k @@Token) @Node
compound_stmt      (k @@Token) @Node
expr_stmt          (k @@Token) @Node
assign             (k @@Token) @Node
juxt               (k @@Token) @Node
conditional        (k @@Token) @Node
postfix            (k @@Token) @Node
prefix             (k @@Token) @Node
primary            (k @@Token) @Node

enum_specifier     (k @@Token) @Type
typeof_specifier   (k @@Token) @Type
type_suffix        (k @@Token) @Type
declarator         (k @@Token) @Type
struct_decl        (k @@Token) @Type
union_decl         (k @@Token) @Type

typedecl           (k @@Token)
is_function        (k  @Token) bool

declspec           (k @@Token v @VarAttr)
declaration        (k @@Token v @VarAttr) @Node
function           (k  @Token v @VarAttr) @Token
global_variable    (k  @Token v @VarAttr) @Token

funcall            (k @@Token e @Node) @Node

array_initializer2 (k @@Token e @Initializer i int    )
struct_initializer2(k @@Token e @Initializer g@ Member)

initializer2       (k @@Token init@ Initializer)
initializer        (k @@Token new_ty @@Type    ) @Initializer

lvar_initializer   (k @@Token o @Obj) @Node
gvar_initializer   (k @@Token o @Obj)

eval               (node  @Node                                               ) int64_t
eval2              (node  @Node   label @@@char                               ) int64_t
eval_rval          (node  @Node   label @@@char                               ) int64_t
is_const_expr      (node  @Node                                               ) bool
eval_double        (node  @Node                                               ) double
new_add            (lhs   @Node   rhs @Node  tok@ Token                       ) @Node
new_sub            (lhs   @Node   rhs @Node  tok@ Token                       ) @Node
get_struct_member  (ty    @Type   tok @Token                                  ) @Member;

s1 [1024]char s2 [1024]char;
format_types(t @Type u @Type) = return
  (s1[0] = 0)->, (s2[0] = 0)->,
  format_type t &s1@,
  format_type u &s2@,
  none;;
align_down(n int alignment int) int = return align_to (n - alignment + 1) alignment;;
enter_scope(void) = let sc = (calloc 1ul sizeof Scope)->@Scope; sc.next = scope; scope = sc;;
leave_scope(void) = scope = scope.next;;
push_scope(name@ char) @VarScope = return (calloc 1ul sizeof VarScope)->@VarScope :: sc hashmap_put &scope.vars name sc->@, sc;;
search_scope(tok @Token which(_@ Scope)@HashMap)@ = for (let sc@ Scope = scope; sc; sc = sc.next) { let sc2 = hashmap_get2 which@ sc tok.loc tok.len; if sc2 return sc2; ; return 0->@; ;
scope_vars(s @Scope) @HashMap = return &s.vars;;
scope_tags(s @Scope) @HashMap = return &s.tags;;

new_initializer(t @Type is_flexible bool) @Initializer =
  let e = (calloc 1ul sizeof Initializer)->@Initializer;
  e.ty = t;
  if (t.kind == TY_ARRAY) {
    if (is_flexible && t.size < 0) {
      e.is_flexible = true;
      return e;;
    e.children = calloc t.array_len->unsigned long sizeof @Initializer;
    for (let i int = 0; i < t.array_len; i++) e.children[i] = new_initializer t.base false;
    return e;;
  if (t.kind == TY_STRUCT || t.kind == TY_UNION) {
    let len = 0;
    for (let g@ Member = t.members; g; g = g.next) len++;
    e.children = calloc len->unsigned long sizeof @;
    for (let g@ Member = t.members; g; g = g.next) {
      if (is_flexible && t.is_flexible && !g.next) {
        let child = (calloc 1ul sizeof Initializer)->@Initializer;
        child.ty = g.ty;
        child.is_flexible = true;
        e.children[g.idx] = child;;
      else e.children[g.idx] = new_initializer g.ty->@Type false;    ;
    return e;;
  return e;;

new_var(name @char t @Type) @Obj = return
  (calloc 1ul sizeof Obj)->@Obj :: o
  (o.name = name)->,
  (o.ty = t)->,
  (o.alignment = t.alignment)->,
  ((push_scope name).var = o)->,
  o;;
new_lvar(name @char t @Type) @Obj = return
  new_var name t :: o
  (o.is_local = true)->,
  (o.next = locals)->,
  (locals = o)->,
  o;;
new_gvar(name @char t @Type) @Obj = return
  new_var name t :: o
  (o.next = globals)->,
  (o.is_export = false)->,
  (o.is_definition = true)->,
  (globals = o)->,
  o;;
nunid int = 0;
new_unique_name(void) @char = return format ".L..%d" nunid++;;
new_anon_gvar(t @Type) @Obj = return new_gvar new_unique_name t;;
new_string_literal(p @char t @Type) @Obj = return new_anon_gvar t :: o (o.init_data = p)->, o;;

new_node(c NodeKind j @Token) @Node = return (calloc 1ul sizeof Node)->@Node :: e (e.kind = c)->, (e.tok = j)->, e;;
new_binary(c NodeKind a @Node b @Node j @Token) @Node = return new_node c j :: e (e.lhs = a)->, (e.rhs = b)->, e;;
new_unary(c NodeKind a @Node k @Token) @Node = return new_binary c a 0->@Node k;;
new_nullary(c NodeKind k @Token) @Node = return new_unary c 0->@Node k;;
new_lit(l long k @Token t @Type) @Node = return new_nullary ND_NUM k :: e (e.val = l)->, (e.ty = t)->, e;;
new_none(k @Token) @Node = return new_lit 0l k ty_void;;
new_bool(l long k @Token) @Node = return new_lit l k ty_bool;;
new_long(l long k @Token) @Node = return new_lit l k ty_long;;
new_ulong(l long k @Token) @Node = return new_lit l k ty_ulong;;
new_reference(o @Obj k @Token) @Node = return new_nullary ND_VAR k :: e (e.var = o)->, (e.ty = o.ty)->, e;;
export new_cast(j @Token a @Node t @Type) @Node = return
  add_type a,
  new_unary ND_CAST a j :: e
  (e.ty = t)->,
  type_equal a.ty e.ty ?
    format_types a.ty e.ty,
    warn_tok j "needless cast from %s to %s" s1 s2,
    e :
  e;;
new_until(j @Token a @Node) @Node = return 
  add_type a,
  new_unary ND_UNTIL a j :: e
  (e.ty = a.ty)->,
  e;;
new_comma(j @Token a @Node b @Node) @Node = return
  add_type a, add_type b,
  (a.ty.kind != TY_VOID && error_tok j "left operand of comma must be void")->,
  new_binary ND_COMMA a b j :: e
  (e.ty = b.ty)->,
  e;;
new_let(j @Token a @Node b @Node o @Obj) @Node = return
  add_type a, add_type b,
  new_comma j new_cast j new_binary ND_ASSIGN new_reference o j a j ty_void b :: e
  (e.ty = b.ty)->, e;;
new_conditional(j @Token a @Node b @Node c @Node) @Node = return
  add_type a, add_type b, add_type c,
  ( ! type_equal b.ty c.ty &&
    ( format_types b.ty c.ty,
      warn_tok j "asymmetric conditional between %s and %s" &s1@ &s2@) )->,
  new_node ND_COND j :: e
  (e.cond = a)->, (e.then = b)->, (e.els = c)->, (e.ty = b.ty)->, e;;
new_assign(j @Token a @Node b @Node) @Node = return
  add_type a, add_type b,
  ! type_equal a.ty b.ty ?
    format_types a.ty b.ty,
    error_tok j "asymmetric assignment to %s from %s" s1 s2,
    0 as @Node :
  new_binary ND_ASSIGN a b j :: e
  (e.ty = ty_void)->, e;;
compound_assign(e @Node) @Node = return new_assign e.tok e.lhs e;;

get_ident(k@ Token) @char = return
  (k.kind != TK_IDENT && error_tok k "expected an identifier")->,
  strndup k.loc k.len->unsigned long;;
find_type(k @Token) @Type = return
  (k.kind == TK_IDENT)->@Type &&
  ( (search_scope k scope_vars->@(sc@Scope)@HashMap)->@VarScope :: sc
    sc->@Type && sc.type_def) ||
  0->@Type;;
push_tag_scope(k@ Token t@ Type) = return hashmap_put2 &scope.tags k.loc k.len t->@;;

declspec(k @@Token v@ VarAttr) =
  for (;;) {
    if (equal k@ "type" || equal k@ "export" || equal k@ "extern" || equal k@ "inline" || equal k@ "_Thread_local" || equal k@ "__thread") {
      if !v error_tok k@ "storage class specifier is not allowed in this context";
      ( equal k@ "type"   ? &v.is_type   :
        equal k@ "export" ? &v.is_export :
        equal k@ "extern" ? &v.is_extern :
        equal k@ "inline" ? &v.is_inline :
                             &v.is_tls      )@ = true;
      if (v.is_type && v.is_static + v.is_export + v.is_extern + v.is_inline + v.is_tls > 1) error_tok k@ "type may not be used together with export, static, extern, inline, __thread or _Thread_local";
      k@ = k.next;;
    else if equal k@ "align" {
      if !v error_tok k@ "align is not allowed in this context";
      k@ = k.next;
      v.alignment = const_expr k;;
    else if consume k k@ "restrict";
    else return;;;
type_specifier(k @@Token)@ Type =
  if consume k k@ "struct" return struct_decl      k; else
  if consume k k@ "union"  return union_decl       k; else
  if consume k k@ "enum"   return enum_specifier   k; else
  if consume k k@ "typeof" return typeof_specifier k; else
  if consume k k@ "same"   {
    if !current_type error_tok k@ "`same` may not be used outside struct/union definition";
    return current_type;;
  else {
    let ty2 = find_type k@;
    if ty2{
      k@ = k.next;
      return ty2;;
    else {
      let counter = 0->enum 
        BOOL     = (1 <<  2)
        CHAR     = (1 <<  4)
        SHORT    = (1 <<  6)
        INT      = (1 <<  8)
        LONG     = (1 << 10)
        FLOAT    = (1 << 12)
        DOUBLE   = (1 << 14)
        SIGNED   = (1 << 17)
        UNSIGNED = (1 << 18);;
      for (;;) {
        if equal k@ "bool"     counter += BOOL    ; else
        if equal k@ "char"     counter += CHAR    ; else
        if equal k@ "short"    counter += SHORT   ; else
        if equal k@ "int"      counter += INT     ; else
        if equal k@ "long"     counter += LONG    ; else
        if equal k@ "float"    counter += FLOAT   ; else
        if equal k@ "double"   counter += DOUBLE  ; else
        if equal k@ "signed"   counter |= SIGNED  ; else
        if equal k@ "unsigned" counter |= UNSIGNED; else
          break;
        k@ = k.next;;
      switch counter {
      case (0                           ) : return ty_void;
      case (BOOL                        ) : return ty_bool;
      case (CHAR                        ) :
      case (SIGNED + CHAR               ) : return ty_char;
      case (UNSIGNED + CHAR             ) : return ty_uchar;
      case (SHORT                       ) :
      case (SHORT + INT                 ) :
      case (SIGNED + SHORT              ) :
      case (SIGNED + SHORT + INT        ) : return ty_short;
      case (UNSIGNED + SHORT            ) :
      case (UNSIGNED + SHORT + INT      ) : return ty_ushort;
      case (INT                         ) :
      case (SIGNED                      ) :
      case (SIGNED + INT                ) : return ty_int;
      case (UNSIGNED                    ) :
      case (UNSIGNED + INT              ) : return ty_uint;
      case (LONG                        ) :
      case (LONG + INT                  ) :
      case (LONG + LONG                 ) :
      case (LONG + LONG + INT           ) :
      case (SIGNED + LONG               ) :
      case (SIGNED + LONG + INT         ) :
      case (SIGNED + LONG + LONG        ) :
      case (SIGNED + LONG + LONG + INT  ) : return ty_long;
      case (UNSIGNED + LONG             ) :
      case (UNSIGNED + LONG + INT       ) :
      case (UNSIGNED + LONG + LONG      ) :
      case (UNSIGNED + LONG + LONG + INT) : return ty_ulong;
      case (FLOAT                       ) : return ty_float;
      case (DOUBLE                      ) : return ty_double;
      case (LONG + DOUBLE               ) : return ty_ldouble;
      default                             : error_tok k@ "invalid type";;;;;
func_params(k @@Token) @Type =
  if (equal k@ "void" && consume k k.next ")") return func_type type_suffix k;
  let
    head = (let Type){;
    cur = &head
    is_variadic = false;
  while ! equal k@ ")" {
    if consume k k@ "..." {
      is_variadic = true;
      break;;
    declspec k 0->@VarAttr;
    let t = declarator k;
    let name = t.name;
   if (t.kind == TY_FUNC) {
      t = pointer_to t;
      t.name = name;;
    cur = cur.next = copy_type t;;
  if (cur == &head) is_variadic = true;
  k@ = k.next;
  let t = func_type type_suffix k;
  t.params = head.next;
  t.is_variadic = is_variadic;
  return t;;
array_dimensions(k @@Token)@ Type =
  while (equal k@ "static" || equal k@ "restrict") k@ = k.next;
  if consume k k@ "]" {
    let t = type_suffix k;
    return array_of t -1;;
  let e = conditional k;
  expect k "]";
  let t = type_suffix k;
  return array_of t (eval e)->int;;
type_suffix(k @@Token)@ Type =
  while ( consume k k@ "const"    ||
          consume k k@ "volatile"  );
     if consume k k@ "("        return func_params            k ;
     if consume k k@ "["        return array_dimensions       k ;
     if consume k k@ "@"        return pointer_to type_suffix k;
  return type_specifier k;;
declarator(k @@Token)@ Type = return
  k@ :: name
  (k@ = k.next)->,
  type_suffix k :: t
  (t.name = name)->,
  (t.name_pos = name)->,
  t;;
enum_specifier(k @@Token) @Type =
  let t = enum_type ;
  let l = 0;
  while ! consume k k@ ";" {
    let p = get_ident k@;
    k@ = k.next;
    if equal k@ "=" {
      k@ = k.next;
      l = const_expr k;;
    let sc = push_scope p;
    sc.enum_ty = t;
    sc.enum_val = l++;;
  return t;;
typeof_specifier(k @@Token) @Type = return
  prefix k :: e
  add_type e,
  e.ty;;
declaration(k @@Token v @VarAttr) @Node =
  let
    head = (let Node){;
    cur = &head;
  while !equal k@ ";" {
    let t = declarator k;
    if (t.kind == TY_VOID) error_tok k@ "variable declared void";
    if !t.name error_tok t.name_pos "variable name omitted";
    if equal t.name "_" continue;
    if (v && v.is_static) {
      let o = new_anon_gvar t;
      (push_scope get_ident t.name).var = o;
      if equal k@ "=" {
        k@ = k.next;
        gvar_initializer k o;;
      continue;;
    let o = new_lvar get_ident t.name t;
    if (v && v.alignment) o.alignment = v.alignment;
    if equal k@ "=" {
      k@ = k.next;
      let e = lvar_initializer k o;
      cur = cur.next = new_unary ND_EXPR_STMT e k@;;
    if (o.ty.size < 0) error_tok t.name "variable has incomplete type";
    if (o.ty.kind == TY_VOID) error_tok t.name "variable declared void";;
  let e = new_node ND_BLOCK k@;
  e.body = head.next;
  k@ = k.next;
  return e;;
string_initializer(k @@Token e@ Initializer)  =
  if e.is_flexible e@ = (new_initializer array_of e.ty.base k.ty->@Type.array_len false)@;
  let len = minl e.ty.array_len->long k.ty->@Type.array_len->long;
  switch e.ty.base.size {
  case 1: { let str = k.str           ; for (let i int = 0; i < len; i++) e.children[i].expr = new_lit str[i]->long k@ ty_int; break; ;
  case 2: { let str = k.str->@uint16_t; for (let i int = 0; i < len; i++) e.children[i].expr = new_lit str[i]->long k@ ty_int; break; ;
  case 4: { let str = k.str->@uint32_t; for (let i int = 0; i < len; i++) e.children[i].expr = new_lit str[i]->long k@ ty_int; break; ;
  default: unreachable ;;
  k@ = k.next;;
array_designator(k @@Token t @Type begin @int end @int) = return
  (k@ = k.next)->,
  (begin@ = const_expr k)->,
  (begin@ >= t.array_len && error_tok k@ "array designator index exceeds array bounds")->,
  equal k@ "..." ?
    (k@ = k.next)->,
    (end@ = const_expr k)->,
    (end@ >= t.array_len && error_tok k@ "array designator index exceeds array bounds")->,
    end@ < begin@ && (error_tok k@ "array designator range [%d, %d] is empty" begin@ end@) as :
  (end@ = begin@)->,
  expect k "]";;
struct_designator(k @@Token t@ Type) @Member =
  let start = k@;
  expect k ".";
  if (k.kind != TK_IDENT )error_tok k@ "expected a field designator";
  for (let g@ Member = t.members; g; g = g.next) {
    if (g.ty->@Type.kind == TY_STRUCT && (!g.name || equal g.name "_") && get_struct_member g.ty->@Type k@) {
        k@ = start;
        return g;;
    else if (g.name.len == k.len && ! strncmp g.name.loc->@ k.loc k.len->unsigned long) {
      k@ = k.next;
      return g;;;
  error_tok k@ "struct has no such member";;
designation(k @@Token e@ Initializer);
designation_children(k @@Token e @Initializer begin int end int) = for (let i int = begin; i <= end; i++) designation k e.children[i];;
designation(k @@Token e@ Initializer) = return
  equal k@ "[" ?
    (e.ty.kind != TY_ARRAY && error_tok k@ "array index in non-array initializer")->,
    0 :: begin
    0 :: end
    array_designator k e.ty &begin &end,
    designation_children k e begin end,
    array_initializer2 k e (begin + 1) :
  equal k@ "." && e.ty.kind == TY_STRUCT ?
    struct_designator k e.ty :: g
    designation k e.children[g.idx],
    (e.expr = 0)->,
    struct_initializer2 k e g.next :
  equal k@ "." && e.ty.kind == TY_UNION ?
    struct_designator k e.ty :: g
    (e.g = g)->,
    designation k e.children[g.idx] :
  equal k@ "." ? error_tok k@ "field name not in struct or union initializer" :
  equal k@ "=" ? k@ = k.next :
  initializer2 k e;;
count_array_init_elements(j @Token t @Type) int =
  let
        k = &j
    dummy = new_initializer t.base true
    i = 0
    max = 0;
  while ! consume k k@ ";" {
    if equal k@ "[" {
      k@ = k.next;
      i = const_expr k;
      if equal k@ "..." {
        k@ = k.next;
        i = const_expr k;;
      expect k "]";
      designation k dummy;
    ; else initializer2 k dummy;
    i++;
    max = maxl max->long i->long;;
  return max;;
array_initializer1(k @@Token e@ Initializer)  =
  expect k "{";
  if e.is_flexible {
    let l = count_array_init_elements k@ e.ty;
    e@ = (new_initializer array_of e.ty.base l false)@;;
  if e.is_flexible {
    let l = count_array_init_elements k@ e.ty;
    let a = array_of e.ty.base l;
    e@ = (new_initializer a false)@;;
  for (let i int = 0; ! consume k k@ ";"; i++) {
    if equal k@ "[" {
      let
        begin = 0
        end = 0
        a = &begin
        b = &end;
      array_designator k e.ty a b;
      for (let j int = begin; j <= end; j++) designation k e.children[j];
      i = end;;
    if (i < e.ty.array_len) initializer2 k e.children[i];;;
array_initializer2(k @@Token e @Initializer i int)  =
  if e.is_flexible {
    let len = count_array_init_elements k@ e.ty;
    e@ = (new_initializer array_of e.ty.base len false)@;;
  for (; i < e.ty.array_len && ! equal k@ ";"; i++) {
    let start = k@;
    if (equal k@ "[" || equal k@ ".") {
      k@ = start;
      return;;
    initializer2 k e.children[i];;;
struct_initializer1(k @@Token e @Initializer)  =
  expect k "{";
  let g = e.ty.members;
  while ! consume k k@ ";" {
    if equal k@ "." {
      g = struct_designator k e.ty;
      designation k e.children[g.idx];
      g = g.next;
    ; else if g {
      initializer2 k e.children[g.idx];
      g = g.next;
    ;;;
struct_initializer2(k @@Token e@ Initializer g @Member)  =
  for (; g && ! equal k@ ";"; g = g.next) {
    let start = k@;
    if (equal k@ "[" || equal k@ ".") {
      k@ = start;
      return;;
    initializer2 k e.children[g.idx];;;
union_initializer(k @@Token e @Initializer) = return
  equal k@ "{" && equal k.next "." ?
    struct_designator k e.ty :: g
    (e.g = g)->,
    designation k e.children[g.idx] :
  (e.g = e.ty.members)->,
  equal k@ "{" ?
    (k@ = k.next)->,
    initializer2 k e.children[0] :
    initializer2 k e.children[0];;
initializer2(k @@Token e @Initializer) =
  if (e.ty.kind == TY_ARRAY && k.kind == TK_STR) string_initializer k e;
  else if (e.ty.kind == TY_ARRAY) {
    if equal k@ "{" array_initializer1 k e;
    else array_initializer2 k e 0;;
  else if (e.ty.kind == TY_STRUCT) {
    if equal k@ "{" struct_initializer1 k e;
    else {
      let a = prefix k;
      add_type a;
      if (a.ty.kind == TY_STRUCT) e.expr = a;
      else struct_initializer2 k e e.ty.members;;
  ; else if (e.ty.kind == TY_UNION) union_initializer k e;
  else if equal k@ "{" {
    k@ = k.next;
    initializer2 k e; // looks ahead to
    expect k ";";     // this semicolon
  ; else e.expr = prefix k;;
copy_struct_type(t @Type) @Type =
  t = copy_type t;
  let
    head = (let Member){;
    cur = &head;
  for (let g@ Member = t.members; g; g = g.next) {
    let m = (calloc 1ul sizeof Member)->@ Member;
    m@ = g@;
    cur = cur.next = m;;
  t.members = head.next;
  return t;;
initializer(k @@Token t @@Type) @Initializer =
  let e = new_initializer t@ true;
  initializer2 k e;
  if ((t.kind == TY_STRUCT || t.kind == TY_UNION) && t.is_flexible) {
    t@ = copy_struct_type t@;
    let g = t.members;
    while g.next g = g.next;
    g.ty = e.children[g.idx].ty;
    t.size += g.ty->@Type.size;
  ; else t@ = e.ty;
  return e;;
init_desg_expr(z @InitDesg k @Token) @Node = return
  z.var ? new_reference z.var k :
  z.member ?
    new_unary ND_MEMBER init_desg_expr z.next k k :: e
    (e.member = z.member)->,
    e :
  new_unary ND_DEREF new_add init_desg_expr z.next k new_lit z.idx->long k ty_int k k;;
create_lvar_init(e @Initializer t @Type z @InitDesg k @Token)@ Node =
  if (t.kind == TY_ARRAY) {
    let a = new_node ND_NULL_EXPR k;
    for (let i int = 0; i < t.array_len; i++) {
      let
        z2 = (let InitDesg){z i;
        b = create_lvar_init e.children[i] t.base &z2 k;
      a = new_binary ND_COMMA a b k;;
    return a;;
  if (t.kind == TY_STRUCT && !e.expr) {
    let a = new_node ND_NULL_EXPR k;
    for (let g @Member = t.members; g; g = g.next) {
      let
        z2 = (let InitDesg){z 0 g;
        b = create_lvar_init e.children[g.idx] g.ty->@Type &z2 k;
      a = new_binary ND_COMMA a b k;;
    return a;;
  if (t.kind == TY_UNION) {
    let
      g = (e.g || t.members)
      z2 = (let InitDesg){z 0 g;;
    return create_lvar_init e.children[g.idx] g.ty->@Type &z2 k;;
  if !e.expr return new_node ND_NULL_EXPR k;
  let a = init_desg_expr z k;
  add_type e.expr;
  add_type a;
  if ! type_equal a.ty e.expr.ty {
    s1[0] = 0; s2[0] = 0;
    format_types e.expr.ty a.ty;
    error_tok e.expr.tok "asymmetric init from %s to %s" s1 s2;;
  return new_binary ND_ASSIGN a e.expr k;;
lvar_initializer(k @@Token o @Obj) @Node = return
  &o.ty :: d
  initializer k d :: e
  (let InitDesg){ 0->@InitDesg 0 0->@Member o; :: z
  new_node ND_MEMZERO k@ :: a
  (a.var = o)->,
  new_binary ND_COMMA a create_lvar_init e o.ty &z k@ k@;;
read_buf(buf@ char sz int) uint64_t = return
  ( sz == 1 ? buf@             :
    sz == 2 ? buf->@ uint16_t@ :
    sz == 4 ? buf->@ uint32_t@ :
    sz == 8 ? buf->@ uint64_t@ :
    0 ) as unsigned long;;
write_buf(buf@ char val uint64_t sz int) = return
  ( sz == 1 ? buf@             = val :
    sz == 2 ? buf->@ uint16_t@ = val :
    sz == 4 ? buf->@ uint32_t@ = val :
    sz == 8 ? buf->@ uint64_t@ = val : 0)->,
  none;;
write_gvar_data(cur@ Relocation init@ Initializer ty@ Type buf@ char offset int)@ Relocation =
  if (ty.kind == TY_ARRAY) {
    let sz = ty.base.size;
    for (let i int = 0; i < ty.array_len; i++) {
      cur = write_gvar_data cur init.children[i] ty.base buf (offset + sz * i);;
    return cur;;
  if (ty.kind == TY_STRUCT) {
    for (let g@ Member = ty.members; g; g = g.next) {
      if g.is_bitfield {
        let expr = init.children[g.idx].expr;
        if !expr break;
        let loc = (buf + offset + g.offset);
        let oldval = read_buf loc g.ty->@Type.size;
        let newval = eval expr;
        let mask = ((1L << g.bit_width) - 1);
        let combined = (oldval | ((newval & mask) << g.bit_offset));
        write_buf loc combined g.ty->@Type.size;;
      else {
        cur = write_gvar_data cur init.children[g.idx] g.ty->@Type buf (offset + g.offset);;;
    return cur;;
  if (ty.kind == TY_UNION) {
    if !init.g return cur;
    return write_gvar_data cur init.children[init.g.idx] init.g.ty->@Type buf offset;;
  if !init.expr return cur;
  if (ty.kind == TY_FLOAT) {
    (buf + offset)->@ float@ = eval_double init.expr;
    return cur;;
  if (ty.kind == TY_DOUBLE) {
    (buf + offset)->@ double@ = eval_double init.expr;
    return cur;;
  let label = 0->@@char;
  let val = eval2 init.expr &label;
  if !label {
    let a = (buf + offset);
    write_buf a val->unsigned long ty.size;
    return cur;;
  let rel = (calloc 1ul sizeof Relocation)->@Relocation;
  rel.offset = offset;
  rel.label = label;
  rel.addend = val;
  cur.next = rel;
  return cur.next;;
gvar_initializer(k @@Token o@ Obj) =
  &o.ty :: d
  initializer k d :: e
  (let Relocation){; :: head
  (calloc 1ul o.ty.size->unsigned long) :: buf
  (write_gvar_data &head e o.ty buf->@char 0)->,
  (o.init_data = buf)->,
  (o.rel = head.next)->;;

stmt(k @@Token) @Node = return
  k@ :: j
  consume k k@ "return" ?
    new_node ND_RETURN j :: e
    consume k k@ ";" ? e :
    (e.lhs = conditional k)->,
    expect k ";",
    add_type e.lhs,
    current_fn.ty.return_ty :: t
    ( !type_equal current_fn.ty.return_ty e.lhs.ty &&
      ( (s1[0] = 0)->, (s2[0] = 0)->,
        format_type e.lhs.ty &s1@,
        format_type current_fn.ty.return_ty &s2@,
        error_tok e.lhs.tok "asymmetric return from %s to %s" s1 s2 ))->,
    e :
  consume k k@ "if" ?
    new_node ND_IF j :: e
    (e.cond = prefix k)->,
    (e.then = stmt k)->,
    (consume k k@ "else" && (e.els = stmt k))->,
    e :
  consume k k@ "switch" ?
    warn_tok k@ "shitty switch case",
    new_node ND_SWITCH j :: e
    (e.cond = prefix k)->,
    current_switch :: sw
    (current_switch = e)->,
    brk_label :: brk
    (brk_label = e.brk_label = new_unique_name)->,
    (e.then = stmt k)->,
    (current_switch = sw)->,
    (brk_label = brk)->,
    e :
  consume k k@ "case" ?
    (!current_switch && error_tok j "stray case")->,
    new_node ND_CASE j :: e
    const_expr k :: begin
    begin :: end
    expect k ":",
    (e.label = new_unique_name)->,
    (e.lhs = stmt k)->,
    (e.begin = begin)->,
    (e.end = end)->,
    (e.case_next = current_switch.case_next)->,
    (current_switch.case_next = e)->,
    e :
  consume k k@ "default" ?
    (! current_switch && error_tok j "stray default")->,
    new_node ND_CASE j :: e
    expect k ":",
    (e.label = new_unique_name)->,
    (e.lhs = stmt k)->,
    (current_switch.default_case = e)->,
    e :
  consume k k@ "for" ?
    new_node ND_FOR j :: e
    expect k "(",
    enter_scope,
    brk_label :: brk
    cont_label :: cont
    (brk_label  = e.brk_label = new_unique_name)->,
    (cont_label = e.cont_label = new_unique_name)->,
    ( consume k k@ "let" ?
        declspec k 0->@VarAttr,
        (e.init = declaration k 0->@VarAttr) :
      (e.init = expr_stmt k))->,
    (! equal k@ ";" && (e.cond = assign k))->,
    expect k ";",
    (! equal k@ ")" && (e.inc = assign k))->,
    expect k ")",
    (e.then     = stmt k)->,
    leave_scope,
    (brk_label  = brk)->,
    (cont_label = cont)->,
    e :
  consume k k@ "while" ?
    new_node ND_FOR j :: e
    (e.cond     = prefix k)->,
    brk_label :: brk
    cont_label :: cont
    (brk_label  = e.brk_label = new_unique_name)->,
    (cont_label = e.cont_label = new_unique_name)->,
    (e.then     = stmt k)->,
    (brk_label  = brk)->,
    (cont_label = cont)->,
    e :
  consume k k@ "do" ?
    new_node ND_DO j :: e
    brk_label :: brk
    cont_label :: cont
    (brk_label  = e.brk_label = new_unique_name)->,
    (cont_label = e.cont_label = new_unique_name)->,
    (e.then     = stmt k)->,
    (brk_label  = brk)->,
    (cont_label = cont)->,
    expect k "while",
    (e.cond = prefix k)->,
    expect k ";",
    e :
  consume k k@ "break" ?
    !brk_label ? error_tok j "stray break", 0->@Node :
    new_node ND_GOTO j :: e
    (e.unique_label = brk_label)->,
    expect k ";",
    e :
  consume k k@ "continue" ?
    !cont_label ? error_tok j "stray continue", 0->@Node :
    new_node ND_GOTO j :: e
    (e.unique_label = cont_label)->,
    expect k ";",
    e :
  consume k k@ "{" ? compound_stmt k :
  expr_stmt k;;
decl_stmt(k @@Token) @Node =
  let
    head = (let Node){;
    cur = &head;
  while ! equal k@ ";" {
    if equal k.next "=" {
      if (k.kind != TK_IDENT || equal k@ "_") error_tok k@ "expected identifer";
      else {
        let name = k@;
        k@ = k.next.next;
        let e = prefix k;
      add_type e;
        if (e.ty.kind == TY_VOID) error_tok k@ "variable declared void";
        else {
          let o = new_lvar get_ident name e.ty;
          cur = cur.next = new_unary ND_EXPR_STMT new_binary ND_ASSIGN new_reference o k@ e k@ k@;;;;
    else {
      //warn_tok(k@ "deprecated initializer");
      let t = declarator k;
      if (t.kind == TY_VOID) error_tok k@ "variable declared void";
      else {
        if !t.name error_tok t.name_pos "variable name omitted";
        else if !equal t.name "_" {
          let o = new_lvar get_ident t.name t;
          if consume k k@ "=" {
            let e = lvar_initializer k o;
            cur = cur.next = new_unary ND_EXPR_STMT e k@;;
          if (o.ty.size < 0) error_tok t.name "variable has incomplete type";
          else if (o.ty.kind == TY_VOID) error_tok t.name "variable declared void";;;;;
  let e = new_node ND_BLOCK k@;
  k@ = k.next;
  e.body = head.next;
  return e;;
compound_stmt(k @@Token) @Node =
  let
    e = new_node ND_BLOCK k@
    head = (let Node){;
    cur = &head;
  enter_scope;
  while !consume k k@ ";" {
    cur = cur.next = (consume k k@ "let" ? &decl_stmt : &stmt)@ k;
    add_type cur;;
  leave_scope;
  e.body = head.next;
  return e;;

expr_stmt(k @@Token)@ Node = return
  equal k@ ";" ?
    new_node ND_BLOCK k@ :: e
    (k@ = k.next)->,
    e :
  new_node ND_EXPR_STMT k@ :: e
  (e.lhs = assign k)->,
  expect k ";",
  e;;
eval2(e@ Node label @@@char) int64_t = return
  add_type e,
  is_flonum e.ty ? (eval_double e)->long :
  e.kind == ND_ADD    ? eval2 e.lhs label + eval e.rhs :
  e.kind == ND_SUB    ? eval2 e.lhs label - eval e.rhs :
  e.kind == ND_NEG    ? -eval e.lhs :
  e.kind == ND_MUL    ? eval e.lhs *  eval e.rhs :
  e.kind == ND_BITAND ? eval e.lhs &  eval e.rhs :
  e.kind == ND_BITOR  ? eval e.lhs |  eval e.rhs :
  e.kind == ND_BITXOR ? eval e.lhs ^  eval e.rhs :
  e.kind == ND_SHL    ? eval e.lhs << eval e.rhs :
  e.kind == ND_EQ     ? (eval e.lhs == eval e.rhs)->long :
  e.kind == ND_NE     ? (eval e.lhs != eval e.rhs)->long :
  e.kind == ND_DIV    ? e.ty.is_unsigned
    ? ((eval e.lhs)->uint64_t /  (eval e.rhs)->uint64_t)->long
    :  (eval e.lhs)           /  (eval e.rhs) :
  e.kind == ND_MOD    ? e.ty.is_unsigned
    ? ((eval e.lhs)->uint64_t %  (eval e.rhs)->uint64_t)->long
    :  (eval e.lhs)           %  (eval e.rhs) :
  e.kind == ND_SHR    ? e.ty.is_unsigned && e.ty.size == 8
    ? ((eval e.lhs)->uint64_t >> (eval e.rhs)->uint64_t)->long
    :  (eval e.lhs)           >> (eval e.rhs) :
  e.kind == ND_LT     ? e.lhs.ty.is_unsigned
    ? ((eval e.lhs)->uint64_t <  (eval e.rhs)->uint64_t)->long
    :  (eval e.lhs)           <  (eval e.rhs) :
  e.kind == ND_LE     ? e.lhs.ty.is_unsigned
    ? ((eval e.lhs)->uint64_t <= (eval e.rhs)->uint64_t)->long
    :  (eval e.lhs)           <= (eval e.rhs) :
  e.kind == ND_GT     ? e.lhs.ty.is_unsigned
    ? ((eval e.lhs)->uint64_t >  (eval e.rhs)->uint64_t)->long
    :  (eval e.lhs)           >  (eval e.rhs) :
  e.kind == ND_GE     ? e.lhs.ty.is_unsigned
    ? ((eval e.lhs)->uint64_t >= (eval e.rhs)->uint64_t)->long
    :  (eval e.lhs)           >= (eval e.rhs) :
  e.kind == ND_COND   ? eval e.cond ? eval2 e.then label : eval2 e.els label :
  e.kind == ND_COMMA  ? eval2 e.rhs label :
  e.kind == ND_NOT    ? (! eval e.lhs)->long :
  e.kind == ND_BITNOT ? ~ eval e.lhs :
  e.kind == ND_LOGAND ? eval e.lhs && eval e.rhs :
  e.kind == ND_LOGOR  ? eval e.lhs || eval e.rhs :
  e.kind == ND_CAST   ?
    eval2 e.lhs label :: l
    ! is_integer e.ty ? l :
    e.ty.size == 1 ? (e.ty.is_unsigned ? l->uint8_t  : l->int8_t )->long :
    e.ty.size == 2 ? (e.ty.is_unsigned ? l->uint16_t : l->int16_t)->long :
    e.ty.size == 4 ? (e.ty.is_unsigned ? l->uint32_t : l->int32_t)->long :
    l :
  e.kind == ND_ADDR ? eval_rval e.lhs label :
  e.kind == ND_LABEL_VAL ? (label@ = &e.unique_label)->, 0l :
  e.kind == ND_MEMBER ?
    !label ? error_tok e.tok "not a compile-time constant", 0l :
    e.ty.kind != TY_ARRAY ? error_tok e.tok "invalid initializer", 0l :
    eval_rval e.lhs label + e.member.offset :
  e.kind == ND_VAR ?
    !label ? error_tok e.tok "not a compile-time constant", 0l :
    e.var.ty.kind != TY_ARRAY && e.var.ty.kind != TY_FUNC ? error_tok e.tok "invalid initializer", 0l :
    (label@ = &e.var.name)->, 0l :
  e.kind == ND_NUM ? e.val :
  error_tok e.tok "not a compile-time constant",
  0l;;
eval(e@ Node) int64_t = return eval2 e 0->@@@char;;
eval_rval(e@ Node label @@@char) long = return
  e.kind == ND_VAR ?
    e.var.is_local ? error_tok e.tok "not a compile-time constant", 0l :
    (label@ = &e.var.name)->, 0l :
  e.kind == ND_DEREF  ? eval2     e.lhs label :
  e.kind == ND_MEMBER ? eval_rval e.lhs label + e.member.offset :
  error_tok e.tok "invalid initializer",
  0l;;
is_const_expr(e@ Node) bool = return
  add_type e,
  e.kind == ND_ADD    ||
  e.kind == ND_SUB    ||
  e.kind == ND_MUL    ||
  e.kind == ND_DIV    ||
  e.kind == ND_BITAND ||
  e.kind == ND_BITOR  ||
  e.kind == ND_BITXOR ||
  e.kind == ND_SHL    ||
  e.kind == ND_SHR    ||
  e.kind == ND_EQ     ||
  e.kind == ND_NE     ||
  e.kind == ND_LT     ||
  e.kind == ND_LE     ||
  e.kind == ND_GT     ||
  e.kind == ND_GE     ||
  e.kind == ND_LOGAND ||
  e.kind == ND_LOGOR   ? is_const_expr e.lhs && is_const_expr e.rhs :
  e.kind == ND_COND    ? is_const_expr e.cond && is_const_expr (eval e.cond ? e.then : e.els) :
  e.kind == ND_COMMA   ? is_const_expr e.rhs :
  e.kind == ND_NEG    ||
  e.kind == ND_NOT    ||
  e.kind == ND_BITNOT ||
  e.kind == ND_CAST    ? is_const_expr e.lhs :
  e.kind == ND_NUM;;
export const_expr(k@@ Token) int64_t = return eval prefix k;;
eval_double(e@ Node) double = return
  add_type e,
  is_integer e.ty ?
    (eval e)->double :
    e.kind == ND_ADD   ?  eval_double e.lhs + eval_double e.rhs :
    e.kind == ND_SUB   ?  eval_double e.lhs - eval_double e.rhs :
    e.kind == ND_MUL   ?  eval_double e.lhs * eval_double e.rhs :
    e.kind == ND_DIV   ?  eval_double e.lhs / eval_double e.rhs :
    e.kind == ND_NEG   ? -eval_double e.lhs                     :
    e.kind == ND_COND  ?  eval_double e.cond                    ? eval_double e.then :
                                                                  eval_double e.els  :
    e.kind == ND_COMMA ? eval_double e.rhs                      :
    e.kind == ND_NUM   ? e.fval->double                         :
    e.kind == ND_CAST  ? is_flonum e.lhs.ty                     ? eval_double e.lhs  :
                                                                  eval        e.lhs  :
                         /*error_tok e.tok "not a compile-time constant",*/ 0.0   ;;;;

s1 [1024]char s2 [1024]char;
assign(k @@Token) @Node = return
  conditional k :: a
  ( equal k@ "="   ? ND_ASSIGN :
    equal k@ "+="  ? ND_ADD    :
    equal k@ "-="  ? ND_SUB    :
    equal k@ "*="  ? ND_MUL    :
    equal k@ "/="  ? ND_DIV    :
    equal k@ "%="  ? ND_MOD    :
    equal k@ "&="  ? ND_BITAND :
    equal k@ "|="  ? ND_BITOR  :
    equal k@ "^="  ? ND_BITXOR :
    equal k@ "<<=" ? ND_SHL    :
    equal k@ ">>=" ? ND_SHR    :
                     0->NodeKind) :: c
  !c ? a :
  advance k :: j
  new_binary c a assign k j :: e
  add_type e,
  (c != ND_ASSIGN && (e = compound_assign e))->,
  e;;
type StrNodeKind struct { s@ char k NodeKind ;};;
ab(tok@@ Token n int next@(tok@@ Token)@ Node a@ StrNodeKind lhs@@ Node) bool =
  for (let i int = 0; i < n; ++i) {
    if equal tok@ a[i].s {
      let e = new_node a[i].k tok@;
      tok@ = tok.next;
      e.lhs = lhs@;
      e.rhs = next@ tok;
      lhs@ = e;
      return true;;;
  return false;;
left_binary(tok@@ Token n int next@(tok@@ Token)@ Node t@ StrNodeKind)@ Node =
  let e = next@ tok;
  while ab tok n next t &e;
  return e;;
mul       (l@@ Token)@ Node = let d []StrNodeKind = { {  "*" ND_MUL    ; { "/"  ND_DIV ; { "%"  ND_MOD ;                                 ;; return left_binary l 3 &prefix     d->@StrNodeKind;;
shift     (l@@ Token)@ Node = let d []StrNodeKind = { { "<<" ND_SHL    ; { ">>" ND_SHR ;                                                                  ;; return left_binary l 2 &add        d->@StrNodeKind;;
relational(l@@ Token)@ Node = let d []StrNodeKind = { {  "<" ND_LT     ; { ">"  ND_GT  ; { "<=" ND_LE  ; { ">=" ND_GE ; ;; return left_binary l 4 &shift      d->@StrNodeKind;;
equality  (l@@ Token)@ Node = let d []StrNodeKind = { { "==" ND_EQ     ; { "!=" ND_NE  ;                                                                  ;; return left_binary l 2 &relational d->@StrNodeKind;;
bitand    (l@@ Token)@ Node = let d []StrNodeKind = { {  "&" ND_BITAND ;                                                                                                   ;; return left_binary l 1 &equality   d->@StrNodeKind;;
bitxor    (l@@ Token)@ Node = let d []StrNodeKind = { {  "^" ND_BITXOR ;                                                                                                   ;; return left_binary l 1 &bitand     d->@StrNodeKind;;
bitor     (l@@ Token)@ Node = let d []StrNodeKind = { {  "|" ND_BITOR  ;                                                                                                   ;; return left_binary l 1 &bitxor     d->@StrNodeKind;;
logand    (l@@ Token)@ Node = let d []StrNodeKind = { { "&&" ND_LOGAND ;                                                                                                   ;; return left_binary l 1 &bitor      d->@StrNodeKind;;
logor     (l@@ Token)@ Node = let d []StrNodeKind = { { "||" ND_LOGOR  ;                                                                                                   ;; return left_binary l 1 &logand     d->@StrNodeKind;;
conditional(k @@Token)@ Node = return
  logor k :: a
  add_type a,
  until !(equal k@ "as" && (advance k :: j (a = new_cast j a type_suffix k))) as,
  equal k@ "::" ?
    advance k as,
    advance k :: j
    enter_scope,
    new_lvar get_ident j a.ty :: o
    new_let j a conditional k o :: e
    leave_scope,
    e :
  equal k@ "?" ?
    advance k :: j
    assign k :: b
    expect k ":",
    new_conditional j a b conditional k :
  equal k@ "," ?
    advance k :: j
    new_comma j a conditional k :
  a;;
new_add(a @Node b @Node j @Token) @Node = return
  add_type a, add_type b,
  is_numeric a.ty && is_numeric b.ty ? new_binary ND_ADD a b j :
  (a.ty.base && b.ty.base) ? error_tok j "invalid operands", 0 as @Node :
  !a.ty.base && b.ty.base && (a :: e (a = b) as , (b = e)) as,
  (b = new_binary ND_MUL b new_long a.ty.base.size->long j j)as,
  new_binary ND_ADD a b j;;
new_sub(a @Node b @Node j @Token) @Node = return
  add_type a, add_type b,
  is_numeric a.ty && is_numeric b.ty ? new_binary ND_SUB a b j :
  a.ty.base && is_integer b.ty ?
    (b = new_binary ND_MUL b new_long a.ty.base.size->long j j) as,
    add_type b,
    new_binary ND_SUB a b j :: e
    (e.ty = a.ty)->,
    e :
  a.ty.base && b.ty.base ?
    new_binary ND_SUB a b j :: e
    (e.ty = ty_long)->,
    new_binary ND_DIV e new_lit a.ty.base.size->long j ty_int j :
  error_tok j "invalid operands",
  0->@Node;;
add(k @@Token) @Node =
  let e = mul k;
  for (;;) {
    let start = k@;
    if consume k k@ "+" e = new_add e mul k start;
    else if consume k k@ "-" e = new_sub e mul k start;
    else return e;;;
prefix(k @@Token) @Node =
  let start = k@;
  if consume k k@ "-" return new_unary ND_NEG prefix k start;
  else if consume k k@ "&" {
    let a = postfix k;
    add_type a;
    if (a.kind == ND_MEMBER && a.member.is_bitfield) error_tok k@ "cannot take address of bitfield";
    return new_unary ND_ADDR a start;;
  else if consume k k@ "!" return new_unary ND_NOT prefix k start;
  else if consume k k@ "~" return new_unary ND_BITNOT prefix k start;
  else if consume k k@ "until" return new_until start prefix k;
  else if consume k k@ "++" return compound_assign new_add prefix k new_lit 1l start ty_int start;
  else if consume k k@ "--" return compound_assign new_sub prefix k new_lit 1l start ty_int start;
  else {
    let a = postfix k;
    for (;;) {
      add_type a;
      if (a.ty.kind == TY_FUNC) {
        let
            t = a.ty
            u = t.params
         head = (let Node){;
          cur = &head;
        while (u || t.is_variadic && ! equal k@ ")" && ! equal k@ ";" && !equal k@ "," && ! equal k@ ":") {
          let b = prefix k;
          add_type b;
          if u {
            if !type_equal b.ty u {
              format_types b.ty u;
              error_tok k@ "asymmetric argument from %s to %s" s1 s2;;
            u = u.next;;
          cur = cur.next = b;;
        if u error_tok k@ "not enough arguments";
        let e = new_unary ND_FUNCALL a k@;
        e.func_ty = t;
        e.ty = t.return_ty;
        e.args = head.next;
        if (e.ty.kind == TY_STRUCT || e.ty.kind == TY_UNION) e.ret_buffer = new_lvar "" e.ty;
        a = e;;
      else return a;;;;
struct_members(k @@Token t @Type)  =
  let
    head = (let Member){;
    cur = &head
    idx = 0;
  while ! consume k k@ "}" {
    let v = &(let VarAttr){;;
    declspec k v;
    while ! consume k k@ ";" {
      let g = (calloc 1ul sizeof Member)->@Member;
      g.ty = declarator k;
      g.name = g.ty->@Type.name;
      g.idx = idx++;
      g.alignment = v.alignment ? v.alignment : g.ty->@Type.alignment;
      if consume k k@ ":" {
        g.is_bitfield = true;
        g.bit_width = const_expr k;;
      cur = cur.next = g;;;
  if (cur != &head && cur.ty->@Type.kind == TY_ARRAY && cur.ty->@Type.array_len < 0) {
    cur.ty = array_of cur.ty->@Type.base 0;
    t.is_flexible = true;;
  t.members = head.next;;
attribute_list(k @@Token t @Type) =
  while consume k k@ "__attribute__" {
    expect k "(";
    expect k "(";
    while ! consume k k@ ")" {
      if consume k k@ "packed" t.is_packed = true;
      else if consume k k@ "aligned" {
        expect k "(";
        t.alignment = const_expr k; // looks ahead to
        expect k ")";;               // this paren
      else error_tok k@ "unknown attribute";;
    expect k ")";;;
struct_union_decl(k @@Token) @Type = return
  struct_type :: t
  attribute_list k t,
  0->@Token :: tag
  (k.kind == TK_IDENT &&
    ( (tag = k@)->,
      (k@ = k.next)))->,
  tag && ! equal k@ "{" ?
    (search_scope tag scope_tags->@(sc@Scope)@HashMap)->@Type :: t2
    t2 ? t2 :
    (t.size = -1)->,
    push_tag_scope tag t,
    t :
  expect k "{",
  (current_type = t)->,
  struct_members k t,
  attribute_list k t,
  (current_type = 0)->,
  tag ?
    (hashmap_get2 &scope.tags tag.loc tag.len)->@Type :: t2
    t2 ? (t2@ = t@)->, t2 :
    push_tag_scope tag t, t :
  t;;
struct_decl(k @@Token) @Type =
  let t = struct_union_decl k;
  t.kind = TY_STRUCT;
  if (t.size < 0) return t;
  let bits = 0;
  for (let g@ Member = t.members; g; g = g.next) {
    if (g.is_bitfield && g.bit_width == 0) bits = align_to bits (g.ty->@Type.size * 8);
    else if g.is_bitfield {
      let sz = g.ty->@Type.size;
      if (bits / (sz * 8) != (bits + g.bit_width - 1) / (sz * 8)) {
        bits = align_to bits (sz * 8);;
      g.offset = align_down (bits / 8) sz;
      g.bit_offset = bits % (sz * 8);
      bits += g.bit_width;;
    else {
      if !t.is_packed bits = align_to bits (g.alignment * 8);
      g.offset = bits / 8;
      bits += g.ty->@Type.size * 8;;
    if (!t.is_packed && t.alignment < g.alignment)
      t.alignment = g.alignment;;
  t.size = align_to bits (t.alignment * 8) / 8;
  return t;;
union_decl(k @@Token) @Type =
  let t = struct_union_decl k;
  t.kind = TY_UNION;
  if (t.size < 0) return t;
  for (let g@ Member = t.members; g; g = g.next) {
    if (t.alignment < g.alignment) t.alignment = g.alignment;
    if (t.size < g.ty->@Type.size) t.size = g.ty->@Type.size;;
  t.size = align_to t.size t.alignment;
  return t;;
get_struct_member(t @Type j @Token) @Member =
  for (let g@ Member = t.members; g; g = g.next) {
    if ((g.ty->@Type.kind == TY_STRUCT || g.ty->@Type.kind == TY_UNION) && (!g.name || equal g.name "_")) {
      if get_struct_member g.ty->@Type j return g;;
    else if (g.name.len == j.len && ! strncmp g.name.loc->@ j.loc j.len->unsigned long) return g;;
  return 0->@Member;;
struct_ref(e @Node k @@Token) @Node =
  add_type e;
  if (e.ty.kind != TY_STRUCT && e.ty.kind != TY_UNION) error_tok e.tok "not a struct nor a union";
  let t = e.ty;
  for (;;) {
    let g = get_struct_member t k@;
    if !g error_tok k@ "no such member";
    e = new_unary ND_MEMBER e k@;
    e.member = g;
    if g.name break;
    t = g.ty;;
  k@ = k.next;
  return e;;
new_inc_dec(a @Node j @Token l long) @Node = return
  add_type a,
  new_comma j compound_assign new_add a new_lit l j ty_int j new_add a new_lit -l j ty_int j :: e
  add_type e,
  type_equal a.ty e.ty ? e :
  new_cast j e a.ty;;
postfix(k @@Token)@ Node =
  let start = k@;
  if (equal k@ "(" && equal k.next "let") {
    k@ = k.next.next;
    let t = type_suffix k;
    expect k ")";
    if !scope.next {
      let o = new_anon_gvar t;
      gvar_initializer k o;
      return new_reference o start;;
    let
      o = new_lvar "" t
      a = lvar_initializer k o
      b = new_reference o k@;
    return new_binary ND_COMMA a b start;; // suspect
  let e = primary k;
  for (;;) {
    let start = k@;
    if consume k k@ "[" {
      let l = conditional k;
      expect k "]";
      e = new_unary ND_DEREF new_add e l start start;;
    else if consume k k@ "." { add_type e; while (e.ty.kind == TY_PTR) { e = new_unary ND_DEREF e start; add_type e;; e = struct_ref e k;;
    else if consume k k@ "@" e = new_unary ND_DEREF e start;
    else if consume k k@ "->" {
      e = new_cast start e type_suffix k;;
    else if consume k k@ "++" e = new_inc_dec e start 1l;
    else if consume k k@ "--" e = new_inc_dec e start -1l;
    else return e;;;
primary(k @@Token) @Node = return
  consume k k@ "none"    ? new_none k@ :
  consume k k@ "true"    ? new_bool 1l k@ :
  consume k k@ "false"   ? new_bool 0l k@ :
  consume k k@ "sizeof"  ? new_ulong (type_suffix k).size     ->long k@ :
  consume k k@ "alignof" ? new_ulong (type_suffix k).alignment->long k@ :
  consume k k@ "(" ?
    assign k :: e
    expect k ")",
    e :
  k.kind == TK_IDENT ?
    (search_scope k@ scope_vars->@(sc@Scope)@HashMap)->@VarScope :: sc
    (k@ = k.next)->,
    sc ?
      sc.var && sc.var.is_function &&
        ( &current_fn.refs :: a
          current_fn ? strarray_push a sc.var.name :
          (sc.var.is_root = true) as) as,
      sc.var ? new_reference sc.var k@ :
      sc.enum_ty ? new_lit sc.enum_val->long k@ sc.enum_ty :
      error_tok k@ "internal compiler error", 0->@Node :
    error_tok k@ "lookup failed", 0->@Node :
  k.kind == TK_STR ?
    new_cast k@ new_reference new_string_literal k.str k.ty->@Type k@ pointer_to k.ty->@Type.base :: e
    (k@ = k.next)->, e :
  k.kind == TK_NUM ?
    ( is_flonum k.ty->@Type
      ? new_node ND_NUM k@ :: e (e.fval = k.fval)->, e
      : new_lit k.val k@ k.ty->@Type) :: e (k@ = k.next)->, e :
  error_tok k@ "expected an expression", 0->@Node;;
typedecl(k@@ Token) =
  while ! consume k k@ ";" {
    declarator k :: t
    t.name || (error_tok t.name_pos "type name may not be omitted in type alias declaration") as,
    ((push_scope get_ident t.name).type_def = t);;;
create_param_lvars(param@ Type) = return
  param &&
  ( create_param_lvars param.next,
    !param.name ? error_tok param.name_pos "parameter name omitted" :
    new_lvar get_ident param.name param as ) as;;
find_func(name@ char)@ Obj =
  let sc = scope;
  while sc.next sc = sc.next;
  let a = &sc.vars;
  let sc2 = (hashmap_get a name)->@VarScope;
  if (sc2 && sc2.var && sc2.var.is_function) return sc2.var;
  return 0->@Obj;;
mark_live(o@ Obj)  =
  if (!o.is_function || o.is_live) return;
  o.is_live = true;
  for (let i int = 0; i < o.refs.len; i++) {
    let o2 = find_func o.refs.data[i];
    if o2 mark_live o2;;;
function(k @@Token attr @VarAttr) = return
  declarator k :: ty
  ((!ty.name || equal ty.name "_") && error_tok ty.name_pos "function name omitted")->,
  get_ident ty.name :: name_str
  find_func name_str :: o
  ( o ?
      (!o.is_function && error_tok k@ "redeclared as a different kind of symbol")->,
      (o.is_definition && equal k@ "=" && error_tok k@ "redefinition of %s" name_str)->,
      (o.is_export != attr.is_export && error_tok k@ "mismatched visibility")->,
      (o.is_definition = o.is_definition || equal k@ "=") :
    (o = new_gvar name_str ty)->,
    (o.is_function = true)->,
    (o.is_definition = equal k@ "=")->,
    (o.is_export = attr.is_export)->,
    (o.is_inline = attr.is_inline))->,
  (o.is_root = o.is_export || !o.is_inline)->,
  equal k@ ";" ? none :
  (current_fn = o)->,
  (locals = 0)->,
  enter_scope,
  create_param_lvars ty.params,
  ty.return_ty :: rty
  (((rty.kind == TY_STRUCT || rty.kind == TY_UNION) && rty.size > 16) && new_lvar "" pointer_to rty)->,
  (o.params = locals)->,
  (ty.is_variadic && (o.va_area = new_lvar "__va_area__" array_of ty_char 136))->,
  (o.alloca_bottom = new_lvar "__alloca_size__" pointer_to ty_char)->,
  expect k "=",
  (o.body = compound_stmt k)->,
  (o.locals = locals)->,
  leave_scope, none;;
global_variable(tok@ Token attr@ VarAttr)@ Token =
  let k = &tok;
  let first = true;
  while ! consume k tok ";" {
    first = false;
    let ty = declarator k;
    if (!ty.name || equal ty.name "_") continue;
    let var = new_gvar get_ident ty.name ty;
    var.is_definition = !attr.is_extern;
    var.is_export = attr.is_export;
    var.is_inline = attr.is_inline;
    var.is_tls = attr.is_tls;
    if attr.alignment var.alignment = attr.alignment;
    if equal tok "=" {
      tok = tok.next;
      gvar_initializer k var;;
    else if (!attr.is_extern && !attr.is_tls) var.is_tentative = true;;
  return tok;;
is_function(j @Token) bool = return
  ! equal j ";" &&
  (declarator &j).kind == TY_FUNC;;
scan_globals(void) =
  let
    head = (let Obj){;
    cur = &head;
  for (let o@ Obj = globals; o; o = o.next) {
    if !o.is_tentative {
      cur = cur.next = o;
      continue;;
    let o2 = globals;
    for (; o2; o2 = o2.next) if (o != o2 && o2.is_definition && ! strcmp o.name->@ o2.name) break;
    if !o2 cur = cur.next = o;;
  cur.next = 0;
  globals = head.next;;
export parse(tok @Token) @Obj =
  let k = &tok;
  locals = 0;
  globals = 0;
  scope = &(let Scope){;;
  current_type = 0;
  current_fn = 0;
  gotos = 0;
  labels = 0;
  brk_label = 0;
  cont_label = 0;
  current_switch = 0;
  builtin_alloca = 0;
  while (tok.kind != TK_EOF) {
    let attr = (let VarAttr){;;
    declspec k &attr;
    if attr.is_type {
      typedecl k;
      continue;;
    if is_function tok {
      function &tok &attr;
      continue;;
    tok = global_variable tok &attr;;
  for (let var@ Obj = globals; var; var = var.next) if var.is_root mark_live var;
  scan_globals;
  return globals;;