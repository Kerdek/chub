#include "chub.hb"

type

  VarScope struct {
    var      @Obj
    type_def @Type
    enum_ty  @Type
    enum_val  i32;
  }

  Scope struct {
    s    @same
    vars  HashMap
    tags  HashMap;
  }

  VarAttr struct {
    is_type    bool
    is_static  bool
    is_extern  bool
    is_export  bool
    is_inline  bool
    is_tls     bool
    alignment  i32;
  }

  Initializer struct {
    s        @same
    t          @Type
    j         @Token
    is_flexible  bool
    expr        @Node
    children   @@same
    g         @Member;
  }

  InitDesg struct {
    s     @same
    idx       i32
    member   @Member
    var      @Obj;
  }

;

locals         @Obj
globals        @Obj
scope          @Scope = &new Scope {;
current_type   @Type
current_fn     @Obj
gotos          @Node
labels         @Node
brk_label      @char
cont_label     @char
current_switch @Node

add                (k @@Token) @Node
compound_stmt      (k @@Token) @Node
expr_stmt          (k @@Token) @Node

primary            (k @@Token t @Type) @Node
secondary          (k @@Token t @Type) @Node
tertiary           (k @@Token t @Type) @Node
seq                (k @@Token t @Type) @Node
infix              (k @@Token t @Type) @Node
quaternary         (k @@Token t @Type) @Node

enum_specifier     (k @@Token) @Type
typeof_specifier   (k @@Token) @Type
type_suffix        (k @@Token) @Type
declarator         (k @@Token) @Type
struct_decl        (k @@Token) @Type
union_decl         (k @@Token) @Type

typedecl           (k @@Token)
is_function        (k  @Token) bool

declspec           (k @@Token v @VarAttr)
declaration        (k @@Token v @VarAttr) @Node
function           (k  @Token v @VarAttr) @Token
global_variable    (k  @Token v @VarAttr) @Token

funcall            (k @@Token e @Node) @Node

array_initializer2 (k @@Token e @Initializer i i32    )
struct_initializer2(k @@Token e @Initializer g@ Member)

initializer2       (k @@Token init@ Initializer)
initializer        (k @@Token new_ty @@Type    ) @Initializer

lvar_initializer   (k @@Token o @Obj) @Node
gvar_initializer   (k @@Token o @Obj)

eval               (node  @Node                                               ) i64
eval2              (node  @Node   label @@@char                               ) i64
eval_rval          (node  @Node   label @@@char                               ) i64
is_const_expr      (node  @Node                                               ) bool
eval_double        (node  @Node                                               ) f64
new_add            (j @Token t @Type a   @Node   b @Node                       ) @Node
new_sub            (j @Token t @Type a   @Node   b @Node                       ) @Node
get_struct_member  (t    @Type   j @Token                                  ) @Member;

s1 [1024]char s2 [1024]char;
format_types(t @Type u @Type) = return
  (s1[0] = ""@) ;: (s2[0] = ""@) ;:
  format_type t &s1[0] ;:
  format_type u &s2[0] ;:
  none;;
enter_scope(void) = let sc =cast @Scope  (calloc 1ul sizeof Scope) ; (sc.s = scope); (scope = sc);;
leave_scope(void) = (scope = scope.s);;
push_scope(name@ char) @VarScope = return cast @VarScope calloc 1ul sizeof VarScope is sc hashmap_put &scope.vars name cast @  sc ;: sc;;
search_scope(j @Token which(_@ Scope)@HashMap)@ = for (let sc@ Scope = scope; sc; sc = sc.s) { let sc2 = hashmap_get2 which@ sc j.loc j.len; if sc2 return sc2; ; return cast @ 0 ; ;
scope_vars(s @Scope) @HashMap = return &s.vars;;
scope_tags(s @Scope) @HashMap = return &s.tags;;

new_initializer(t @Type is_flexible bool) @Initializer =
  let e = cast @Initializer calloc 1ul sizeof Initializer;
  (e.t = t);
  if (t.kind == TY_ARRAY) {
    if (is_flexible && t.size < 0) {
      (e.is_flexible = true);
      return e;;
    (e.children = (calloc cast unsigned i64 t.array_len  sizeof @Initializer as @@Initializer));
    for (let i i32 = 0; i < t.array_len; i += 1) (e.children[i] = new_initializer t.base false);
    return e;;
  if (t.kind == TY_STRUCT || t.kind == TY_UNION) {
    let len = 0;
    for (let g@ Member = t.members; g; g = g.s) (len += 1);
    (e.children = (calloc cast unsigned i64 len  sizeof @Initializer as @@Initializer));
    for (let g@ Member = t.members; g; g = g.s) {
      if (is_flexible && t.is_flexible && !g.s) {
        let child = cast @Initializer calloc 1ul sizeof Initializer;
        (child.t = cast @Type g.t );
        (child.is_flexible = true);
        (e.children[g.idx] = child);;
      else (e.children[g.idx] = new_initializer cast @Type g.t  false);    ;
    return e;;
  return e;;

new_var(name @char t @Type) @Obj = return
  (calloc 1ul sizeof Obj as @Obj) is o
  (o.name = name) ;:
  (o.t = t) ;:
  (o.alignment = t.alignment) ;:
  ((push_scope name).var = o) ;:
  o;;
new_lvar(name @char t @Type) @Obj = return
  new_var name t is o
  (o.is_local = true) ;:
  (o.s = locals) ;:
  (locals = o) ;:
  o;;
new_gvar(name @char t @Type) @Obj = return
  new_var name t is o
  (o.s = globals) ;:
  (o.is_export = false) ;:
  (o.is_definition = true) ;:
  (globals = o) ;:
  o;;
nunid i32 = 0;
new_unique_name(void) @char = return (format ".L..%d" (nunid += 1));;
new_anon_gvar(t @Type) @Obj = return new_gvar new_unique_name t;;
new_string_literal(p @char t @Type t2 @Type) @Obj = return new_anon_gvar t2 is o (o.init_data = p) ;: o;;

// ######## ########  ######## ########
//    ##    ##     ## ##       ##
//    ##    ##     ## ##       ##
//    ##    ########  ######   ######
//    ##    ##   ##   ##       ##
//    ##    ##    ##  ##       ##
//    ##    ##     ## ######## ########

expect_type(j @Token t @Type u @Type) = return
   !!t
&& !type_equal t u
&& format_types t u
;: (error_tok j "expected %s but found %s" s1 s2) as void
;;

new_node            (j @Token t @Type g NodeKind                                ) @Node = return cast @Node calloc 1ul sizeof Node is e e :; (e.j = j) :; (e.t = t) :; (e.kind = g);;
new_ternary         (j @Token t @Type g NodeKind a @Node b @Node c @Node        ) @Node = return new_node j t g is e e :; (e.a = a) :; (e.a.s = b) :; (e.a.s.s = c) ;;
new_binary          (j @Token t @Type g NodeKind a @Node b @Node                ) @Node = return new_node j t g is e e :; (e.a = a) :; (e.a.s = b) ;;
new_unary           (j @Token t @Type g NodeKind a @Node                        ) @Node = return new_node j t g is e e :; (e.a = a) ;;
new_nullary         (j @Token t @Type g NodeKind                                ) @Node = return new_node j t g ;;

new_lit             (j @Token t @Type t2 @Type l i64 ld f80 ) @Node = return expect_type j t t2             ;: new_nullary j t2             ND_NUM         is e e :; (e.val  = l) :; (e.fval = ld);;
new_reference       (j @Token t @Type         o @Obj        ) @Node = return expect_type j t o.t            ;: new_nullary j o.t            ND_VAR         is e e :; (e.var    = o) ;;
new_member_reference(j @Token t @Type a @Node g @Member     ) @Node = return expect_type j t cast @Type g.t ;: new_unary   j cast @Type g.t ND_MEMBER  a   is e e :; (e.member = g) ;;
new_cassign         (j @Token t @Type a @Node               ) @Node = return expect_type j t ty_void        ;: new_unary   j ty_void        ND_CASSIGN a   ;;
new_lognot          (j @Token t @Type a @Node               ) @Node = return expect_type j t ty_bool        ;: new_unary   j ty_bool        ND_NOT     a   ;;
new_bitnot          (j @Token t @Type a @Node               ) @Node = return expect_type j t a.t            ;: new_unary   j a.t            ND_BITNOT  a   ;;
new_the             (j @Token t @Type a @Node u @Type       ) @Node = return expect_type j t a.t            ;: new_unary   j a.t            ND_THE     a   ;;
new_assign          (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_void        ;: new_binary  j ty_void        ND_ASSIGN  a b ;;
new_bitor           (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_BITOR   a b ;;
new_bitxor          (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_BITXOR  a b ;;
new_bitand          (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_BITAND  a b ;;
new_eq              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_EQ      a b ;;
new_neq             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_NE      a b ;;
new_gt              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_GT      a b ;;
new_lt              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_LT      a b ;;
new_ge              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_GE      a b ;;
new_le              (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t ty_bool        ;: new_binary  j ty_bool        ND_LE      a b ;;
new_shl             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_SHL     a b ;;
new_shr             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_SHR     a b ;;
new_mul             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_MUL     a b ;;
new_div             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_DIV     a b ;;
new_mod             (j @Token t @Type a @Node b @Node       ) @Node = return expect_type j t a.t            ;: new_binary  j a.t            ND_MOD     a b ;;

new_none            (j @Token t @Type       ) @Node = return new_lit     j t ty_void 0l 0.0l;;
new_bool            (j @Token t @Type l i64) @Node = return new_lit     j t ty_bool  l 0.0l;;
new_false           (j @Token t @Type       ) @Node = return new_bool    j t 0l;;
new_true            (j @Token t @Type       ) @Node = return new_bool    j t 1l;;
new_long            (j @Token t @Type l i64) @Node = return new_lit     j t ty_i64  l 0.0l;;
new_ulong           (j @Token t @Type l i64) @Node = return new_lit     j t ring_of ty_i64 l 0.0l;;


new_cast(j @Token t @Type a @Node t2 @Type) @Node = return
  ( type_equal     a.t ty_void && (
    format_types a.t t2 ;:
    (error_tok j "(%s as %s) absurd axiom" s1 s2)) as void) ;:
  ( type_equal     a.t t2 && (
    format_types a.t t2 ;:
    (warn_tok j "(%s as %s) extraneous axiom" s1 s2)) as void) ;:
  (a.kind != ND_THE && (
    format_types a.t t2 /*;:
    (warn_tok j "(%s as %s) bare axiom" s1 s2)*/) as void) 
;: expect_type j t t2
;: new_unary   j   t2 ND_CAST a
;;
new_then(j @Token t @Type a @Node b @Node) @Node = return
   ( b.t.kind != TY_VOID
  && format_types a.t b.t
  ;: (error_tok j "(%s :; %s) must be (T :; void)" s1 s2)  as void)
;: expect_type j t a.t
;: new_binary  j   a.t ND_THEN a b
;;
new_neth(j @Token t @Type a @Node b @Node) @Node = return
   ( a.t.kind != TY_VOID
  && format_types a.t b.t
  ;: (error_tok j "(%s ;: %s) must be (void ;: T)" s1 s2) as void )
;: expect_type j t b.t
;: new_binary  j   b.t ND_COMMA a b
;;
new_let(j @Token t @Type a @Node b @Node o @Obj) @Node = return
   new_neth j t new_assign j ty_void new_reference j o.t o a b
;;
new_deref(j @Token t @Type a @Node) @Node = return
  (  a.t.kind != TY_PTR
  && format_types a.t ty_void
  ;: (error_tok j "(%s @) must be (@T @)" s1) as void)
;:(  a.t.base.kind == TY_VOID
  && format_types a.t ty_void
  ;: (error_tok j "(%s @) may not be (@void @)") as void )
;: expect_type j t a.t.base
;: new_unary   j   a.t.base ND_DEREF a ;;
new_deref_all(j @Token t @Type a @Node) @Node = return
   a for e
  (  e.t.kind == TY_PTR
  && new_deref j t e );;
new_repeat(j @Token t @Type a @Node b @Node o @Obj) @Node = return 
  (! type_equal   a.t b.t && (
    format_types a.t b.t ;:
    (error_tok j "(%s for %s) must be of the form (T for T)" s1 s2)) as void) 
;: expect_type j t a.t
;: new_binary  j   a.t ND_REPEAT a b is e e
:; (e.var = o)
;;
new_conditional(j @Token t @Type a @Node b @Node c @Node) @Node = return
  (! type_equal   a.t ty_bool && (
    format_types a.t b.t ;:
    (error_tok j "(%s ?:) must be of the form (bool ?:)" s1 s2)) as void) ;:
  (! type_equal   b.t c.t && (
    format_types b.t c.t ;:
    (error_tok j "(? %s : %s) must be of the form (: T ? T)" s1 s2)) as void) 
;: expect_type j t ty_bool
;: new_ternary j b.t ND_COND a b c;;
new_logor(j @Token t @Type a @Node b @Node) @Node = return
  (  !type_equal   a.t b.t
  && !type_equal   b.t ty_void
  &&(  format_types a.t b.t
    ;: (error_tok j "(%s || %s) must be of the form (T || T) or (T || void)" s1 s2) ) as void )
;: expect_type j t a.t
;: new_binary j a.t ND_LOGOR a b
;;
new_logand(j @Token t @Type a @Node b @Node) @Node = return
  (  !type_equal a.t ty_bool
  && !type_equal ty_void b.t
  &&(  format_types a.t b.t
    ;: (error_tok j "(%s && %s) must be of the form (bool && T) or (T && void)" s1 s2) ) as void)
;: expect_type j t ((b.t.kind == TY_VOID) ? ty_bool : b.t)
;: new_binary  j   ((b.t.kind == TY_VOID) ? ty_bool : b.t) ND_LOGAND a b
;;
new_add   (j @Token t @Type a @Node b @Node) @Node = return
  ( ( (     a.t.kind == TY_PTR
      ||    a.t.kind == TY_ARRAY )
    &&(     b.t.kind == TY_PTR 
      ||    b.t.kind == TY_ARRAY )
    ||      a.t.kind != TY_PTR
    &&      a.t.kind != TY_ARRAY
    &&      b.t.kind != TY_PTR
    &&      b.t.kind != TY_ARRAY
    &&     !type_equal a.t b.t
    &&     format_types a.t b.t
    ;: error_tok j "(%s + %s) must be (T + T) or (@T + U) or (T + @U)" s1 s2 ) as void )
;: new_binary j ((a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) ? pointer_to(a.t.base) : (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY) ? pointer_to(b.t.base) : a.t) ND_ADD a b;;
new_sub(j @Token t @Type a @Node b @Node) @Node = return
  (  a.t.kind != TY_PTR 
  && a.t.kind != TY_ARRAY
  &&(  b.t.kind == TY_PTR
    || b.t.kind == TY_ARRAY ) 
  || a.t.kind != TY_PTR
  && a.t.kind != TY_ARRAY
  && b.t.kind != TY_PTR
  && b.t.kind != TY_ARRAY
  && !type_equal a.t b.t
  &&(  format_types a.t b.t
    ;: error_tok j "(%s - %s) must be (T - T) or (@T - U) or (@T - @U)" s1 s2 ) as void )
;: new_binary j ((a.t.kind == TY_PTR || a.t.kind == TY_ARRAY) ? pointer_to(a.t.base) : (b.t.kind == TY_PTR || b.t.kind == TY_ARRAY) ? ty_i64 : a.t) ND_SUB a b
;;
new_neg(j @Token t @Type a @Node) @Node = return
  new_unary j a.t ND_NEG a ;;
new_addressof(j @Token t @Type a @Node) @Node = return
  (a.kind == ND_MEMBER && a.member.is_bitfield && (error_tok j "cannot take address of bitfield") as void) ;:
  new_unary j pointer_to a.t ND_ADDR a ;;
new_sizeof (j @Token t @Type t2 @Type) @Node = return new_ulong j t cast i64 t2.size     ;;
new_alignof(j @Token t @Type t2 @Type) @Node = return new_ulong j t cast i64 t2.alignment;;
new_member_access(j @Token t @Type a @Node) @Node = return
   (a = new_deref_all j t a)
;:(  a.t.kind != TY_STRUCT
  && a.t.kind != TY_UNION
  &&(  format_types a.t ty_void
    ;: error_tok j "(%s . %.*s) must be of the form (@*struct . %.*s)" s1 j.s.len j.s.loc j.s.len j.s.loc ) as void)
;: get_struct_member a.t j is g
  (  !g
  &&(  format_types a.t ty_void
    ;: error_tok j "(%s . %.*s) no such member" s1 j.s.len j.s.loc ) as void )
;: new_unary j cast @Type g.t ND_MEMBER a is e e
:; (e.member = g)
;;
new_call(j @Token t @Type a @Node) @Node = return
   expect_type j t a.t.return_ty 
;: new_unary j a.t.return_ty ND_FUNCALL a is e e
:;( (  e.t.kind == TY_STRUCT
    || e.t.kind == TY_UNION )
  && (e.ret_buffer = new_lvar "" e.t)
  as void )
;;


















get_ident(k@ Token) @char = return
  ((k.kind != TK_IDENT) && (error_tok k "expected an nonymousifier") as void) ;:
  strndup k.loc cast unsigned i64 k.len ;;
find_type(k @Token) @Type = return
  (k.kind != TK_IDENT) ? cast @Type 0  :
  cast @VarScope search_scope k &scope_vars is sc
  (!!sc ? sc.type_def : cast @Type 0 );;
push_tag_scope(k@ Token t@ Type) = return hashmap_put2 &scope.tags k.loc k.len cast @ t ;;

declspec(k @@Token v@ VarAttr) =
  for (;;) {
    if (equal k@ "type" || equal k@ "export" || equal k@ "extern" || equal k@ "inline" || equal k@ "_Thread_local" || equal k@ "__thread") {
      if !v (error_tok k@ "storage class specifier is not allowed in this context");
      (( equal k@ "type"   ? &v.is_type   :
         equal k@ "export" ? &v.is_export :
         equal k@ "extern" ? &v.is_extern :
         equal k@ "inline" ? &v.is_inline :
                             &v.is_tls    )@ = true);
      if (v.is_type && v.is_static + v.is_export + v.is_extern + v.is_inline + v.is_tls > 1) (error_tok k@ "type may not be used together with export, static, extern, inline, __thread or _Thread_local");
      (k@ = k.s);;
    else if equal k@ "align" {
      if !v (error_tok k@ "align is not allowed in this context");
      (k@ = k.s);
      (v.alignment = const_expr k as i32);;
    else if consume k k@ "restrict";
    else return;;;
type_specifier(k @@Token)@ Type =
  if consume k k@ "i8"  return ty_i8; else
  if consume k k@ "i16" return ty_i16; else
  if consume k k@ "i32" return ty_i32; else
  if consume k k@ "i64" return ty_i64; else
  if consume k k@ "f32" return ty_f32; else
  if consume k k@ "f64" return ty_f64; else
  if consume k k@ "f80" return ty_f80; else
  if consume k k@ "struct" return struct_decl      k; else
  if consume k k@ "union"  return union_decl       k; else
  if consume k k@ "enum"   return enum_specifier   k; else
  if consume k k@ "typeof" return typeof_specifier k; else
  if consume k k@ "same"   {
    if !current_type (error_tok k@ "`same` may not be used outside struct/union definition");
    return current_type;;
  else {
    let ty2 = find_type k@;
    if ty2{
      (k@ = k.s);
      return ty2;;
    else {
      let counter = the enum 
        VOID     =  0
        BOOL     = (1 <<  2)
        CHAR     = (1 <<  4)
        SHORT    = (1 <<  6)
        INT      = (1 <<  8)
        LONG     = (1 << 10)
        FLOAT    = (1 << 12)
        DOUBLE   = (1 << 14)
        SIGNED   = (1 << 17)
        UNSIGNED = (1 << 18);
        VOID;
      for (;;) {
        if equal k@ "void"     (counter += VOID    ); else
        if equal k@ "bool"     (counter += BOOL    ); else
        if equal k@ "char"     (counter += CHAR    ); else
        if equal k@ "i16"    (counter += SHORT   ); else
        if equal k@ "i32"      (counter += INT     ); else
        if equal k@ "i64"     (counter += LONG    ); else
        if equal k@ "f32"    (counter += FLOAT   ); else
        if equal k@ "f64"   (counter += DOUBLE  ); else
          break;
        (k@ = k.s);;
      switch counter {
        case (0                           ) : return ty_void;
        case (BOOL                        ) : return ty_bool;
        case (CHAR                        ) :
        case (SIGNED + CHAR               ) : return ty_i8;
        case (SHORT                       ) :
        case (SHORT + INT                 ) :
        case (SIGNED + SHORT              ) :
        case (SIGNED + SHORT + INT        ) : return ty_i16;
        case (INT                         ) :
        case (SIGNED                      ) :
        case (SIGNED + INT                ) : return ty_i32;
        case (LONG                        ) :
        case (LONG + INT                  ) :
        case (LONG + LONG                 ) :
        case (LONG + LONG + INT           ) :
        case (SIGNED + LONG               ) :
        case (SIGNED + LONG + INT         ) :
        case (SIGNED + LONG + LONG        ) :
        case (SIGNED + LONG + LONG + INT  ) : return ty_i64;
        case (FLOAT                       ) : return ty_f32;
        case (DOUBLE                      ) : return ty_f64;
        case (LONG + DOUBLE               ) : return ty_f80;;
      (error_tok k@ "invalid type");;;;
func_params(k @@Token) @Type =
  if (equal k@ "void" && consume k k.s ")") return func_type type_suffix k;
  let
    head = new Type {;
    cur = &head
    is_variadic = false;
  while ! equal k@ ")" {
    if consume k k@ "..." {
      (is_variadic = true);
      break;;
    declspec k cast @VarAttr 0;
    let t = declarator k;
    let name = t.name;
   if (t.kind == TY_FUNC) {
      (t = pointer_to t);
      (t.name = name);;
    (cur.s = copy_type t);
    (cur = cur.s);;
  if (cur == &head) (is_variadic = true);
  (k@ = k.s);
  let t = func_type type_suffix k;
  (t.params = head.s);
  (t.is_variadic = is_variadic);
  return t;;
array_dimensions(k @@Token) @Type =
  while (equal k@ "static" || equal k@ "restrict") (k@ = k.s);
  if consume k k@ "]" {
    let t = type_suffix k;
    return array_of t -1;;
  let e = infix k ty_i32;
  expect k "]";
  let t = type_suffix k;
  return array_of t cast i32 eval e;;
typeof_specifier(k @@Token) @Type = return
  tertiary k cast @Type 0 is e
  e.t;;
type_suffix(k @@Token) @Type = return
  (k@ = k@ for j ((equal j "const" || equal j "volatile") && j.s)) ;:
  consume k k@ "%" ? ring_of type_suffix k :
  consume k k@ "unsigned" ? ring_of type_suffix k :
  consume k k@ "(" ? func_params            k :
  consume k k@ "[" ? array_dimensions       k :
  consume k k@ "@" ? pointer_to type_suffix k :
  type_specifier k;;
declarator(k @@Token)@ Type = return
  advance k is j
  type_suffix k is t t :;
  (t.name = j) ;:
  (t.name_pos = j);;
enum_specifier(k @@Token) @Type =
  let t = enum_type ;
  let l = 0;
  while ! consume k k@ ";" {
    let p = get_ident k@;
    (k@ = k.s);
    if equal k@ "=" {
      (k@ = k.s);
      (l = cast i32 const_expr k);;
    let sc = push_scope p;
    (sc.enum_ty = t);
    (sc.enum_val = (l :; (l += 1)));;
  return t;;
declaration(k @@Token v @VarAttr) @Node =
  let
    head = new Node {;
    cur = &head;
  while !equal k@ ";" {
    let t = declarator k;
    if (t.kind == TY_VOID) (error_tok k@ "variable declared void");
    if !t.name (error_tok t.name_pos "variable name omitted");
    if !equal t.name "_" {
      if (!!v && v.is_static) {
        new_anon_gvar t is o
        ((push_scope get_ident t.name).var = o) ;:
        (equal k@ "=" && (
          (k@ = k.s) ;:
          gvar_initializer k o));;
      else {
        let o = new_lvar get_ident t.name t;
        if (!!v && v.alignment) (o.alignment = v.alignment);
        if equal k@ "=" {
          (k@ = k.s);
          let e = lvar_initializer k o;
          (cur.s = new_unary k@ cast @Type 0 ND_EXPR_STMT e);
          (cur = cur.s);;
        if (o.t.size < 0) (error_tok t.name "variable has incomplete type");
        if (o.t.kind == TY_VOID) (error_tok t.name "variable declared void");;;;
  let e = new_node k@ cast @Type 0 ND_BLOCK;
  (e.body = head.s);
  (k@ = k.s);
  return e;;







string_initializer(k @@Token e@ Initializer)  =
  if e.is_flexible (e@ = (new_initializer array_of e.t.base (cast @Type k.t ).array_len false)@);
  let len = minl cast i64 e.t.array_len cast i64 (cast @Type k.t).array_len;
  switch e.t.base.size {
  case 1: { let str = k.str                ; for (let i i32 = 0; i < len; i += 1) (e.children[i].expr = new_lit k@ cast @Type 0 ty_i32 cast i64 str[i] 0.0l); (k@ = k.s); return; ;
  case 2: { let str = cast @unsigned i16 k.str ; for (let i i32 = 0; i < len; i += 1) (e.children[i].expr = new_lit k@ cast @Type 0 ty_i32 cast i64 str[i] 0.0l); (k@ = k.s); return; ;
  case 4: { let str = cast @unsigned i32 k.str ; for (let i i32 = 0; i < len; i += 1) (e.children[i].expr = new_lit k@ cast @Type 0 ty_i32 cast i64 str[i] 0.0l); (k@ = k.s); return; ;;
  none ;;
count_array_init_elements(j @Token t @Type) i32 =
  let
        k = &j
    dummy = new_initializer t.base true
    i = 0
    max = 0;
  while ! consume k k@ ";" {
    initializer2 k dummy;
    (i += 1);
    (max = cast i32 maxl cast i64 max  cast i64 i );;
  return max;;
array_initializer1(k @@Token e@ Initializer)  =
  expect k "{";
  if e.is_flexible {
    let l = count_array_init_elements k@ e.t;
    (e@ = (new_initializer array_of e.t.base l false)@);;
  0 for i (!consume k k@ ";" && ((i < e.t.array_len) && initializer2 k e.children[i] as void) ;: (i + 1));;
array_initializer2(k @@Token e @Initializer i i32)  =
  if e.is_flexible {
    let len = count_array_init_elements k@ e.t;
    (e@ = (new_initializer array_of e.t.base len false)@);;
  for (; i < e.t.array_len && ! equal k@ ";"; i += 1) {
    let start = k@;
    if (equal k@ "[" || equal k@ ".") {
      (k@ = start);
      return;;
    initializer2 k e.children[i];;;
struct_initializer1(k @@Token e @Initializer)  =
  expect k "{";
  let g = e.t.members;
  while ! consume k k@ ";" {
    if g {
      initializer2 k e.children[g.idx];
      (g = g.s);
    ;;;
struct_initializer2(k @@Token e@ Initializer g @Member)  =
  for (; !!g && ! equal k@ ";"; g = g.s) {
    let start = k@;
    if (equal k@ "[" || equal k@ ".") {
      (k@ = start);
      return;;
    initializer2 k e.children[g.idx];;;
union_initializer(k @@Token e @Initializer) = return
  (e.g = e.t.members) ;:
  equal k@ "{" ?
    (k@ = k.s) ;:
    initializer2 k e.children[0] :
    initializer2 k e.children[0] ;;
initializer2(k @@Token e @Initializer) =
  if (e.t.kind == TY_ARRAY && k.kind == TK_STR) string_initializer k e;
  else if (e.t.kind == TY_ARRAY) {
    if equal k@ "{" array_initializer1 k e;
    else array_initializer2 k e 0;;
  else if (e.t.kind == TY_STRUCT) {
    if equal k@ "{" struct_initializer1 k e;
    else {
      let a = tertiary k cast @Type 0;
      if (a.t.kind == TY_STRUCT) (e.expr = a);
      else struct_initializer2 k e e.t.members;;;
  else if (e.t.kind == TY_UNION) union_initializer k e;
  else if equal k@ "{" {
    (k@ = k.s);
    initializer2 k e;
    expect k ";";;
  else (e.expr = tertiary k cast @Type 0);;
copy_struct_type(t @Type) @Type =
  (t = copy_type t);
  let
    head = new Member {;
    cur = &head;
  for (let g@ Member = t.members; g; g = g.s) {
    let m = cast @Member calloc 1ul sizeof Member;
    (m@ = g@);
    (cur.s = m);
    (cur = cur.s);;
  (t.members = head.s);
  return t;;
initializer(k @@Token t @@Type) @Initializer =
  let e = new_initializer t@ true;
  initializer2 k e;
  if ((t.kind == TY_STRUCT || t.kind == TY_UNION) && t.is_flexible) {
    (t@ = copy_struct_type t@);
    let g = t.members;
    while g.s (g = g.s);
    (g.t = e.children[g.idx].t as @);
    (t.size += (cast @Type g.t ).size);;
  else (t@ = e.t);
  (e.t = ty_void);
  return e;;
init_desg_expr(z @InitDesg j @Token) @Node = return
  !!z.var ? new_reference j cast @Type 0 z.var :
  !!z.member ?
    new_unary j cast @Type 0 ND_MEMBER init_desg_expr z.s j is e
    (e.member = z.member) ;:
    (e.t = cast @Type e.member.t) ;:
    e :
  new_deref j cast @Type 0 new_add j ty_i32 init_desg_expr z.s j new_lit j cast @Type 0 ty_i32 cast i64 z.idx 0.0l;;






read_buf(x @char n i32) unsigned i64 = return
  (n == 1) ? cast unsigned i64 (                     x)@ :
  (n == 2) ? cast unsigned i64 (cast @unsigned i16 x)@ :
  (n == 4) ? cast unsigned i64 (cast @unsigned i32   x)@ :
  (n == 8) ?                    (cast @unsigned i64  x)@ :
             0ul                                         	;;

write_buf(x @char v unsigned i64 sz i32) = return
  (sz == 1) ? ((cast @unsigned i8  x)@ = cast unsigned i8  v) :
  (sz == 2) ? ((cast @unsigned i16 x)@ = cast unsigned i16 v) :
  (sz == 4) ? ((cast @unsigned i32   x)@ = cast unsigned i32   v) :
  (sz == 8) ? ((cast @unsigned i64  x)@ =                     v) :
                 none                                                ;;

write_gvar_data(cur@ Relocation init@ Initializer t@ Type buf@ char offset i32)@ Relocation =
  if (t.kind == TY_ARRAY) {
    let sz = t.base.size;
    for (let i i32 = 0; i < t.array_len; i += 1) {
      (cur = write_gvar_data cur init.children[i] t.base buf (offset + sz * i));;
    return cur;;
  if (t.kind == TY_STRUCT) {
    for (let g@ Member = t.members; g; g = g.s) {
      if g.is_bitfield {
        let expr = init.children[g.idx].expr;
        if !expr break;
        let loc = (buf + offset + g.offset);
        let oldval = read_buf loc (cast @Type g.t ).size;
        let newval = eval expr;
        let mask = ((1 << g.bit_width) - 1);
        let combined = (oldval | cast unsigned i64 the i64 ((newval & cast i64 mask) << cast i64 g.bit_offset));
        write_buf loc combined (cast @Type g.t ).size;;
      else {
        (cur = write_gvar_data cur init.children[g.idx] cast @Type g.t  buf (offset + g.offset));;;
    return cur;;
  if (t.kind == TY_UNION) {
    if !init.g return cur;
    return write_gvar_data cur init.children[init.g.idx] cast @Type init.g.t  buf offset;;
  if !init.expr return cur;
  if (t.kind == TY_FLOAT32) {
    ((buf + offset as @f32)@ = eval_double init.expr as f32);
    return cur;;
  if (t.kind == TY_FLOAT64) {
    ((buf + offset as @f64)@ = eval_double init.expr);
    return cur;;
  let label = (0 as @@char);
  let val = eval2 init.expr &label;
  if !label {
    let a = (buf + offset);
    write_buf a cast unsigned i64 val  t.size;
    return cur;;
  let rel = (calloc 1ul sizeof Relocation as @Relocation);
  (rel.offset = offset);
  (rel.label  = label );
  (rel.addend = val   );
  (cur.s   = rel   );
  return cur.s;;

create_lvar_init(e @Initializer t @Type z @InitDesg j @Token)@ Node =
  if (t.kind == TY_ARRAY) {
    let a = new_none j ty_void;
    for (let i i32 = 0; i < t.array_len; i += 1) {
      let
        z2 = new InitDesg {z i;
        b = create_lvar_init e.children[i] t.base &z2 j;
      (a = new_neth j cast @Type 0 a b);;
    return a;;
  if (t.kind == TY_STRUCT && !e.expr) {
    let a = new_none j ty_void;
    for (let g @Member = t.members; g; g = g.s) {
      let
        z2 = new InitDesg {z 0 g;
        b = create_lvar_init e.children[g.idx] cast @Type g.t  &z2 j;
      (a = new_neth j cast @Type 0 a b);;
    return a;;
  if (t.kind == TY_UNION) {
    let
      g = (e.g || t.members)
      z2 = new InitDesg {z 0 g;;
    return create_lvar_init e.children[g.idx] cast @Type g.t  &z2 j;;
  if !e.expr
    return new_none j ty_void;
  let a = init_desg_expr z j;
  if ! type_equal a.t e.expr.t {
    format_types e.expr.t a.t;
    (error_tok e.expr.j "asymmetric init from %s to %s" s1 s2);;
  return new_assign j ty_void a e.expr;;

gvar_initializer(k @@Token o@ Obj) =
  &o.t is t
  initializer k t is e
  new Relocation {; is head
  cast @char calloc 1ul cast unsigned i64 o.t.size  is buf
  cast void (write_gvar_data &head e o.t buf 0) ;:
  (o.init_data = buf) ;:
  (o.rel = head.s);;
lvar_initializer(k @@Token o @Obj) @Node = return
  &o.t is t
  initializer k t is e
  new InitDesg { cast @InitDesg 0 0 cast @Member 0 o; is z
  new_node k@ ty_void ND_MEMZERO is a
  (a.var = o) ;:
  new_neth k@ ty_void a create_lvar_init e o.t &z k@;;


// ######## ##     ## #### ##
// ##       ##     ##  ##  ##
// ##       ##     ##  ##  ##
// ######   ##     ##  ##  ##
// ##        ##   ##   ##  ##
// ##         ## ##    ##  ##
// ########    ###    #### ########


stmt(k @@Token) @Node = return
  k@ is j
  (consume k k@ "return" ?
    new_node j cast @Type 0 ND_RETURN is e
    (consume k k@ ";" ? e :
    (e.a = infix k current_fn.t.return_ty)     ;:
    expect k ";"          ;:
    current_fn.t.return_ty is t
    (!type_equal current_fn.t.return_ty e.a.t &&
      ( format_types e.a.t current_fn.t.return_ty ;:
        (error_tok e.a.j "asymmetric return from %s to %s" s1 s2)) as void) ;:
    e) :
  consume k k@ "if" ?
    new_node j cast @Type 0 ND_IF is e
    (e.cond = tertiary k ty_bool) ;:
    (e.then = stmt k) ;:
    (consume k k@ "else" && (e.els = stmt k) as void) ;:
    e :
  consume k k@ "switch" ?
    new_node j cast @Type 0 ND_SWITCH is e
    (e.cond = tertiary k ty_bool) ;:
    current_switch is sw
    (current_switch = e) ;:
    brk_label is brk
    (e.brk_label = new_unique_name) ;:
    (brk_label = e.brk_label) ;:
    (e.then = stmt k) ;:
    (current_switch = sw) ;:
    (brk_label = brk) ;:
    e :
  consume k k@ "case" ?
    (!current_switch && (error_tok j "stray case") as void) ;:
    new_node j cast @Type 0 ND_CASE is e
    const_expr k is begin
    begin is end
    expect k ":" ;:
    (e.label = new_unique_name) ;:
    (e.a = stmt k) ;:
    (e.begin = begin) ;:
    (e.end = end) ;:
    (e.case_next = current_switch.case_next) ;:
    (current_switch.case_next = e) ;:
    e :
  consume k k@ "default" ?
    //(warn_tok k@ "delet pls") ;:
    (!current_switch && (error_tok j "stray default") as void) ;:
    new_node j cast @Type 0 ND_CASE is e
    expect k ":" ;:
    (e.label = new_unique_name) ;:
    (e.a = stmt k) ;:
    (current_switch.default_case = e) ;:
    e :
  consume k k@ "for" ?
    new_node j cast @Type 0 ND_FOR is e
    expect k "(" ;:
    enter_scope ;:
    brk_label is brk
    cont_label is cont
    (e.brk_label  = new_unique_name) ;:
    (brk_label    = e.brk_label    ) ;:
    (e.cont_label = new_unique_name) ;:
    (cont_label   = e.cont_label   ) ;:
    ( consume k k@ "let" ?
        declspec k cast @VarAttr 0 ;:
        (e.init = declaration k cast @VarAttr 0) :
      (e.init = expr_stmt k) ) ;:
    (!equal k@ ";" && (e.cond = quaternary k ty_bool) as void) ;:
    expect k ";" ;:
    (!equal k@ ")" && (e.inc = quaternary k ty_void) as void) ;:
    expect k ")" ;:
    (e.then     = stmt k) ;:
    leave_scope ;:
    (brk_label  = brk) ;:
    (cont_label = cont) ;:
    e :
  consume k k@ "while" ?
    new_node j cast @Type 0 ND_FOR is e
    brk_label is brk
    cont_label is cont
    (e.cond       = tertiary k       ty_bool) ;:
    (e.brk_label  = new_unique_name  ) ;:
    (brk_label    = e.brk_label      ) ;:
    (e.cont_label = new_unique_name  ) ;:
    (cont_label   = e.cont_label     ) ;:
    (e.then       = stmt k           ) ;:
    (brk_label    = brk              ) ;:
    (cont_label   = cont             ) ;:
    e :
  consume k k@ "break" ?
    !brk_label ? (error_tok j "stray break") ;: cast @Node 0  :
    new_node j cast @Type 0 ND_GOTO is e
    (e.unique_label = brk_label) ;:
    expect k ";" ;:
    e :
  consume k k@ "{" ? compound_stmt k :
  expr_stmt k);;


decl_stmt(k @@Token) @Node =
  //warn_tok k@ "you are so dumb bro";
  let
    head = new Node {;
    cur = &head;
  while ! equal k@ ";" {
    if equal k.s "=" {
      if (k.kind != TK_IDENT || equal k@ "_") (error_tok k@ "expected nonymousifer");
      else {
        let name = k@;
        (k@ = k.s.s);
        let e = tertiary k cast @Type 0;
        if (e.t.kind == TY_VOID) (error_tok k@ "variable declared void");
        else {
          let o = new_lvar get_ident name e.t;
          (cur.s = new_unary k@ ty_void ND_EXPR_STMT new_assign k@ ty_void new_reference k@ e.t o e);
          (cur = cur.s);;;;
    else {
      //warn_tok(k@ "deprecated initializer");
      let t = declarator k;
      if (t.kind == TY_VOID) (error_tok k@ "variable declared void");
      else {
        if !t.name (error_tok t.name_pos "variable name omitted");
        else if !equal t.name "_" {
          let o = new_lvar get_ident t.name t;
          if consume k k@ "=" {
            let e = lvar_initializer k o;
            (cur.s = new_unary k@ cast @Type 0 ND_EXPR_STMT e);
            (cur = cur.s);;
          if (o.t.size < 0) (error_tok t.name "variable has incomplete type");
          else if (o.t.kind == TY_VOID) (error_tok t.name "variable declared void");;;;;
  let e = new_node k@ cast @Type 0 ND_BLOCK;
  (k@ = k.s);
  (e.body = head.s);
  return e;;

compound_stmt(k @@Token) @Node = return
   new_node k@ cast @Type 0 ND_BLOCK is e e
:; enter_scope
:; cast @Node 0 is head
  (  &e.body for p
    (  !consume k k@ ";"
    && (p@ = (consume k k@ "let" ? &decl_stmt : &stmt)@ k)
    ;: &p.s ) as void )
:; leave_scope
;;

expr_stmt(k @@Token)@ Node = return
  equal k@ ";" ?
    new_node k@ cast @Type 0 ND_BLOCK is e
    (k@ = k.s) ;:
    e :
  new_node k@ cast @Type 0 ND_EXPR_STMT is e
  (e.a = quaternary k ty_void) ;:
  expect k ";" ;:
  e;;




//  ####    ####   #    #   ####   #####  ######  #    #    ##    #
// #    #  #    #  ##   #  #         #    #       #    #   #  #   #
// #       #    #  # #  #   ####     #    #####   #    #  #    #  #
// #       #    #  #  # #       #    #    #       #    #  ######  #
// #    #  #    #  #   ##  #    #    #    #        #  #   #    #  #
//  ####    ####   #    #   ####     #    ######    ##    #    #  ######


eval2(e@ Node label @@@char) i64 = return
  (e.kind == ND_NOT   ) ? cast i64 !eval e.a              :
  (e.kind == ND_ADD   ) ? (eval2 e.a label + eval e.a.s)   :
  (e.kind == ND_SUB   ) ? (eval2 e.a label - eval e.a.s)   :
  (e.kind == ND_NEG   ) ? -eval e.a                        :
  (e.kind == ND_MUL   ) ? (eval e.a *  eval e.a.s)         :
  (e.kind == ND_BITAND) ? (eval e.a &  eval e.a.s)         :
  (e.kind == ND_BITOR ) ? (eval e.a |  eval e.a.s)         :
  (e.kind == ND_BITXOR) ? (eval e.a ^  eval e.a.s)         :
  (e.kind == ND_SHL   ) ? (eval e.a << eval e.a.s)         :
  (e.kind == ND_EQ    ) ? (eval e.a == eval e.a.s as i64) :
  (e.kind == ND_NE    ) ? (eval e.a != eval e.a.s as i64) :
  (e.kind == ND_SHR   ) ? ((e.a.t.kind == TY_UNSIGNED) &&
                           e.t.size == 8        )  ? (cast unsigned i64 eval e.a >> cast unsigned i64 eval e.a.s as i64) :
                                                      (                   eval e.a >>                    eval e.a.s        ) :
  (e.kind == ND_DIV   ) ?  (e.a.t.kind == TY_UNSIGNED)     ? (cast unsigned i64 eval e.a /  cast unsigned i64 eval e.a.s as i64) :
                                                      (                   eval e.a /                     eval e.a.s        ) :
  (e.kind == ND_MOD   ) ?  (e.a.t.kind == TY_UNSIGNED)     ? (cast unsigned i64 eval e.a %  cast unsigned i64 eval e.a.s as i64) :
                                                      (                   eval e.a %                     eval e.a.s        ) :
  (e.kind == ND_LT    ) ?  (e.a.t.kind == TY_UNSIGNED)     ? (cast unsigned i64 eval e.a <  cast unsigned i64 eval e.a.s as i64) :
                                                      (                   eval e.a <                     eval e.a.s as i64) :
  (e.kind == ND_LE    ) ?  (e.a.t.kind == TY_UNSIGNED)     ? (cast unsigned i64 eval e.a <= cast unsigned i64 eval e.a.s as i64) :
                                                      (                   eval e.a <=                    eval e.a.s as i64) :
  (e.kind == ND_GT    ) ?  (e.a.t.kind == TY_UNSIGNED)     ? (cast unsigned i64 eval e.a >  cast unsigned i64 eval e.a.s as i64) :
                                                      (                   eval e.a >                     eval e.a.s as i64) :
  (e.kind == ND_GE    ) ?  (e.a.t.kind == TY_UNSIGNED)     ? (cast unsigned i64 eval e.a >= cast unsigned i64 eval e.a.s as i64) :
                                                      (                   eval e.a >=                    eval e.a.s as i64) :
  (e.kind == ND_COND  ) ? !!eval e.a ? eval2 e.a.s label :
                                          eval2 e.a.s.s  label :
  (e.kind == ND_COMMA ) ? eval2 e.a.s label :
  (e.kind == ND_THE   ) ? eval2 e.a label :
  (e.kind == ND_BITNOT) ? ~ eval e.a      :
  (e.kind == ND_LOGAND) ? (!!eval e.a &&
                             eval e.a.s  )  :
  (e.kind == ND_LOGOR ) ? (  eval e.a ||
                             eval e.a.s  )  :
  (e.kind == ND_CAST  ) ?
    eval2 e.a label is l
    (
    (e.t.size == 1) ? ((e.t.kind == TY_UNSIGNED) ? cast i64 cast unsigned i8  the i64 l : cast i64 cast  char  the i64 l) :
    (e.t.size == 2) ? ((e.t.kind == TY_UNSIGNED) ? cast i64 cast unsigned i16 the i64 l : cast i64 cast i16 the i64 l) :
    (e.t.size == 4) ? ((e.t.kind == TY_UNSIGNED) ? cast i64 cast unsigned i32 the i64 l : cast i64 cast i32 the i64 l) :
                                                                            l)                                      :
  (e.kind == ND_ADDR     ) ? eval_rval e.a label :
  (e.kind == ND_MEMBER   ) ?
    !label ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (e.t.kind != TY_ARRAY) ? (error_tok e.j "invalid initializer") ;: 0l :
    (eval_rval e.a label + cast i64 e.member.offset) :
  (e.kind == ND_VAR      ) ?
    !label ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (e.var.t.kind != TY_ARRAY && e.var.t.kind != TY_FUNC) ? (error_tok e.j "invalid initializer") ;: 0l :
    (label@ = &e.var.name) ;: 0l :
  (e.kind == ND_NUM      ) ? e.val :
  (error_tok e.j "not a compile-time constant") ;:
  0l;;
eval(e@ Node) i64 = return eval2 e cast @@@char 0;;
eval_rval(e@ Node label @@@char) i64 = return
  (e.kind == ND_VAR) ?
    e.var.is_local ? (error_tok e.j "not a compile-time constant") ;: 0l :
    (label@ = &e.var.name) ;: 0l :
  (e.kind == ND_DEREF ) ? (eval2     e.a label                  ) :
  (e.kind == ND_MEMBER) ? (eval_rval e.a label + cast i64 e.member.offset) :
  (error_tok e.j "invalid initializer") ;:
  0l;;
is_const_expr(e@ Node) bool = return
  ( e.kind == ND_NEG    ||
    e.kind == ND_NOT    ||
    e.kind == ND_BITNOT ||
    e.kind == ND_THE    ||
    e.kind == ND_CAST    )  ? is_const_expr e.a :
  ( e.kind == ND_ADD    ||
    e.kind == ND_SUB    ||
    e.kind == ND_MUL    ||
    e.kind == ND_DIV    ||
    e.kind == ND_BITAND ||
    e.kind == ND_BITOR  ||
    e.kind == ND_BITXOR ||
    e.kind == ND_SHL    ||
    e.kind == ND_SHR    ||
    e.kind == ND_EQ     ||
    e.kind == ND_NE     ||
    e.kind == ND_LT     ||
    e.kind == ND_LE     ||
    e.kind == ND_GT     ||
    e.kind == ND_GE     ||
    e.kind == ND_LOGAND ||
    e.kind == ND_LOGOR   )  ? (is_const_expr e.a  && is_const_expr e.a.s                           ) :
  ( e.kind == ND_COND    )  ? (is_const_expr e.a && is_const_expr (!!eval e.a ? e.a.s : e.a.s.s)) :
  ( e.kind == ND_NUM     ) ;;
export const_expr(k@@ Token) i64 = return eval tertiary k ty_i64;;





// ######  #    #  #####   #####   ######   ####    ####   #   ####   #    # 
// #        #  #   #    #  #    #  #       #       #       #  #    #  ##   # 
// #####     ##    #    #  #    #  #####    ####    ####   #  #    #  # #  # 
// #         ##    #####   #####   #            #       #  #  #    #  #  # # 
// #        #  #   #       #   #   #       #    #  #    #  #  #    #  #   ## 
// ######  #    #  #       #    #  ######   ####    ####   #   ####   #    # 

nullary        (k @@Token t @Type          op @char                                 new_@ (j @Token t @Type                                ) @Node                             ) @Node = return equal k@ op && (advance k is j                                  new_@ j t                             );;
nullary_type   (k @@Token t @Type          op @char                                 new_@ (j @Token t @Type                 t2 @Type       ) @Node                             ) @Node = return equal k@ op && (advance k is j type_suffix k is t2              new_@ j t           t2                 );;
unary          (k @@Token t @Type          op @char                                 new_@ (j @Token t @Type a @Node                        ) @Node s@ (k @@Token t @Type) @Node) @Node = return equal k@ op && (advance k is j                                  new_@ j t    s@ k t                  );;
unary_type     (k @@Token t @Type          op @char                                 new_@ (j @Token t @Type a @Node         t2 @Type       ) @Node s@ (k @@Token t @Type) @Node) @Node = return equal k@ op && (advance k is j type_suffix k is t2              new_@ j t    s@ k t t2                 );;
binary_right   (k @@Token t @Type a @@Node op @char                                 new_@ (j @Token t @Type a @Node b @Node                ) @Node b@ (k @@Token t @Type) @Node) bool  = return equal k@ op && (advance k is j                          (a@ =   new_@ j t a@ b@ k t) ;: true            );;
binary_left    (k @@Token t @Type a @Node  op @char                                 new_@ (j @Token t @Type a @Node b @Node                ) @Node s@ (k @@Token t @Type) @Node) @Node = return equal k@ op && (advance k is j                                  new_@ j t a  s@ k t                   );;
binary_left_var(k @@Token t @Type a @Node  op @char lvar_@ (k @@Token t @Type) @Obj new_@ (j @Token t @Type a @Node b @Node         o @Obj ) @Node s@ (k @@Token t @Type) @Node) @Node = return equal k@ op && (advance k is j enter_scope ;: lvar_@ k a.t is o new_@ j t a  s@ k t   o :; leave_scope);;

left(k @@Token t @Type op @char parse_@ (k @@Token t @Type) @Node) @Node = return
equal k@ op && parse_@ k t ;;
right(k @@Token t @Type a @Node op @char parse_@ (k @@Token t @Type a @Node) @Node) @Node = return
equal k@ op && parse_@ k t a ;;

array_access(k @@Token t @Type a @Node) @Node = return
   advance k is j
   infix k ty_i32 is b
   expect k "]"
;: new_deref j t new_add j ty_i32 a b
;;
member_access(k @@Token t @Type a @Node) @Node = return
   cast void advance k ;:
   new_member_access advance k t a;;

nonee      (k @@Token t @Type        ) @Node = return advance k is j                                                                                                                  new_none        j t                      ;;
falsee     (k @@Token t @Type        ) @Node = return advance k is j                                                                                                                  new_false       j t                      ;;
truee      (k @@Token t @Type        ) @Node = return advance k is j                                                                                                                  new_true        j t                      ;;
sizee      (k @@Token t @Type        ) @Node = return advance k is j type_suffix k is t2                                                                                              new_sizeof      j t t2                   ;;
aligne     (k @@Token t @Type        ) @Node = return advance k is j type_suffix k is t2                                                                                              new_alignof     j t t2                   ;;
deref      (k @@Token t @Type a @Node) @Node = return advance k is j                                                                                                                  new_deref       j t a                  ;;
addressof  (k @@Token t @Type        ) @Node = return advance k is j                                                          secondary k t       is a                                new_addressof   j t a                    ;;
theorem    (k @@Token t @Type        ) @Node = return advance k is j type_suffix k is t2                                       tertiary k t       is a                                new_the         j t a t2                 ;;
axiom      (k @@Token t @Type        ) @Node = return advance k is j type_suffix k is t2                                       tertiary k t       is a                                new_cast        j t a t2                 ;;
neg        (k @@Token t @Type        ) @Node = return advance k is j                                                           tertiary k t       is a                                new_neg         j t a                    ;;
lognot     (k @@Token t @Type        ) @Node = return advance k is j                                                           tertiary k t       is a                                new_lognot      j t a                    ;;
bitnot     (k @@Token t @Type        ) @Node = return advance k is j                                                           tertiary k t       is a                                new_bitnot      j t a                    ;;
then       (k @@Token t @Type a @Node) @Node = return advance k is j                                                                seq k ty_void is b                                new_then        j t a b                  ;;
neth       (k @@Token t @Type a @Node) @Node = return advance k is j                                                                seq k t       is b                                new_neth        j t a b                  ;;
conditional(k @@Token t @Type a @Node) @Node = return advance k is j                                                                seq k t       is b  expect k ":" ;: seq k t is c  new_conditional j t a b c                ;;
islet      (k @@Token t @Type a @Node) @Node = return advance k is j enter_scope ;: new_lvar get_ident advance k a.t is o           seq k t       is b                                new_let         j t a b o :; leave_scope ;;
repeat     (k @@Token t @Type a @Node) @Node = return advance k is j enter_scope ;: new_lvar get_ident advance k a.t is o           seq k t       is b                                new_repeat      j t a b o :; leave_scope ;;

secondary(k @@Token t @Type) @Node = return
   left    k t       "cast"    &axiom
|| left    k t       "the"     &theorem
|| left    k t       "&"       &addressof
|| left    k t       "sizeof"  &sizee
|| left    k t       "alignof" &aligne
|| left    k t       "none"    &nonee
|| left    k t       "false"   &falsee
|| left    k t       "true"    &truee
|| primary k t for a
(  right   k t     a "["       &array_access
|| right   k t     a "."       &member_access
|| right   k t     a "@"       &deref
 ) ;;

tertiary_left(k @@Token t @Type) @Node = return
(  left k t "-"     &neg
|| left k t "!"     &lognot
|| left k t "~"     &bitnot
 ) ;;

seq(k @@Token t @Type) @Node = return 
  tertiary k cast @Type 0 is a
(  right k t a ":;"  &then
|| right k t a ";:"  &neth
|| right k t a "is"  &islet
|| right k t a "for" &repeat
|| right k t a "?"   &conditional
|| a
 ) ;;


primary(k @@Token t @Type) @Node = return
  ( equal k@ "new" ?
      advance k is j
      type_suffix k is t2
      !scope.s ?
        new_anon_gvar t2 is o
        gvar_initializer k o ;:
        new_reference j t o :
      new_lvar "" t2 is o
      lvar_initializer k o is a
      !a ? new_reference k@ t o : new_neth j t a new_reference k@ t o :
    consume k k@ "(" ? quaternary k t :; expect k ")" :
    (k.kind == TK_IDENT) ?
      cast @VarScope search_scope k@ &scope_vars is sc
      (k@ = k.s) ;:
      (!!sc ?
        ( !!sc.var && sc.var.is_function &&
          ( &current_fn.refs is a
            (!!current_fn ? strarray_push a sc.var.name :
            ( sc.var.is_root = true ) ) ) as void) ;:
        !!sc.var     ? new_reference k@ t sc.var                     :
        !!sc.enum_ty ? new_lit k@ t sc.enum_ty cast i64 sc.enum_val 0.0l:
        (error_tok k@ "internal compiler error") ;: cast @Node 0   :
      (error_tok k@ "lookup failed") ;: cast @Node 0) :
    (k.kind == TK_STR) ?
      new_string_literal k.str t cast @Type k.t  is o
      new_cast k@ t new_the k@ cast @Type k.t new_reference k@ cast @Type k.t o o.t pointer_to (cast @Type k.t).base :;
      cast void advance k :
    (k.kind == TK_NUM) ?
      ( new_lit k@ t cast @Type k.t k.val k.fval :; cast void advance k ) :
    (error_tok k@ "expected an expression") ;: cast @Node 0);;

tertiary(k @@Token t @Type) @Node = return
   tertiary_left k cast @Type 0
|| secondary k cast @Type 0 for a
  (  a.t.kind == TY_FUNC
  && a.t.params is u
    (  a for b
      (  (!!u || a.t.is_variadic && ! equal k@ ")")
      && (b.s = tertiary k u)
      ;: (  !!u 
         && (!type_equal b.s.t u && format_types b.s.t u ;: (error_tok k@ "asymmetric argument from %s to %s" s1 s2) as void)
         ;: (u = u.s)
         as void)
      ;: b.s )
    as void )
  ;: (!!u && (error_tok k@ "not enough arguments") as void)
  ;: new_call k@ t a )
;;

mul        (k @@Token t @Type) @Node = return seq        k t             for a (  equal k@ "*"  && advance k is j new_mul    j t a seq        k a.t
                                                                               || equal k@ "/"  && advance k is j new_div    j t a seq        k a.t
                                                                               || equal k@ "%"  && advance k is j new_mod    j t a seq        k a.t) ;;
add        (k @@Token t @Type) @Node = return mul        k t             for a (  equal k@ "+"  && advance k is j new_add    j t a mul        k a.t
                                                                               || equal k@ "-"  && advance k is j new_sub    j t a mul        k a.t) ;;
shift      (k @@Token t @Type) @Node = return add        k t             for a (  equal k@ "<<" && advance k is j new_shl    j t a add        k a.t
                                                                               || equal k@ ">>" && advance k is j new_shr    j t a add        k a.t) ;;
relational (k @@Token t @Type) @Node = return shift      k cast @Type 0  for a (  equal k@ "<"  && advance k is j new_lt     j t a shift      k cast @Type 0
                                                                               || equal k@ ">"  && advance k is j new_gt     j t a shift      k cast @Type 0
                                                                               || equal k@ "<=" && advance k is j new_le     j t a shift      k cast @Type 0
                                                                               || equal k@ ">=" && advance k is j new_ge     j t a shift      k cast @Type 0
                                                                               || equal k@ "==" && advance k is j new_eq     j t a shift      k cast @Type 0
                                                                               || equal k@ "!=" && advance k is j new_neq    j t a shift      k cast @Type 0) ;;
bitand     (k @@Token t @Type) @Node = return relational k t             for a (  equal k@ "&"  && advance k is j new_bitand j t a relational k a.t) ;;
bitxor     (k @@Token t @Type) @Node = return bitand     k t             for a (  equal k@ "^"  && advance k is j new_bitxor j t a bitand     k a.t) ;;
bitor      (k @@Token t @Type) @Node = return bitxor     k t             for a (  equal k@ "|"  && advance k is j new_bitor  j t a bitxor     k a.t) ;;
logand     (k @@Token t @Type) @Node = return bitor      k cast @Type 0  for a (  equal k@ "&&" && advance k is j new_logand j t a bitor      k a.t) ;;
logor      (k @@Token t @Type) @Node = return logand     k t             for a (  equal k@ "||" && advance k is j new_logor  j t a logand     k a.t) ;;

infix(k @@Token t @Type) @Node = return
  logor k cast @Type 0 for a (  equal k@ "as"   && advance k is j type_suffix k is u new_cast j u a u :; (t = u)
                             || equal k@ "from" && advance k is j type_suffix k is u new_the  j u a u :; (t = u) ) ;;


quaternary(k @@Token t @Type) @Node = return
   infix k cast @Type 0 is a
                     k@ is j
   equal j "=" ? advance k is j new_assign j t a infix k a.t :
(  equal k@  "+=" && (advance k is j new_cassign j t new_add    j a.t a infix k a.t)
|| equal k@  "-=" && (advance k is j new_cassign j t new_sub    j a.t a infix k a.t)
|| equal k@  "*=" && (advance k is j new_cassign j t new_mul    j a.t a infix k a.t)
|| equal k@  "/=" && (advance k is j new_cassign j t new_div    j a.t a infix k a.t)
|| equal k@  "%=" && (advance k is j new_cassign j t new_mod    j a.t a infix k a.t)
|| equal k@  "&=" && (advance k is j new_cassign j t new_bitand j a.t a infix k a.t)
|| equal k@  "|=" && (advance k is j new_cassign j t new_bitor  j a.t a infix k a.t)
|| equal k@  "^=" && (advance k is j new_cassign j t new_bitxor j a.t a infix k a.t)
|| equal k@ "||=" && (advance k is j new_cassign j t new_logor  j a.t a infix k a.t)
|| equal k@ "&&=" && (advance k is j new_cassign j t new_logand j a.t a infix k a.t)
|| equal k@ "<<=" && (advance k is j new_cassign j t new_shl    j a.t a infix k a.t)
|| equal k@ ">>=" && (advance k is j new_cassign j t new_shr    j a.t a infix k a.t)
|| a
 ) ;;


































struct_members(k @@Token t @Type)  =
  let
    head = new Member{;
    cur = &head
    idx = 0;
  while ! consume k k@ "}" {
    let v = &new VarAttr {;;
    declspec k v;
    while ! consume k k@ ";" {
      let g = (calloc 1ul sizeof Member as @Member);
      (g.t = declarator k as @);
      (g.name = (cast @Type the @ g.t).name);
      (g.idx = (idx :; (idx += 1)));
      (g.alignment = v.alignment || (cast @Type g.t ).alignment);
      if consume k k@ ":" {
        (g.is_bitfield = true);
        (g.bit_width = const_expr k as i32);;
      (cur.s = g);
      (cur = cur.s);;;
  if (cur != &head && (cast @Type cur.t ).kind == TY_ARRAY && (cast @Type cur.t ).array_len < 0) {
    (cur.t = array_of (cast @Type cur.t ).base 0 as @);
    (t.is_flexible = true);;
  (t.members = head.s);;

struct_union_decl(k @@Token) @Type = return
  struct_type is t
  cast @Token 0 is tag
  (( k.kind == TK_IDENT &&
    ( (tag = k@    )  ;:
      ( k@ = k.s) ) as void) ;:
  (!!tag && ! equal k@ "{") ?
    cast @Type search_scope tag &scope_tags is t2
    ( t2 ||
      ( (t.size = -1) ;:
        push_tag_scope tag t ;:
        t) ) :
  expect k "{" ;:
  (current_type = t) ;:
  struct_members k t ;:
  (current_type = 0 as @Type) ;:
  !!tag ?
    cast @Type hashmap_get2 &scope.tags tag.loc tag.len is t2
    (!!t2 ? (t2@ = t@) ;: t2 :
    push_tag_scope tag t ;: t) :
  t);;
struct_decl(k @@Token) @Type =
  let t = struct_union_decl k;
  (t.kind = TY_STRUCT);
  if (t.size < 0) return t;
  let bits = 0;
  for (let g@ Member = t.members; g; g = g.s) {
    if (g.is_bitfield && g.bit_width == 0) (bits = align_to bits ((cast @Type g.t ).size * 8));
    else if g.is_bitfield {
      let sz = (cast @Type g.t ).size;
      if (bits / (sz * 8) != (bits + g.bit_width - 1) / (sz * 8)) {
        (bits = align_to bits (sz * 8));;
      (g.offset = align_to ((bits / 8) - sz + 1) sz);
      (g.bit_offset = bits % (sz * 8));
      (bits += g.bit_width);;
    else {
      if !t.is_packed (bits = align_to bits (g.alignment * 8));
      (g.offset = bits / 8);
      (bits += (cast @Type g.t ).size * 8);;
    if (!t.is_packed && t.alignment < g.alignment)
      (t.alignment = g.alignment);;
  (t.size = align_to bits (t.alignment * 8) / 8);
  return t;;
union_decl(k @@Token) @Type =
  let t = struct_union_decl k;
  (t.kind = TY_UNION);
  if (t.size < 0) return t;
  for (let g@ Member = t.members; g; g = g.s) {
    if (t.alignment < g.alignment) (t.alignment = g.alignment);
    if (t.size < (cast @Type g.t ).size) (t.size = (cast @Type g.t ).size);;
  (t.size = align_to t.size t.alignment);
  return t;;
get_struct_member(t @Type j @Token) @Member =
  for (let g@ Member = t.members; g; g = g.s) {
    if (((cast @Type g.t ).kind == TY_STRUCT || (cast @Type g.t ).kind == TY_UNION) && (!g.name || equal g.name "_")) {
      if cast bool get_struct_member cast @Type g.t j return g;;
    else if (g.name.len == j.len && ! strncmp cast @  g.name.loc j.loc cast unsigned i64 j.len ) return g;;
  return 0 as @Member;;
typedecl(j @Token) @Token = return
  j for j
  (  !equal j ";" &&
    (  declarator &j is t
       (!t.name && (error_tok t.name_pos "type name may not be omitted in type alias declaration") as void)
    ;: ((push_scope get_ident t.name).type_def = t)
    ;: j ) );;
create_param_lvars(param@ Type) = return
  !!param ?
    create_param_lvars param.s ;:
    !param.name ?
      (error_tok param.name_pos "parameter name omitted") :
    (new_lvar get_ident param.name param as) :
  none;;
find_func(name @char) @Obj = return
  cast @VarScope hashmap_get &(scope for s s.s).vars name is s
  (!!s && s.var.is_function && s.var);;
mark_live(o@ Obj) = return
    o.is_function
  && !o.is_live
  && (o.is_live = true)
  :;( 0 for i
      (  i != o.refs.len && (i + 1)
      :; find_func o.refs.data[i] is o2
        ((o2 && mark_live o2) from bool as void) )
    as void )
  as void;;
function(k @@Token attr @VarAttr) = return
  declarator k is t
  ((!t.name || equal t.name "_") && (error_tok t.name_pos "function name omitted") as void) ;:
  get_ident t.name is name_str
  find_func name_str is o
  ( !!o ?
      (!o.is_function                  && (error_tok k@ "redeclared as a different kind of symbol") as void) ;:
      (o.is_definition && equal k@ "=" && (error_tok k@ "redefinition of %s" name_str) as void) ;:
      (o.is_export != attr.is_export   && (error_tok k@ "mismatched visibility") as void) ;:
      (o.is_definition = o.is_definition || equal k@ "=") :
    (o = new_gvar name_str t) ;:
    (o.is_function = true) ;:
    (o.is_definition = equal k@ "=") ;:
    (o.is_export = attr.is_export)  ;:
    (o.is_inline = attr.is_inline) ) ;:
  ( o.is_root = o.is_export || !o.is_inline ) ;:
  (equal k@ ";" ? none :
  (current_fn = o) ;:
  (locals = 0 as @Obj) ;:
  enter_scope ;:
  create_param_lvars t.params ;:
  t.return_ty is rty
  (((rty.kind == TY_STRUCT || rty.kind == TY_UNION) && rty.size > 16) && new_lvar "" pointer_to rty as) ;:
  (o.params = locals) ;:
  (t.is_variadic && (o.va_area = new_lvar "__va_area__" array_of ty_i8 136) as void) ;:
  (o.alloca_bottom = new_lvar "__alloca_size__" pointer_to ty_i8) ;:
  expect k "=" ;:
  (o.body = compound_stmt k as @) ;:
  (o.locals = locals) ;:
  leave_scope ;: none);;
global_variable(j@ Token attr@ VarAttr)@ Token =
  let k = &j;
  let first = true;
  while ! consume k j ";" {
    (first = false);
    let t = declarator k;
    if !(!t.name || equal t.name "_") {
      let var = new_gvar get_ident t.name t;
      (var.is_definition = !attr.is_extern);
      (var.is_export = attr.is_export);
      (var.is_inline = attr.is_inline);
      (var.is_tls = attr.is_tls);
      if attr.alignment (var.alignment = attr.alignment);
      if equal j "=" {
        (j = j.s);
        gvar_initializer k var;;
      else if (!attr.is_extern && !attr.is_tls) (var.is_tentative = true);;;
  return j;;
is_function(j @Token) bool = return
  ! equal j ";" &&
  (declarator &j).kind == TY_FUNC;;
scan_globals(void) =
  let
    head = new Obj{;
    cur = &head;
  for (let o@ Obj = globals; o; o = o.s) {
    if !o.is_tentative {
      (cur.s = o);
      (cur = cur.s);;
    else {
      let o2 = globals;
      for (; o2; o2 = o2.s) if (o != o2 && o2.is_definition && ! strcmp cast @ o.name o2.name) break;
      if !o2 { (cur.s = o); (cur = cur.s);;;;
  (cur.s = 0 as @Obj);
  (globals = head.s);;
export parse(j @Token) @Obj = return
  (locals         = cast @Obj   0) ;:
  (globals        = cast @Obj   0) ;:
  (scope          = &new Scope {;) ;:
  (current_type   = cast @Type  0) ;:
  (current_fn     = cast @Obj   0) ;:
  (gotos          = cast @Node  0) ;:
  (labels         = cast @Node  0) ;:
  (brk_label      = cast @char  0) ;:
  (cont_label     = cast @char  0) ;:
  (current_switch = cast @Node  0) ;:
  (j for j (j.kind != TK_EOF && 
    new VarAttr {; is v
    declspec &j &v ;:
    v.is_type     ? typedecl j          :
    is_function j ? function &j &v ;: j :
    global_variable j &v) as void) ;:
  ( globals for v
    ( !!v && v.s :; (v.is_root && mark_live v as void) ) as void) ;:
  scan_globals ;:
  globals;;