#include "chub.hb"

type
  TypeID enum
    I8 I16 I32 I64
    U8 U16 U32 U64
           F32 F64 F80;;

output_file@FILE
depth i32
argreg8 []@char = {"%dil" "%sil" "%dl"  "%cl"  "%r8b" "%r9b";
argreg16[]@char = {"%di"  "%si"  "%dx"  "%cx"  "%r8w" "%r9w";
argreg32[]@char = {"%edi" "%esi" "%edx" "%ecx" "%r8d" "%r9d";
argreg64[]@char = {"%rdi" "%rsi" "%rdx" "%rcx" "%r8"  "%r9" ;
current_fn@Obj;

gen_expr(e @Node);
gen_stmt(e @Node);

println(fmt @char ...) =
  let ap = new va_list {;;
  (ap = (cast @__va_elem __va_area__)@);
  vfprintf output_file fmt &ap;
  (fprintf output_file "\n");;

i counti i32 = 1;
count(void     ) i32 = return counti :; (counti += 1);;

push (void     )     = return (println "  push %%rax") ;: (depth += 1);;
pop  (arg @char)     = return (println "  pop %s" arg) ;: (depth -= 1);;

pushf(void     )     = return (println "  sub $8, %%rsp"             ) ;: (println "  movsd %%xmm0, (%%rsp)") ;: (depth += 1);;
popf (reg   i32)     = return (println "  movsd (%%rsp), %%xmm%d" reg) ;: (println "  add $8, %%rsp"        ) ;: (depth -= 1);;

export align_to(n i32 alignment i32) i32 = return (n + alignment - 1) / alignment * alignment;;

reg_dx(sz i32) @char = return (sz == 1) ? "%dl"  :
                              (sz == 2) ? "%dx"  :
                              (sz == 4) ? "%edx" :
                              (sz == 8) ? "%rdx" : cast @char 0 ;;
reg_ax(sz i32) @char = return (sz == 1) ? "%al"  :
                              (sz == 2) ? "%ax"  :
                              (sz == 4) ? "%eax" :
                              (sz == 8) ? "%rax" : cast @char 0 ;;

gen_addr(e @Node) = return
  ( e.kind    == ND_VAR     ) ?
  (  e.var.is_local
  && (println "  lea %d(%%rbp), %%rax" e.var.offset)
  || (println "  mov %s@GOTPCREL(%%rip), %%rax" e.var.name) as void) :
  ( e.kind    == ND_COMMA   ) ? gen_expr e.a   ;: gen_expr e.a.s  :
  ( e.kind    == ND_THEN    ) ? gen_expr e.a   ;: push ;: gen_expr e.a.s  ;: pop "%rax" :
  ( e.kind    == ND_MEMBER  ) ? gen_addr e.a   ;: (println "  add $%d, %%rax" e.member.offset ) :
  ( e.kind    == ND_THE    ||
    e.kind    == ND_DEREF   ) ? gen_expr e.a  :
  ( e.kind    == ND_FUNCALL||
    e.kind    == ND_COND   ||
    e.kind    == ND_UNTIL  ||
    e.kind    == ND_REPEAT  ) ? gen_expr e      :
  ( e.t.kind == TY_STRUCT ||
    e.t.kind == TY_UNION   ) ? gen_expr e      :
  ( error_tok e.j "not an lvalue" );;
load(t @Type) = return cast void(
  t.kind == TY_ARRAY  ||
  t.kind == TY_STRUCT ||
  t.kind == TY_UNION  ||
  t.kind == TY_FUNC   ||
  ( (t.kind == TY_FLOAT32  ) ? (println "  movss (%%rax), %%xmm0"      ) :
    (t.kind == TY_FLOAT64 ) ? (println "  movsd (%%rax), %%xmm0"      ) :
    (t.kind == TY_FLOAT80) ? (println "  fldt (%%rax)"               ) :
    ((t.kind == TY_UNSIGNED) ? "movz" : "movs") is insn
    ((t.kind == TY_UNSIGNED) ? t.base : t ) is u
    ( (u.size == 1         ) ? (println "  %sbl (%%rax), %%eax"   insn ) :
      (u.size == 2         ) ? (println "  %swl (%%rax), %%eax"   insn ) :
      (u.size == 4         ) ? (println "  movsxd (%%rax), %%rax"      ) :
                               (println "  mov (%%rax), %%rax"         ) ) ));;
store_rax_struct_union(t @Type) =
  for (let i i32 = 0; i < t.size; i += 1) {
    (println "  mov %d(%%rax), %%r8b" i);
    (println "  mov %%r8b, %d(%%rdi)" i);;;
store(t@Type) =
  pop "%rdi"      ;:
  (t.kind == TY_STRUCT ||
   t.kind == TY_UNION   ) ? store_rax_struct_union t             :
  (t.kind == TY_FLOAT32   ) ? (println "  movss %%xmm0, (%%rdi)"  ) :
  (t.kind == TY_FLOAT64  ) ? (println "  movsd %%xmm0, (%%rdi)"  ) :
  (t.kind == TY_FLOAT80 ) ? (println "  fstpt (%%rdi)"          ) : 
  (t.size == 1          ) ? (println "  mov %%al, (%%rdi)"      ) :
  (t.size == 2          ) ? (println "  mov %%ax, (%%rdi)"      ) :
  (t.size == 4          ) ? (println "  mov %%eax, (%%rdi)"     ) :
                             (println "  mov %%rax, (%%rdi)"     ) ;;
cmp_zero(t@Type) =
  (t.kind == TY_FLOAT32   ) ? (println "  xorps %%xmm1, %%xmm1"   )  ;:
                             (println "  ucomiss %%xmm1, %%xmm0" ) :
  (t.kind == TY_FLOAT64  ) ? (println "  xorpd %%xmm1, %%xmm1"   )  ;:
                             (println "  ucomisd %%xmm1, %%xmm0" ) :
  (t.kind == TY_FLOAT80 ) ? (println "  fldz"                   )  ;:
                             (println "  fucomip"                )  ;:
                             (println "  fstp %%st(0)"           ) :
  (t.size <= 4          ) ? (println "  cmp $0, %%eax"          ) :
                             (println "  cmp $0, %%rax"          ) ;;
getTypeId(t @Type)TypeID = return
  (t.kind == TY_FLOAT32  )  ? F32 :
  (t.kind == TY_FLOAT64 )  ? F64 :
  (t.kind == TY_FLOAT80)  ? F80 :
  (t.kind == TY_UNSIGNED) ?
    (t.base.kind == TY_INT08   ) ? U8  :
    (t.base.kind == TY_INT16  ) ? U16 :
    (t.base.kind == TY_INT32    ) ? U32 :
                                  U64 :
  (t.kind == TY_INT08   ) ? I8  :
  (t.kind == TY_INT16  ) ? I16 :
  (t.kind == TY_INT32    ) ? I32 :
                           I64 ;;

i32i8 []char = "movsbl %al, %eax"                                   ;
i32u8 []char = "movzbl %al, %eax"                                   ;
i32i16[]char = "movswl %ax, %eax"                                   ;
i32u16[]char = "movzwl %ax, %eax"                                   ;
i32f32[]char = "cvtsi2ssl %eax, %xmm0"                              ;
i32i64[]char = "movsxd %eax, %rax"                                  ;
i32f64[]char = "cvtsi2sdl %eax, %xmm0"                              ;
i32f80[]char = "mov %eax, -4(%rsp); fildl -4(%rsp)"                 ;
              
u32f32[]char = "mov %eax, %eax; cvtsi2ssq %rax, %xmm0"              ;
u32i64[]char = "mov %eax, %eax"                                     ;
u32f64[]char = "mov %eax, %eax; cvtsi2sdq %rax, %xmm0"              ;
u32f80[]char = "mov %eax, %eax; mov %rax, -8(%rsp); fildll -8(%rsp)";

i64f32[]char = "cvtsi2ssq %rax, %xmm0";
i64f64[]char = "cvtsi2sdq %rax, %xmm0";
i64f80[]char = "movq %rax, -8(%rsp); fildll -8(%rsp)";

u64f32[]char = "cvtsi2ssq %rax, %xmm0";
u64f64[]char = "test %rax,%rax; js 1f; pxor %xmm0,%xmm0; cvtsi2sd %rax,%xmm0; jmp 2f; 1: mov %rax,%rdi; and $1,%eax; pxor %xmm0,%xmm0; shr %rdi; or %rax,%rdi; cvtsi2sd %rdi,%xmm0; addsd %xmm0,%xmm0; 2:";
u64f80[]char = "mov %rax, -8(%rsp); fildq -8(%rsp); test %rax, %rax; jns 1f; mov $1602224128, %eax; mov %eax, -4(%rsp); fadds -4(%rsp); 1:";

f32i8 []char = "cvttss2sil %xmm0, %eax; movsbl %al, %eax";
f32u8 []char = "cvttss2sil %xmm0, %eax; movzbl %al, %eax";
f32i16[]char = "cvttss2sil %xmm0, %eax; movswl %ax, %eax";
f32u16[]char = "cvttss2sil %xmm0, %eax; movzwl %ax, %eax";
f32i32[]char = "cvttss2sil %xmm0, %eax"                  ;
f32u32[]char = "cvttss2siq %xmm0, %rax"                  ;
f32i64[]char = "cvttss2siq %xmm0, %rax"                  ;
f32u64[]char = "cvttss2siq %xmm0, %rax"                  ;
f32f64[]char = "cvtss2sd %xmm0, %xmm0"                   ;
f32f80[]char = "movss %xmm0, -4(%rsp); flds -4(%rsp)"    ;

f64i8 []char = "cvttsd2sil %xmm0, %eax; movsbl %al, %eax";
f64u8 []char = "cvttsd2sil %xmm0, %eax; movzbl %al, %eax";
f64i16[]char = "cvttsd2sil %xmm0, %eax; movswl %ax, %eax";
f64u16[]char = "cvttsd2sil %xmm0, %eax; movzwl %ax, %eax";
f64i32[]char = "cvttsd2sil %xmm0, %eax"                  ;
f64u32[]char = "cvttsd2siq %xmm0, %rax"                  ;
f64i64[]char = "cvttsd2siq %xmm0, %rax"                  ;
f64u64[]char = "cvttsd2siq %xmm0, %rax"                  ;
f64f32[]char = "cvtsd2ss %xmm0, %xmm0"                   ;
f64f80[]char = "movsd %xmm0, -8(%rsp); fldl -8(%rsp)"    ;

f80i8 []char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movsbl -24(%rsp), %eax"
f80u8 []char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movzbl -24(%rsp), %eax"
f80i16[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movzbl -24(%rsp), %eax"
f80u16[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); movswl -24(%rsp), %eax"
f80i32[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %eax"
f80u32[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %eax"
f80i64[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpq -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %rax"
f80u64[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpq -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %rax"
f80f32[]char = "fstps -8(%rsp); movss -8(%rsp), %xmm0"
f80f64[]char = "fstpl -8(%rsp); movsd -8(%rsp), %xmm0";

cast_table[][11]@char = {
  // i8   i16     i32     i64     u8     u16     u32     u64     f32     f64     f80
  { 0     0      0      i32i64 i32u8 i32u16 0      i32i64 i32f32 i32f64 i32f80 ; // i8
  { i32i8 0      0      i32i64 i32u8 i32u16 0      i32i64 i32f32 i32f64 i32f80 ; // i16
  { i32i8 i32i16 0      i32i64 i32u8 i32u16 0      i32i64 i32f32 i32f64 i32f80 ; // i32
  { i32i8 i32i16 0      0      i32u8 i32u16 0      0      i64f32 i64f64 i64f80 ; // i64
  { i32i8 0      0      i32i64 0     0      0      i32i64 i32f32 i32f64 i32f80 ; // u8
  { i32i8 i32i16 0      i32i64 i32u8 0      0      i32i64 i32f32 i32f64 i32f80 ; // u16
  { i32i8 i32i16 0      u32i64 i32u8 i32u16 0      u32i64 u32f32 u32f64 u32f80 ; // u32
  { i32i8 i32i16 0      0      i32u8 i32u16 0      0      u64f32 u64f64 u64f80 ; // u64
  { f32i8 f32i16 f32i32 f32i64 f32u8 f32u16 f32u32 f32u64 0      f32f64 f32f80 ; // f32
  { f64i8 f64i16 f64i32 f64i64 f64u8 f64u16 f64u32 f64u64 f64f32 0      f64f80 ; // f64
  { f80i8 f80i16 f80i32 f80i64 f80u8 f80u16 f80u32 f80u64 f80f32 f80f64 0      ; // f80
;;
gen_cast(a@Type b@Type) = return
  (b.kind == TY_VOID) ? none :
  (b.kind == TY_BOOL) ?
    cmp_zero a                        ;:
    (println "  setne %%al"        )  ;:
    (println "  movzx %%al, %%eax" ) :
  getTypeId a is t1
  getTypeId b is t2
  (!!cast_table[t1][t2] && (println "  %s" cast_table[t1][t2]) as void) ;:
  none;;
has_flonum(t@Type lo i32 hi i32 offset i32) bool =
  if (t.kind == TY_STRUCT || t.kind == TY_UNION) {
    for (let mem@Member = t.members; mem; mem = mem.s) if !has_flonum cast @Type mem.t lo hi (offset + mem.offset) return false;
    return true;;
  if (t.kind == TY_ARRAY) {
    for (let i i32 = 0; i < t.array_len; i += 1) if !has_flonum t.base lo hi (offset + t.base.size * i) return false;
    return true;;
  return offset < lo || hi <= offset || t.kind == TY_FLOAT32 || t.kind == TY_FLOAT64;;
has_flonum1(t@Type)bool = return has_flonum t 0 8 0;;
has_flonum2(t@Type)bool = return has_flonum t 8 16 0;;
push_struct(t@Type) =
  let sz = align_to t.size 8;
  (println "  sub $%d, %%rsp" sz);
  (depth += sz / 8);
  for (let i i32 = 0; i < t.size; i += 1) {
    (println "  mov %d(%%rax), %%r10b" i);
    (println "  mov %%r10b, %d(%%rsp)" i);;;
push_args2(args@Node first_pass bool) =
  if !args return;
  push_args2 args.s first_pass ;
  if ((first_pass && !args.pass_by_stack) || (!first_pass && args.pass_by_stack)) return;
  gen_expr args ;
  switch  args.t.kind {
  case TY_STRUCT:
  case TY_UNION:
    push_struct args.t;
    break;
  case TY_FLOAT32:
  case TY_FLOAT64:
    pushf ;
    break;
  case TY_FLOAT80:
    (println "  sub $16, %%rsp");
    (println "  fstpt (%%rsp)");
    (depth += 2);
    break;
  default:
    push ;;;

// Load function call arguments. Arguments are already evaluated and
// stored to the stack as local variables. What we need to do in this
// function is to load them to registers or push them to the stack as
// specified by the x86-64 psABI. Here is what the spec says:
//
// - Up to 6 arguments of integral type are passed using RDI, RSI,
//   RDX, RCX, R8 and R9.
//
// - Up to 8 arguments of floating-point type are passed using XMM0 to
//   XMM7.
//
// - If all registers of an appropriate type are already used, push an
//   argument to the stack in the right-to-left order.
//
// - Each argument passed on the stack takes 8 bytes, and the end of
//   the argument area must be aligned to a 16 byte boundary.
//
// - If a function is variadic, set the number of floating-point type
//   arguments to RAX.
push_args(e@Node)i32 =
  let stack = 0 gp = 0 fp = 0;

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if (!!e.ret_buffer && e.t.size > 16) (gp += 1);

  // Load as many arguments to the registers as possible.
  for (let arg@Node = e.a.s; arg; arg = arg.s) {
    let t = arg.t;

    switch  t.kind {
    case TY_STRUCT:
    case TY_UNION:
      if (t.size > 16) {
        (arg.pass_by_stack = true);
        (stack += align_to t.size 8 / 8);
      ; else {
        let fp1 = cast i32 has_flonum1 t;
        let fp2 = cast i32 has_flonum2 t;

        if (fp + fp1 + fp2 < 8 && gp + cast i32 !fp1 + cast i32 !fp2 < 6) {
          (fp = fp + fp1 + fp2);
          (gp = gp + cast i32 !fp1 + cast i32 !fp2);
        ; else {
          (arg.pass_by_stack = true);
          (stack += align_to t.size 8 / 8);
        ;
      ;
      break;
    case TY_FLOAT32:
    case TY_FLOAT64:
      if ((fp >= 8) :; (fp += 1)) {
        (arg.pass_by_stack = true);
        (stack += 1);
      ;
      break;
    case TY_FLOAT80:
      (arg.pass_by_stack = true);
      (stack += 2);
      break;
    default:
      if ((gp >= 6) :; (gp += 1)) {
        (arg.pass_by_stack = true);
        (stack += 1);
      ;
    ;
  ;

  if ((depth + stack) % 2 == 1) {
    (println "  sub $8, %%rsp");
    (depth += 1);
    (stack += 1);
  ;

  push_args2 e.a.s true ;
  push_args2 e.a.s false ;

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if (!!e.ret_buffer && e.t.size > 16) {
    (println "  lea %d(%%rbp), %%rax" e.ret_buffer.offset);
    push ;
  ;

  return stack;
;

copy_ret_buffer(var@Obj) =
  let t = var.t gp = 0 fp = 0;

  if has_flonum1 t {
    if (t.size == 4) (println "  movss %%xmm0, %d(%%rbp)" var.offset);
    else (println "  movsd %%xmm0, %d(%%rbp)" var.offset);
    (fp += 1);
  ; else {
    for (let i i32 = 0; i < minl 8l cast i64 t.size; i += 1) {
      (println "  mov %%al, %d(%%rbp)" (var.offset + i));
      (println "  shr $8, %%rax");
    ;
    (gp += 1);
  ;

  if (t.size > 8) {
    if has_flonum2 t {
      if (t.size == 12) (println "  movss %%xmm%d, %d(%%rbp)" fp (var.offset + 8));
      else (println "  movsd %%xmm%d, %d(%%rbp)" fp (var.offset + 8));
    ; else {
      let reg1 = (!gp ? "%al" : "%dl");
      let reg2 = (!gp ? "%rax" : "%rdx");
      for (let i i32 = 8; i < minl 16l cast i64 t.size; i += 1) {
        (println "  mov %s, %d(%%rbp)" reg1 (var.offset + i));
        (println "  shr $8, %s" reg2);
      ;
    ;
  ;
;

copy_struct_reg(void) =
  let t = current_fn.t.return_ty gp = 0 fp = 0;

  (println "  mov %%rax, %%rdi");

  if has_flonum t 0 8 0 {
    if (t.size == 4) (println "  movss (%%rdi), %%xmm0");
    else (println "  movsd (%%rdi), %%xmm0");
    (fp += 1);
  ; else {
    (println "  mov $0, %%rax");
    for (let i i32 = (minl 8l cast i64 t.size - 1l as i32); i >= 0; i -= 1) {
      (println "  shl $8, %%rax");
      (println "  mov %d(%%rdi), %%al" i);
    ;
    (gp += 1);
  ;

  if (t.size > 8) {
    if has_flonum t 8 16 0 {
      if (t.size == 4) (println "  movss 8(%%rdi), %%xmm%d" fp);
      else (println "  movsd 8(%%rdi), %%xmm%d" fp);
    ; else {
      let reg1 = (!gp ? "%al" : "%dl");
      let reg2 = (!gp ? "%rax" : "%rdx");
      (println "  mov $0, %s" reg2);
      for (let i i32 = (minl 16l cast i64 t.size - 1l as i32); i >= 8; i -= 1) {
        (println "  shl $8, %s" reg2);
        (println "  mov %d(%%rdi), %s" i reg1);
      ;
    ;
  ;
;

copy_struct_mem(void) =
  let t = current_fn.t.return_ty var = current_fn.params;

  (println "  mov %d(%%rbp), %%rdi" var.offset);

  for (let i i32 = 0; i < t.size; i += 1) {
    (println "  mov %d(%%rax), %%dl" i);
    (println "  mov %%dl, %d(%%rdi)" i);
  ;
;

gen_expr(e @Node) =
  (println "  .loc %d %d" e.j.file.file_no e.j.line_no);

  switch  e.kind {
  case ND_NULL_EXPR:
    return;
  case ND_THE:
    return gen_expr e.a ;
  case ND_NUM: {
    switch  e.t.kind {
    case TY_FLOAT32: {
      let u union { f32 f32; u32 unsigned i32; } = { cast f32 e.fval ;
      (println "  mov $%u, %%eax  # f32 %Lf" u.u32 e.fval);
      (println "  movq %%rax, %%xmm0");
      return;
    ;
    case TY_FLOAT64: {
      let u union { f64 f64 u64 unsigned i64; } = { cast f64 e.fval ;
      (println "  mov $%lu, %%rax  # f64 %Lf" u.u64 e.fval);
      (println "  movq %%rax, %%xmm0");
      return;
    ;
    case TY_FLOAT80: {
      let u union { f80 f80; u64[2]unsigned i64; };
      memset cast @ &u 0 sizeof typeof u;
      (u.f80 = e.fval);
      (println "  mov $%lu, %%rax  # f80 %Lf" u.u64[0] e.fval);
      (println "  mov %%rax, -16(%%rsp)");
      (println "  mov $%lu, %%rax" u.u64[1]);
      (println "  mov %%rax, -8(%%rsp)");
      (println "  fldt -16(%%rsp)");
      return;
    ;
    ;

    (println "  mov $%ld, %%rax" e.val);
    return;
  ;
  case ND_NEG:
    gen_expr e.a ;
    switch  e.t.kind {
    case TY_FLOAT32:
      (println "  mov $1, %%rax");
      (println "  shl $31, %%rax");
      (println "  movq %%rax, %%xmm1");
      (println "  xorps %%xmm1, %%xmm0");
      return;
    case TY_FLOAT64:
      (println "  mov $1, %%rax");
      (println "  shl $63, %%rax");
      (println "  movq %%rax, %%xmm1");
      (println "  xorpd %%xmm1, %%xmm0");
      return;
    case TY_FLOAT80:
      (println "  fchs");
      return;
    ;
    (println "  neg %%rax");
    return;
  case ND_VAR: return
    gen_addr e  ;:
    load e.t;
  case ND_MEMBER: return
    gen_addr e  ;:
    load e.t ;:
    e.member is mem
    ( mem.is_bitfield ?
        (println "  shl $%d, %%rax" (64 - mem.bit_width - mem.bit_offset)) ;:
        ((cast @Type mem.t).kind == TY_UNSIGNED) ? (println "  shr $%d, %%rax" (64 - mem.bit_width) ) :
        (println "  sar $%d, %%rax" (64 - mem.bit_width) ) :
      none );
  case ND_DEREF: return
    gen_expr e.a  ;:
    load e.t;
  case ND_ADDR: return
    gen_addr e.a ;
  case ND_CASSIGN: return
    gen_addr e.a.a  ;:
    push ;:
    gen_expr e.a  ;:
    (e.a.a.kind == ND_MEMBER && e.a.a.member.is_bitfield) ?
      (println "  mov %%rax, %%r8") ;:
      e.a.a.member is mem
      (println "  mov %%rax, %%rdi") ;:
      (println "  and $%ld, %%rdi" ((1 << mem.bit_width) - 1)) ;:
      (println "  shl $%d, %%rdi" mem.bit_offset) ;:
      (println "  mov (%%rsp), %%rax") ;:
      load cast @Type mem.t ;:
      (println "  mov $%ld, %%r9" ~(((1 << mem.bit_width) - 1) << mem.bit_offset)) ;:
      (println "  and %%r9, %%rax") ;:
      (println "  or %%rdi, %%rax") ;:
      store e.a.a.t ;:
      (println "  mov %%r8, %%rax" ):
    store e.a.a.t;
  case ND_ASSIGN: return
    gen_addr e.a  ;:
    push ;:
    gen_expr e.a.s  ;:
    (e.a.kind == ND_MEMBER && e.a.member.is_bitfield) ?
      (println "  mov %%rax, %%r8") ;:
      e.a.member is mem
      (println "  mov %%rax, %%rdi") ;:
      (println "  and $%ld, %%rdi" ((1 << mem.bit_width) - 1)) ;:
      (println "  shl $%d, %%rdi" mem.bit_offset) ;:
      (println "  mov (%%rsp), %%rax") ;:
      load cast @Type mem.t ;:
      (println "  mov $%ld, %%r9" ~(((1 << mem.bit_width) - 1) << mem.bit_offset)) ;:
      (println "  and %%r9, %%rax") ;:
      (println "  or %%rdi, %%rax") ;:
      store e.a.t ;:
      (println "  mov %%r8, %%rax" ):
    store e.a.t;
  case ND_THE:
    return gen_expr e.a ;
  case ND_UNTIL: return
    count is c
    (println ".L.until.%d:" c) ;:
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  je .L.until.%d" c);
  case ND_REPEAT: return
    count is c
    (println "  lea %d(%%rbp), %%rax" e.var.offset ) ;:
    push ;:
    gen_expr e.a  ;:
    (println ".L.repeat.%d:" c) ;:
    store e.a.t ;:
    (println "  lea %d(%%rbp), %%rax" e.var.offset ) ;:
    push ;:
    gen_expr e.a.s  ;:
    cmp_zero e.a.s.t ;:
    (println "  jne .L.repeat.%d" c) ;:
    pop "%rax" ;:
    (println "  mov 0(%%rax), %%rax");
  case ND_COMMA: return
    gen_expr e.a  ;:
    gen_expr e.a.s ;
  case ND_THEN: return
    gen_expr e.a  ;:
    push ;:
    gen_expr e.a.s  ;:
    pop "%rax";
  case ND_CAST: return
    gen_expr e.a  ;:
    gen_cast e.a.t e.t;
  case ND_MEMZERO: return
    (println "  mov $%d, %%rcx" e.var.t.size) ;:
    (println "  lea %d(%%rbp), %%rdi" e.var.offset) ;:
    (println "  mov $0, %%al") ;:
    (println "  rep stosb");
  case ND_COND: return
    count is c
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  je .L.else.%d" c) ;:
    gen_expr e.a.s  ;:
    (println "  jmp .L.end.%d" c) ;:
    (println ".L.else.%d:" c) ;:
    gen_expr e.a.s.s  ;:
    (println ".L.end.%d:" c);
  case ND_NOT: return
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  sete %%al") ;:
    (println "  movzx %%al, %%rax");
  case ND_BITNOT: return
    gen_expr e.a  ;:
    (println "  not %%rax");
  case ND_LOGAND: return
    count is c
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  je .L.end.%d" c) ;:
    gen_expr e.a.s  ;:
    (println ".L.end.%d:" c);
  case ND_LOGOR: return
    count is c
    gen_expr e.a     ;:
    cmp_zero e.a.t          ;:
    (println "  jne .L.end.%ld" c) ;:
    gen_expr e.a.s  ;:
    (println ".L.end.%ld:" c);
  case ND_FUNCALL: {
    let stack_args = push_args e ;
    gen_expr e.a ;

    let gp = 0 fp = 0;

    // If the return type is a large struct/union, the caller passes
    // a pointer to a buffer as if it were the first argument.
    if (!!e.ret_buffer && e.t.size > 16) pop argreg64[gp :; (gp += 1)];

    for (let arg @Node = e.a.s; arg; arg = arg.s) {
      let t = arg.t;
      switch  t.kind {
      case TY_STRUCT:
      case TY_UNION:
        if !(t.size > 16) {
          let fp1 = cast i32 has_flonum1 t;
          let fp2 = cast i32 has_flonum2 t;
          if (fp + fp1 + fp2 < 8 && gp + cast i32 !fp1 + cast i32 !fp2 < 6) {
            if fp1 popf (fp :; (fp += 1));
            else pop argreg64[((gp :; (gp+=1)))];
            if (t.size > 8) {
              if fp2 popf ((fp :; (fp+=1)));
              else pop argreg64[((gp :; (gp+=1)))];;;;
        break;
      case TY_FLOAT32:
      case TY_FLOAT64: if (fp < 8) popf ((fp :; (fp+=1)));
      case TY_FLOAT80: break;
      default: if (gp < 6) pop argreg64[((gp :; (gp+=1)))];
      ;
    ;

    (println "  mov %%rax, %%r10");
    (println "  mov $%d, %%rax" fp);
    (println "  call *%%r10");
    (println "  add $%d, %%rsp" (stack_args * 8));

    (depth -= stack_args);

    // It looks like the most significant 48 or 56 bits in RAX may
    // contain garbage if a function return type is i16 or bool/char,
    // respectively. We clear the upper bits here.
    switch  e.t.kind {
    case TY_BOOL:
      (println "  movzx %%al, %%eax");
      return;
    case TY_INT08:
      if (e.t.kind == TY_UNSIGNED)
        (println "  movzbl %%al, %%eax");
      else
        (println "  movsbl %%al, %%eax");
      return;
    case TY_INT16:
      if (e.t.kind == TY_UNSIGNED)
        (println "  movzwl %%ax, %%eax");
      else
        (println "  movswl %%ax, %%eax");
      return;
    ;

    // If the return type is a small struct, a value is returned
    // using up to two registers.
    if (!!e.ret_buffer && e.t.size <= 16) {
      copy_ret_buffer e.ret_buffer;
      (println "  lea %d(%%rbp), %%rax" e.ret_buffer.offset);
    ;

    return;
  ;
  ;

  switch  e.a.t.kind {
  case TY_FLOAT32:
  case TY_FLOAT64: {
    gen_expr e.a.s ;
    pushf ;
    gen_expr e.a ;
    popf 1;

    let sz = ((e.a.t.kind == TY_FLOAT32) ? "ss" : "sd");

    switch  e.kind {
    case ND_ADD:
      (println "  add%s %%xmm1, %%xmm0" sz);
      return;
    case ND_SUB:
      (println "  sub%s %%xmm1, %%xmm0" sz);
      return;
    case ND_MUL:
      (println "  mul%s %%xmm1, %%xmm0" sz);
      return;
    case ND_DIV:
      (println "  div%s %%xmm1, %%xmm0" sz);
      return;
    case ND_EQ:
    case ND_NE:
    case ND_LT:
    case ND_LE:
    case ND_GT:
    case ND_GE:
      (println "  ucomi%s %%xmm0, %%xmm1" sz);

      if (e.kind == ND_EQ) {
        (println "  sete %%al");
        (println "  setnp %%dl");
        (println "  and %%dl, %%al");
      ; else if (e.kind == ND_NE) {
        (println "  setne %%al");
        (println "  setp %%dl");
        (println "  or %%dl, %%al");
      ;
      else if (e.kind == ND_LT) (println "  seta %%al");
      else if (e.kind == ND_LE) (println "  setae %%al");
      else if (e.kind == ND_GT) (println "  setb %%al");
      else if (e.kind == ND_GE) (println "  setbe %%al");


      (println "  and $1, %%al");
      (println "  movzb %%al, %%rax");
      return;
    ;

    (error_tok e.j "invalid expression");
  ;
  case TY_FLOAT80: {
    gen_expr e.a ;
    gen_expr e.a.s ;

    switch  e.kind {
    case ND_ADD:
      (println "  faddp");
      return;
    case ND_SUB:
      (println "  fsubrp");
      return;
    case ND_MUL:
      (println "  fmulp");
      return;
    case ND_DIV:
      (println "  fdivrp");
      return;
    case ND_EQ:
    case ND_NE:
    case ND_LT:
    case ND_LE:
    case ND_GT:
    case ND_GE:
      (println "  fcomip");
      (println "  fstp %%st(0)");

      if (e.kind == ND_EQ)
        (println "  sete %%al");
      else if (e.kind == ND_NE)
        (println "  setne %%al");

      else if (e.kind == ND_LT) (println "  seta %%al");
      else if (e.kind == ND_LE) (println "  setae %%al");
      else if (e.kind == ND_GT) (println "  setb %%al");
      else if (e.kind == ND_GE) (println "  setbe %%al");

      (println "  movzb %%al, %%rax");
      return;
    ;

    (error_tok e.j "invalid expression");
  ;;

  gen_expr e.a.s ;
  push ;
  gen_expr e.a ;
  pop "%rdi";

  let ax = cast @char 0 di = cast @char 0 dx = cast @char 0;

  if (e.a.t.kind == TY_INT64 || !!e.a.t.base) {
    (ax = "%rax");
    (di = "%rdi");
    (dx = "%rdx");
  ; else {
    (ax = "%eax");
    (di = "%edi");
    (dx = "%edx");
  ;

  switch  e.kind {
  case ND_ADD:
    return
    ((e.a.t.kind == TY_PTR || e.a.t.kind == TY_ARRAY) && (println "  imul $%d, %s" e.a.t.base.size di) as void) ;:
    ((e.a.s.t.kind == TY_PTR || e.a.s.t.kind == TY_ARRAY) && (println "  imul $%d, %s" e.a.s.t.base.size ax) as void) ;:
    (println "  add %s, %s" di ax);
  case ND_SUB:
    return
    ((e.a.t.kind == TY_PTR || e.a.t.kind == TY_ARRAY) && !(e.a.s.t.kind == TY_PTR || e.a.s.t.kind == TY_ARRAY) && (println "  imul $%d, %s" e.a.t.base.size di) as void) ;:
    (println "  sub %s, %s" di ax) ;:
    ((e.a.s.t.kind == TY_PTR || e.a.s.t.kind == TY_ARRAY) && (println "  mov $%d,%s" e.a.s.t.base.size di) ;: (println "  mov $0, %s" dx) ;: (println "  div %s" di) as void);
  case ND_MUL:
    (println "  imul %s, %s" di ax);
    return;
  case ND_DIV:
  case ND_MOD:
    if (e.t.kind == TY_UNSIGNED) {
      (println "  mov $0, %s" dx);
      (println "  div %s" di);
    ; else {
      if (e.a.t.size == 8) (println "  cqo");
      else (println "  cdq");
      (println "  idiv %s" di);
    ;

    if (e.kind == ND_MOD) (println "  mov %%rdx, %%rax");
    return;
  case ND_BITAND:
    (println "  and %s, %s" di ax);
    return;
  case ND_BITOR:
    (println "  or %s, %s" di ax);
    return;
  case ND_BITXOR:
    (println "  xor %s, %s" di ax);
    return;
  case ND_EQ:
  case ND_NE:
  case ND_LT:
  case ND_LE:
  case ND_GT:
  case ND_GE:
    (println "  cmp %s, %s" di ax);

    if (e.kind == ND_EQ) {
      (println "  sete %%al");
    ; else if (e.kind == ND_NE) {
      (println "  setne %%al");
    ; else if (e.kind == ND_LT) {
      if (e.a.t.kind == TY_UNSIGNED)
        (println "  setb %%al");
      else
        (println "  setl %%al");
    ; else if (e.kind == ND_LE){
      if (e.a.t.kind == TY_UNSIGNED)
        (println "  setbe %%al");
      else
        (println "  setle %%al");
    ; else if (e.kind == ND_GT){
      if (e.a.t.kind == TY_UNSIGNED)
        (println "  seta %%al");
      else
        (println "  setg %%al");
    ; else if (e.kind == ND_GE){
      if (e.a.t.kind == TY_UNSIGNED)
        (println "  setae %%al");
      else
        (println "  setge %%al");
    ;

    (println "  movzb %%al, %%rax");
    return;
  case ND_SHL:
    (println "  mov %%rdi, %%rcx");
    (println "  shl %%cl, %s" ax);
    return;
  case ND_SHR:
    (println "  mov %%rdi, %%rcx");
    if (e.a.t.kind == TY_UNSIGNED)
      (println "  shr %%cl, %s" ax);
    else
      (println "  sar %%cl, %s" ax);
    return;
  ;

  (error_tok e.j "invalid expression");
;

gen_stmt(e@Node) =
  (println "  .loc %d %d" e.j.file.file_no e.j.line_no);

  switch  e.kind {
  case ND_IF: {
    let c = count ;
    gen_expr e.cond ;
    cmp_zero e.cond.t;
    (println "  je  .L.else.%d" c);
    gen_stmt e.then ;
    (println "  jmp .L.end.%d" c);
    (println ".L.else.%d:" c);
    if e.els gen_stmt e.els ;
    (println ".L.end.%d:" c);
    return;
  ;
  case ND_FOR: {
    let c = count ;
    if e.init gen_stmt e.init ;
    (println ".L.begin.%d:" c);
    if e.cond{
      gen_expr e.cond ;
      cmp_zero e.cond.t;
      (println "  je %s" e.brk_label);
    ;
    gen_stmt e.then ;
    (println "%s:" e.cont_label);
    if e.inc gen_expr e.inc ;
    (println "  jmp .L.begin.%d" c);
    (println "%s:" e.brk_label);
    return;
  ;
  case ND_DO: {
    let c = count ;
    (println ".L.begin.%d:" c);
    gen_stmt e.then ;
    (println "%s:" e.cont_label);
    gen_expr e.cond ;
    cmp_zero e.cond.t;
    (println "  jne .L.begin.%d" c);
    (println "%s:" e.brk_label);
    return;
  ;
  case ND_SWITCH:
    gen_expr e.cond ;

    for (let n@Node = e.case_next; n; n = n.case_next) {
      let ax = ((e.cond.t.size == 8) ? "%rax" : "%eax");
      let di = ((e.cond.t.size == 8) ? "%rdi" : "%edi");

      (println "  cmp $%ld, %s" n.begin ax);
      (println "  je %s" n.label);
    ;

    if e.default_case (println "  jmp %s" e.default_case.label);
    (println "  jmp %s" e.brk_label);
    gen_stmt e.then ;
    (println "%s:" e.brk_label);
    return;
  case ND_CASE:
    (println "%s:" e.label);
    gen_stmt e.a ;
    return;
  case ND_BLOCK:
    for (let n@Node = e.body; n; n = n.s) gen_stmt n ;
    return;
  case ND_GOTO:
    (println "  jmp %s" e.unique_label);
    return;
  case ND_LABEL:
    (println "%s:" e.unique_label);
    gen_stmt e.a ;
    return;
  case ND_RETURN:
    if e.a{
      gen_expr e.a ;
      let t = e.a.t;
      switch  t.kind {
      case TY_STRUCT:
      case TY_UNION:
        if (t.size <= 16) copy_struct_reg ;
        else copy_struct_mem ;
        break;
      ;
    ;

    ((println "  jmp .L.return.%s" current_fn.name));
    return;
  case ND_EXPR_STMT:
    gen_expr e.a ;
    return;
  case ND_ASM:
    (println "  %s" e.asm_str);
    return;
  ;

  (error_tok e.j "invalid statement");
;

assign_one_param_offset(var @Obj top @i32 gp @i32 fp @i32) =
  let t = var.t;
  switch  t.kind {
    case TY_STRUCT:
    case TY_UNION:none;
      let fp1 = cast i32 has_flonum t 0 8 0;
      let fp2 = cast i32 has_flonum t 8 16 8;
      if (!(fp@ + fp1 + fp2 < 8 && gp@ + cast i32 !fp1 + cast i32 !fp2 < 6) && t.size > 16) {
        (fp@ = fp@ +           fp1 +           fp2);
        (gp@ = gp@ + cast i32 !fp1 + cast i32 !fp2);
        return;;
    case TY_FLOAT64: if ((fp@ :; (fp@ += 1)) < 8) return;
    default       : if ((gp@ :; (gp@ += 1)) < 6) return;
    case TY_FLOAT32:
    case TY_FLOAT80:none;;
  (top@ = align_to top@ 8);
  (var.offset = top@);
  (top@ += var.t.size);;
assign_param_offsets(fn @Obj) =
  let top = 16 gp = 0 fp = 0;
  for (let var @Obj = fn.params; var; var = var.s)
    assign_one_param_offset var &top &gp &fp;;

assign_one_lvar_offset(fn @Obj) =
  if !fn.is_function return;
  assign_param_offsets fn;
  let bottom = 0;
  for (let var@Obj = fn.locals; var; var = var.s)
    if !var.offset {
    let alignment = var.alignment as i64;
    (bottom += var.t.size);
    (bottom = align_to bottom alignment);
    (var.offset = -bottom);;
  (fn.stack_size = align_to bottom 16);;
assign_lvar_offsets(prog @Obj) =
  for (let fn @Obj = prog; fn; fn = fn.s)
    assign_one_lvar_offset fn;;

emit_data(prog @Obj) =
  for (let var@Obj = prog; var; var = var.s)
    if !(var.is_function || !var.is_definition) {
    if !var.is_export (println "  .local %s" var.name);
    else (println "  .globl %s" var.name);

    let alignment = ((var.t.kind == TY_ARRAY && var.t.size >= 16)
      ? maxl 16l cast i64 var.alignment : cast i64 var.alignment);

    // .data or .tdata
    if var.init_data{
      if var.is_tls
        (println "  .section .tdata,\"awT\",@progbits");
      else
        (println "  .data");

      (println "  .type %s, @object" var.name);
      (println "  .size %s, %d" var.name var.t.size);
      (println "  .align %d" alignment);
      (println "%s:" var.name);

      let
        rel = var.rel
        pos = 0;
      while (pos < var.t.size) {
        if (!!rel && rel.offset == pos) {
          (println "  .quad %s%+ld" rel.label@ rel.addend);
          (rel = rel.s);
          (pos += 8);
        ; else {
          (println "  .byte %d" var.init_data[((pos :; (pos+=1)))]);
        ;
      ;
    ;
    else {
      // .bss or .tbss
      if var.is_tls
        (println "  .section .tbss,\"awT\",@nobits");
      else
        (println "  .bss");

      (println "  .align %d" alignment);
      (println "%s:" var.name);
      (println "  .zero %d" var.t.size);
  ;;
;

store_fp(r i32 offset i32 sz i32) = 
  (sz == 4) ? (println "  movss %%xmm%d, %d(%%rbp)" r offset ):
  (sz == 8) ? (println "  movsd %%xmm%d, %d(%%rbp)" r offset ):
              none;;

store_gp(r i32 offset i32 sz i32) =
  switch  sz {
  case 1:
    (println "  mov %s, %d(%%rbp)" argreg8[r] offset);
    return;
  case 2:
    (println "  mov %s, %d(%%rbp)" argreg16[r] offset);
    return;
  case 4:
    (println "  mov %s, %d(%%rbp)" argreg32[r] offset);
    return;
  case 8:
    (println "  mov %s, %d(%%rbp)" argreg64[r] offset);
    return;
  default:
    for (let i i32 = 0; i < sz; ((i :; (i+=1)))) {
      (println "  mov %s, %d(%%rbp)" argreg8[r] (offset + i));
      (println "  shr $8, %s" argreg64[r]);
    ;
    return;
  ;
;

emit_text(prog@Obj) =
  for (let fn@Obj = prog; fn; fn = fn.s)
    if (!(!fn.is_function || !fn.is_definition) && fn.is_live) {

    if !fn.is_export (println "  .local %s" fn.name);
    else             (println "  .globl %s" fn.name);

    (println "  .text");
    (println "  .type %s, @function" fn.name);
    (println "%s:" fn.name);
    (current_fn = fn);

    // Prologue
    (println "  push %%rbp");
    (println "  mov %%rsp, %%rbp");
    (println "  sub $%d, %%rsp" fn.stack_size);
    (println "  mov %%rsp, %d(%%rbp)" fn.alloca_bottom.offset);

    // Save arg registers if function is variadic
    if fn.va_area {
      let
        gp = 0
        fp = 0;
      for (let var@Obj = fn.params; var; var = var.s) {
        if (var.t.kind == TY_FLOAT32 || var.t.kind == TY_FLOAT64 || var.t.kind == TY_FLOAT80)
          ((fp :; (fp+=1)));
        else
          ((gp :; (gp+=1)));
      ;

      let off = fn.va_area.offset;

      // va_elem
      (println "  movl $%d, %d(%%rbp)" (gp * 8) off);          // gp_offset
      (println "  movl $%d, %d(%%rbp)" (fp * 8 + 48) (off + 4)); // fp_offset
      (println "  movq %%rbp, %d(%%rbp)" (off + 8));            // overflow_arg_area
      (println "  addq $16, %d(%%rbp)" (off + 8));
      (println "  movq %%rbp, %d(%%rbp)" (off + 16));           // reg_save_area
      (println "  addq $%d, %d(%%rbp)" (off + 24) (off + 16));

      let b = (off + 24);
      // __reg_save_area__
      (println "  movq %%rdi, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rsi, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rdx, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rcx, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%r8, %d(%%rbp)"    b);
      (b += 8); (println "  movq %%r9, %d(%%rbp)"    b);
      (b += 8); (println "  movsd %%xmm0, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm1, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm2, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm3, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm4, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm5, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm6, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm7, %d(%%rbp)" b);
    ;

    (  0 is gp
       0 is fp
       fn.params for o
      (  !!o
      && o.s
      :;(  o.offset <= 0
        && o.t is t
          (  t.kind == TY_STRUCT
          || t.kind == TY_UNION ) ?
            cast i32 minl cast i64 t.size 8l is b
            (  has_flonum t 0 8 0
              ?  store_fp (fp :; (fp+=1)) o.offset b
              :  store_gp (gp :; (gp+=1)) o.offset b )
            ;:(  (t.size   > 8)
              && (o.offset + 8) is b
                 (t.size   - 8) is c
                 has_flonum t 8 16 0
                ?  store_fp (fp :; (fp+=1)) b c
                :  store_gp (gp :; (gp+=1)) b c as void) :
          (  t.kind == TY_FLOAT32
          || t.kind == TY_FLOAT64 )
            ?  store_fp ((fp :; (fp+=1))) o.offset t.size
            :  store_gp ((gp :; (gp+=1))) o.offset t.size
        as void ) )
    as void )
    ;: gen_stmt cast @Node fn.body
    ;: (! strcmp cast @ fn.name "main" && (println "  mov $0, %%rax") as void)
    ;: (println ".L.return.%s:" fn.name)
    ;: (println "  mov %%rbp, %%rsp")
    ;: (println "  pop %%rbp")
    ;: (println "  ret");;;

export codegen(prog@Obj out@FILE) = return
  (output_file = out) ;:
  get_input_files is files
  (  0 for i 
    (  !!files[i] && (i + 1) :;
    (println "  .file %d \"%s\"" files[i].file_no files[i].name) ) as void) ;:
  assign_lvar_offsets prog ;:
  emit_data prog  ;:
  emit_text prog ;;
