#"chub.hb"

argreg(sz i32 g i32) @i8 = return
  (sz == 0) ? (g == 0) ? "%dil" :
              (g == 1) ? "%sil" :
              (g == 2) ? "%dl"  :
              (g == 3) ? "%cl"  :
              (g == 4) ? "%r8b" :
                         "%r9b" :
  (sz == 1) ? (g == 0) ? "%edi" :
              (g == 1) ? "%esi" :
              (g == 2) ? "%edx" :
              (g == 3) ? "%ecx" :
              (g == 4) ? "%r8d" :
                         "%r9d" :
              (g == 0) ? "%rdi" :
              (g == 1) ? "%rsi" :
              (g == 2) ? "%rdx" :
              (g == 3) ? "%rcx" :
              (g == 4) ? "%r8"  :
                         "%r9"  ;;

gen_expr(out @FILE e @Node c @i32 depth @i32);
gen_stmt(out @FILE e @Node c @i32 depth @i32);

println(out @FILE fmt @i8 ...) = return
  vfprintf out fmt cast @va_list __va_area__
;: (cast none fprintf out "\n")
;;

gen_push (out @FILE depth @i32        )     = return (println out "  push %%rax") ;: (depth@ = depth@ + 1);;
gen_pop  (out @FILE depth @i32 arg @i8)     = return (println out "  pop %s" arg) ;: (depth@ = depth@ - 1);;

gen_addr(out @FILE e @Node c @i32 depth @i32) = return
  ( e.kind    == ND_VAR     ) ?
  (  e.var.is_local
  ? (println out "  lea %d(%%rbp), %%rax" e.var.offset)
  : (println out "  mov %s@GOTPCREL(%%rip), %%rax" e.var.name)) :
  ( e.kind    == ND_COMMA   ) ? gen_expr out e.a c depth ;: gen_expr out e.a.s c depth :
  ( e.kind    == ND_THEN    ) ? gen_expr out e.a c depth ;: gen_push out depth ;: gen_expr out e.a.s c depth ;: gen_pop out depth "%rax" :
  ( e.kind    == ND_MEMBER  ) ? gen_addr out e.a c depth ;: (println out "  add $%d, %%rax" e.t.offset ) :
  ( e.kind    == ND_THE    ||
    e.kind    == ND_DEREF   ) ? gen_expr out e.a c depth :
  ( e.kind    == ND_FUNCALL||
    e.kind    == ND_COND   ||
    e.kind    == ND_LET    ||
    e.kind    == ND_REPEAT  ) ? gen_expr out e   c depth :
  ( e.t.kind == TY_STRUCT   ) ? gen_expr out e   c depth :
  ( jdiag e.j "not an lvalue" );;

load(out @FILE t @Type) = return
  t.kind == TY_ARRAY  ||
  t.kind == TY_STRUCT ||
  t.kind == TY_FUNC   ||
  ( ((t.kind == TY_RING) ? "movz" : "movs") is insn
    ((t.kind == TY_RING) ? t.a : t ) is u
    ( (u.size == 1         ) ? (println out "  %sbl (%%rax), %%eax"   insn ) :
      (u.size == 4         ) ? (println out "  movsxd (%%rax), %%rax"      ) :
                               (println out "  mov (%%rax), %%rax"         ) ) )
as none
;;
store(out @FILE t @Type depth @i32) =
   gen_pop out depth "%rdi"
;: (t.kind == TY_STRUCT  ) ? (0 for i (i < t.size && (i + 1)
:; (println out "  mov %d(%%rax), %%r8b" i)
;: (println out "  mov %%r8b, %d(%%rdi)" i)) as none)
:  (t.size == 1) ? (println out "  mov %%al , (%%rdi)")
:  (t.size == 4) ? (println out "  mov %%eax, (%%rdi)")
:                  (println out "  mov %%rax, (%%rdi)")
;;

gen_zero(out @FILE) = return (println out "  xor %%eax, %%eax") ;;
gen_cmpz(out @FILE) = return (println out "  cmp $0, %%rax"   ) ;;
gen_not (out @FILE) = return (println out "  not %%eax"       ) ;;

gen_casti8 (out @FILE a @Type b @Type) = return a.kind != b.kind &&                     (println out "  movsbl %%al  , %%eax") as none ;;
gen_castu8 (out @FILE a @Type b @Type) = return a.kind != b.kind &&                     (println out "  movzbl %%al  , %%eax") as none ;;
gen_cast64 (out @FILE a @Type b @Type) = return (a.size < 32 || a.kind == TY_I32)    && (println out "  movsxd %%eax , %%rax") as none ;;

gen_cast(out @FILE a @Type b @Type) = return
(b.kind == TY_VOID) ? gen_zero out               :
(b.kind == TY_BOOL) ? gen_not out ;: gen_not out :
(b.kind == TY_I08 ) ? gen_casti8 out a b         :
(b.kind == TY_RING) ? (b.a.kind == TY_I08) ? gen_castu8 out a b :
                                             gen_cast64 out a b :
                      gen_cast64 out a b      ;;

push_args2(out @FILE args @Node first_pass bool c @i32 depth @i32) = return
   !!args
&& push_args2 out args.s first_pass c depth
;: !((first_pass && !args.pass_by_stack) || (!first_pass && args.pass_by_stack))
&& gen_expr out args c depth
;: gen_push out depth
as none
;;
push_args(out @FILE e @Node c @i32 depth @i32) i32 = return
  0 is stack
  0 is gp
  (  !!e.a.s && e.a.s for arg
     arg.s
  :;(  ((gp >= 6) :; (gp = gp + 1))
    && (arg.pass_by_stack = true)
    ;: (stack = stack + 1)
    as none )
  as none )
;:(  (depth@ + stack) % 2 == 1
  && (println out "  sub $8, %%rsp")
  ;: (depth@ = depth@ + 1)
  ;: (stack = stack + 1)
  as none )
;: push_args2 out e.a.s true c depth
;: push_args2 out e.a.s false c depth
;: stack
;;
gen_expr(out @FILE e @Node c @i32 depth @i32) =
   (println out "  .loc %d %d" e.j.in.file_no e.j.line_no)
;: (e.kind == ND_NULL_EXPR) ? none
:  (e.kind == ND_THE   ) ? gen_expr out e.a c depth
:  (e.kind == ND_ADDR  ) ? gen_addr out e.a c depth
:  (e.kind == ND_NUM   ) ? (println out "  mov $%ld, %%rax" e.val)
:  (e.kind == ND_NEG   ) ? gen_expr out e.a c depth ;: (println out "  neg %%rax")
:  (e.kind == ND_VAR   ) ? gen_addr out e   c depth ;: load out e.t
:  (e.kind == ND_MEMBER) ? gen_addr out e   c depth ;: load out e.t
:  (e.kind == ND_DEREF ) ? gen_expr out e.a c depth ;: load out e.t
:  (e.kind == ND_COMMA ) ? gen_expr out e.a c depth ;: gen_expr out e.a.s c  depth
:  (e.kind == ND_CAST  ) ? gen_expr out e.a c depth ;: gen_cast out e.a.t e.t
:  (e.kind == ND_ASSIGN) ? gen_addr out e.a c depth ;: gen_push out depth ;: gen_expr out e.a.s c depth ;: store out e.a.t depth ;: (println out "  xor %%eax, %%eax") 
:  (e.kind == ND_THEN  ) ? gen_expr out e.a c depth ;: gen_push out depth ;: gen_expr out e.a.s c depth ;: gen_pop out depth "%rax"
:  (e.kind == ND_NOT   ) ? gen_expr out e.a c depth ;: gen_cmpz out       ;: (println out "  sete %%al") ;: (println out "  movzx %%al, %%rax")
:  (e.kind == ND_BITNOT) ? gen_expr out e.a c depth ;: (println out "  not %%rax")
:  (e.kind == ND_LET   ) ?
   (println out "  lea %d(%%rbp), %%rax" e.var.offset )
;: gen_push out depth
;: gen_expr out e.a  c depth
;: store out e.a.t depth
;: gen_expr out e.a.s c depth
:  (e.kind == ND_REPEAT)
?  (c@ = c@ + 1)
;: c@ is d
   (println out "  lea %d(%%rbp), %%rax" e.var.offset)
;: gen_push out depth
;: gen_expr out e.a c depth
;: (println out ".L.repeat.%d:" d)
;: store out e.a.t depth
;: (println out "  lea %d(%%rbp), %%rax" e.var.offset )
;: gen_push out depth
;: gen_expr out e.a.s c depth
;: gen_cmpz out
;: (println out "  jne .L.repeat.%d" d)
;: gen_pop out depth "%rax"
;: (println out "  mov 0(%%rax), %%rax")
:  (e.kind == ND_MEMZERO)
?  (println out "  mov $%d, %%rcx" e.var.t.size)
;: (println out "  lea %d(%%rbp), %%rdi" e.var.offset)
;: (println out "  mov $0, %%al")
;: (println out "  rep stosb")
:  (e.kind == ND_COND)
?  gen_expr out e.a c depth
;: (c@ = c@ + 1)
;: c@ is d
   gen_cmpz out
;: (println out "  je .L.else.%d" d)
;: gen_expr out e.a.s c depth
;: (println out "  jmp .L.end.%d" d)
;: (println out ".L.else.%d:" d)
;: gen_expr out e.a.s.s c depth
;: (println out ".L.end.%d:" d)
:  (e.kind == ND_LOGAND || e.kind ==  ND_LOGOR)
?  gen_expr out e.a c depth
;: (c@ = c@ + 1)
;: c@ is d
   gen_cmpz out
;: (println out ((e.kind == ND_LOGAND) ? "  je .L.end.%ld" : "  jne .L.end.%ld") d)
;: (e.a.s.t.kind == TY_VOID && gen_push out depth)
;: gen_expr out e.a.s c depth
;: (e.a.s.t.kind == TY_VOID && gen_pop out depth "%rax")
;: (println out ".L.end.%ld:" d)
:  (e.kind == ND_FUNCALL)
?  push_args out e c depth is stack_args
   gen_expr out e.a c depth
;: 0 is gp
   (!!e.a.s && e.a.s for e e.s :; (gp < 6 && gen_pop out depth argreg 2 gp :; (gp = gp + 1)) as none)
;: (println out "  mov %%rax, %%r10")
;: (println out "  call *%%r10")
;: (println out "  add $%d, %%rsp" (stack_args * 8))
;: (depth@ = depth@ - stack_args)
:  gen_expr out e.a.s c depth
;: gen_push out depth
;: gen_expr out e.a c depth
;: gen_pop out depth "%rdi"
;: (e.a.t.kind == TY_I64 || !!e.a.t.a) is big
   (big ? "%rax" : "%eax") is ax
   (big ? "%rdi" : "%edi") is di
   (big ? "%rdx" : "%edx") is dx
  (e.kind == ND_ADD) ? ((e.a.t.kind == TY_PTR || e.a.t.kind == TY_ARRAY) && (println out "  imul $%d, %s" e.a.t.a.size di) as none) ;:
    ((e.a.s.t.kind == TY_PTR || e.a.s.t.kind == TY_ARRAY) && (println out "  imul $%d, %s" e.a.s.t.a.size ax) as none) ;:
    (println out "  add %s, %s" di ax) :
  (e.kind == ND_SUB) ? 
    ((e.a.t.kind == TY_PTR || e.a.t.kind == TY_ARRAY) && !(e.a.s.t.kind is k (k == TY_PTR || k == TY_ARRAY)) && (println out "  imul $%d, %s" e.a.t.a.size di) as none) ;:
    (println out "  sub %s, %s" di ax) ;:
    ((e.a.s.t.kind is k (k == TY_PTR || k == TY_ARRAY)) && (println out "  mov $%d,%s" e.a.s.t.a.size di) ;: (println out "  mov $0, %s" dx) ;: (println out "  div %s" di) as none) :
  (e.kind == ND_MUL) ? (println out "  imul %s, %s" di ax) :
  (e.kind == ND_DIV || e.kind == ND_MOD) ?
    (  (e.t.kind == TY_RING)
    ?  (println out "  mov $0, %s" dx)
    ;: (println out "  div %s" di)
    :  ((e.a.t.size == 8) ? (println out "  cqo") : (println out "  cdq"))
    ;: (println out "  idiv %s" di))
    ;: (e.kind == ND_MOD && (println out "  mov %%rdx, %%rax") as none) :
    (e.kind == ND_BITAND ) ? (println out "  and %s, %s" di ax) :
    (e.kind == ND_BITOR  ) ? (println out "  or  %s, %s" di ax) :
    (e.kind == ND_BITXOR ) ? (println out "  xor %s, %s" di ax) :
    (e.kind == ND_EQ     ) ?                           (println out "  cmp %s, %s" di ax) ;: (println out "  sete  %%al") ;: (println out "  movzb %%al, %%rax") :
    (e.kind == ND_NE     ) ?                           (println out "  cmp %s, %s" di ax) ;: (println out "  setne %%al") ;: (println out "  movzb %%al, %%rax") :
    (e.kind == ND_SHL    ) ?                           (println out "  mov %%rdi, %%rcx") ;: (println out "  shl %%cl, %s" ax)                                   :
    (e.kind == ND_LT     ) ? (e.a.t.kind == TY_RING) ? (println out "  cmp %s, %s" di ax) ;: (println out "  setb  %%al") ;: (println out "  movzb %%al, %%rax")
                                                     : (println out "  cmp %s, %s" di ax) ;: (println out "  setl  %%al") ;: (println out "  movzb %%al, %%rax") :
    (e.kind == ND_LE     ) ? (e.a.t.kind == TY_RING) ? (println out "  cmp %s, %s" di ax) ;: (println out "  setbe %%al") ;: (println out "  movzb %%al, %%rax")
                                                     : (println out "  cmp %s, %s" di ax) ;: (println out "  setle %%al") ;: (println out "  movzb %%al, %%rax") :
    (e.kind == ND_GT     ) ? (e.a.t.kind == TY_RING) ? (println out "  cmp %s, %s" di ax) ;: (println out "  seta  %%al") ;: (println out "  movzb %%al, %%rax")
                                                     : (println out "  cmp %s, %s" di ax) ;: (println out "  setg  %%al") ;: (println out "  movzb %%al, %%rax") :
    (e.kind == ND_GE     ) ? (e.a.t.kind == TY_RING) ? (println out "  cmp %s, %s" di ax) ;: (println out "  setae %%al") ;: (println out "  movzb %%al, %%rax")
                                                     : (println out "  cmp %s, %s" di ax) ;: (println out "  setge %%al") ;: (println out "  movzb %%al, %%rax") :
                             (e.a.t.kind == TY_RING) ? (println out "  mov %%rdi, %%rcx") ;: (println out "  shr %%cl, %s" ax)
                                                     : (println out "  mov %%rdi, %%rcx") ;: (println out "  sar %%cl, %s" ax) ;
;

gen_stmt(out @FILE e @Node c @i32 depth @i32) = return
   (println out "  .loc %d %d" e.j.in.file_no e.j.line_no)
;: (e.kind == ND_IF)
?  (c@ = c@ + 1)
;: c@ is d
   gen_expr out e.cond c depth
;: gen_cmpz out
;: (println out "  je  .L.else.%d" d)
;: gen_stmt out e.then c depth
;: (println out "  jmp .L.end.%d" d)
;: (println out ".L.else.%d:" d)
;: (!!e.els && gen_stmt out e.els c depth as none)
;: (println out ".L.end.%d:" d)
:  (e.kind == ND_FOR)
?  (c@ = c@ + 1)
;: c@ is d
   (!!e.init && gen_stmt out e.init c depth as none )
;: (println out ".L.begin.%d:" d)
;:(  !!e.cond
  && gen_expr out e.cond c depth
  ;: gen_cmpz out
  ;: (println out "  je .L.end.%d" d) as none )
;: gen_stmt out e.then c depth
;: (!!e.inc && gen_expr out e.inc c depth as none )
;: (println out "  jmp .L.begin.%d" d)
;: (println out ".L.end.%d:" d)
:  (e.kind == ND_BLOCK)
?  (!!e.body && e.body for a a.s :; gen_stmt out a c depth as none)
:  (e.kind == ND_RETURN)
?  (!!e.a && gen_expr out e.a c depth as none)
;: (println out "  mov %%rbp, %%rsp")
;: (println out "  pop %%rbp")
;: (println out "  ret")
:  (e.kind  == ND_EXPR_STMT)
?  gen_expr out e.a c depth
:  (jdiag e.j "invalid statement")
;;

assign_param_offsets(f @Obj) = return
   !!f.params
&& 16 is t
    0 is g
   f.params for o o.s
:; (!((g :; (g = g + 1)) < 6)
&& (t        = align_to t 8)
;: (o.offset = t           )
;: (t        = t + o.t.size) )
as none
;;

assign_one_lvar_offset(fn @Obj) =
  if !fn.is_function return;
  assign_param_offsets fn;
  let bottom = 0 var = fn.locals;
  for (none; var; var = var.s)
    if !var.offset {
    (bottom = bottom + var.t.size);
    (bottom = align_to bottom var.t.align);
    (var.offset = -bottom);;
  (fn.stack_size = align_to bottom 16);;
assign_lvar_offsets(prog @Obj) = return prog for f f.s :; assign_one_lvar_offset f as none;;

emit_datum(out @FILE var @Obj) =
    if !var.is_export (println out "  .local %s" var.name);
    else (println out "  .globl %s" var.name);

    if var.init_data{
      (println out "  .data");
      (println out "  .type %s, @object" var.name);
      (println out "  .size %s, %d" var.name var.t.size);
      (println out "  .align %d" var.t.align);
      (println out "%s:" var.name);

      let
        rel = var.rel
        pos = 0;
      while (pos < var.t.size) {
        if (!!rel && rel.offset == pos) {
          (println out "  .quad %s%+ld" rel.label@ rel.addend);
          (rel = rel.s);
          (pos = pos + 8);
        ; else {
          (println out "  .byte %d" var.init_data[((pos :; (pos = pos + 1)))]);
        ;
      ;
    ;
    else {
      (println out "  .bss");
      (println out "  .align %d" var.t.align);
      (println out "%s:" var.name);
      (println out "  .zero %d" var.t.size);
  ;;

emit_data(out @FILE prog @Obj) = return (!!prog && prog for var var.s :; (!(var.is_function || !var.is_definition) && emit_datum out var as none) as none);;

store_gp(out @FILE r i32 offset i32 sz i32) = return
   (sz == 1) ? (println out "  mov %s, %d(%%rbp)" argreg 0 r offset)
:  (sz == 4) ? (println out "  mov %s, %d(%%rbp)" argreg 1 r offset)
:  (sz == 8) ? (println out "  mov %s, %d(%%rbp)" argreg 2 r offset)
: (  0 for i
    (  i < sz
    && (i + 1)
    :; (println out "  mov %s, %d(%%rbp)" argreg 0 r (offset + i))
    ;: (println out "  shr $8, %s" argreg 2 r) )
  as none )
;;

emit_text(out @FILE prog @Obj c @i32) =
  let fn = prog;
  for (none; fn; fn = fn.s)
    if (!(!fn.is_function || !fn.is_definition)) {
    if !fn.is_export (println out "  .local %s" fn.name);
    else             (println out "  .globl %s" fn.name);
    (println out "  .text");
    (println out "  .type %s, @function" fn.name);
    (println out "%s:" fn.name);
    (println out "  push %%rbp");
    (println out "  mov %%rsp, %%rbp");
    (println out "  sub $%d, %%rsp" fn.stack_size);
    if fn.va_area {
      let gp = 0 var = fn.params;
      for (none; var; var = var.s) ((gp :; (gp = gp + 1)));
      let off = fn.va_area.offset;
      (println out "  movl $%d, %d(%%rbp)" (gp * 8) off);
      (println out "  movq %%rbp, %d(%%rbp)" (off + 8));
      (println out "  addq $16, %d(%%rbp)" (off + 8));
      (println out "  movq %%rbp, %d(%%rbp)" (off + 16));
      (println out "  addq $%d, %d(%%rbp)" (off + 24) (off + 16));
      let b = (off + 24);
      (println out "  movq %%rdi, %d(%%rbp)"   b);
      (b = b + 8); (println out "  movq %%rsi, %d(%%rbp)"   b);
      (b = b + 8); (println out "  movq %%rdx, %d(%%rbp)"   b);
      (b = b + 8); (println out "  movq %%rcx, %d(%%rbp)"   b);
      (b = b + 8); (println out "  movq %%r8, %d(%%rbp)"    b);
      (b = b + 8); (println out "  movq %%r9, %d(%%rbp)"    b);;
    (  0 is gp
       fn.params for o
      (  !!o
      && o.s
      :;(  o.offset <= 0
        && o.t is t
          (  t.kind == TY_STRUCT ) ?
            cast i32 minl cast i64 t.size 8l is b
            ( store_gp out (gp :; (gp = gp + 1)) o.offset b )
            ;:(  (t.size   > 8)
              && (o.offset + 8) is b
                 (t.size   - 8) is c
                 store_gp out (gp :; (gp = gp + 1)) b c as none) :
          store_gp out ((gp :; (gp = gp + 1))) o.offset t.size
        as none ) )
    as none )
    ;: 0 is depth
       gen_stmt out cast @Node fn.body c &depth
    ;: (! strcmp fn.name "main" && (println out "  mov $0, %%rax") as none)
    ;: (println out "  mov %%rbp, %%rsp")
    ;: (println out "  pop %%rbp")
    ;: (println out "  ret");;;

export codegen(prog @Obj out @FILE files @@File) = return
  ( &files[0] for i
    (  !!i@
    && (i + 1)
    :; (println out "  .file %d \q%s\q" i.file_no i.name) )
  as none )
;: assign_lvar_offsets prog
;: emit_data out prog
;: 0 is c
   emit_text out prog &c
;;
