#include "chub.hb"

#define GP_MAX 6
#define FP_MAX 8

type
  TypeID enum
    I8 I16 I32 I64
    U8 U16 U32 U64
           F32 F64 F80
  ;
;

output_file@FILE
depth int
argreg8 []@char = {"%dil", "%sil", "%dl" , "%cl" , "%r8b", "%r9b";
argreg16[]@char = {"%di" , "%si" , "%dx" , "%cx" , "%r8w", "%r9w";
argreg32[]@char = {"%edi", "%esi", "%edx", "%ecx", "%r8d", "%r9d";
argreg64[]@char = {"%rdi", "%rsi", "%rdx", "%rcx", "%r8" , "%r9" ;
current_fn@Obj;

gen_expr(node@Node opt_fpic bool);
gen_stmt(node@Node opt_fpic bool);

__attribute__((format(printf, 1, 2)))
println(fmt@char ...) =
  let ap = (let va_list){;;
  va_start(ap, fmt);
  vfprintf(output_file fmt ap);
  va_end(ap)
  fprintf(output_file "\n");
;

i counti int = 1;
count(void)int =
  return counti++;
;

push(void) =
  println("  push %%rax");
  depth++;
;

pop(arg@char) =
  println("  pop %s" arg);
  depth--;
;

pushf(void) =
  println("  sub $8, %%rsp");
  println("  movsd %%xmm0, (%%rsp)");
  depth++;
;

popf(reg int) =
  println("  movsd (%%rsp), %%xmm%d" reg);
  println("  add $8, %%rsp");
  depth--;
;

// Round up `n` to the nearest multiple of `align`. For instance,
// align_to(5, 8) returns 8 and align_to(11, 8) returns 16.
export align_to(n int alignment int) int =
  return (n + alignment - 1) / alignment * alignment;
;

reg_dx(sz int)@char =
  switch (sz) {
  case 1: return "%dl";
  case 2: return "%dx";
  case 4: return "%edx";
  case 8: return "%rdx";
  ;
  unreachable();
;

reg_ax(sz int)@char =
  switch (sz) {
  case 1: return "%al";
  case 2: return "%ax";
  case 4: return "%eax";
  case 8: return "%rax";
  ;
  unreachable();
;

gen_addr(node@Node opt_fpic bool) =
  switch (node@.kind) {
  case ND_VAR:
    // Local variable
    if node@.var@.is_local{
      println("  lea %d(%%rbp), %%rax" node@.var@.offset);
      return;
    ;

    if opt_fpic{
      // Thread-local variable
      if node@.var@.is_tls{
        println("  data16 lea %s@tlsgd(%%rip), %%rdi" node@.var@.name);
        println("  .value 0x6666");
        println("  rex64");
        println("  call __tls_get_addr@PLT");
        return;
      ;

      // Function or global variable
      println("  mov %s@GOTPCREL(%%rip), %%rax" node@.var@.name);
      return;
    ;

    // Thread-local variable
    if node@.var@.is_tls{
      println("  mov %%fs:0, %%rax");
      println("  add $%s@tpoff, %%rax" node@.var@.name);
      return;
    ;
    if node@.ty@.kind == TY_FUNC{
      if node@.var@.is_definition
        println("  lea %s(%%rip), %%rax" node@.var@.name);
      else
        println("  mov %s@GOTPCREL(%%rip), %%rax" node@.var@.name);
      return;
    ;

    // Global variable
    println("  lea %s(%%rip), %%rax" node@.var@.name);
    return;
  case ND_DEREF:
    //warn_tok(node@.tok, "address of deref");
    gen_expr(node@.lhs opt_fpic);
    return;
  case ND_COMMA:
    gen_expr(node@.lhs opt_fpic);
    gen_addr(node@.rhs opt_fpic);
    return;
  case ND_MEMBER:
    gen_addr(node@.lhs opt_fpic);
    println("  add $%d, %%rax" node@.member@.offset);
    return;
  case ND_FUNCALL:
    if node@.ret_buffer{
      gen_expr(node opt_fpic);
      return;
    ;
    break;
  case ND_ASSIGN:
  case ND_COND:
    if node@.ty@.kind == TY_STRUCT || node@.ty@.kind == TY_UNION{
      gen_expr(node opt_fpic);
      return;
    ;
    break;
  ;

  error_tok(node@.tok "not an lvalue");
;

// Load a value from where %rax is pointing to.
load(ty@Type) =
  switch (ty@.kind) {
  case TY_ARRAY:
  case TY_STRUCT:
  case TY_UNION:
  case TY_FUNC:
    return;
  case TY_FLOAT:
    println("  movss (%%rax), %%xmm0");
    return;
  case TY_DOUBLE:
    println("  movsd (%%rax), %%xmm0");
    return;
  case TY_LDOUBLE:
    println("  fldt (%%rax)");
    return;
  ;

  let insn = ty@.is_unsigned ? "movz" : "movs";

  // When we load a char or a short value to a register, we always
  // extend them to the size of int, so we can assume the lower half of
  // a register always contains a valid value. The upper half of a
  // register for char, short and int may contain garbage. When we load
  // a long value to a register, it simply occupies the entire register.
  if ty@.size == 1
    println("  %sbl (%%rax), %%eax" insn);
  else if ty@.size == 2
    println("  %swl (%%rax), %%eax" insn);
  else if ty@.size == 4
    println("  movsxd (%%rax), %%rax");
  else
    println("  mov (%%rax), %%rax");
;

// Store %rax to an address that the stack top is pointing to.
store(ty@Type) =
  pop("%rdi");

  switch (ty@.kind) {
  case TY_STRUCT:
  case TY_UNION:
    for (let i int = 0; i < ty@.size; i++) {
      println("  mov %d(%%rax), %%r8b" i);
      println("  mov %%r8b, %d(%%rdi)" i);
    ;
    return;
  case TY_FLOAT:
    println("  movss %%xmm0, (%%rdi)");
    return;
  case TY_DOUBLE:
    println("  movsd %%xmm0, (%%rdi)");
    return;
  case TY_LDOUBLE:
    println("  fstpt (%%rdi)");
    return;
  ;

  if ty@.size == 1
    println("  mov %%al, (%%rdi)");
  else if ty@.size == 2
    println("  mov %%ax, (%%rdi)");
  else if ty@.size == 4
    println("  mov %%eax, (%%rdi)");
  else
    println("  mov %%rax, (%%rdi)");
;

cmp_zero(ty@Type) =
  switch (ty@.kind) {
  case TY_FLOAT:
    println("  xorps %%xmm1, %%xmm1");
    println("  ucomiss %%xmm1, %%xmm0");
    return;
  case TY_DOUBLE:
    println("  xorpd %%xmm1, %%xmm1");
    println("  ucomisd %%xmm1, %%xmm0");
    return;
  case TY_LDOUBLE:
    println("  fldz");
    println("  fucomip");
    println("  fstp %%st(0)");
    return;
  ;

  if is_integer(ty) && ty@.size <= 4
    println("  cmp $0, %%eax");
  else
    println("  cmp $0, %%rax");
;

getTypeId(ty@Type)TypeID =
  switch (ty@.kind) {
  case TY_CHAR:
    return ty@.is_unsigned ? U8 : I8;
  case TY_SHORT:
    return ty@.is_unsigned ? U16 : I16;
  case TY_INT:
    return ty@.is_unsigned ? U32 : I32;
  case TY_LONG:
    return ty@.is_unsigned ? U64 : I64;
  case TY_FLOAT:
    return F32;
  case TY_DOUBLE:
    return F64;
  case TY_LDOUBLE:
    return F80;
  ;
  return U64;
;

// The table for type casts
i32i8[]char = "movsbl %al, %eax";
i32u8[]char = "movzbl %al, %eax";
i32i16[]char = "movswl %ax, %eax";
i32u16[]char = "movzwl %ax, %eax";
i32f32[]char = "cvtsi2ssl %eax, %xmm0";
i32i64[]char = "movsxd %eax, %rax";
i32f64[]char = "cvtsi2sdl %eax, %xmm0";
i32f80[]char = "mov %eax, -4(%rsp); fildl -4(%rsp)";

u32f32[]char = "mov %eax, %eax; cvtsi2ssq %rax, %xmm0";
u32i64[]char = "mov %eax, %eax";
u32f64[]char = "mov %eax, %eax; cvtsi2sdq %rax, %xmm0";
u32f80[]char = "mov %eax, %eax; mov %rax, -8(%rsp); fildll -8(%rsp)";

i64f32[]char = "cvtsi2ssq %rax, %xmm0";
i64f64[]char = "cvtsi2sdq %rax, %xmm0";
i64f80[]char = "movq %rax, -8(%rsp); fildll -8(%rsp)";

u64f32[]char = "cvtsi2ssq %rax, %xmm0";
u64f64[]char = "test %rax,%rax; js 1f; pxor %xmm0,%xmm0; cvtsi2sd %rax,%xmm0; jmp 2f; 1: mov %rax,%rdi; and $1,%eax; pxor %xmm0,%xmm0; shr %rdi; or %rax,%rdi; cvtsi2sd %rdi,%xmm0; addsd %xmm0,%xmm0; 2:";
u64f80[]char = "mov %rax, -8(%rsp); fildq -8(%rsp); test %rax, %rax; jns 1f; mov $1602224128, %eax; mov %eax, -4(%rsp); fadds -4(%rsp); 1:";

f32i8[]char = "cvttss2sil %xmm0, %eax; movsbl %al, %eax";
f32u8[]char = "cvttss2sil %xmm0, %eax; movzbl %al, %eax";
f32i16[]char = "cvttss2sil %xmm0, %eax; movswl %ax, %eax";
f32u16[]char = "cvttss2sil %xmm0, %eax; movzwl %ax, %eax";
f32i32[]char = "cvttss2sil %xmm0, %eax";
f32u32[]char = "cvttss2siq %xmm0, %rax";
f32i64[]char = "cvttss2siq %xmm0, %rax";
f32u64[]char = "cvttss2siq %xmm0, %rax";
f32f64[]char = "cvtss2sd %xmm0, %xmm0";
f32f80[]char = "movss %xmm0, -4(%rsp); flds -4(%rsp)";

f64i8[]char = "cvttsd2sil %xmm0, %eax; movsbl %al, %eax";
f64u8[]char = "cvttsd2sil %xmm0, %eax; movzbl %al, %eax";
f64i16[]char = "cvttsd2sil %xmm0, %eax; movswl %ax, %eax";
f64u16[]char = "cvttsd2sil %xmm0, %eax; movzwl %ax, %eax";
f64i32[]char = "cvttsd2sil %xmm0, %eax";
f64u32[]char = "cvttsd2siq %xmm0, %rax";
f64i64[]char = "cvttsd2siq %xmm0, %rax";
f64u64[]char = "cvttsd2siq %xmm0, %rax";
f64f32[]char = "cvtsd2ss %xmm0, %xmm0";
f64f80[]char = "movsd %xmm0, -8(%rsp); fldl -8(%rsp)";

f80i8[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movsbl -24(%rsp), %eax"
f80u8[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movzbl -24(%rsp), %eax"
f80i16[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movzbl -24(%rsp), %eax"
f80u16[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); movswl -24(%rsp), %eax"
f80i32[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %eax"
f80u32[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %eax"
f80i64[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpq -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %rax"
f80u64[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpq -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %rax"
f80f32[]char = "fstps -8(%rsp); movss -8(%rsp), %xmm0"
f80f64[]char = "fstpl -8(%rsp); movsd -8(%rsp), %xmm0";

cast_table[][11]@char = {
  // i8   i16     i32     i64     u8     u16     u32     u64     f32     f64     f80
  {NULL,  NULL,   NULL,   i32i64, i32u8, i32u16, NULL,   i32i64, i32f32, i32f64, i32f80;, // i8
  {i32i8, NULL,   NULL,   i32i64, i32u8, i32u16, NULL,   i32i64, i32f32, i32f64, i32f80;, // i16
  {i32i8, i32i16, NULL,   i32i64, i32u8, i32u16, NULL,   i32i64, i32f32, i32f64, i32f80;, // i32
  {i32i8, i32i16, NULL,   NULL,   i32u8, i32u16, NULL,   NULL,   i64f32, i64f64, i64f80;, // i64

  {i32i8, NULL,   NULL,   i32i64, NULL,  NULL,   NULL,   i32i64, i32f32, i32f64, i32f80;, // u8
  {i32i8, i32i16, NULL,   i32i64, i32u8, NULL,   NULL,   i32i64, i32f32, i32f64, i32f80;, // u16
  {i32i8, i32i16, NULL,   u32i64, i32u8, i32u16, NULL,   u32i64, u32f32, u32f64, u32f80;, // u32
  {i32i8, i32i16, NULL,   NULL,   i32u8, i32u16, NULL,   NULL,   u64f32, u64f64, u64f80;, // u64

  {f32i8, f32i16, f32i32, f32i64, f32u8, f32u16, f32u32, f32u64, NULL,   f32f64, f32f80;, // f32
  {f64i8, f64i16, f64i32, f64i64, f64u8, f64u16, f64u32, f64u64, f64f32, NULL,   f64f80;, // f64
  {f80i8, f80i16, f80i32, f80i64, f80u8, f80u16, f80u32, f80u64, f80f32, f80f64, NULL  ;  // f80
;;

cast(from@Type to@Type) =
  if to@.kind == TY_VOID
    return;

  if to@.kind == TY_BOOL{
    cmp_zero(from);
    println("  setne %%al");
    println("  movzx %%al, %%eax");
    return;
  ;

  let t1 = getTypeId(from);
  let t2 = getTypeId(to);
  if cast_table[t1][t2]
    println("  %s" cast_table[t1][t2]);
;

// Structs or unions equal or smaller than 16 bytes are passed
// using up to two registers.
//
// If the first 8 bytes contains only floating-point type members,
// they are passed in an XMM register. Otherwise, they are passed
// in a general-purpose register.
//
// If a struct/union is larger than 8 bytes, the same rule is
// applied to the the next 8 byte chunk.
//
// This function returns true if `ty` has only floating-point
// members in its byte range [lo, hi).
has_flonum(ty@Type lo int hi int offset int)bool =
  if ty@.kind == TY_STRUCT || ty@.kind == TY_UNION{
    for (let mem@Member = ty@.members; mem; mem = mem@.next) {
      let d = offset + mem@.offset;
      if !has_flonum(mem@.ty lo hi d)
        return false;
    ;
    return true;
  ;

  if ty@.kind == TY_ARRAY{
    for (let i int = 0; i < ty@.array_len; i++) {
      let d = offset + ty@.base@.size * i;
      if !has_flonum(ty@.base lo hi d)
        return false;
    ;
    return true;
  ;

  return offset < lo || hi <= offset || ty@.kind == TY_FLOAT || ty@.kind == TY_DOUBLE;
;

has_flonum1(ty@Type)bool =
  return has_flonum(ty 0 8 0);
;

has_flonum2(ty@Type)bool =
  return has_flonum(ty 8 16 0);
;

push_struct(ty@Type) =
  let sz = align_to(ty@.size 8);
  println("  sub $%d, %%rsp" sz);
  depth += sz / 8;

  for (let i int = 0; i < ty@.size; i++) {
    println("  mov %d(%%rax), %%r10b" i);
    println("  mov %%r10b, %d(%%rsp)" i);
  ;
;

push_args2(args@Node first_pass bool opt_fpic bool) =
  if !args
    return;
  push_args2(args@.next first_pass opt_fpic);

  if ((first_pass && !args@.pass_by_stack) || (!first_pass && args@.pass_by_stack))
    return;

  gen_expr(args opt_fpic);

  switch (args@.ty@.kind) {
  case TY_STRUCT:
  case TY_UNION:
    push_struct(args@.ty);
    break;
  case TY_FLOAT:
  case TY_DOUBLE:
    pushf();
    break;
  case TY_LDOUBLE:
    println("  sub $16, %%rsp");
    println("  fstpt (%%rsp)");
    depth += 2;
    break;
  default:
    push();
  ;
;

// Load function call arguments. Arguments are already evaluated and
// stored to the stack as local variables. What we need to do in this
// function is to load them to registers or push them to the stack as
// specified by the x86-64 psABI. Here is what the spec says:
//
// - Up to 6 arguments of integral type are passed using RDI, RSI,
//   RDX, RCX, R8 and R9.
//
// - Up to 8 arguments of floating-point type are passed using XMM0 to
//   XMM7.
//
// - If all registers of an appropriate type are already used, push an
//   argument to the stack in the right-to-left order.
//
// - Each argument passed on the stack takes 8 bytes, and the end of
//   the argument area must be aligned to a 16 byte boundary.
//
// - If a function is variadic, set the number of floating-point type
//   arguments to RAX.
push_args(node@Node opt_fpic bool)int =
  let stack = 0 gp = 0 fp = 0;

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if node@.ret_buffer && node@.ty@.size > 16
    gp++;

  // Load as many arguments to the registers as possible.
  for (let arg@Node = node@.args; arg; arg = arg@.next) {
    let ty = arg@.ty;

    switch (ty@.kind) {
    case TY_STRUCT:
    case TY_UNION:
      if ty@.size > 16{
        arg@.pass_by_stack = true;
        stack += align_to(ty@.size 8) / 8;
      ; else {
        let fp1 = has_flonum1(ty);
        let fp2 = has_flonum2(ty);

        if fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX{
          fp = fp + fp1 + fp2;
          gp = gp + !fp1 + !fp2;
        ; else {
          arg@.pass_by_stack = true;
          stack += align_to(ty@.size 8) / 8;
        ;
      ;
      break;
    case TY_FLOAT:
    case TY_DOUBLE:
      if fp++ >= FP_MAX{
        arg@.pass_by_stack = true;
        stack++;
      ;
      break;
    case TY_LDOUBLE:
      arg@.pass_by_stack = true;
      stack += 2;
      break;
    default:
      if gp++ >= GP_MAX{
        arg@.pass_by_stack = true;
        stack++;
      ;
    ;
  ;

  if ((depth + stack) % 2 == 1) {
    println("  sub $8, %%rsp");
    depth++;
    stack++;
  ;

  push_args2(node@.args true opt_fpic);
  push_args2(node@.args false opt_fpic);

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if node@.ret_buffer && node@.ty@.size > 16{
    println("  lea %d(%%rbp), %%rax" node@.ret_buffer@.offset);
    push();
  ;

  return stack;
;

copy_ret_buffer(var@Obj) =
  let ty = var@.ty gp = 0 fp = 0;

  if has_flonum1(ty) {
    assert(ty@.size == 4 || 8 <= ty@.size);
    if ty@.size == 4
      println("  movss %%xmm0, %d(%%rbp)" var@.offset);
    else
      println("  movsd %%xmm0, %d(%%rbp)" var@.offset);
    fp++;
  ; else {
    for (let i int = 0; i < minl(8 ty@.size); i++) {
      let b = var@.offset + i;
      println("  mov %%al, %d(%%rbp)" b);
      println("  shr $8, %%rax");
    ;
    gp++;
  ;

  if ty@.size > 8{
    if has_flonum2(ty) {
      assert(ty@.size == 12 || ty@.size == 16);
      let b = var@.offset + 8;
      if ty@.size == 12 println("  movss %%xmm%d, %d(%%rbp)" fp b);
      else println("  movsd %%xmm%d, %d(%%rbp)" fp b);
    ; else {
      let reg1 = (gp == 0) ? "%al" : "%dl";
      let reg2 = (gp == 0) ? "%rax" : "%rdx";
      for (let i int = 8; i < minl(16 ty@.size); i++) {
        let b = var@.offset + i;
        println("  mov %s, %d(%%rbp)" reg1 b);
        println("  shr $8, %s" reg2);
      ;
    ;
  ;
;

copy_struct_reg(void) =
  let ty = current_fn@.ty@.return_ty gp = 0 fp = 0;

  println("  mov %%rax, %%rdi");

  if has_flonum(ty 0 8 0) {
    assert(ty@.size == 4 || 8 <= ty@.size);
    if ty@.size == 4
      println("  movss (%%rdi), %%xmm0");
    else
      println("  movsd (%%rdi), %%xmm0");
    fp++;
  ; else {
    println("  mov $0, %%rax");
    for (let i int = minl(8 ty@.size) - 1; i >= 0; i--) {
      println("  shl $8, %%rax");
      println("  mov %d(%%rdi), %%al" i);
    ;
    gp++;
  ;

  if ty@.size > 8{
    if has_flonum(ty 8 16 0) {
      assert(ty@.size == 12 || ty@.size == 16);
      if ty@.size == 4
        println("  movss 8(%%rdi), %%xmm%d" fp);
      else
        println("  movsd 8(%%rdi), %%xmm%d" fp);
    ; else {
      let reg1 = (gp == 0) ? "%al" : "%dl";
      let reg2 = (gp == 0) ? "%rax" : "%rdx";
      println("  mov $0, %s" reg2);
      for (let i int = minl(16 ty@.size) - 1; i >= 8; i--) {
        println("  shl $8, %s" reg2);
        println("  mov %d(%%rdi), %s" i reg1);
      ;
    ;
  ;
;

copy_struct_mem(void) =
  let ty = current_fn@.ty@.return_ty var = current_fn@.params;

  println("  mov %d(%%rbp), %%rdi" var@.offset);

  for (let i int = 0; i < ty@.size; i++) {
    println("  mov %d(%%rax), %%dl" i);
    println("  mov %%dl, %d(%%rdi)" i);
  ;
;

builtin_alloca(void) =
  // Align size to 16 bytes.
  println("  add $15, %%rdi");
  println("  and $0xfffffff0, %%edi");

  // Shift the temporary area by %rdi.
  println("  mov %d(%%rbp), %%rcx" current_fn@.alloca_bottom@.offset);
  println("  sub %%rsp, %%rcx");
  println("  mov %%rsp, %%rax");
  println("  sub %%rdi, %%rsp");
  println("  mov %%rsp, %%rdx");
  println("1:");
  println("  cmp $0, %%rcx");
  println("  je 2f");
  println("  mov (%%rax), %%r8b");
  println("  mov %%r8b, (%%rdx)");
  println("  inc %%rdx");
  println("  inc %%rax");
  println("  dec %%rcx");
  println("  jmp 1b");
  println("2:");

  // Move alloca_bottom pointer.
  println("  mov %d(%%rbp), %%rax" current_fn@.alloca_bottom@.offset);
  println("  sub %%rdi, %%rax");
  println("  mov %%rax, %d(%%rbp)" current_fn@.alloca_bottom@.offset);
;

// Generate code for a given node.
gen_expr(node@Node opt_fpic bool) =
  println("  .loc %d %d" node@.tok@.file@.file_no node@.tok@.line_no);

  switch (node@.kind) {
  case ND_NULL_EXPR:
    return;
  case ND_NUM: {
    switch (node@.ty@.kind) {
    case TY_FLOAT: {
      let u union { f32 float; u32 uint32_t; } = { node@.fval ;
      println("  mov $%u, %%eax  # float %Lf" u.u32 node@.fval);
      println("  movq %%rax, %%xmm0");
      return;
    ;
    case TY_DOUBLE: {
      let u union { f64 double u64 uint64_t; } = { node@.fval ;
      println("  mov $%lu, %%rax  # double %Lf" u.u64 node@.fval);
      println("  movq %%rax, %%xmm0");
      return;
    ;
    case TY_LDOUBLE: {
      let u union { f80 long double; u64[2]uint64_t; };
      let a = &u;
      memset(a 0 sizeof typeof u);
      u.f80 = node@.fval;
      println("  mov $%lu, %%rax  # long double %Lf" u.u64[0] node@.fval);
      println("  mov %%rax, -16(%%rsp)");
      println("  mov $%lu, %%rax" u.u64[1]);
      println("  mov %%rax, -8(%%rsp)");
      println("  fldt -16(%%rsp)");
      return;
    ;
    ;

    println("  mov $%ld, %%rax" node@.val);
    return;
  ;
  case ND_NEG:
    gen_expr(node@.lhs opt_fpic);

    switch (node@.ty@.kind) {
    case TY_FLOAT:
      println("  mov $1, %%rax");
      println("  shl $31, %%rax");
      println("  movq %%rax, %%xmm1");
      println("  xorps %%xmm1, %%xmm0");
      return;
    case TY_DOUBLE:
      println("  mov $1, %%rax");
      println("  shl $63, %%rax");
      println("  movq %%rax, %%xmm1");
      println("  xorpd %%xmm1, %%xmm0");
      return;
    case TY_LDOUBLE:
      println("  fchs");
      return;
    ;

    println("  neg %%rax");
    return;
  case ND_VAR:
    gen_addr(node opt_fpic);
    load(node@.ty);
    return;
  case ND_MEMBER: {
    gen_addr(node opt_fpic);
    load(node@.ty);

    let mem = node@.member;
    if mem@.is_bitfield{
      let b = 64 - mem@.bit_width - mem@.bit_offset;
      println("  shl $%d, %%rax" b);
      b = 64 - mem@.bit_width;
      if mem@.ty->@Type@.is_unsigned println("  shr $%d, %%rax" b);
      else println("  sar $%d, %%rax" b);
    ;
    return;
  ;
  case ND_DEREF:
    gen_expr(node@.lhs opt_fpic);
    load(node@.ty);
    return;
  case ND_ADDR:
    gen_addr(node@.lhs opt_fpic);
    return;
  case ND_ASSIGN:
    gen_addr(node@.lhs opt_fpic);
    push();
    gen_expr(node@.rhs opt_fpic);

    if node@.lhs@.kind == ND_MEMBER && node@.lhs@.member@.is_bitfield{
      println("  mov %%rax, %%r8");

      // If the lhs is a bitfield, we need to read the current value
      // from memory and merge it with a new value.
      let mem = node@.lhs@.member;
      let mask = (1L << mem@.bit_width) - 1;
      println("  mov %%rax, %%rdi");
      println("  and $%ld, %%rdi" mask);
      println("  shl $%d, %%rdi" mem@.bit_offset);

      println("  mov (%%rsp), %%rax");
      load(mem@.ty);

      mask = ~(mask << mem@.bit_offset);
      println("  mov $%ld, %%r9" mask);
      println("  and %%r9, %%rax");
      println("  or %%rdi, %%rax");
      store(node@.ty);
      println("  mov %%r8, %%rax");
      return;
    ;

    store(node@.ty);
    return;
  case ND_STMT_EXPR:
    for (let n @Node = node@.body; n; n = n@.next)
      gen_stmt(n opt_fpic);
    return;
  case ND_COMMA:
    gen_expr(node@.lhs opt_fpic);
    gen_expr(node@.rhs opt_fpic);
    return;
  case ND_CAST:
    gen_expr(node@.lhs opt_fpic);
    cast(node@.lhs@.ty node@.ty);
    return;
  case ND_MEMZERO:
    // `rep stosb` is equivalent to `memset(%rdi, %al, %rcx)`.
    println("  mov $%d, %%rcx" node@.var@.ty@.size);
    println("  lea %d(%%rbp), %%rdi" node@.var@.offset);
    println("  mov $0, %%al");
    println("  rep stosb");
    return;
  case ND_COND: {
    let c = count();
    gen_expr(node@.cond opt_fpic);
    cmp_zero(node@.cond@.ty);
    println("  je .L.else.%d" c);
    gen_expr(node@.then opt_fpic);
    println("  jmp .L.end.%d" c);
    println(".L.else.%d:" c);
    gen_expr(node@.els opt_fpic);
    println(".L.end.%d:" c);
    return;
  ;
  case ND_NOT:
    gen_expr(node@.lhs opt_fpic);
    cmp_zero(node@.lhs@.ty);
    println("  sete %%al");
    println("  movzx %%al, %%rax");
    return;
  case ND_BITNOT:
    gen_expr(node@.lhs opt_fpic);
    println("  not %%rax");
    return;
  case ND_LOGAND: {
    let c = count();
    gen_expr(node@.lhs opt_fpic);
    cmp_zero(node@.lhs@.ty);
    println("  je .L.false.%d" c);
    gen_expr(node@.rhs opt_fpic);
    cmp_zero(node@.rhs@.ty);
    println("  je .L.false.%d" c);
    println("  mov $1, %%rax");
    println("  jmp .L.end.%d" c);
    println(".L.false.%d:" c);
    println("  mov $0, %%rax");
    println(".L.end.%d:" c);
    return;
  ;
  case ND_LOGOR: {
    let c = count();
    gen_expr(node@.lhs opt_fpic);
    cmp_zero(node@.lhs@.ty);
    println("  jne .L.true.%d" c);
    gen_expr(node@.rhs opt_fpic);
    cmp_zero(node@.rhs@.ty);
    println("  jne .L.true.%d" c);
    println("  mov $0, %%rax");
    println("  jmp .L.end.%d" c);
    println(".L.true.%d:" c);
    println("  mov $1, %%rax");
    println(".L.end.%d:" c);
    return;
  ;
  case ND_FUNCALL: {
    if node@.lhs@.kind == ND_VAR && !strcmp(node@.lhs@.var@.name "alloca") {
      gen_expr(node@.args opt_fpic);
      println("  mov %%rax, %%rdi");
      builtin_alloca();
      return;
    ;

    let stack_args = push_args(node opt_fpic);
    gen_expr(node@.lhs opt_fpic);

    let gp = 0 fp = 0;

    // If the return type is a large struct/union, the caller passes
    // a pointer to a buffer as if it were the first argument.
    if node@.ret_buffer && node@.ty@.size > 16
      pop(argreg64[gp++]);

    for (let arg @Node = node@.args; arg; arg = arg@.next) {
      let ty = arg@.ty;

      switch (ty@.kind) {
      case TY_STRUCT:
      case TY_UNION:
        if ty@.size > 16
          continue;

        let fp1 = has_flonum1(ty);
        let fp2 = has_flonum2(ty);

        if fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX{
          if fp1
            popf(fp++);
          else
            pop(argreg64[gp++]);

          if ty@.size > 8{
            if fp2
              popf(fp++);
            else
              pop(argreg64[gp++]);
          ;
        ;
        break;
      case TY_FLOAT:
      case TY_DOUBLE:
        if fp < FP_MAX
          popf(fp++);
        break;
      case TY_LDOUBLE:
        break;
      default:
        if gp < GP_MAX
          pop(argreg64[gp++]);
      ;
    ;

    println("  mov %%rax, %%r10");
    println("  mov $%d, %%rax" fp);
    println("  call *%%r10");
    let b = stack_args * 8;
    println("  add $%d, %%rsp" b);

    depth -= stack_args;

    // It looks like the most significant 48 or 56 bits in RAX may
    // contain garbage if a function return type is short or bool/char,
    // respectively. We clear the upper bits here.
    switch (node@.ty@.kind) {
    case TY_BOOL:
      println("  movzx %%al, %%eax");
      return;
    case TY_CHAR:
      if node@.ty@.is_unsigned
        println("  movzbl %%al, %%eax");
      else
        println("  movsbl %%al, %%eax");
      return;
    case TY_SHORT:
      if node@.ty@.is_unsigned
        println("  movzwl %%ax, %%eax");
      else
        println("  movswl %%ax, %%eax");
      return;
    ;

    // If the return type is a small struct, a value is returned
    // using up to two registers.
    if node@.ret_buffer && node@.ty@.size <= 16{
      copy_ret_buffer(node@.ret_buffer);
      println("  lea %d(%%rbp), %%rax" node@.ret_buffer@.offset);
    ;

    return;
  ;
  case ND_LABEL_VAL:
    println("  lea %s(%%rip), %%rax" node@.unique_label);
    return;
  case ND_CAS: {
    gen_expr(node@.cas_addr opt_fpic);
    push();
    gen_expr(node@.cas_new opt_fpic);
    push();
    gen_expr(node@.cas_old opt_fpic);
    println("  mov %%rax, %%r8");
    load(node@.cas_old@.ty@.base);
    pop("%rdx"); // new
    pop("%rdi"); // addr

    let sz = node@.cas_addr@.ty@.base@.size;
    println("  lock cmpxchg %s, (%%rdi)" reg_dx(sz));
    println("  sete %%cl");
    println("  je 1f");
    println("  mov %s, (%%r8)" reg_ax(sz));
    println("1:");
    println("  movzbl %%cl, %%eax");
    return;
  ;
  case ND_EXCH: {
    gen_expr(node@.lhs opt_fpic);
    push();
    gen_expr(node@.rhs opt_fpic);
    pop("%rdi");

    let sz = node@.lhs@.ty@.base@.size;
    println("  xchg %s, (%%rdi)" reg_ax(sz));
    return;
  ;
  ;

  switch (node@.lhs@.ty@.kind) {
  case TY_FLOAT:
  case TY_DOUBLE: {
    gen_expr(node@.rhs opt_fpic);
    pushf();
    gen_expr(node@.lhs opt_fpic);
    popf(1);

    let sz = (node@.lhs@.ty@.kind == TY_FLOAT) ? "ss" : "sd";

    switch (node@.kind) {
    case ND_ADD:
      println("  add%s %%xmm1, %%xmm0" sz);
      return;
    case ND_SUB:
      println("  sub%s %%xmm1, %%xmm0" sz);
      return;
    case ND_MUL:
      println("  mul%s %%xmm1, %%xmm0" sz);
      return;
    case ND_DIV:
      println("  div%s %%xmm1, %%xmm0" sz);
      return;
    case ND_EQ:
    case ND_NE:
    case ND_LT:
    case ND_LE:
    case ND_GT:
    case ND_GE:
      println("  ucomi%s %%xmm0, %%xmm1" sz);

      if node@.kind == ND_EQ{
        println("  sete %%al");
        println("  setnp %%dl");
        println("  and %%dl, %%al");
      ; else if node@.kind == ND_NE{
        println("  setne %%al");
        println("  setp %%dl");
        println("  or %%dl, %%al");
      ;
      else if node@.kind == ND_LT println("  seta %%al");
      else if node@.kind == ND_LE println("  setae %%al");
      else if node@.kind == ND_GT println("  setb %%al");
      else if node@.kind == ND_GE println("  setbe %%al");


      println("  and $1, %%al");
      println("  movzb %%al, %%rax");
      return;
    ;

    error_tok(node@.tok "invalid expression");
  ;
  case TY_LDOUBLE: {
    gen_expr(node@.lhs opt_fpic);
    gen_expr(node@.rhs opt_fpic);

    switch (node@.kind) {
    case ND_ADD:
      println("  faddp");
      return;
    case ND_SUB:
      println("  fsubrp");
      return;
    case ND_MUL:
      println("  fmulp");
      return;
    case ND_DIV:
      println("  fdivrp");
      return;
    case ND_EQ:
    case ND_NE:
    case ND_LT:
    case ND_LE:
    case ND_GT:
    case ND_GE:
      println("  fcomip");
      println("  fstp %%st(0)");

      if node@.kind == ND_EQ
        println("  sete %%al");
      else if node@.kind == ND_NE
        println("  setne %%al");

      else if node@.kind == ND_LT println("  seta %%al");
      else if node@.kind == ND_LE println("  setae %%al");
      else if node@.kind == ND_GT println("  setb %%al");
      else if node@.kind == ND_GE println("  setbe %%al");

      println("  movzb %%al, %%rax");
      return;
    ;

    error_tok(node@.tok "invalid expression");
  ;;

  gen_expr(node@.rhs opt_fpic);
  push();
  gen_expr(node@.lhs opt_fpic);
  pop("%rdi");

  let ax = 0->@ char di = 0->@char dx = 0->@char;

  if node@.lhs@.ty@.kind == TY_LONG || node@.lhs@.ty@.base{
    ax = "%rax";
    di = "%rdi";
    dx = "%rdx";
  ; else {
    ax = "%eax";
    di = "%edi";
    dx = "%edx";
  ;

  switch (node@.kind) {
  case ND_ADD:
    println("  add %s, %s" di ax);
    return;
  case ND_SUB:
    println("  sub %s, %s" di ax);
    return;
  case ND_MUL:
    println("  imul %s, %s" di ax);
    return;
  case ND_DIV:
  case ND_MOD:
    if node@.ty@.is_unsigned{
      println("  mov $0, %s" dx);
      println("  div %s" di);
    ; else {
      if node@.lhs@.ty@.size == 8
        println("  cqo");
      else
        println("  cdq");
      println("  idiv %s" di);
    ;

    if node@.kind == ND_MOD
      println("  mov %%rdx, %%rax");
    return;
  case ND_BITAND:
    println("  and %s, %s" di ax);
    return;
  case ND_BITOR:
    println("  or %s, %s" di ax);
    return;
  case ND_BITXOR:
    println("  xor %s, %s" di ax);
    return;
  case ND_EQ:
  case ND_NE:
  case ND_LT:
  case ND_LE:
  case ND_GT:
  case ND_GE:
    println("  cmp %s, %s" di ax);

    if node@.kind == ND_EQ{
      println("  sete %%al");
    ; else if node@.kind == ND_NE{
      println("  setne %%al");
    ; else if node@.kind == ND_LT{
      if node@.lhs@.ty@.is_unsigned
        println("  setb %%al");
      else
        println("  setl %%al");
    ; else if node@.kind == ND_LE{
      if node@.lhs@.ty@.is_unsigned
        println("  setbe %%al");
      else
        println("  setle %%al");
    ; else if node@.kind == ND_GT{
      if node@.lhs@.ty@.is_unsigned
        println("  seta %%al");
      else
        println("  setg %%al");
    ; else if node@.kind == ND_GE{
      if node@.lhs@.ty@.is_unsigned
        println("  setae %%al");
      else
        println("  setge %%al");
    ;

    println("  movzb %%al, %%rax");
    return;
  case ND_SHL:
    println("  mov %%rdi, %%rcx");
    println("  shl %%cl, %s" ax);
    return;
  case ND_SHR:
    println("  mov %%rdi, %%rcx");
    if node@.lhs@.ty@.is_unsigned
      println("  shr %%cl, %s" ax);
    else
      println("  sar %%cl, %s" ax);
    return;
  ;

  error_tok(node@.tok "invalid expression");
;

gen_stmt(node@Node opt_fpic bool) =
  println("  .loc %d %d" node@.tok@.file@.file_no node@.tok@.line_no);

  switch (node@.kind) {
  case ND_IF: {
    let c = count();
    gen_expr(node@.cond opt_fpic);
    cmp_zero(node@.cond@.ty);
    println("  je  .L.else.%d" c);
    gen_stmt(node@.then opt_fpic);
    println("  jmp .L.end.%d" c);
    println(".L.else.%d:" c);
    if node@.els
      gen_stmt(node@.els opt_fpic);
    println(".L.end.%d:" c);
    return;
  ;
  case ND_FOR: {
    let c = count();
    if node@.init
      gen_stmt(node@.init opt_fpic);
    println(".L.begin.%d:" c);
    if node@.cond{
      gen_expr(node@.cond opt_fpic);
      cmp_zero(node@.cond@.ty);
      println("  je %s" node@.brk_label);
    ;
    gen_stmt(node@.then opt_fpic);
    println("%s:" node@.cont_label);
    if node@.inc
      gen_expr(node@.inc opt_fpic);
    println("  jmp .L.begin.%d" c);
    println("%s:" node@.brk_label);
    return;
  ;
  case ND_DO: {
    let c = count();
    println(".L.begin.%d:" c);
    gen_stmt(node@.then opt_fpic);
    println("%s:" node@.cont_label);
    gen_expr(node@.cond opt_fpic);
    cmp_zero(node@.cond@.ty);
    println("  jne .L.begin.%d" c);
    println("%s:" node@.brk_label);
    return;
  ;
  case ND_SWITCH:
    gen_expr(node@.cond opt_fpic);

    for (let n@Node = node@.case_next; n; n = n@.case_next) {
      let ax = (node@.cond@.ty@.size == 8) ? "%rax" : "%eax";
      let di = (node@.cond@.ty@.size == 8) ? "%rdi" : "%edi";

      println("  cmp $%ld, %s" n@.begin ax);
      println("  je %s" n@.label);
    ;

    if node@.default_case
      println("  jmp %s" node@.default_case@.label);

    println("  jmp %s" node@.brk_label);
    gen_stmt(node@.then opt_fpic);
    println("%s:" node@.brk_label);
    return;
  case ND_CASE:
    println("%s:" node@.label);
    gen_stmt(node@.lhs opt_fpic);
    return;
  case ND_BLOCK:
    for (let n@Node = node@.body; n; n = n@.next)
      gen_stmt(n opt_fpic);
    return;
  case ND_GOTO:
    println("  jmp %s" node@.unique_label);
    return;
  case ND_GOTO_EXPR:
    gen_expr(node@.lhs opt_fpic);
    println("  jmp *%%rax");
    return;
  case ND_LABEL:
    println("%s:" node@.unique_label);
    gen_stmt(node@.lhs opt_fpic);
    return;
  case ND_RETURN:
    if node@.lhs{
      gen_expr(node@.lhs opt_fpic);
      let ty = node@.lhs@.ty;

      switch (ty@.kind) {
      case TY_STRUCT:
      case TY_UNION:
        if ty@.size <= 16
          copy_struct_reg();
        else
          copy_struct_mem();
        break;
      ;
    ;

    println("  jmp .L.return.%s" current_fn@.name);
    return;
  case ND_EXPR_STMT:
    gen_expr(node@.lhs opt_fpic);
    return;
  case ND_ASM:
    println("  %s" node@.asm_str);
    return;
  ;

  error_tok(node@.tok "invalid statement");
;

// Assign offsets to local variables.
assign_lvar_offsets(prog@Obj) =
  for (let fn@Obj = prog; fn; fn = fn@.next) {
    if !fn@.is_function
      continue;

    // If a function has many parameters, some parameters are
    // inevitably passed by stack rather than by register.
    // The first passed-by-stack parameter resides at RBP+16.
    let top = 16 bottom = 0 gp = 0 fp = 0;

    // Assign offsets to pass-by-stack parameters.
    for (let var@Obj = fn@.params; var; var = var@.next) {
      let ty = var@.ty;

      switch (ty@.kind) {
      case TY_STRUCT:
      case TY_UNION:
        if ty@.size <= 16{
          let fp1 = has_flonum(ty 0 8 0);
          let fp2 = has_flonum(ty 8 16 8);
          if fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX{
            fp = fp + fp1 + fp2;
            gp = gp + !fp1 + !fp2;
            continue;
          ;
        ;
        break;
      case TY_FLOAT:
      case TY_DOUBLE:
        if fp++ < FP_MAX
          continue;
        break;
      case TY_LDOUBLE:
        break;
      default:
        if gp++ < GP_MAX
          continue;
      ;

      top = align_to(top 8);
      var@.offset = top;
      top += var@.ty@.size;
    ;

    // Assign offsets to pass-by-register parameters and local variables.
    for (let var@Obj = fn@.locals; var; var = var@.next) {
      if var@.offset
        continue;

      // AMD64 System V ABI has a special alignment rule for an array of
      // length at least 16 bytes. We need to align such array to at least
      // 16-byte boundaries. See p.14 of
      // https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-draft.pdf.
      let alignment = (var@.ty@.kind == TY_ARRAY && var@.ty@.size >= 16)
        ? maxl(16 var@.alignment) : var@.alignment;

      bottom += var@.ty@.size;
      bottom = align_to(bottom alignment);
      var@.offset = -bottom;
    ;

    fn@.stack_size = align_to(bottom 16);
  ;
;

emit_data(prog@Obj opt_fpic bool) =
  for (let var@Obj = prog; var; var = var@.next) {
    if var@.is_function || !var@.is_definition
      continue;

    if !var@.is_export
      println("  .local %s" var@.name);
    else
      println("  .globl %s" var@.name);

    let alignment = (var@.ty@.kind == TY_ARRAY && var@.ty@.size >= 16)
      ? maxl(16 var@.alignment) : var@.alignment;

    // .data or .tdata
    if var@.init_data{
      if var@.is_tls
        println("  .section .tdata,\"awT\",@progbits");
      else
        println("  .data");

      println("  .type %s, @object" var@.name);
      println("  .size %s, %d" var@.name var@.ty@.size);
      println("  .align %d" alignment);
      println("%s:" var@.name);

      let
        rel = var@.rel
        pos = 0;
      while pos < var@.ty@.size {
        if rel && rel@.offset == pos{
          println("  .quad %s%+ld" rel@.label@ rel@.addend);
          rel = rel@.next;
          pos += 8;
        ; else {
          println("  .byte %d" var@.init_data[pos++]);
        ;
      ;
      continue;
    ;

    // .bss or .tbss
    if var@.is_tls
      println("  .section .tbss,\"awT\",@nobits");
    else
      println("  .bss");

    println("  .align %d" alignment);
    println("%s:" var@.name);
    println("  .zero %d" var@.ty@.size);
  ;
;

store_fp(r int offset int sz int) =
  switch (sz) {
  case 4:
    println("  movss %%xmm%d, %d(%%rbp)" r offset);
    return;
  case 8:
    println("  movsd %%xmm%d, %d(%%rbp)" r offset);
    return;
  ;
  unreachable();
;

store_gp(r int offset int sz int) =
  switch (sz) {
  case 1:
    println("  mov %s, %d(%%rbp)" argreg8[r] offset);
    return;
  case 2:
    println("  mov %s, %d(%%rbp)" argreg16[r] offset);
    return;
  case 4:
    println("  mov %s, %d(%%rbp)" argreg32[r] offset);
    return;
  case 8:
    println("  mov %s, %d(%%rbp)" argreg64[r] offset);
    return;
  default:
    for (let i int = 0; i < sz; i++) {
      let c = offset + i;
      println("  mov %s, %d(%%rbp)" argreg8[r] c);
      println("  shr $8, %s" argreg64[r]);
    ;
    return;
  ;
;

emit_text(prog@Obj opt_fpic bool) =
  for (let fn@Obj = prog; fn; fn = fn@.next) {
    if !fn@.is_function || !fn@.is_definition
      continue;

    // No code is emitted for "static inline" functions
    // if no one is referencing them.
    if !fn@.is_live
      continue;

    if !fn@.is_export
      println("  .local %s" fn@.name);
    else
      println("  .globl %s" fn@.name);

    println("  .text");
    println("  .type %s, @function" fn@.name);
    println("%s:" fn@.name);
    current_fn = fn;

    // Prologue
    println("  push %%rbp");
    println("  mov %%rsp, %%rbp");
    println("  sub $%d, %%rsp" fn@.stack_size);
    println("  mov %%rsp, %d(%%rbp)" fn@.alloca_bottom@.offset);

    // Save arg registers if function is variadic
    if fn@.va_area {
      let
        gp = 0
        fp = 0;
      for (let var@Obj = fn@.params; var; var = var@.next) {
        if is_flonum(var@.ty)
          fp++;
        else
          gp++;
      ;

      let off = fn@.va_area@.offset;

      // va_elem
      let b = gp * 8;
      println("  movl $%d, %d(%%rbp)" b off);          // gp_offset
      b = fp * 8 + 48;
      let c = off + 4;
      println("  movl $%d, %d(%%rbp)" b c); // fp_offset
      b = off + 8;
      println("  movq %%rbp, %d(%%rbp)" b);            // overflow_arg_area
      println("  addq $16, %d(%%rbp)" b);
      b = off + 16;
      println("  movq %%rbp, %d(%%rbp)" b);           // reg_save_area
      b = off + 24; c = off + 16;
      println("  addq $%d, %d(%%rbp)" b c);

      // __reg_save_area__
      println("  movq %%rdi, %d(%%rbp)"   b);
      b += 8; println("  movq %%rsi, %d(%%rbp)"   b);
      b += 8; println("  movq %%rdx, %d(%%rbp)"   b);
      b += 8; println("  movq %%rcx, %d(%%rbp)"   b);
      b += 8; println("  movq %%r8, %d(%%rbp)"    b);
      b += 8; println("  movq %%r9, %d(%%rbp)"    b);
      b += 8; println("  movsd %%xmm0, %d(%%rbp)" b);
      b += 8; println("  movsd %%xmm1, %d(%%rbp)" b);
      b += 8; println("  movsd %%xmm2, %d(%%rbp)" b);
      b += 8; println("  movsd %%xmm3, %d(%%rbp)" b);
      b += 8; println("  movsd %%xmm4, %d(%%rbp)" b);
      b += 8; println("  movsd %%xmm5, %d(%%rbp)" b);
      b += 8; println("  movsd %%xmm6, %d(%%rbp)" b);
      b += 8; println("  movsd %%xmm7, %d(%%rbp)" b);
    ;

    // Save passed-by-register arguments to the stack
    let gp = 0 fp = 0;
    for (let var@Obj = fn@.params; var; var = var@.next) {
      if var@.offset > 0
        continue;

      let ty = var@.ty;

      switch (ty@.kind) {
      case TY_STRUCT:
      case TY_UNION:
        assert(ty@.size <= 16);
        let b = ty@.size < 8 ? ty@.size : 8;
        if has_flonum(ty 0 8 0)
          store_fp(fp++ var@.offset b);
        else
          store_gp(gp++ var@.offset b);

        if ty@.size > 8 {
          let b = var@.offset + 8 c = ty@.size - 8;
          if has_flonum(ty 8 16 0)
            store_fp(fp++ b c);
          else
            store_gp(gp++ b c);
        ;
        break;
      case TY_FLOAT:
      case TY_DOUBLE:
        store_fp(fp++ var@.offset ty@.size);
        break;
      default:
        store_gp(gp++ var@.offset ty@.size);
      ;
    ;

    // Emit code
    gen_stmt(fn@.body opt_fpic);
    assert(depth == 0);

    // [https://www.sigbus.info/n1570#5.1.2.2.3p1] The C spec defines
    // a special rule for the main function. Reaching the end of the
    // main function is equivalent to returning 0, even though the
    // behavior is undefined for the other functions.
    if strcmp(fn@.name "main") == 0
      println("  mov $0, %%rax");

    // Epilogue
    println(".L.return.%s:" fn@.name);
    println("  mov %%rbp, %%rsp");
    println("  pop %%rbp");
    println("  ret");
  ;
;

export codegen(prog@Obj out@FILE  opt_fpic) =
  output_file = out;

  let files = get_input_files();
  for (let i int = 0; files[i]; i++)
    println("  .file %d \"%s\"" files[i]@.file_no files[i]@.name);

  assign_lvar_offsets(prog);
  emit_data(prog opt_fpic);
  emit_text(prog opt_fpic);
;
