# "chub.hb"

type
  TypeID enum
    I8 I16 I32 I64
    U8 U16 U32 U64
           F32 F64 F80;;

output_file@FILE
depth i32
argreg8 []@i8 = {"%dil" "%sil" "%dl"  "%cl"  "%r8b" "%r9b";
argreg16[]@i8 = {"%di"  "%si"  "%dx"  "%cx"  "%r8w" "%r9w";
argreg32[]@i8 = {"%edi" "%esi" "%edx" "%ecx" "%r8d" "%r9d";
argreg64[]@i8 = {"%rdi" "%rsi" "%rdx" "%rcx" "%r8"  "%r9" ;
current_fn@Obj;

gen_expr(e @Node);
gen_stmt(e @Node);

println(fmt @i8 ...) =
  let ap = new va_list {;;
  (ap = (cast @__va_elem __va_area__)@);
  vfprintf output_file fmt &ap;
  (fprintf output_file "\n");;

i counti i32 = 1;
count(     ) i32 = return counti :; (counti += 1);;

push (     )     = return (println "  push %%rax") ;: (depth += 1);;
pop  (arg @i8)     = return (println "  pop %s" arg) ;: (depth -= 1);;

pushf(     )     = return (println "  sub $8, %%rsp"             ) ;: (println "  movsd %%xmm0, (%%rsp)") ;: (depth += 1);;
popf (reg   i32)     = return (println "  movsd (%%rsp), %%xmm%d" reg) ;: (println "  add $8, %%rsp"        ) ;: (depth -= 1);;

export align_to(n i32 alignment i32) i32 = return (n + alignment - 1) / alignment * alignment;;

reg_dx(sz i32) @i8 = return (sz == 1) ? "%dl"  :
                              (sz == 2) ? "%dx"  :
                              (sz == 4) ? "%edx" :
                              (sz == 8) ? "%rdx" : cast @i8 0 ;;
reg_ax(sz i32) @i8 = return (sz == 1) ? "%al"  :
                              (sz == 2) ? "%ax"  :
                              (sz == 4) ? "%eax" :
                              (sz == 8) ? "%rax" : cast @i8 0 ;;

gen_addr(e @Node) = return
  ( e.kind    == ND_VAR     ) ?
  (  e.var.is_local
  && (println "  lea %d(%%rbp), %%rax" e.var.offset)
  || (println "  mov %s@GOTPCREL(%%rip), %%rax" e.var.name) as void) :
  ( e.kind    == ND_COMMA   ) ? gen_expr e.a   ;: gen_expr e.a.s  :
  ( e.kind    == ND_THEN    ) ? gen_expr e.a   ;: (push) ;: gen_expr e.a.s  ;: pop "%rax" :
  ( e.kind    == ND_MEMBER  ) ? gen_addr e.a   ;: (println "  add $%d, %%rax" e.member.offset ) :
  ( e.kind    == ND_THE    ||
    e.kind    == ND_DEREF   ) ? gen_expr e.a  :
  ( e.kind    == ND_FUNCALL||
    e.kind    == ND_COND   ||
    e.kind    == ND_UNTIL  ||
    e.kind    == ND_LET    ||
    e.kind    == ND_REPEAT  ) ? gen_expr e      :
  ( e.t.kind == TY_STRUCT ||
    e.t.kind == TY_UNION   ) ? gen_expr e      :
  ( error_tok e.j "not an lvalue" );;
load(t @Type) = return cast void(
  t.kind == TY_ARRAY  ||
  t.kind == TY_STRUCT ||
  t.kind == TY_UNION  ||
  t.kind == TY_FUNC   ||
  ( ((t.kind == TY_RING) ? "movz" : "movs") is insn
    ((t.kind == TY_RING) ? t.a : t ) is u
    ( (u.size == 1         ) ? (println "  %sbl (%%rax), %%eax"   insn ) :
      (u.size == 2         ) ? (println "  %swl (%%rax), %%eax"   insn ) :
      (u.size == 4         ) ? (println "  movsxd (%%rax), %%rax"      ) :
                               (println "  mov (%%rax), %%rax"         ) ) ));;
store_rax_struct_union(t @Type) =
  for (let i i32 = 0; i < t.size; i += 1) {
    (println "  mov %d(%%rax), %%r8b" i);
    (println "  mov %%r8b, %d(%%rdi)" i);;;
store(t@Type) =
  pop "%rdi"      ;:
  (t.kind == TY_STRUCT ||
   t.kind == TY_UNION   ) ? store_rax_struct_union t             :
  (t.size == 1          ) ? (println "  mov %%al, (%%rdi)"      ) :
  (t.size == 2          ) ? (println "  mov %%ax, (%%rdi)"      ) :
  (t.size == 4          ) ? (println "  mov %%eax, (%%rdi)"     ) :
                             (println "  mov %%rax, (%%rdi)"     ) ;;
cmp_zero(t@Type) =
  (t.size <= 4          ) ? (println "  cmp $0, %%eax"          ) :
                             (println "  cmp $0, %%rax"          ) ;;
getTypeId(t @Type)TypeID = return
  (t.kind == TY_RING) ?
    (t.a.kind == TY_I08   ) ? U8  :
    (t.a.kind == TY_I16  ) ? U16 :
    (t.a.kind == TY_I32    ) ? U32 :
                                  U64 :
  (t.kind == TY_I08   ) ? I8  :
  (t.kind == TY_I16  ) ? I16 :
  (t.kind == TY_I32    ) ? I32 :
                           I64 ;;

i32i8 []i8 = "movsbl %al, %eax"                                   ;
i32u8 []i8 = "movzbl %al, %eax"                                   ;
i32i16[]i8 = "movswl %ax, %eax"                                   ;
i32u16[]i8 = "movzwl %ax, %eax"                                   ;
i32i64[]i8 = "movsxd %eax, %rax"                                  ;
u32i64[]i8 = "mov %eax, %eax"                                     ;

cast_table[][8]@i8 = {
  // i8   i16     i32     i64     u8     u16     u32     u64
  { 0     0      0      i32i64 i32u8 i32u16 0      i32i64 ; // i8
  { i32i8 0      0      i32i64 i32u8 i32u16 0      i32i64 ; // i16
  { i32i8 i32i16 0      i32i64 i32u8 i32u16 0      i32i64 ; // i32
  { i32i8 i32i16 0      0      i32u8 i32u16 0      0      ; // i64
  { i32i8 0      0      i32i64 0     0      0      i32i64 ; // u8
  { i32i8 i32i16 0      i32i64 i32u8 0      0      i32i64 ; // u16
  { i32i8 i32i16 0      u32i64 i32u8 i32u16 0      u32i64 ; // u32
  { i32i8 i32i16 0      0      i32u8 i32u16 0      0      ; // u64
;;
gen_cast(a@Type b@Type) = return
  (b.kind == TY_VOID) ? none :
  (b.kind == TY_BOOL) ?
    cmp_zero a                        ;:
    (println "  setne %%al"        )  ;:
    (println "  movzx %%al, %%eax" ) :
  getTypeId a is t1
  getTypeId b is t2
  (!!cast_table[t1][t2] && (println "  %s" cast_table[t1][t2]) as void) ;:
  none;;
push_struct(t@Type) =
  let sz = align_to t.size 8;
  (println "  sub $%d, %%rsp" sz);
  (depth += sz / 8);
  for (let i i32 = 0; i < t.size; i += 1) {
    (println "  mov %d(%%rax), %%r10b" i);
    (println "  mov %%r10b, %d(%%rsp)" i);;;
push_args2(args@Node first_pass bool) =
  if !args return;
  push_args2 args.s first_pass ;
  if ((first_pass && !args.pass_by_stack) || (!first_pass && args.pass_by_stack)) return;
  gen_expr args ;
  switch  args.t.kind {
  case TY_STRUCT:
  case TY_UNION:
    push_struct args.t;
    break;
  default:
    (push) ;;;

// Load function call arguments. Arguments are already evaluated and
// stored to the stack as local variables. What we need to do in this
// function is to load them to registers or push them to the stack as
// specified by the x86-64 psABI. Here is what the spec says:
//
// - Up to 6 arguments of integral type are passed using RDI, RSI,
//   RDX, RCX, R8 and R9.
//
// - Up to 8 arguments of floating-point type are passed using XMM0 to
//   XMM7.
//
// - If all registers of an appropriate type are already used, push an
//   argument to the stack in the right-to-left order.
//
// - Each argument passed on the stack takes 8 bytes, and the end of
//   the argument area must be aligned to a 16 byte boundary.
//
// - If a function is variadic, set the number of floating-point type
//   arguments to RAX.
push_args(e@Node)i32 =
  let stack = 0 gp = 0 fp = 0;

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if (!!e.ret_buffer && e.t.size > 16) (gp += 1);

  // Load as many arguments to the registers as possible.
  for (let arg@Node = e.a.s; arg; arg = arg.s) {
    let t = arg.t;

    switch  t.kind {
    case TY_STRUCT:
    case TY_UNION:
      if (t.size > 16) {
        (arg.pass_by_stack = true);
        (stack += align_to t.size 8 / 8);
      ; else {
        let fp1 = 0;
        let fp2 = 0;

        if (fp + fp1 + fp2 < 8 && gp + cast i32 !fp1 + cast i32 !fp2 < 6) {
          (fp = fp + fp1 + fp2);
          (gp = gp + cast i32 !fp1 + cast i32 !fp2);
        ; else {
          (arg.pass_by_stack = true);
          (stack += align_to t.size 8 / 8);
        ;
      ;
      break;
    default:
      if ((gp >= 6) :; (gp += 1)) {
        (arg.pass_by_stack = true);
        (stack += 1);
      ;
    ;
  ;

  if ((depth + stack) % 2 == 1) {
    (println "  sub $8, %%rsp");
    (depth += 1);
    (stack += 1);
  ;

  push_args2 e.a.s true ;
  push_args2 e.a.s false ;

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if (!!e.ret_buffer && e.t.size > 16) {
    (println "  lea %d(%%rbp), %%rax" e.ret_buffer.offset);
    (push) ;
  ;

  return stack;
;

copy_ret_buffer(var@Obj) =
  let t = var.t gp = 0 fp = 0;

  
  for (let i i32 = 0; i < minl 8l cast i64 t.size; i += 1) {
    (println "  mov %%al, %d(%%rbp)" (var.offset + i));
    (println "  shr $8, %%rax");
  ;
  (gp += 1);

  if (t.size > 8) {
    
    let reg1 = (!gp ? "%al" : "%dl");
    let reg2 = (!gp ? "%rax" : "%rdx");
    for (let i i32 = 8; i < minl 16l cast i64 t.size; i += 1) {
      (println "  mov %s, %d(%%rbp)" reg1 (var.offset + i));
      (println "  shr $8, %s" reg2);
    ;
  ;
;

copy_struct_reg() =
  let t = current_fn.t.a gp = 0 fp = 0;

  (println "  mov %%rax, %%rdi");

  (println "  mov $0, %%rax");
  for (let i i32 = (minl 8l cast i64 t.size - 1l as i32); i >= 0; i -= 1) {
    (println "  shl $8, %%rax");
    (println "  mov %d(%%rdi), %%al" i);
  ;
  (gp += 1);

  if (t.size > 8) {
    let reg1 = (!gp ? "%al" : "%dl");
    let reg2 = (!gp ? "%rax" : "%rdx");
    (println "  mov $0, %s" reg2);
    for (let i i32 = (minl 16l cast i64 t.size - 1l as i32); i >= 8; i -= 1) {
      (println "  shl $8, %s" reg2);
      (println "  mov %d(%%rdi), %s" i reg1);
    ;
  ;
;

copy_struct_mem() =
  let t = current_fn.t.a var = current_fn.params;

  (println "  mov %d(%%rbp), %%rdi" var.offset);

  for (let i i32 = 0; i < t.size; i += 1) {
    (println "  mov %d(%%rax), %%dl" i);
    (println "  mov %%dl, %d(%%rdi)" i);
  ;
;

gen_expr(e @Node) =
  (println "  .loc %d %d" e.j.file.file_no e.j.line_no);

  switch  e.kind {
  case ND_NULL_EXPR:
    return;
  case ND_THE:
    return gen_expr e.a ;
  case ND_NUM: {

    (println "  mov $%ld, %%rax" e.val);
    return;
  ;
  case ND_NEG:
    gen_expr e.a ;
    (println "  neg %%rax");
    return;
  case ND_VAR: return
    gen_addr e  ;:
    load e.t;
  case ND_MEMBER: return
    gen_addr e  ;:
    load e.t;
  case ND_DEREF: return
    gen_expr e.a  ;:
    load e.t;
  case ND_ADDR: return
    gen_addr e.a ;
  case ND_CASSIGN: return
    gen_addr e.a.a  ;:
    (push) ;:
    gen_expr e.a  ;:
    store e.a.a.t;
  case ND_ASSIGN: return
    gen_addr e.a  ;:
    (push) ;:
    gen_expr e.a.s  ;:
    store e.a.t;
  case ND_THE:
    return gen_expr e.a ;
  case ND_UNTIL: return
    (count) is c
    (println ".L.until.%d:" c) ;:
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  je .L.until.%d" c);
  case ND_LET: return
    (println "  lea %d(%%rbp), %%rax" e.var.offset ) ;:
    (push) ;:
    gen_expr e.a  ;:
    store e.a.t ;:
    gen_expr e.a.s;
  case ND_REPEAT: return
    (count) is c
    (println "  lea %d(%%rbp), %%rax" e.var.offset ) ;:
    (push) ;:
    gen_expr e.a  ;:
    (println ".L.repeat.%d:" c) ;:
    store e.a.t ;:
    (println "  lea %d(%%rbp), %%rax" e.var.offset ) ;:
    (push) ;:
    gen_expr e.a.s  ;:
    cmp_zero e.a.s.t ;:
    (println "  jne .L.repeat.%d" c) ;:
    pop "%rax" ;:
    (println "  mov 0(%%rax), %%rax");
  case ND_COMMA: return
    gen_expr e.a  ;:
    gen_expr e.a.s ;
  case ND_THEN: return
    gen_expr e.a  ;:
    (push) ;:
    gen_expr e.a.s  ;:
    pop "%rax";
  case ND_CAST: return
    gen_expr e.a  ;:
    gen_cast e.a.t e.t;
  case ND_MEMZERO: return
    (println "  mov $%d, %%rcx" e.var.t.size) ;:
    (println "  lea %d(%%rbp), %%rdi" e.var.offset) ;:
    (println "  mov $0, %%al") ;:
    (println "  rep stosb");
  case ND_COND: return
    (count) is c
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  je .L.else.%d" c) ;:
    gen_expr e.a.s  ;:
    (println "  jmp .L.end.%d" c) ;:
    (println ".L.else.%d:" c) ;:
    gen_expr e.a.s.s  ;:
    (println ".L.end.%d:" c);
  case ND_NOT: return
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  sete %%al") ;:
    (println "  movzx %%al, %%rax");
  case ND_BITNOT: return
    gen_expr e.a  ;:
    (println "  not %%rax");
  case ND_LOGAND: return
    (count) is c
    gen_expr e.a  ;:
    cmp_zero e.a.t ;:
    (println "  je .L.end.%d" c) ;:
    gen_expr e.a.s  ;:
    (println ".L.end.%d:" c);
  case ND_LOGOR: return
    (count) is c
    gen_expr e.a     ;:
    cmp_zero e.a.t          ;:
    (println "  jne .L.end.%ld" c) ;:
    gen_expr e.a.s  ;:
    (println ".L.end.%ld:" c);
  case ND_FUNCALL: {
    let stack_args = push_args e ;
    gen_expr e.a ;

    let gp = 0 fp = 0;

    // If the return type is a large struct/union, the caller passes
    // a pointer to a buffer as if it were the first argument.
    if (!!e.ret_buffer && e.t.size > 16) pop argreg64[gp :; (gp += 1)];

    for (let arg @Node = e.a.s; arg; arg = arg.s) {
      let t = arg.t;
      switch  t.kind {
      case TY_STRUCT:
      case TY_UNION:
        if !(t.size > 16) {
          let fp1 = 0;
          let fp2 = 0;
          if (fp + fp1 + fp2 < 8 && gp + cast i32 !fp1 + cast i32 !fp2 < 6) {
            if fp1 popf (fp :; (fp += 1));
            else pop argreg64[((gp :; (gp+=1)))];
            if (t.size > 8) {
              if fp2 popf ((fp :; (fp+=1)));
              else pop argreg64[((gp :; (gp+=1)))];;;;
        break;
      default: if (gp < 6) pop argreg64[((gp :; (gp+=1)))];
      ;
    ;

    (println "  mov %%rax, %%r10");
    (println "  mov $%d, %%rax" fp);
    (println "  call *%%r10");
    (println "  add $%d, %%rsp" (stack_args * 8));

    (depth -= stack_args);

    // It looks like the most significant 48 or 56 bits in RAX may
    // contain garbage if a function return type is i16 or bool/i8,
    // respectively. We clear the upper bits here.
    switch  e.t.kind {
    case TY_BOOL:
      (println "  movzx %%al, %%eax");
      return;
    case TY_I08:
      if (e.t.kind == TY_RING)
        (println "  movzbl %%al, %%eax");
      else
        (println "  movsbl %%al, %%eax");
      return;
    case TY_I16:
      if (e.t.kind == TY_RING)
        (println "  movzwl %%ax, %%eax");
      else
        (println "  movswl %%ax, %%eax");
      return;
    ;

    // If the return type is a small struct, a value is returned
    // using up to two registers.
    if (!!e.ret_buffer && e.t.size <= 16) {
      copy_ret_buffer e.ret_buffer;
      (println "  lea %d(%%rbp), %%rax" e.ret_buffer.offset);
    ;

    return;
  ;
  ;

  gen_expr e.a.s ;
  ((push)) ;
  gen_expr e.a ;
  pop "%rdi";

  let ax = cast @i8 0 di = cast @i8 0 dx = cast @i8 0;

  if (e.a.t.kind == TY_I64 || !!e.a.t.a) {
    (ax = "%rax");
    (di = "%rdi");
    (dx = "%rdx");
  ; else {
    (ax = "%eax");
    (di = "%edi");
    (dx = "%edx");
  ;

  switch  e.kind {
  case ND_ADD:
    return
    ((e.a.t.kind == TY_PTR || e.a.t.kind == TY_ARRAY) && (println "  imul $%d, %s" e.a.t.a.size di) as void) ;:
    ((e.a.s.t.kind == TY_PTR || e.a.s.t.kind == TY_ARRAY) && (println "  imul $%d, %s" e.a.s.t.a.size ax) as void) ;:
    (println "  add %s, %s" di ax);
  case ND_SUB:
    return
    ((e.a.t.kind == TY_PTR || e.a.t.kind == TY_ARRAY) && !(e.a.s.t.kind == TY_PTR || e.a.s.t.kind == TY_ARRAY) && (println "  imul $%d, %s" e.a.t.a.size di) as void) ;:
    (println "  sub %s, %s" di ax) ;:
    ((e.a.s.t.kind == TY_PTR || e.a.s.t.kind == TY_ARRAY) && (println "  mov $%d,%s" e.a.s.t.a.size di) ;: (println "  mov $0, %s" dx) ;: (println "  div %s" di) as void);
  case ND_MUL:
    (println "  imul %s, %s" di ax);
    return;
  case ND_DIV:
  case ND_MOD:
    if (e.t.kind == TY_RING) {
      (println "  mov $0, %s" dx);
      (println "  div %s" di);
    ; else {
      if (e.a.t.size == 8) (println "  cqo");
      else (println "  cdq");
      (println "  idiv %s" di);
    ;

    if (e.kind == ND_MOD) (println "  mov %%rdx, %%rax");
    return;
  case ND_BITAND:
    (println "  and %s, %s" di ax);
    return;
  case ND_BITOR:
    (println "  or %s, %s" di ax);
    return;
  case ND_BITXOR:
    (println "  xor %s, %s" di ax);
    return;
  case ND_EQ:
  case ND_NE:
  case ND_LT:
  case ND_LE:
  case ND_GT:
  case ND_GE:
    (println "  cmp %s, %s" di ax);

    if (e.kind == ND_EQ) {
      (println "  sete %%al");
    ; else if (e.kind == ND_NE) {
      (println "  setne %%al");
    ; else if (e.kind == ND_LT) {
      if (e.a.t.kind == TY_RING)
        (println "  setb %%al");
      else
        (println "  setl %%al");
    ; else if (e.kind == ND_LE){
      if (e.a.t.kind == TY_RING)
        (println "  setbe %%al");
      else
        (println "  setle %%al");
    ; else if (e.kind == ND_GT){
      if (e.a.t.kind == TY_RING)
        (println "  seta %%al");
      else
        (println "  setg %%al");
    ; else if (e.kind == ND_GE){
      if (e.a.t.kind == TY_RING)
        (println "  setae %%al");
      else
        (println "  setge %%al");
    ;

    (println "  movzb %%al, %%rax");
    return;
  case ND_SHL:
    (println "  mov %%rdi, %%rcx");
    (println "  shl %%cl, %s" ax);
    return;
  case ND_SHR:
    (println "  mov %%rdi, %%rcx");
    if (e.a.t.kind == TY_RING)
      (println "  shr %%cl, %s" ax);
    else
      (println "  sar %%cl, %s" ax);
    return;
  ;

  (error_tok e.j "invalid expression");
;

gen_stmt(e@Node) =
  (println "  .loc %d %d" e.j.file.file_no e.j.line_no);

  switch  e.kind {
  case ND_IF: {
    let c = (count) ;
    gen_expr e.cond ;
    cmp_zero e.cond.t;
    (println "  je  .L.else.%d" c);
    gen_stmt e.then ;
    (println "  jmp .L.end.%d" c);
    (println ".L.else.%d:" c);
    if e.els gen_stmt e.els ;
    (println ".L.end.%d:" c);
    return;
  ;
  case ND_FOR: {
    let c = (count) ;
    if e.init gen_stmt e.init ;
    (println ".L.begin.%d:" c);
    if e.cond{
      gen_expr e.cond ;
      cmp_zero e.cond.t;
      (println "  je %s" e.brk_label);
    ;
    gen_stmt e.then ;
    (println "%s:" e.cont_label);
    if e.inc gen_expr e.inc ;
    (println "  jmp .L.begin.%d" c);
    (println "%s:" e.brk_label);
    return;
  ;
  case ND_DO: {
    let c = (count) ;
    (println ".L.begin.%d:" c);
    gen_stmt e.then ;
    (println "%s:" e.cont_label);
    gen_expr e.cond ;
    cmp_zero e.cond.t;
    (println "  jne .L.begin.%d" c);
    (println "%s:" e.brk_label);
    return;
  ;
  case ND_SWITCH:
    gen_expr e.cond ;

    for (let n@Node = e.case_next; n; n = n.case_next) {
      let ax = ((e.cond.t.size == 8) ? "%rax" : "%eax");
      let di = ((e.cond.t.size == 8) ? "%rdi" : "%edi");

      (println "  cmp $%ld, %s" n.begin ax);
      (println "  je %s" n.label);
    ;

    if e.default_case (println "  jmp %s" e.default_case.label);
    (println "  jmp %s" e.brk_label);
    gen_stmt e.then ;
    (println "%s:" e.brk_label);
    return;
  case ND_CASE:
    (println "%s:" e.label);
    gen_stmt e.a ;
    return;
  case ND_BLOCK:
    for (let n@Node = e.body; n; n = n.s) gen_stmt n ;
    return;
  case ND_GOTO:
    (println "  jmp %s" e.unique_label);
    return;
  case ND_LABEL:
    (println "%s:" e.unique_label);
    gen_stmt e.a ;
    return;
  case ND_RETURN:
    if e.a{
      gen_expr e.a ;
      let t = e.a.t;
      switch  t.kind {
      case TY_STRUCT:
      case TY_UNION:
        if (t.size <= 16) (copy_struct_reg) ;
        else (copy_struct_mem) ;
        break;
      ;
    ;

    ((println "  jmp .L.return.%s" current_fn.name));
    return;
  case ND_EXPR_STMT:
    gen_expr e.a ;
    return;
  case ND_ASM:
    (println "  %s" e.asm_str);
    return;
  ;

  (error_tok e.j "invalid statement");
;

assign_one_param_offset(var @Obj top @i32 gp @i32 fp @i32) =
  let t = var.t;
  switch  t.kind {
    case TY_STRUCT:
    case TY_UNION:none;
      let fp1 = 0;
      let fp2 = 0;
      if (!(fp@ + fp1 + fp2 < 8 && gp@ + cast i32 !fp1 + cast i32 !fp2 < 6) && t.size > 16) {
        (fp@ = fp@ +           fp1 +           fp2);
        (gp@ = gp@ + cast i32 !fp1 + cast i32 !fp2);
        return;;
    default       : if ((gp@ :; (gp@ += 1)) < 6) return;;
  (top@ = align_to top@ 8);
  (var.offset = top@);
  (top@ += var.t.size);;
assign_param_offsets(fn @Obj) =
  let top = 16 gp = 0 fp = 0;
  for (let var @Obj = fn.params; var; var = var.s)
    assign_one_param_offset var &top &gp &fp;;

assign_one_lvar_offset(fn @Obj) =
  if !fn.is_function return;
  assign_param_offsets fn;
  let bottom = 0;
  for (let var@Obj = fn.locals; var; var = var.s)
    if !var.offset {
    let alignment = var.alignment as i64;
    (bottom += var.t.size);
    (bottom = align_to bottom alignment);
    (var.offset = -bottom);;
  (fn.stack_size = align_to bottom 16);;
assign_lvar_offsets(prog @Obj) =
  for (let fn @Obj = prog; fn; fn = fn.s)
    assign_one_lvar_offset fn;;

emit_data(prog @Obj) =
  for (let var@Obj = prog; var; var = var.s)
    if !(var.is_function || !var.is_definition) {
    if !var.is_export (println "  .local %s" var.name);
    else (println "  .globl %s" var.name);

    let alignment = ((var.t.kind == TY_ARRAY && var.t.size >= 16)
      ? maxl 16l cast i64 var.alignment : cast i64 var.alignment);

    // .data or .tdata
    if var.init_data{
      if var.is_tls
        (println "  .section .tdata,\"awT\",@progbits");
      else
        (println "  .data");

      (println "  .type %s, @object" var.name);
      (println "  .size %s, %d" var.name var.t.size);
      (println "  .align %d" alignment);
      (println "%s:" var.name);

      let
        rel = var.rel
        pos = 0;
      while (pos < var.t.size) {
        if (!!rel && rel.offset == pos) {
          (println "  .quad %s%+ld" rel.label@ rel.addend);
          (rel = rel.s);
          (pos += 8);
        ; else {
          (println "  .byte %d" var.init_data[((pos :; (pos+=1)))]);
        ;
      ;
    ;
    else {
      // .bss or .tbss
      if var.is_tls
        (println "  .section .tbss,\"awT\",@nobits");
      else
        (println "  .bss");

      (println "  .align %d" alignment);
      (println "%s:" var.name);
      (println "  .zero %d" var.t.size);
  ;;
;

store_fp(r i32 offset i32 sz i32) = 
  (sz == 4) ? (println "  movss %%xmm%d, %d(%%rbp)" r offset ):
  (sz == 8) ? (println "  movsd %%xmm%d, %d(%%rbp)" r offset ):
              none;;

store_gp(r i32 offset i32 sz i32) =
  switch  sz {
  case 1:
    (println "  mov %s, %d(%%rbp)" argreg8[r] offset);
    return;
  case 2:
    (println "  mov %s, %d(%%rbp)" argreg16[r] offset);
    return;
  case 4:
    (println "  mov %s, %d(%%rbp)" argreg32[r] offset);
    return;
  case 8:
    (println "  mov %s, %d(%%rbp)" argreg64[r] offset);
    return;
  default:
    for (let i i32 = 0; i < sz; ((i :; (i+=1)))) {
      (println "  mov %s, %d(%%rbp)" argreg8[r] (offset + i));
      (println "  shr $8, %s" argreg64[r]);
    ;
    return;
  ;
;

emit_text(prog@Obj) =
  for (let fn@Obj = prog; fn; fn = fn.s)
    if (!(!fn.is_function || !fn.is_definition) && fn.is_live) {

    if !fn.is_export (println "  .local %s" fn.name);
    else             (println "  .globl %s" fn.name);

    (println "  .text");
    (println "  .type %s, @function" fn.name);
    (println "%s:" fn.name);
    (current_fn = fn);

    // Prologue
    (println "  push %%rbp");
    (println "  mov %%rsp, %%rbp");
    (println "  sub $%d, %%rsp" fn.stack_size);
    (println "  mov %%rsp, %d(%%rbp)" fn.alloca_bottom.offset);

    // Save arg registers if function is variadic
    if fn.va_area {
      let
        gp = 0
        fp = 0;
      for (let var@Obj = fn.params; var; var = var.s) {
          ((gp :; (gp+=1)));
      ;

      let off = fn.va_area.offset;

      // va_elem
      (println "  movl $%d, %d(%%rbp)" (gp * 8) off);          // gp_offset
      (println "  movl $%d, %d(%%rbp)" (fp * 8 + 48) (off + 4)); // fp_offset
      (println "  movq %%rbp, %d(%%rbp)" (off + 8));            // overflow_arg_area
      (println "  addq $16, %d(%%rbp)" (off + 8));
      (println "  movq %%rbp, %d(%%rbp)" (off + 16));           // reg_save_area
      (println "  addq $%d, %d(%%rbp)" (off + 24) (off + 16));

      let b = (off + 24);
      // __reg_save_area__
      (println "  movq %%rdi, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rsi, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rdx, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rcx, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%r8, %d(%%rbp)"    b);
      (b += 8); (println "  movq %%r9, %d(%%rbp)"    b);
      (b += 8); (println "  movsd %%xmm0, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm1, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm2, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm3, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm4, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm5, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm6, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm7, %d(%%rbp)" b);
    ;

    (  0 is gp
       0 is fp
       fn.params for o
      (  !!o
      && o.s
      :;(  o.offset <= 0
        && o.t is t
          (  t.kind == TY_STRUCT
          || t.kind == TY_UNION ) ?
            cast i32 minl cast i64 t.size 8l is b
            ( store_gp (gp :; (gp+=1)) o.offset b )
            ;:(  (t.size   > 8)
              && (o.offset + 8) is b
                 (t.size   - 8) is c
                 store_gp (gp :; (gp+=1)) b c as void) :
          store_gp ((gp :; (gp+=1))) o.offset t.size
        as void ) )
    as void )
    ;: gen_stmt cast @Node fn.body
    ;: (! strcmp cast @ fn.name "main" && (println "  mov $0, %%rax") as void)
    ;: (println ".L.return.%s:" fn.name)
    ;: (println "  mov %%rbp, %%rsp")
    ;: (println "  pop %%rbp")
    ;: (println "  ret");;;

export codegen(prog@Obj out@FILE) = return
  (output_file = out) ;:
  (input_files) is files
  (  0 for i 
    (  !!files[i] && (i + 1) :;
    (println "  .file %d \"%s\"" files[i].file_no files[i].name) ) as void) ;:
  assign_lvar_offsets prog ;:
  emit_data prog  ;:
  emit_text prog ;;
