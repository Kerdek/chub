#include "chub.hb"

#define GP_MAX 6
#define FP_MAX 8

type
  TypeID enum
    I8 I16 I32 I64
    U8 U16 U32 U64
           F32 F64 F80;;

output_file@FILE
depth int
argreg8 []@char = {"%dil" "%sil" "%dl"  "%cl"  "%r8b" "%r9b";
argreg16[]@char = {"%di"  "%si"  "%dx"  "%cx"  "%r8w" "%r9w";
argreg32[]@char = {"%edi" "%esi" "%edx" "%ecx" "%r8d" "%r9d";
argreg64[]@char = {"%rdi" "%rsi" "%rdx" "%rcx" "%r8"  "%r9" ;
current_fn@Obj;

gen_expr(e @Node fpic bool);
gen_stmt(e @Node fpic bool);

__attribute__((format(printf, 1, 2)))
println(fmt @char ...) =
  let ap = new va_list {;;
  va_start(ap, fmt);
  vfprintf output_file fmt &ap;
  va_end(ap)
  (fprintf output_file "\n");;

i counti int = 1;
count(void     ) int = return counti :; (counti += 1);;

push (void     )     = return (println "  push %%rax") ;: (depth += 1);;
pop  (arg @char)     = return (println "  pop %s" arg) ;: (depth -= 1);;

pushf(void     )     = return (println "  sub $8, %%rsp"             ) ;: (println "  movsd %%xmm0, (%%rsp)") ;: (depth += 1);;
popf (reg   int)     = return (println "  movsd (%%rsp), %%xmm%d" reg) ;: (println "  add $8, %%rsp"        ) ;: (depth -= 1);;

export align_to(n int alignment int) int = return (n + alignment - 1) / alignment * alignment;;

reg_dx(sz int) @char = return (sz == 1) ? "%dl"  :
                              (sz == 2) ? "%dx"  :
                              (sz == 4) ? "%edx" :
                              (sz == 8) ? "%rdx" : cast @char 0 ;;
reg_ax(sz int) @char = return (sz == 1) ? "%al"  :
                              (sz == 2) ? "%ax"  :
                              (sz == 4) ? "%eax" :
                              (sz == 8) ? "%rax" : cast @char 0 ;;

gen_addr(e @Node fpic bool) = return
  (e.kind == ND_VAR) ?
    e.var.is_local ?
      (println "  lea %d(%%rbp), %%rax" e.var.offset ):
    fpic ?
      e.var.is_tls ?
        (println "  data16 lea %s@tlsgd(%%rip), %%rdi" e.var.name) ;:
        (println "  .value 0x6666") ;:
        (println "  rex64") ;:
        (println "  call __tls_get_addr@PLT" ):
      (println "  mov %s@GOTPCREL(%%rip), %%rax" e.var.name ) :
    e.var.is_tls ?
      (println "  mov %%fs:0, %%rax") ;:
      (println "  add $%s@tpoff, %%rax" e.var.name ) :
    (e.ty.kind == TY_FUNC) ?
      e.var.is_definition ?
        (println "  lea %s(%%rip), %%rax" e.var.name ):
        (println "  mov %s@GOTPCREL(%%rip), %%rax" e.var.name ):
    (println "  lea %s(%%rip), %%rax" e.var.name ):
  ( e.kind    == ND_COMMA   ) ? gen_expr e.lhs fpic  ;: gen_expr e.rhs fpic :
  ( e.kind    == ND_MEMBER  ) ? gen_addr e.lhs fpic  ;: (println "  add $%d, %%rax" e.member.offset ) :
  ( e.kind    == ND_THE    ||
    e.kind    == ND_DEREF   ) ? gen_expr e.lhs fpic :
  ( e.kind    == ND_FUNCALL||
    e.kind    == ND_COND   ||
    e.kind    == ND_UNTIL  ||
    e.kind    == ND_REPEAT  ) ? gen_expr e     fpic :
  ( e.ty.kind == TY_STRUCT ||
    e.ty.kind == TY_UNION   ) ? gen_expr e     fpic :
  ( error_tok e.tok "not an lvalue" );;
load(t @Type) = return cast void(
  t.kind == TY_ARRAY  ||
  t.kind == TY_STRUCT ||
  t.kind == TY_UNION  ||
  t.kind == TY_FUNC   ||
  ( (t.kind == TY_FLOAT  ) ? (println "  movss (%%rax), %%xmm0"      ) :
    (t.kind == TY_DOUBLE ) ? (println "  movsd (%%rax), %%xmm0"      ) :
    (t.kind == TY_LDOUBLE) ? (println "  fldt (%%rax)"               ) :
    (t.is_unsigned ? "movz" : "movs") is insn
    ( (t.size == 1         ) ? (println "  %sbl (%%rax), %%eax"   insn ) :
    (t.size == 2         ) ? (println "  %swl (%%rax), %%eax"   insn ) :
    (t.size == 4         ) ? (println "  movsxd (%%rax), %%rax"      ) :
                             (println "  mov (%%rax), %%rax"         ) ) ));;
store_rax_struct_union(t @Type) =
  for (let i int = 0; i < t.size; i += 1) {
    (println "  mov %d(%%rax), %%r8b" i);
    (println "  mov %%r8b, %d(%%rdi)" i);;;
store(ty@Type) =
  pop "%rdi"      ;:
  (ty.kind == TY_STRUCT ||
   ty.kind == TY_UNION   ) ? store_rax_struct_union ty             :
  (ty.kind == TY_FLOAT   ) ? (println "  movss %%xmm0, (%%rdi)"  ) :
  (ty.kind == TY_DOUBLE  ) ? (println "  movsd %%xmm0, (%%rdi)"  ) :
  (ty.kind == TY_LDOUBLE ) ? (println "  fstpt (%%rdi)"          ) : 
  (ty.size == 1          ) ? (println "  mov %%al, (%%rdi)"      ) :
  (ty.size == 2          ) ? (println "  mov %%ax, (%%rdi)"      ) :
  (ty.size == 4          ) ? (println "  mov %%eax, (%%rdi)"     ) :
                             (println "  mov %%rax, (%%rdi)"     ) ;;
cmp_zero(ty@Type) =
  (ty.kind == TY_FLOAT   ) ? (println "  xorps %%xmm1, %%xmm1"   )  ;:
                             (println "  ucomiss %%xmm1, %%xmm0" ) :
  (ty.kind == TY_DOUBLE  ) ? (println "  xorpd %%xmm1, %%xmm1"   )  ;:
                             (println "  ucomisd %%xmm1, %%xmm0" ) :
  (ty.kind == TY_LDOUBLE ) ? (println "  fldz"                   )  ;:
                             (println "  fucomip"                )  ;:
                             (println "  fstp %%st(0)"           ) :
  (is_integer ty        &&
   ty.size <= 4          ) ? (println "  cmp $0, %%eax"          ) :
                             (println "  cmp $0, %%rax"          ) ;;
getTypeId(ty @Type)TypeID = return
  (ty.kind == TY_FLOAT  ) ?                  F32 :
  (ty.kind == TY_DOUBLE ) ?                  F64 :
  (ty.kind == TY_LDOUBLE) ?                  F80 :
  (ty.kind == TY_CHAR   ) ? ty.is_unsigned ? U8  : 
                                             I8  :
  (ty.kind == TY_SHORT  ) ? ty.is_unsigned ? U16 : 
                                             I16 :
  (ty.kind == TY_INT    ) ? ty.is_unsigned ? U32 : 
                                             I32 :
  (ty.kind == TY_LONG   ) ? ty.is_unsigned ? U64 : 
                                             I64 :
                                             U64 ;;

i32i8 []char = "movsbl %al, %eax"                                   ;
i32u8 []char = "movzbl %al, %eax"                                   ;
i32i16[]char = "movswl %ax, %eax"                                   ;
i32u16[]char = "movzwl %ax, %eax"                                   ;
i32f32[]char = "cvtsi2ssl %eax, %xmm0"                              ;
i32i64[]char = "movsxd %eax, %rax"                                  ;
i32f64[]char = "cvtsi2sdl %eax, %xmm0"                              ;
i32f80[]char = "mov %eax, -4(%rsp); fildl -4(%rsp)"                 ;
              
u32f32[]char = "mov %eax, %eax; cvtsi2ssq %rax, %xmm0"              ;
u32i64[]char = "mov %eax, %eax"                                     ;
u32f64[]char = "mov %eax, %eax; cvtsi2sdq %rax, %xmm0"              ;
u32f80[]char = "mov %eax, %eax; mov %rax, -8(%rsp); fildll -8(%rsp)";

i64f32[]char = "cvtsi2ssq %rax, %xmm0";
i64f64[]char = "cvtsi2sdq %rax, %xmm0";
i64f80[]char = "movq %rax, -8(%rsp); fildll -8(%rsp)";

u64f32[]char = "cvtsi2ssq %rax, %xmm0";
u64f64[]char = "test %rax,%rax; js 1f; pxor %xmm0,%xmm0; cvtsi2sd %rax,%xmm0; jmp 2f; 1: mov %rax,%rdi; and $1,%eax; pxor %xmm0,%xmm0; shr %rdi; or %rax,%rdi; cvtsi2sd %rdi,%xmm0; addsd %xmm0,%xmm0; 2:";
u64f80[]char = "mov %rax, -8(%rsp); fildq -8(%rsp); test %rax, %rax; jns 1f; mov $1602224128, %eax; mov %eax, -4(%rsp); fadds -4(%rsp); 1:";

f32i8 []char = "cvttss2sil %xmm0, %eax; movsbl %al, %eax";
f32u8 []char = "cvttss2sil %xmm0, %eax; movzbl %al, %eax";
f32i16[]char = "cvttss2sil %xmm0, %eax; movswl %ax, %eax";
f32u16[]char = "cvttss2sil %xmm0, %eax; movzwl %ax, %eax";
f32i32[]char = "cvttss2sil %xmm0, %eax"                  ;
f32u32[]char = "cvttss2siq %xmm0, %rax"                  ;
f32i64[]char = "cvttss2siq %xmm0, %rax"                  ;
f32u64[]char = "cvttss2siq %xmm0, %rax"                  ;
f32f64[]char = "cvtss2sd %xmm0, %xmm0"                   ;
f32f80[]char = "movss %xmm0, -4(%rsp); flds -4(%rsp)"    ;

f64i8 []char = "cvttsd2sil %xmm0, %eax; movsbl %al, %eax";
f64u8 []char = "cvttsd2sil %xmm0, %eax; movzbl %al, %eax";
f64i16[]char = "cvttsd2sil %xmm0, %eax; movswl %ax, %eax";
f64u16[]char = "cvttsd2sil %xmm0, %eax; movzwl %ax, %eax";
f64i32[]char = "cvttsd2sil %xmm0, %eax"                  ;
f64u32[]char = "cvttsd2siq %xmm0, %rax"                  ;
f64i64[]char = "cvttsd2siq %xmm0, %rax"                  ;
f64u64[]char = "cvttsd2siq %xmm0, %rax"                  ;
f64f32[]char = "cvtsd2ss %xmm0, %xmm0"                   ;
f64f80[]char = "movsd %xmm0, -8(%rsp); fldl -8(%rsp)"    ;

f80i8 []char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movsbl -24(%rsp), %eax"
f80u8 []char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movzbl -24(%rsp), %eax"
f80i16[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistps -24(%rsp); fldcw -10(%rsp); movzbl -24(%rsp), %eax"
f80u16[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); movswl -24(%rsp), %eax"
f80i32[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %eax"
f80u32[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpl -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %eax"
f80i64[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpq -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %rax"
f80u64[]char = "fnstcw -10(%rsp); movzwl -10(%rsp), %eax; or $12, %ah; mov %ax, -12(%rsp); fldcw -12(%rsp); fistpq -24(%rsp); fldcw -10(%rsp); mov -24(%rsp), %rax"
f80f32[]char = "fstps -8(%rsp); movss -8(%rsp), %xmm0"
f80f64[]char = "fstpl -8(%rsp); movsd -8(%rsp), %xmm0";

cast_table[][11]@char = {
  // i8   i16     i32     i64     u8     u16     u32     u64     f32     f64     f80
  { 0     0      0      i32i64 i32u8 i32u16 0      i32i64 i32f32 i32f64 i32f80 ; // i8
  { i32i8 0      0      i32i64 i32u8 i32u16 0      i32i64 i32f32 i32f64 i32f80 ; // i16
  { i32i8 i32i16 0      i32i64 i32u8 i32u16 0      i32i64 i32f32 i32f64 i32f80 ; // i32
  { i32i8 i32i16 0      0      i32u8 i32u16 0      0      i64f32 i64f64 i64f80 ; // i64
  { i32i8 0      0      i32i64 0     0      0      i32i64 i32f32 i32f64 i32f80 ; // u8
  { i32i8 i32i16 0      i32i64 i32u8 0      0      i32i64 i32f32 i32f64 i32f80 ; // u16
  { i32i8 i32i16 0      u32i64 i32u8 i32u16 0      u32i64 u32f32 u32f64 u32f80 ; // u32
  { i32i8 i32i16 0      0      i32u8 i32u16 0      0      u64f32 u64f64 u64f80 ; // u64
  { f32i8 f32i16 f32i32 f32i64 f32u8 f32u16 f32u32 f32u64 0      f32f64 f32f80 ; // f32
  { f64i8 f64i16 f64i32 f64i64 f64u8 f64u16 f64u32 f64u64 f64f32 0      f64f80 ; // f64
  { f80i8 f80i16 f80i32 f80i64 f80u8 f80u16 f80u32 f80u64 f80f32 f80f64 0      ; // f80
;;
gen_cast(a@Type b@Type) = return
  (b.kind == TY_VOID) ? none :
  (b.kind == TY_BOOL) ?
    cmp_zero a                        ;:
    (println "  setne %%al"        )  ;:
    (println "  movzx %%al, %%eax" ) :
  getTypeId a is t1
  getTypeId b is t2
  (!!cast_table[t1][t2] && (println "  %s" cast_table[t1][t2])) ;:
  none;;
has_flonum(ty@Type lo int hi int offset int) bool =
  if (ty.kind == TY_STRUCT || ty.kind == TY_UNION) {
    for (let mem@Member = ty.members; mem; mem = mem.next) if !has_flonum cast @Type mem.ty lo hi (offset + mem.offset) return false;
    return true;;
  if (ty.kind == TY_ARRAY) {
    for (let i int = 0; i < ty.array_len; i += 1) if !has_flonum ty.base lo hi (offset + ty.base.size * i) return false;
    return true;;
  return offset < lo || hi <= offset || ty.kind == TY_FLOAT || ty.kind == TY_DOUBLE;;
has_flonum1(ty@Type)bool = return has_flonum ty 0 8 0;;
has_flonum2(ty@Type)bool = return has_flonum ty 8 16 0;;
push_struct(ty@Type) =
  let sz = align_to ty.size 8;
  (println "  sub $%d, %%rsp" sz);
  (depth += sz / 8);
  for (let i int = 0; i < ty.size; i += 1) {
    (println "  mov %d(%%rax), %%r10b" i);
    (println "  mov %%r10b, %d(%%rsp)" i);;;
push_args2(args@Node first_pass bool fpic bool) =
  if !args return;
  push_args2 args.next first_pass fpic;
  if ((first_pass && !args.pass_by_stack) || (!first_pass && args.pass_by_stack)) return;
  gen_expr args fpic;
  switch  args.ty.kind {
  case TY_STRUCT:
  case TY_UNION:
    push_struct args.ty;
    break;
  case TY_FLOAT:
  case TY_DOUBLE:
    pushf ;
    break;
  case TY_LDOUBLE:
    (println "  sub $16, %%rsp");
    (println "  fstpt (%%rsp)");
    (depth += 2);
    break;
  default:
    push ;;;

// Load function call arguments. Arguments are already evaluated and
// stored to the stack as local variables. What we need to do in this
// function is to load them to registers or push them to the stack as
// specified by the x86-64 psABI. Here is what the spec says:
//
// - Up to 6 arguments of integral type are passed using RDI, RSI,
//   RDX, RCX, R8 and R9.
//
// - Up to 8 arguments of floating-point type are passed using XMM0 to
//   XMM7.
//
// - If all registers of an appropriate type are already used, push an
//   argument to the stack in the right-to-left order.
//
// - Each argument passed on the stack takes 8 bytes, and the end of
//   the argument area must be aligned to a 16 byte boundary.
//
// - If a function is variadic, set the number of floating-point type
//   arguments to RAX.
push_args(e@Node fpic bool)int =
  let stack = 0 gp = 0 fp = 0;

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if (!!e.ret_buffer && e.ty.size > 16) (gp += 1);

  // Load as many arguments to the registers as possible.
  for (let arg@Node = e.args; arg; arg = arg.next) {
    let ty = arg.ty;

    switch  ty.kind {
    case TY_STRUCT:
    case TY_UNION:
      if (ty.size > 16) {
        (arg.pass_by_stack = true);
        (stack += align_to ty.size 8 / 8);
      ; else {
        let fp1 = has_flonum1 ty;
        let fp2 = has_flonum2 ty;

        if (fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX) {
          (fp = fp + fp1 + fp2);
          (gp = gp + !fp1 + !fp2);
        ; else {
          (arg.pass_by_stack = true);
          (stack += align_to ty.size 8 / 8);
        ;
      ;
      break;
    case TY_FLOAT:
    case TY_DOUBLE:
      if ((fp >= FP_MAX) :; (fp += 1)) {
        (arg.pass_by_stack = true);
        (stack += 1);
      ;
      break;
    case TY_LDOUBLE:
      (arg.pass_by_stack = true);
      (stack += 2);
      break;
    default:
      if ((gp >= GP_MAX) :; (gp += 1)) {
        (arg.pass_by_stack = true);
        (stack += 1);
      ;
    ;
  ;

  if ((depth + stack) % 2 == 1) {
    (println "  sub $8, %%rsp");
    (depth += 1);
    (stack += 1);
  ;

  push_args2 e.args true fpic;
  push_args2 e.args false fpic;

  // If the return type is a large struct/union, the caller passes
  // a pointer to a buffer as if it were the first argument.
  if (!!e.ret_buffer && e.ty.size > 16) {
    (println "  lea %d(%%rbp), %%rax" e.ret_buffer.offset);
    push ;
  ;

  return stack;
;

copy_ret_buffer(var@Obj) =
  let ty = var.ty gp = 0 fp = 0;

  if has_flonum1 ty {
    assert(ty.size == 4 || 8 <= ty.size);
    if (ty.size == 4) (println "  movss %%xmm0, %d(%%rbp)" var.offset);
    else (println "  movsd %%xmm0, %d(%%rbp)" var.offset);
    (fp += 1);
  ; else {
    for (let i int = 0; i < minl 8l cast long ty.size; i += 1) {
      (println "  mov %%al, %d(%%rbp)" (var.offset + i));
      (println "  shr $8, %%rax");
    ;
    (gp += 1);
  ;

  if (ty.size > 8) {
    if has_flonum2 ty {
      assert(ty.size == 12 || ty.size == 16);
      if (ty.size == 12) (println "  movss %%xmm%d, %d(%%rbp)" fp (var.offset + 8));
      else (println "  movsd %%xmm%d, %d(%%rbp)" fp (var.offset + 8));
    ; else {
      let reg1 = (!gp ? "%al" : "%dl");
      let reg2 = (!gp ? "%rax" : "%rdx");
      for (let i int = 8; i < minl 16l cast long ty.size; i += 1) {
        (println "  mov %s, %d(%%rbp)" reg1 (var.offset + i));
        (println "  shr $8, %s" reg2);
      ;
    ;
  ;
;

copy_struct_reg(void) =
  let ty = current_fn.ty.return_ty gp = 0 fp = 0;

  (println "  mov %%rax, %%rdi");

  if has_flonum ty 0 8 0 {
    assert(ty.size == 4 || 8 <= ty.size);
    if (ty.size == 4) (println "  movss (%%rdi), %%xmm0");
    else (println "  movsd (%%rdi), %%xmm0");
    (fp += 1);
  ; else {
    (println "  mov $0, %%rax");
    for (let i int = (minl 8l cast long ty.size - 1 as int); i >= 0; i -= 1) {
      (println "  shl $8, %%rax");
      (println "  mov %d(%%rdi), %%al" i);
    ;
    (gp += 1);
  ;

  if (ty.size > 8) {
    if has_flonum ty 8 16 0 {
      assert(ty.size == 12 || ty.size == 16);
      if (ty.size == 4) (println "  movss 8(%%rdi), %%xmm%d" fp);
      else (println "  movsd 8(%%rdi), %%xmm%d" fp);
    ; else {
      let reg1 = (!gp ? "%al" : "%dl");
      let reg2 = (!gp ? "%rax" : "%rdx");
      (println "  mov $0, %s" reg2);
      for (let i int = (minl 16l cast long ty.size - 1 as int); i >= 8; i -= 1) {
        (println "  shl $8, %s" reg2);
        (println "  mov %d(%%rdi), %s" i reg1);
      ;
    ;
  ;
;

copy_struct_mem(void) =
  let ty = current_fn.ty.return_ty var = current_fn.params;

  (println "  mov %d(%%rbp), %%rdi" var.offset);

  for (let i int = 0; i < ty.size; i += 1) {
    (println "  mov %d(%%rax), %%dl" i);
    (println "  mov %%dl, %d(%%rdi)" i);
  ;
;

// Generate code for a given e.
gen_expr(e@Node fpic bool) =
  (println "  .loc %d %d" e.tok.file.file_no e.tok.line_no);

  switch  e.kind {
  case ND_NULL_EXPR:
    return;
  case ND_THE:
    return gen_expr e.lhs fpic;
  case ND_NUM: {
    switch  e.ty.kind {
    case TY_FLOAT: {
      let u union { f32 float; u32 uint32_t; } = { cast float e.fval ;
      (println "  mov $%u, %%eax  # float %Lf" u.u32 e.fval);
      (println "  movq %%rax, %%xmm0");
      return;
    ;
    case TY_DOUBLE: {
      let u union { f64 double u64 uint64_t; } = { cast double e.fval ;
      (println "  mov $%lu, %%rax  # double %Lf" u.u64 e.fval);
      (println "  movq %%rax, %%xmm0");
      return;
    ;
    case TY_LDOUBLE: {
      let u union { f80 long double; u64[2]uint64_t; };
      memset cast @ &u 0 sizeof typeof u;
      (u.f80 = e.fval);
      (println "  mov $%lu, %%rax  # long double %Lf" u.u64[0] e.fval);
      (println "  mov %%rax, -16(%%rsp)");
      (println "  mov $%lu, %%rax" u.u64[1]);
      (println "  mov %%rax, -8(%%rsp)");
      (println "  fldt -16(%%rsp)");
      return;
    ;
    ;

    (println "  mov $%ld, %%rax" e.val);
    return;
  ;
  case ND_NEG:
    gen_expr e.lhs fpic;
    switch  e.ty.kind {
    case TY_FLOAT:
      (println "  mov $1, %%rax");
      (println "  shl $31, %%rax");
      (println "  movq %%rax, %%xmm1");
      (println "  xorps %%xmm1, %%xmm0");
      return;
    case TY_DOUBLE:
      (println "  mov $1, %%rax");
      (println "  shl $63, %%rax");
      (println "  movq %%rax, %%xmm1");
      (println "  xorpd %%xmm1, %%xmm0");
      return;
    case TY_LDOUBLE:
      (println "  fchs");
      return;
    ;
    (println "  neg %%rax");
    return;
  case ND_VAR: return
    gen_addr e fpic ;:
    load e.ty;
  case ND_MEMBER: return
    gen_addr e fpic ;:
    load e.ty ;:
    e.member is mem
    ( mem.is_bitfield ?
        (println "  shl $%d, %%rax" (64 - mem.bit_width - mem.bit_offset)) ;:
        (cast @Type mem.ty).is_unsigned ? (println "  shr $%d, %%rax" (64 - mem.bit_width) ) :
        (println "  sar $%d, %%rax" (64 - mem.bit_width) ) :
      none );
  case ND_DEREF: return
    gen_expr e.lhs fpic ;:
    load e.ty;
  case ND_ADDR: return
    gen_addr e.lhs fpic;
  case ND_ASSIGN: return
    gen_addr e.lhs fpic ;:
    push ;:
    gen_expr e.rhs fpic ;:
    (e.lhs.kind == ND_MEMBER && e.lhs.member.is_bitfield) ?
      (println "  mov %%rax, %%r8") ;:
      e.lhs.member is mem
      (println "  mov %%rax, %%rdi") ;:
      (println "  and $%ld, %%rdi" ((1L << mem.bit_width) - 1)) ;:
      (println "  shl $%d, %%rdi" mem.bit_offset) ;:
      (println "  mov (%%rsp), %%rax") ;:
      load cast @Type mem.ty ;:
      (println "  mov $%ld, %%r9" ~(((1L << mem.bit_width) - 1) << mem.bit_offset)) ;:
      (println "  and %%r9, %%rax") ;:
      (println "  or %%rdi, %%rax") ;:
      store e.lhs.ty ;:
      (println "  mov %%r8, %%rax" ):
    store e.lhs.ty;
  case ND_THE:
    return gen_expr e.lhs fpic;
  case ND_UNTIL: return
    count is c
    (println ".L.until.%d:" c) ;:
    gen_expr e.lhs fpic ;:
    cmp_zero e.lhs.ty ;:
    (println "  je .L.until.%d" c);
  case ND_REPEAT: return
    count is c
    (println "  lea %d(%%rbp), %%rax" e.var.offset ) ;:
    push ;:
    gen_expr e.lhs fpic ;:
    (println ".L.repeat.%d:" c) ;:
    store e.lhs.ty ;:
    (println "  lea %d(%%rbp), %%rax" e.var.offset ) ;:
    push ;:
    gen_expr e.rhs fpic ;:
    cmp_zero e.rhs.ty ;:
    (println "  jne .L.repeat.%d" c) ;:
    pop "%rax" ;:
    (println "  mov 0(%%rax), %%rax");
  case ND_COMMA: return
    gen_expr e.lhs fpic ;:
    gen_expr e.rhs fpic;
  case ND_CAST: return
    gen_expr e.lhs fpic ;:
    gen_cast e.lhs.ty e.ty;
  case ND_MEMZERO: return
    (println "  mov $%d, %%rcx" e.var.ty.size) ;:
    (println "  lea %d(%%rbp), %%rdi" e.var.offset) ;:
    (println "  mov $0, %%al") ;:
    (println "  rep stosb");
  case ND_COND: return
    count is c
    gen_expr e.cond fpic ;:
    cmp_zero e.cond.ty ;:
    (println "  je .L.else.%d" c) ;:
    gen_expr e.then fpic ;:
    (println "  jmp .L.end.%d" c) ;:
    (println ".L.else.%d:" c) ;:
    gen_expr e.els fpic ;:
    (println ".L.end.%d:" c);
  case ND_NOT: return
    gen_expr e.lhs fpic ;:
    cmp_zero e.lhs.ty ;:
    (println "  sete %%al") ;:
    (println "  movzx %%al, %%rax");
  case ND_BITNOT: return
    gen_expr e.lhs fpic ;:
    (println "  not %%rax");
  case ND_LOGAND: return
    count is c
    gen_expr e.lhs fpic ;:
    cmp_zero e.lhs.ty ;:
    (println "  je .L.end.%d" c) ;:
    gen_expr e.rhs fpic ;:
    (println ".L.end.%d:" c);
  case ND_LOGOR: return
    count is c
    gen_expr e.lhs    fpic ;:
    cmp_zero e.lhs.ty          ;:
    (println "  jne .L.end.%ld" c) ;:
    gen_expr e.rhs fpic ;:
    (println ".L.end.%ld:" c);
  case ND_FUNCALL: {
    let stack_args = push_args e fpic;
    gen_expr e.lhs fpic;

    let gp = 0 fp = 0;

    // If the return type is a large struct/union, the caller passes
    // a pointer to a buffer as if it were the first argument.
    if (!!e.ret_buffer && e.ty.size > 16) pop argreg64[gp :; (gp += 1)];

    for (let arg @Node = e.args; arg; arg = arg.next) {
      let ty = arg.ty;
      switch  ty.kind {
      case TY_STRUCT:
      case TY_UNION:
        if !(ty.size > 16) {
          let fp1 = has_flonum1 ty;
          let fp2 = has_flonum2 ty;
          if (fp + fp1 + fp2 < FP_MAX && gp + !fp1 + !fp2 < GP_MAX) {
            if fp1 popf (fp :; (fp += 1));
            else pop argreg64[((gp :; (gp+=1)))];
            if (ty.size > 8) {
              if fp2 popf ((fp :; (fp+=1)));
              else pop argreg64[((gp :; (gp+=1)))];;;;
        break;
      case TY_FLOAT:
      case TY_DOUBLE: if (fp < FP_MAX) popf ((fp :; (fp+=1)));
      case TY_LDOUBLE: break;
      default: if (gp < GP_MAX) pop argreg64[((gp :; (gp+=1)))];
      ;
    ;

    (println "  mov %%rax, %%r10");
    (println "  mov $%d, %%rax" fp);
    (println "  call *%%r10");
    (println "  add $%d, %%rsp" (stack_args * 8));

    (depth -= stack_args);

    // It looks like the most significant 48 or 56 bits in RAX may
    // contain garbage if a function return type is short or bool/char,
    // respectively. We clear the upper bits here.
    switch  e.ty.kind {
    case TY_BOOL:
      (println "  movzx %%al, %%eax");
      return;
    case TY_CHAR:
      if e.ty.is_unsigned
        (println "  movzbl %%al, %%eax");
      else
        (println "  movsbl %%al, %%eax");
      return;
    case TY_SHORT:
      if e.ty.is_unsigned
        (println "  movzwl %%ax, %%eax");
      else
        (println "  movswl %%ax, %%eax");
      return;
    ;

    // If the return type is a small struct, a value is returned
    // using up to two registers.
    if (!!e.ret_buffer && e.ty.size <= 16) {
      copy_ret_buffer e.ret_buffer;
      (println "  lea %d(%%rbp), %%rax" e.ret_buffer.offset);
    ;

    return;
  ;
  case ND_LABEL_VAL:
    (println "  lea %s(%%rip), %%rax" e.unique_label);
    return;
  case ND_CAS: {
    gen_expr e.cas_addr fpic;
    push ;
    gen_expr e.cas_new fpic;
    push ;
    gen_expr e.cas_old fpic;
    (println "  mov %%rax, %%r8");
    load e.cas_old.ty.base;
    pop "%rdx"; // new
    pop "%rdi"; // addr

    let sz = e.cas_addr.ty.base.size;
    (println "  lock cmpxchg %s,  %%(rdi)" reg_dx sz);
    (println "  sete %%cl");
    (println "  je 1f");
    (println "  mov %s,  %%(r8)" reg_ax sz);
    (println "1:");
    (println "  movzbl %%cl, %%eax");
    return;
  ;
  case ND_EXCH: {
    gen_expr e.lhs fpic;
    push ;
    gen_expr e.rhs fpic;
    pop "%rdi";

    let sz = e.lhs.ty.base.size;
    (println "  xchg %s, (%%rdi)" reg_ax sz);
    return;
  ;
  ;

  switch  e.lhs.ty.kind {
  case TY_FLOAT:
  case TY_DOUBLE: {
    gen_expr e.rhs fpic;
    pushf ;
    gen_expr e.lhs fpic;
    popf 1;

    let sz = ((e.lhs.ty.kind == TY_FLOAT) ? "ss" : "sd");

    switch  e.kind {
    case ND_ADD:
      (println "  add%s %%xmm1, %%xmm0" sz);
      return;
    case ND_SUB:
      (println "  sub%s %%xmm1, %%xmm0" sz);
      return;
    case ND_MUL:
      (println "  mul%s %%xmm1, %%xmm0" sz);
      return;
    case ND_DIV:
      (println "  div%s %%xmm1, %%xmm0" sz);
      return;
    case ND_EQ:
    case ND_NE:
    case ND_LT:
    case ND_LE:
    case ND_GT:
    case ND_GE:
      (println "  ucomi%s %%xmm0, %%xmm1" sz);

      if (e.kind == ND_EQ) {
        (println "  sete %%al");
        (println "  setnp %%dl");
        (println "  and %%dl, %%al");
      ; else if (e.kind == ND_NE) {
        (println "  setne %%al");
        (println "  setp %%dl");
        (println "  or %%dl, %%al");
      ;
      else if (e.kind == ND_LT) (println "  seta %%al");
      else if (e.kind == ND_LE) (println "  setae %%al");
      else if (e.kind == ND_GT) (println "  setb %%al");
      else if (e.kind == ND_GE) (println "  setbe %%al");


      (println "  and $1, %%al");
      (println "  movzb %%al, %%rax");
      return;
    ;

    (error_tok e.tok "invalid expression");
  ;
  case TY_LDOUBLE: {
    gen_expr e.lhs fpic;
    gen_expr e.rhs fpic;

    switch  e.kind {
    case ND_ADD:
      (println "  faddp");
      return;
    case ND_SUB:
      (println "  fsubrp");
      return;
    case ND_MUL:
      (println "  fmulp");
      return;
    case ND_DIV:
      (println "  fdivrp");
      return;
    case ND_EQ:
    case ND_NE:
    case ND_LT:
    case ND_LE:
    case ND_GT:
    case ND_GE:
      (println "  fcomip");
      (println "  fstp %%st(0)");

      if (e.kind == ND_EQ)
        (println "  sete %%al");
      else if (e.kind == ND_NE)
        (println "  setne %%al");

      else if (e.kind == ND_LT) (println "  seta %%al");
      else if (e.kind == ND_LE) (println "  setae %%al");
      else if (e.kind == ND_GT) (println "  setb %%al");
      else if (e.kind == ND_GE) (println "  setbe %%al");

      (println "  movzb %%al, %%rax");
      return;
    ;

    (error_tok e.tok "invalid expression");
  ;;

  gen_expr e.rhs fpic;
  push ;
  gen_expr e.lhs fpic;
  pop "%rdi";

  let ax = cast @char 0 di = cast @char 0 dx = cast @char 0;

  if (e.lhs.ty.kind == TY_LONG || !!e.lhs.ty.base) {
    (ax = "%rax");
    (di = "%rdi");
    (dx = "%rdx");
  ; else {
    (ax = "%eax");
    (di = "%edi");
    (dx = "%edx");
  ;

  switch  e.kind {
  case ND_ADD:
    (println "  add %s, %s" di ax);
    return;
  case ND_SUB:
    (println "  sub %s, %s" di ax);
    return;
  case ND_MUL:
    (println "  imul %s, %s" di ax);
    return;
  case ND_DIV:
  case ND_MOD:
    if e.ty.is_unsigned{
      (println "  mov $0, %s" dx);
      (println "  div %s" di);
    ; else {
      if (e.lhs.ty.size == 8) (println "  cqo");
      else (println "  cdq");
      (println "  idiv %s" di);
    ;

    if (e.kind == ND_MOD) (println "  mov %%rdx, %%rax");
    return;
  case ND_BITAND:
    (println "  and %s, %s" di ax);
    return;
  case ND_BITOR:
    (println "  or %s, %s" di ax);
    return;
  case ND_BITXOR:
    (println "  xor %s, %s" di ax);
    return;
  case ND_EQ:
  case ND_NE:
  case ND_LT:
  case ND_LE:
  case ND_GT:
  case ND_GE:
    (println "  cmp %s, %s" di ax);

    if (e.kind == ND_EQ) {
      (println "  sete %%al");
    ; else if (e.kind == ND_NE) {
      (println "  setne %%al");
    ; else if (e.kind == ND_LT) {
      if e.lhs.ty.is_unsigned
        (println "  setb %%al");
      else
        (println "  setl %%al");
    ; else if (e.kind == ND_LE){
      if e.lhs.ty.is_unsigned
        (println "  setbe %%al");
      else
        (println "  setle %%al");
    ; else if (e.kind == ND_GT){
      if e.lhs.ty.is_unsigned
        (println "  seta %%al");
      else
        (println "  setg %%al");
    ; else if (e.kind == ND_GE){
      if e.lhs.ty.is_unsigned
        (println "  setae %%al");
      else
        (println "  setge %%al");
    ;

    (println "  movzb %%al, %%rax");
    return;
  case ND_SHL:
    (println "  mov %%rdi, %%rcx");
    (println "  shl %%cl, %s" ax);
    return;
  case ND_SHR:
    (println "  mov %%rdi, %%rcx");
    if e.lhs.ty.is_unsigned
      (println "  shr %%cl, %s" ax);
    else
      (println "  sar %%cl, %s" ax);
    return;
  ;

  (error_tok e.tok "invalid expression");
;

gen_stmt(e@Node fpic bool) =
  (println "  .loc %d %d" e.tok.file.file_no e.tok.line_no);

  switch  e.kind {
  case ND_IF: {
    let c = count ;
    gen_expr e.cond fpic;
    cmp_zero e.cond.ty;
    (println "  je  .L.else.%d" c);
    gen_stmt e.then fpic;
    (println "  jmp .L.end.%d" c);
    (println ".L.else.%d:" c);
    if e.els gen_stmt e.els fpic;
    (println ".L.end.%d:" c);
    return;
  ;
  case ND_FOR: {
    let c = count ;
    if e.init gen_stmt e.init fpic;
    (println ".L.begin.%d:" c);
    if e.cond{
      gen_expr e.cond fpic;
      cmp_zero e.cond.ty;
      (println "  je %s" e.brk_label);
    ;
    gen_stmt e.then fpic;
    (println "%s:" e.cont_label);
    if e.inc gen_expr e.inc fpic;
    (println "  jmp .L.begin.%d" c);
    (println "%s:" e.brk_label);
    return;
  ;
  case ND_DO: {
    let c = count ;
    (println ".L.begin.%d:" c);
    gen_stmt e.then fpic;
    (println "%s:" e.cont_label);
    gen_expr e.cond fpic;
    cmp_zero e.cond.ty;
    (println "  jne .L.begin.%d" c);
    (println "%s:" e.brk_label);
    return;
  ;
  case ND_SWITCH:
    gen_expr e.cond fpic;

    for (let n@Node = e.case_next; n; n = n.case_next) {
      let ax = ((e.cond.ty.size == 8) ? "%rax" : "%eax");
      let di = ((e.cond.ty.size == 8) ? "%rdi" : "%edi");

      (println "  cmp $%ld, %s" n.begin ax);
      (println "  je %s" n.label);
    ;

    if e.default_case (println "  jmp %s" e.default_case.label);
    (println "  jmp %s" e.brk_label);
    gen_stmt e.then fpic;
    (println "%s:" e.brk_label);
    return;
  case ND_CASE:
    (println "%s:" e.label);
    gen_stmt e.lhs fpic;
    return;
  case ND_BLOCK:
    for (let n@Node = e.body; n; n = n.next) gen_stmt n fpic;
    return;
  case ND_GOTO:
    (println "  jmp %s" e.unique_label);
    return;
  case ND_GOTO_EXPR:
    gen_expr e.lhs fpic;
    (println "  jmp *%%rax");
    return;
  case ND_LABEL:
    (println "%s:" e.unique_label);
    gen_stmt e.lhs fpic;
    return;
  case ND_RETURN:
    if e.lhs{
      gen_expr e.lhs fpic;
      let ty = e.lhs.ty;
      switch  ty.kind {
      case TY_STRUCT:
      case TY_UNION:
        if (ty.size <= 16) copy_struct_reg ;
        else copy_struct_mem ;
        break;
      ;
    ;

    ((println "  jmp .L.return.%s" current_fn.name));
    return;
  case ND_EXPR_STMT:
    gen_expr e.lhs fpic;
    return;
  case ND_ASM:
    (println "  %s" e.asm_str);
    return;
  ;

  (error_tok e.tok "invalid statement");
;

assign_one_param_offset(var @Obj top @int gp @int fp @int) =
  let ty = var.ty;
  switch  ty.kind {
    case TY_STRUCT:
    case TY_UNION:none;
      let fp1 = has_flonum ty 0 8 0;
      let fp2 = has_flonum ty 8 16 8;
      if (!(fp@ + fp1 + fp2 < FP_MAX && gp@ + !fp1 + !fp2 < GP_MAX) && ty.size > 16) {
        (fp@ = fp@ +  fp1 +  fp2);
        (gp@ = gp@ + !fp1 + !fp2);
        return;;
    case TY_DOUBLE: if ((fp@ :; (fp@ += 1)) < FP_MAX) return;
    default       : if ((gp@ :; (gp@ += 1)) < GP_MAX) return;
    case TY_FLOAT:
    case TY_LDOUBLE:none;;
  (top@ = align_to top@ 8);
  (var.offset = top@);
  (top@ += var.ty.size);;
assign_param_offsets(fn @Obj) =
  let top = 16 gp = 0 fp = 0;
  for (let var @Obj = fn.params; var; var = var.next)
    assign_one_param_offset var &top &gp &fp;;

assign_one_lvar_offset(fn @Obj) =
  if !fn.is_function return;
  assign_param_offsets fn;
  let bottom = 0;
  for (let var@Obj = fn.locals; var; var = var.next)
    if !var.offset {
    let alignment = var.alignment as long;
    (bottom += var.ty.size);
    (bottom = align_to bottom alignment);
    (var.offset = -bottom);;
  (fn.stack_size = align_to bottom 16);;
assign_lvar_offsets(prog @Obj) =
  for (let fn @Obj = prog; fn; fn = fn.next)
    assign_one_lvar_offset fn;;

emit_data(prog @Obj fpic bool) =
  for (let var@Obj = prog; var; var = var.next)
    if !(var.is_function || !var.is_definition) {
    if !var.is_export (println "  .local %s" var.name);
    else (println "  .globl %s" var.name);

    let alignment = ((var.ty.kind == TY_ARRAY && var.ty.size >= 16)
      ? maxl 16l cast long var.alignment : cast long var.alignment);

    // .data or .tdata
    if var.init_data{
      if var.is_tls
        (println "  .section .tdata,\"awT\",@progbits");
      else
        (println "  .data");

      (println "  .type %s, @object" var.name);
      (println "  .size %s, %d" var.name var.ty.size);
      (println "  .align %d" alignment);
      (println "%s:" var.name);

      let
        rel = var.rel
        pos = 0;
      while (pos < var.ty.size) {
        if (!!rel && rel.offset == pos) {
          (println "  .quad %s%+ld" rel.label@ rel.addend);
          (rel = rel.next);
          (pos += 8);
        ; else {
          (println "  .byte %d" var.init_data[((pos :; (pos+=1)))]);
        ;
      ;
    ;
    else {
      // .bss or .tbss
      if var.is_tls
        (println "  .section .tbss,\"awT\",@nobits");
      else
        (println "  .bss");

      (println "  .align %d" alignment);
      (println "%s:" var.name);
      (println "  .zero %d" var.ty.size);
  ;;
;

store_fp(r int offset int sz int) = 
  (sz == 4) ? (println "  movss %%xmm%d, %d(%%rbp)" r offset ):
  (sz == 8) ? (println "  movsd %%xmm%d, %d(%%rbp)" r offset ):
            unreachable;;

store_gp(r int offset int sz int) =
  switch  sz {
  case 1:
    (println "  mov %s, %d(%%rbp)" argreg8[r] offset);
    return;
  case 2:
    (println "  mov %s, %d(%%rbp)" argreg16[r] offset);
    return;
  case 4:
    (println "  mov %s, %d(%%rbp)" argreg32[r] offset);
    return;
  case 8:
    (println "  mov %s, %d(%%rbp)" argreg64[r] offset);
    return;
  default:
    for (let i int = 0; i < sz; ((i :; (i+=1)))) {
      (println "  mov %s, %d(%%rbp)" argreg8[r] (offset + i));
      (println "  shr $8, %s" argreg64[r]);
    ;
    return;
  ;
;

emit_text(prog@Obj fpic bool) =
  for (let fn@Obj = prog; fn; fn = fn.next)
    if (!(!fn.is_function || !fn.is_definition) && fn.is_live) {

    if !fn.is_export (println "  .local %s" fn.name);
    else             (println "  .globl %s" fn.name);

    (println "  .text");
    (println "  .type %s, @function" fn.name);
    (println "%s:" fn.name);
    (current_fn = fn);

    // Prologue
    (println "  push %%rbp");
    (println "  mov %%rsp, %%rbp");
    (println "  sub $%d, %%rsp" fn.stack_size);
    (println "  mov %%rsp, %d(%%rbp)" fn.alloca_bottom.offset);

    // Save arg registers if function is variadic
    if fn.va_area {
      let
        gp = 0
        fp = 0;
      for (let var@Obj = fn.params; var; var = var.next) {
        if is_flonum var.ty
          ((fp :; (fp+=1)));
        else
          ((gp :; (gp+=1)));
      ;

      let off = fn.va_area.offset;

      // va_elem
      (println "  movl $%d, %d(%%rbp)" (gp * 8) off);          // gp_offset
      (println "  movl $%d, %d(%%rbp)" (fp * 8 + 48) (off + 4)); // fp_offset
      (println "  movq %%rbp, %d(%%rbp)" (off + 8));            // overflow_arg_area
      (println "  addq $16, %d(%%rbp)" (off + 8));
      (println "  movq %%rbp, %d(%%rbp)" (off + 16));           // reg_save_area
      (println "  addq $%d, %d(%%rbp)" (off + 24) (off + 16));

      let b = (off + 24);
      // __reg_save_area__
      (println "  movq %%rdi, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rsi, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rdx, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%rcx, %d(%%rbp)"   b);
      (b += 8); (println "  movq %%r8, %d(%%rbp)"    b);
      (b += 8); (println "  movq %%r9, %d(%%rbp)"    b);
      (b += 8); (println "  movsd %%xmm0, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm1, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm2, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm3, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm4, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm5, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm6, %d(%%rbp)" b);
      (b += 8); (println "  movsd %%xmm7, %d(%%rbp)" b);
    ;

    // Save passed-by-register arguments to the stack
    let gp = 0 fp = 0;
    for (let var@Obj = fn.params; var; var = var.next) {
      if !(var.offset > 0) {

        let ty = var.ty;

        switch  ty.kind {
        case TY_STRUCT:
        case TY_UNION:
          assert(ty.size <= 16);
          let b = ((ty.size < 8) ? ty.size : 8);
          if has_flonum ty 0 8 0
            store_fp (fp :; (fp+=1)) var.offset b;
          else
            store_gp (gp :; (gp+=1)) var.offset b;

          if (ty.size > 8) {
            let b = (var.offset + 8) c = (ty.size - 8);
            if has_flonum ty 8 16 0
              store_fp (fp :; (fp+=1)) b c;
            else
              store_gp (gp :; (gp+=1)) b c;
          ;
          break;
        case TY_FLOAT:
        case TY_DOUBLE:
          store_fp ((fp :; (fp+=1))) var.offset ty.size;
          break;
        default:
          store_gp ((gp :; (gp+=1))) var.offset ty.size;;;;
    gen_stmt cast @Node fn.body fpic;
    assert(!depth);
    if ! strcmp cast @ fn.name "main" (println "  mov $0, %%rax");
    (println ".L.return.%s:" fn.name);
    (println "  mov %%rbp, %%rsp");
    (println "  pop %%rbp");
    (println "  ret");;;

export codegen(prog@Obj out@FILE fpic bool) = return
  (output_file = out) ;:
  get_input_files is files
  0 is i
  cast until (!files[i] || (
    (println "  .file %d \"%s\"" files[i].file_no files[i].name) ;:
    (i += 1) ;:
    none)) ;:
  assign_lvar_offsets prog ;:
  emit_data prog fpic ;:
  emit_text prog fpic;;
