export jadv   (x X        ) K    = { (x.k@ or diag "unexpected end of tokens") x.k@ ret (x.k = &x.k.s) token x  }
export jeq    (x X c @byte) nat  = { x.k@ then memcmp x.k.p c x.k.n then !c^x.k.n }
export expect (x X c @byte) none = { { !jeq x c then kdiag x.k@ "unexpected" } jadv x }
export consume(x X c @byte) nat  = { jeq x c is r { r then jadv x } r }

export try_search_scope(o O c @byte n nat) O = {
  cast O 0 is r
  { o then
    o for oi
    (n != oi.k.n or !strncmp oi.k.p c n) ?
      oi.s
      { (r = oi)
        cast O 0 } }
  r
}

export search_scope(x X o O c @byte n nat) @Scope = {
  try_search_scope o c n else
  kdiag x.k@ "lookup failed"
}

export declarator (x X o O t @T) none = {
  (t@ = cast T alloc sizeof Type)
  jadv x is k
  ptype x o is u
  memcpy cast @byte t@ cast @byte u sizeof Type
  (t.k = k)
}

align(n nat a nat) nat = ((n + a - 1) / a * a)

struct_decl txo = {
  nstct is t
  &t.a is u
  { 1 for _ 
     !consume x "}" then
      declarator x o u
      (u = &u.s) }
  0 is bits
  { !!t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

func_params txo = {
  cast T 0 is params
  &params is u
  { 1 for _
    !jeq x ")" then
    declarator x o u
    (u = &u.s)
    1 }
  jadv x
  ptype x o is ret
  nfunc cast T alloc sizeof Type is t
  memcpy cast @byte t.a cast @byte ret sizeof Type
  (t.a.s = params)
  t
}

export ptype txo = {
  consume x "none"   ? nnone
  consume x "byte"   ? nbyte
  consume x "nat"    ? nnat
  consume x "@"      ? nptr        ptype x o
  consume x "("      ? func_params       x o
  consume x "{"      ? struct_decl       x o
  { 
  search_scope x o x.k.p x.k.n is s
    (s.is_type or kdiag x.k@ "not a type")
    jadv x
    s.t }
}

pj(x X o O     q TokenKind e @exok ) E = { x.k@ then (x.k.q == q) then jadv x is k e@ x o k }
pl(x X o O     c @byte     e @exok ) E = { x.k@ then jeq x c then jadv x is k e@ x o k   }
pr(x X o O a E c @byte     e @exoka) E = { x.k@ then jeq x c then jadv x is k e@ x o k a }
pu(x X o O a E c @byte     e @exoka) E = { x.k@ then consume x c ? a e@ x o x.k@ a }

pa1    lhs  = { pj    x o   &JID   &eid   else
                pj    x o   &JSTR  &estr  else
                pj    x o   &JNUM  &enat  else
                pj    x o   &JCHR  &ebyte      }
pa3    rhs = { (a.t.q == &TFUNC) then ecall x o x.k@ a }
pa4    rhs = { pr    x o a "?"    &econd      }
pa5    rhs = { pr    x o a "ret"  &eret  else
                pr    x o a "is"   &eis   else
                pr    x o a "for"  &efor  else
                pr    x o a "then" &ethen else
                pr    x o a "else" &eelse else
                pu    x o a "}"    &eseq       }
pamul  rhs = { pr    x o a "*"    &emul  else
                pr    x o a "/"    &ediv  else
                pr    x o a "%"    &emod       }
paadd  rhs = { pr    x o a "+"    &eadd  else
                pr    x o a "-"    &esub       }
pash   rhs = { pr    x o a "<<"   &eshl  else
                pr    x o a ">>"   &eshr       }
pacmp  rhs = { pr    x o a "<"    &eb    else
                pr    x o a ">"    &ea    else
                pr    x o a "<="   &ebe   else
                pr    x o a ">="   &eae   else
                pr    x o a "=="   &ee    else
                pr    x o a "!="   &ene        }
paland rhs = { pr    x o a "and"  &eland      }
palor  rhs = { pr    x o a "or"   &elor       }
pa7    rhs = { pr    x o a "as"   &eas        }

export p2 lhs = {
  pl x o "&"       &eaddr    else
  pl x o "-"       &eneg     else
  pl x o "!"       &elnot    else
  pl x o "not"     &elnot    else
  pl x o "cast"    &ecast    else
  pl x o "sizeof"  &esize    else
  pl x o "exit"    &eexit    else
  pl x o "brk"     &ebrk     else
  pl x o "ibrk"    &eibrk    else
  pl x o "read"    &eread    else
  pl x o "write"   &ewrite   else
  pl x o "err"     &eerr     else
  { consume x "(" ?
      { { p7    x o for a
          pr    x o a "=" &eass else
          pa7   x o a
        } ret
        expect x ")"                     }
    pl  x o "{"  &ebrace else
    pa1 x o else
    kdiag x.k@ "expected an expression"
  } for a
  pr    x o     a "^"       &eelem   else
  pr    x o     a "."       &emem   else
  pr    x o     a "@"       &ederef
}

export p3    lhs = { p2    x o for a pa3    x o a }
export p4    lhs = { p3    x o for a pa4    x o a }
export p5    lhs = { pl    x o "scratch" &escratch else
                     p4    x o is  a pa5    x o a }
export pmul  lhs = { p4    x o for a pamul  x o a }
export padd  lhs = { pmul  x o for a paadd  x o a }
export psh   lhs = { padd  x o for a pash   x o a }
export pcmp  lhs = { psh   x o for a pacmp  x o a }
export pland lhs = { pcmp  x o for a paland x o a }
export plor  lhs = { pland x o for a palor  x o a }
export p7    lhs = { plor  x o for a pa7    x o a }


gtpars(x X o O t T c nat g nat) nat = {
  !t ? { gdrop p4 x o c 0 }
    { scratch Expr nd
      scratch Scope o1
      (o1.s = o)
      (o1.k = t.k)
      (o1.e = &nd)
      (o1.is_type = 0)
      (nd.c  = -g)
      (nd.u   = t)
      gtpars x &o1 t.s c (g + 1) }
}
gtparr(x X o O t T c nat g nat) nat = {
  !t ? { gdrop p4 x o c 0 }
    { gpush &c argreg g
      scratch Expr nd
      scratch Scope o1
      (o1.s = o)
      (o1.k = t.k)
      (o1.is_type = 0)
      (o1.e = &nd)
      (nd.c = c)
      (nd.u  = t)
      (((g == 5) ? &gtpars &gtparr)@ x &o1 t.s c (g + 1) + 1) }
}

typedecl(x X o O) none = {
  consume x ";" ?
    decls x o
    { scratch Scope o1
      (o1.s = o)
      (o1.k = x.k@)
      (o1.is_type = 1)
      declarator x &o1 &o1.t
      typedecl x &o1 }
}

function(x X o O) none = {
  consume x "export" is globl
  scratch T t
  declarator x o &t
  try_search_scope o t.k.p t.k.n is o1
  { o1 then
    (o1.is_type and kdiag x.k@ "redeclared as a different type of symbol")
    (o1.is_def >= jeq x "=" and kdiag x.k@ "remention") }
  scratch Scope o2
  (o2.s = o)
  (o2.k = t.k)
  (o2.t = t)
  (o2.e = 0)
  (o2.is_type = 0)
  (o2.is_def = jeq x "=")
  (x.section = t.k)
  { o2.is_def then
    jadv x
    gs ".section .text." gk t.k glf
    { globl then gs ".globl" gc ' ' gk t.k glf }
    gk t.k gc ':' glf
    0 is c
    gfpop &c gtparr x &o2 t.a.s c 0
    gt0 "ret" }
  decls x &o2
}

export decls(x X o O) none = {
  x.k@ then
  ( consume x "type" ? &typedecl
                       &function )@ x o
}
