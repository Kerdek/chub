export jadv   (x X        ) none = { (x.kp or diag "unexpected end of tokens") token x }
export jeq    (x X c @byte) nat  = { x.kp then memcmp c x.kp x.kn then !c^x.kn }
export expect (x X c @byte) none = { { !jeq x c then kdiag x "unexpected" } jadv x }
export consume(x X c @byte) nat  = { jeq x c is r { r then jadv x } r }

try_search_scope(x X) O = {
  cast O 0 is r
  { x.o then x.o for o
    (o.kn != x.kn or !strncmp o.kp x.kp x.kn) ?
      o.s
      { (r = o)
        cast O 0 } }
  r
}

export search_scope(x X) @Scope = {
  try_search_scope x else
  kdiag x "lookup failed"
}

export declarator (x X t @T) none = {
  (t@ = cast T alloc sizeof Type &x.curbrk)
  (t.kp = x.kp)
  (t.kn = x.kn)
  jadv x
  ptype x is u
  (t.a = u.a)
  (t.q = u.q)
  (t.size = u.size)
  (t.align = u.align)
  (t.offset = u.offset)
}

align(n nat a nat) nat = ((n + a - 1) / a * a)

struct_decl (x X) T = {
  nstct x is t
  &t.a is u
  { 1 for _ 
     !consume x "}" then
      declarator x u
      (u = &u.s) }
  0 is bits
  { !!t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

func_params (x X) T = {
  cast T 0 is params
  &params is u
  { 1 for _
    !jeq x ")" then
    declarator x u
    (u = &u.s)
    1 }
  jadv x
  ptype x is ret
  nfunc x cast T alloc sizeof Type &x.curbrk is t
  memcpy cast @byte t.a cast @byte ret sizeof Type
  (t.a.s = params)
  t
}

export ptype (x X) T = {
  consume x "none"   ? nnone x
  consume x "byte"   ? nbyte x
  consume x "nat"    ? nnat x
  consume x "@"      ? nptr x        ptype x
  consume x "("      ? func_params       x
  consume x "{"      ? struct_decl       x
  { search_scope x is o
    (o.is_type or kdiag x "not a type")
    jadv x
    o.t }
}

pj(x X xcat @(x X) nat e @ex) nat = { x.kp then xcat@ x then e@ x 1 }
pl(x X c @byte     e @ex) nat = { x.kp then jeq x c then jadv x e@ x 1 }
pr(x X c @byte     e @ex) nat = { x.kp then jeq x c then jadv x e@ x 1 }
pu(x X c @byte     e @ex) nat = { x.kp then !jeq x c then e@ x 1 }

p1     (x X) nat = { pl x "&"       &eaddr    else
                     pl x "-"       &eneg     else
                     pl x "!"       &elnot    else
                     pl x "not"     &elnot    else
                     pl x "cast"    &ecast    else
                     pl x "sizeof"  &esize    else
                     pl x "exit"    &eexit    else
                     pl x "brk"     &ebrk     else
                     pl x "read"    &eread    else
                     pl x "write"   &ewrite   else
                     pl x "err"     &eerr     else
                     pl x "("       &eparen   else
                     pl x "{"       &ebrace   else
                     pj x &xisid    &eid      else
                     pj x &xisstr   &estr     else
                     pj x &xisnum   &enat     else
                     pj x &xischr   &ebyte    else
                     kdiag x "expected an expression"
                     0 }
pa2    (x X) nat = { pr x "^"    &eelem       else
                     pr x "."    &emem        else
                     pr x "@"    &ederef           }
pa3    (x X) nat = { (x.t.q == &TFUNC) then { ecall x 1 } }
pa4    (x X) nat = { pr x "?"    &econd      }
pa5    (x X) nat = { pr x "ret"  &eret  else
                     pr x "is"   &eis   else
                     pr x "for"  &efor  else
                     pr x "then" &ethen else
                     pr x "else" &eelse else
                     pu x "}"    &eseq       }
pamul  (x X) nat = { pr x "*"    &emul  else
                     pr x "/"    &ediv  else
                     pr x "%"    &emod       }
paadd  (x X) nat = { pr x "+"    &eadd  else
                     pr x "-"    &esub       }
pash   (x X) nat = { pr x "<<"   &eshl  else
                     pr x ">>"   &eshr       }
pacmp  (x X) nat = { pr x "<"    &eb    else
                     pr x ">"    &ea    else
                     pr x "<="   &ebe   else
                     pr x ">="   &eae   else
                     pr x "=="   &ee    else
                     pr x "!="   &ene        }
paland (x X) nat = { pr x "and"  &eland      }
palor  (x X) nat = { pr x "or"   &elor       }
pa7    (x X) nat = { pr x "as"   &eas        }
pa8    (x X) nat = { pr x "="    &eass       }


export p2    (x X) nat = { p1    x for _ pa2    x }
export p3    (x X) nat = { p2    x for _ pa3    x }
export p4    (x X) nat = { p3    x for _ pa4    x }
export p5    (x X) nat = { pl    x "scratch" &escratch else
                           p4    x       pa5    x }
export pmul  (x X) nat = { p4    x for _ pamul  x }
export padd  (x X) nat = { pmul  x for _ paadd  x }
export psh   (x X) nat = { padd  x for _ pash   x }
export pcmp  (x X) nat = { psh   x for _ pacmp  x }
export pland (x X) nat = { pcmp  x for _ paland x }
export plor  (x X) nat = { pland x for _ palor  x }
export p7    (x X) nat = { plor  x for _ pa7    x }
export p8    (x X) nat = { p7    x       pa8    x }

gtpars(x X t T g nat) nat = {
  !t ? { p4 x geval x 0 0 }
    { scratch Scope o1
      (o1.s = x.o)
      (o1.kp = t.kp)
      (o1.kn = t.kn)
      (o1.is_type  = 0)
      (o1.is_local = 1)
      (o1.c  = -g)
      (o1.t   = t)
      x.o is o
      (x.o = &o1)
      gtpars x t.s (g + 1) ret
      (x.o = o) }
}
gtparr(x X t T g nat) nat = {
  !t ? { p4 x geval x 0 0 }
    { gpush &x.c argreg g
      scratch Scope o1
      (o1.s = x.o)
      (o1.kp = t.kp)
      (o1.kn = t.kn)
      (o1.is_type  = 0)
      (o1.is_local = 1)
      (o1.c = x.c)
      (o1.t = t)
      x.o is o
      (x.o = &o1)
      (((g == 5) ? &gtpars &gtparr)@ x t.s (g + 1) + 1) ret
      (x.o = o) }
}

typedecl (x X) none = {
  consume x ";" ?
    decls x
    { scratch Scope o1
      (o1.s  = x.o )
      (o1.kp = x.kp)
      (o1.kn = x.kn)
      (o1.is_type = 1)
      (x.o = &o1)
      declarator x &o1.t
      typedecl x }
}

function (x X) none = {
  consume x "export" is globl
  try_search_scope x is o
  scratch T t
  declarator x &t
  (!o or !o.is_type and !o.is_def and jeq x "=" or kdiag x "remention")
  scratch Scope o1
  (o1.s = x.o)
  (o1.kp = t.kp)
  (o1.kn = t.kn)
  (o1.t = t)
  (o1.is_type  = 0)
  (o1.is_local = 0)
  (o1.is_def   = jeq x "=")
  (x.o = &o1)
  { o1.is_def then
    jadv x
    gs ".section .text." gsn o1.kp o1.kn glf
    { globl then gs ".globl" gc ' ' gsn o1.kp o1.kn glf }
    gsn o1.kp o1.kn gc ':' glf
    (x.c = 0)
    gtparr x t.a.s 0 is stack
    gfpop &x.c stack
    gt0 "ret" }
  decls x
}

export decls (x X) none = {
  x.kp then
  ( consume x "type" ? &typedecl
                       &function ) is f
  f@ x
}
