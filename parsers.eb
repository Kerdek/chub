jadv   (x X        ) none = { (x.kp or diag "unexpected end of tokens") token x }
jeq    (x X c @byte) nat  = { x.kp then memcmp c x.kp cast nat x.kn then !c^x.kn }
expect (x X c @byte) none = { { !jeq x c then kdiag x "unexpected" } jadv x }
consume(x X c @byte) nat  = { jeq x c is r { r then jadv x } r }

try_search_scope(x X) X = {
  cast X 0 is x1
  { x.s then
    x.s for s
    (s.kn != x.kn or !strncmp s.kp x.kp cast nat x.kn) ?
      s.s
      { (x1 = s)
        cast X 0 } }
  x1
}

search_scope(x X) X = {
  try_search_scope x else
  kdiag x "lookup failed"
}

declarator (x X t @T) none = {
  (t@ = cast T alloc sizeof Type &x.curbrk)
  (t.kp = x.kp)
  (t.kn = x.kn)
  jadv x
  ptype x is u
  (t.a = u.a)
  (t.kind = u.kind)
  (t.size = u.size)
  (t.align = u.align)
  (t.offset = u.offset)
}

align(n nat a nat) nat = ((n + a - 1) / a * a)

struct_decl (x X) T = {
  nstct x is t
  &t.a is u
  { 1 for _ 
     !consume x "}" then
      declarator x u
      (u = &u.s) }
  0 is bits
  { !!t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

func_params (x X) T = {
  cast T 0 is params
  &params is u
  { 1 for _
    !jeq x ")" then
    declarator x u
    (u = &u.s)
    1 }
  jadv x
  ptype x is ret
  nfunc x cast T alloc sizeof Type &x.curbrk is t
  memcpy cast @byte t.a cast @byte ret sizeof Type
  (t.a.s = params)
  t
}

ptype (x X) T = {
  consume x "none"   ? nnone x
  consume x "byte"   ? nbyte x
  consume x "nat"    ? nnat x
  consume x "@"      ? nptr x        ptype x
  consume x "("      ? func_params       x
  consume x "{"      ? struct_decl       x
  { search_scope x is o
    (o.is_type or kdiag x "not a type")
    jadv x
    o.t }
}

pj(x X xcat @(x X) nat e @ex) nat = { x.kp then xcat@ x then e@ x 1 }
pl(x X c @byte         e @ex) nat = { x.kp then jeq x c then jadv x e@ x 1 }
pr(x X c @byte         e @ex) nat = { x.kp then jeq x c then jadv x e@ x 1 }
pu(x X c @byte         e @ex) nat = { x.kp then !jeq x c then e@ x 1 }

p1     (x X) nat = { pl x "&"       &eaddr    else
                     pl x "-"       &eneg     else
                     pl x "!"       &elnot    else
                     pl x "not"     &elnot    else
                     pl x "cast"    &ecast    else
                     pl x "sizeof"  &esize    else
                     pl x "exit"    &eexit    else
                     pl x "clock_gettime"   &eclock_gettime   else
                     pl x "brk"     &ebrk     else
                     pl x "read"    &eread    else
                     pl x "write"   &ewrite   else
                     pl x "err"     &eerr     else
                     pl x "("       &eparen   else
                     pl x "{"       &ebrace   else
                     pj x &xisid    &eid      else
                     pj x &xisstr   &estr     else
                     pj x &xisnum   &enat     else
                     pj x &xischr   &ebyte    else
                     kdiag x "expected an expression"
                     0 }
pa2    (x X) nat = { pr x "^"    &eelem       else
                     pr x "."    &emem        else
                     pr x "@"    &ederef           }
pa3    (x X) nat = { (x.t.kind== 5) then { ecall x 1 } }
pa4    (x X) nat = { pr x "?"    &econd      }
pa5    (x X) nat = { pr x "ret"  &eret  else
                     pr x "is"   &eis   else
                     pr x "for"  &efor  else
                     pr x "then" &ethen else
                     pr x "else" &eelse else
                     pu x "}"    &eseq       }
pamul  (x X) nat = { pr x "*"    &emul  else
                     pr x "/"    &ediv  else
                     pr x "%"    &emod       }
paadd  (x X) nat = { pr x "+"    &eadd  else
                     pr x "-"    &esub       }
pash   (x X) nat = { pr x "<<"   &eshl  else
                     pr x ">>"   &eshr       }
pacmp  (x X) nat = { pr x "<"    &eb    else
                     pr x ">"    &ea    else
                     pr x "<="   &ebe   else
                     pr x ">="   &eae   else
                     pr x "=="   &ee    else
                     pr x "!="   &ene        }
paland (x X) nat = { pr x "and"  &eland      }
palor  (x X) nat = { pr x "or"   &elor       }
pa7    (x X) nat = { pr x "as"   &eas        }
pa8    (x X) nat = { pr x "="    &eass       }


p2    (x X) nat = { p1    x for _ pa2    x }
p3    (x X) nat = { p2    x for _ pa3    x }
p4    (x X) nat = { p3    x for _ pa4    x }
p5    (x X) nat = { pl    x "scratch" &escratch else
                           p4    x       pa5    x }
pmul  (x X) nat = { p4    x for _ pamul  x }
padd  (x X) nat = { pmul  x for _ paadd  x }
psh   (x X) nat = { padd  x for _ pash   x }
pcmp  (x X) nat = { psh   x for _ pacmp  x }
pland (x X) nat = { pcmp  x for _ paland x }
plor  (x X) nat = { pland x for _ palor  x }
p7    (x X) nat = { plor  x for _ pa7    x }
p8    (x X) nat = { p7    x       pa8    x }

gtpars(x X t T g nat) nat = {
  !t ? { p4 x geval x 0 0 }
    { scratch Ctx x1
      xcpy &x1 x
      (x.s.kp = t.kp)
      (x.s.kn = t.kn)
      (x.s.is_type  = 0)
      (x.s.is_local = 1)
      (x.s.c  = -g)
      (x.s.t   = t)
      gtpars x t.s (g + 1) ret
      (x.s = x.s.s) }
}

gtparr(x X t T g nat) nat = {
  !t ? { p4 x geval x 0 0 }
    { gpush x argreg g
      scratch Ctx x1
      xcpy &x1 x
      (x.s.kp = t.kp)
      (x.s.kn = t.kn)
      (x.s.is_type  = 0)
      (x.s.is_local = 1)
      (x.s.t = t)
      (((g == 5) ? &gtpars &gtparr)@ x t.s (g + 1) + 1) ret
      (x.s = x.s.s) }
}

typedecl (x X) none = {
  consume x ";" ?
    decls x
    { scratch Ctx x1
      xcpy &x1 x
      (x.s.is_type = 1)
      declarator x &x.s.t
      typedecl x }
}

function (x X) none = {
  consume x "export" is globl
  try_search_scope x is o
  scratch Ctx x1
  xcpy &x1 x
  (x.s.is_type  = 0)
  (x.s.is_local = 0)
  declarator x &x.s.t
  (x.s.is_def   = jeq x "=")
  (!o or !o.is_type and !o.is_def and x.s.is_def or kdiag x "remention")
  { x.s.is_def then
    gs x ".section .text." gsn x &x1 glf x
    { globl then gs x ".globl" gc x ' ' gsn x &x1 glf x }
    gsn x &x1 gc x ':' glf x
    jadv x
    (x.c = 0)
    x.curbrk is ibrk
    gtparr x x.s.t.a.s 0 is stack
    (x.curbrk = ibrk)
    gfpop x stack
    gt0 x "ret" }
  decls x
}

decls (x X) none = {
  x.kp then
  ( consume x "type" ? &typedecl
                       &function ) is f
  f@ x
}
