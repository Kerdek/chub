export declarator (x X o O t @T) none = {
  (t@ = cast T alloc sizeof Type)
  jadv x is k
  ptype x o is u
  memcpy cast S t@ cast S u sizeof Type
  (t.k = k)
}

align(n N a N) N = ((n + a - 1) / a * a)

struct_decl txo = {
  nstct is t
  &t.a is u
  { 1 for _ 
     !consume x "}" then
      declarator x o u
      (u = &u.s) }
  0 is bits
  { !!t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

func_params txo = {
  cast T 0 is params
  &params is u
  { 1 for _
    !jeq x ")" then
    declarator x o u
    (u = &u.s)
    1 }
  jadv x
  ptype x o is ret
  nfunc cast T alloc sizeof Type is t
  memcpy cast S t.a cast S ret sizeof Type
  (t.a.s = params)
  t
}

export ptype txo = {
  consume x "none"   ? nnone
  consume x "byte"   ? nbyte
  consume x "nat"    ? nnat
  consume x "@"      ? nptr        ptype x o
  consume x "("      ? func_params       x o
  consume x "{"      ? struct_decl       x o
  { search_scope x o x.p x.n is s
    (s.is_type or diag "not a type")
    jadv x
    s.t }
}

pj(x X o O     q TokenKind e @exok ) E = {x@ then (x.q == q) then jadv x is k e@ x o k}
pl(x X o O     c S         e @exok ) E = {x@ then jeq x c then jadv x is k e@ x o k  }
pr(x X o O a E c S         e @exoka) E = {x@ then jeq x c then jadv x is k e@ x o k a}
pu(x X o O a E c S         e @exoka) E = {x@ then consume x c ? a e@ x o x@ a}

pa1    exo  = { pj    x o   &JID   &eid   else
                pj    x o   &JSTR  &estr  else
                pj    x o   &JNUM  &enat  else
                pj    x o   &JCHR  &ebyte      }
pa3    exoa = { (a.t.q == &TFUNC) then ecall x o x@ a }
pa4    exoa = { pr    x o a "?"    &econd      }
pa5    exoa = { pr    x o a "ret"  &eret  else
                pr    x o a "is"   &eis   else
                pr    x o a "for"  &efor  else
                pr    x o a "then" &ethen else
                pr    x o a "else" &eelse else
                pu    x o a "}"    &eseq       }
pamul  exoa = { pr    x o a "*"    &emul  else
                pr    x o a "/"    &ediv  else
                pr    x o a "%"    &emod       }
paadd  exoa = { pr    x o a "+"    &eadd  else
                pr    x o a "-"    &esub       }
pash   exoa = { pr    x o a "<<"   &eshl  else
                pr    x o a ">>"   &eshr       }
pacmp  exoa = { pr    x o a "<"    &eb    else
                pr    x o a ">"    &ea    else
                pr    x o a "<="   &ebe   else
                pr    x o a ">="   &eae   else
                pr    x o a "=="   &ee    else
                pr    x o a "!="   &ene        }
paland exoa = { pr    x o a "and"  &eland      }
palor  exoa = { pr    x o a "or"   &elor       }
pa7    exoa = { pr    x o a "as"   &eas        }

export p2 exo = {
  pl x o "&"       &eaddr    else
  pl x o "-"       &eneg     else
  pl x o "!"       &elnot    else
  pl x o "not"     &elnot    else
  pl x o "cast"    &ecast    else
  pl x o "sizeof"  &esize    else
  pl x o "exit"    &eexit    else
  pl x o "brk"     &ebrk     else
  pl x o "ibrk"    &eibrk    else
  pl x o "read"    &eread    else
  pl x o "write"   &ewrite   else
  pl x o "err"     &eerr     else
  { consume x "(" ?
      { { p7    x o for a
          pr    x o a "=" &eass else
          pa7   x o a
        } ret
        expect x ")"                     }
    pl  x o "{"  &ebrace else
    pa1 x o else
    diag "expected an expression"
  } for a
  pr    x o     a "^"       &eelem   else
  pr    x o     a "."       &emem   else
  pr    x o     a "@"       &ederef
}

export p3    exo = { p2    x o for a pa3    x o a }
export p4    exo = { p3    x o for a pa4    x o a }
export p5    exo = { pl    x o "scratch" &escratch else
                     p4    x o is  a pa5    x o a }
export pmul  exo = { p4    x o for a pamul  x o a }
export padd  exo = { pmul  x o for a paadd  x o a }
export psh   exo = { padd  x o for a pash   x o a }
export pcmp  exo = { psh   x o for a pacmp  x o a }
export pland exo = { pcmp  x o for a paland x o a }
export plor  exo = { pland x o for a palor  x o a }
export p7    exo = { plor  x o for a pa7    x o a }


gtpars(x X o O t T c N g N) N = {
  !t ? { gdrop p4 x o c 0 }
    { scratch Expr nd
      scratch Scope o1
      (o1.s = o)
      (o1.k = t.k)
      (o1.e = &nd)
      (o1.is_type = 0)
      (nd.c  = -g)
      (nd.u   = t)
      gtpars x &o1 t.s c (g + 1) }
}
gtparr(x X o O t T c N g N) N = {
  !t ? { gdrop p4 x o c 0 }
    { gpush &c argreg8 g
      scratch Expr nd
      scratch Scope o1
      (o1.s = o)
      (o1.k = t.k)
      (o1.is_type = 0)
      (o1.e = &nd)
      (nd.c = c)
      (nd.u  = t)
      (((g == 5) ? &gtpars &gtparr)@ x &o1 t.s c (g + 1) + 1) }
}


typedecl(x X o O) none = {
  consume x ";" ?
    decls x o
    { scratch Scope o1
      (o1.s = o)
      (o1.k = x@)
      (o1.is_type = 1)
      declarator x &o1 &o1.t
      typedecl x &o1 }
}

function(x X o O) none = {
  consume x "export" is globl
  scratch T t
  declarator x o &t
  try_search_scope o t.k.p t.k.n is o1
  { o1 then
    (o1.is_type and diag "redeclared as a different type of symbol")
    (o1.is_def >= jeq x "=" and diag "remention") }
  scratch Scope o2
  (o2.s = o)
  (o2.k = t.k)
  (o2.t = t)
  (o2.e = 0)
  (o2.is_type = 0)
  (o2.is_def = jeq x "=")
  { o2.is_def then
    jadv x
    gs ".section .text." gk t.k glf
    { globl then gs ".globl" gc ' ' gk t.k glf }
    gk t.k gc ':' glf
    0 is c
    gfpop &c gtparr x &o2 t.a.s c 0
    gt0 "ret" }
  decls x &o2
}

export decls(x X o O) none = {
  x@ then
  (consume x "type" ? &typedecl &function)@ x o
}
