// This is an implementation of the open-addressing hash table.

#include "chub.hb"

// Initial hash bucket size
#define INIT_SIZE 16->unsigned long

// Rehash if the usage exceeds 70%.
#define HIGH_WATERMARK 70

// We'll keep the usage below 50% after rehashing.
#define LOW_WATERMARK 50

// Represents a deleted hash entry
#define TOMBSTONE -1->@

fnv_hash(s@ char len int) uint64_t =
  let hash = 0xcbf29ce484222325;
  for (let i int = 0; i < len; i++) {
    hash *= 0x100000001b3;
    hash ^= s[i]->unsigned char;
  ;
  return hash;
;

// Make room for new entires in a given hashmap by removing
// tombstones and possibly extending the bucket size.
rehash(map@ HashMap)  =
  // Compute the size of the new hashmap.
  let nkeys = 0;
  for (let i int = 0; i < map.capacity; i++)
    if (map.buckets[i].key && map.buckets[i].key != TOMBSTONE)
      nkeys++;

  let cap = map.capacity;
  while ((nkeys * 100) / cap >= LOW_WATERMARK)
    cap = cap * 2;
  assert(cap > 0);

  // Create a new hashmap and copy all key-values.
  let map2 = (let HashMap){;;
  map2.buckets = (calloc cap->unsigned long sizeof HashEntry);
  map2.capacity = cap;

  for (let i int = 0; i < map.capacity; i++) {
    let ent = &map.buckets[i];
    let a = &map2;
    if (ent.key && ent.key != TOMBSTONE) hashmap_put2 a ent.key ent.keylen ent.val;;
  assert(map2.used == nkeys);
  map@ = map2;;

match(ent@ HashEntry key@ char keylen int) bool =
  return (ent.key && ent.key != TOMBSTONE &&
         ent.keylen == keylen && ! memcmp ent.key->@ key->@ keylen->unsigned long)->bool;;
get_entry(map@ HashMap key@ char keylen int)@ HashEntry =
  if !map.buckets return 0->@HashEntry;
  let hash = fnv_hash key keylen;
  for (let i int = 0; i < map.capacity; i++) {
    let ent = &map.buckets[(hash + i) % map.capacity];
    if match ent key keylen return ent;
    if !ent.key return 0->@HashEntry;;
  unreachable;;
get_or_insert_entry(map@ HashMap key@ char keylen int)@ HashEntry =
  if !map.buckets {
    map.buckets = (calloc INIT_SIZE sizeof HashEntry);
    map.capacity = INIT_SIZE;;
  else if ((map.used * 100) / map.capacity >= HIGH_WATERMARK) rehash map;
  let hash = fnv_hash key keylen;
  for (let i int = 0; i < map.capacity; i++) {
    let ent = &map.buckets[(hash + i) % map.capacity];
    if match ent key keylen return ent;
    if (ent.key == TOMBSTONE) {
      ent.key = key;
      ent.keylen = keylen;
      return ent;;
    if !ent.key {
      ent.key = key;
      ent.keylen = keylen;
      map.used++;
      return ent;;;
  unreachable;;
export hashmap_get(map@ HashMap key@ char)@ = { let wat = (strlen key)->int; return hashmap_get2 map key wat;;;
export hashmap_get2(map@ HashMap key@ char keylen int)@ =
  let ent = get_entry map key keylen;
  return ent ? ent.val : 0->@;;
export hashmap_put(map@ HashMap key@ char val@) =
  let wat = (strlen key)->int;
  hashmap_put2 map key wat val;;
export hashmap_put2(map@HashMap key@ char keylen int val@) =
  let ent = get_or_insert_entry map key keylen;
  ent.val = val;;
export hashmap_delete(map@HashMap key@ char) =
  let wat = (strlen key)->int;
  hashmap_delete2 map key wat;;
export hashmap_delete2(map@HashMap key@ char keylen int) =
  let ent = get_entry map key keylen;
  if ent ent.key = TOMBSTONE;;
export hashmap_test(void) =
  let map = (calloc 1ul sizeof HashMap)->@HashMap;

  for (let i int = 0   ; i < 5000; i++) { let wat = format "key %d"->@char i; hashmap_put map wat i->size_t->@;;
  for (let i int = 1000; i < 2000; i++) { let wat = format "key %d"->@char i; hashmap_delete map wat;;
  for (let i int = 1500; i < 1600; i++) { let wat = format "key %d"->@char i; hashmap_put map wat i->size_t->@;;
  for (let i int = 6000; i < 7000; i++) { let wat = format "key %d"->@char i; hashmap_put map wat i->size_t->@;;

  for (let i int = 0   ; i < 1000; i++) assert(  (hashmap_get map format "key %d"->@char i->size_t) == i);
  for (let i int = 1000; i < 1500; i++) assert(! hashmap_get map "no such key"->@char);
  for (let i int = 1500; i < 1600; i++) assert(  (hashmap_get map format "key %d"->@char i->size_t) == i);
  for (let i int = 1600; i < 2000; i++) assert(! hashmap_get map "no such key"->@char);
  for (let i int = 2000; i < 5000; i++) assert(  (hashmap_get map format "key %d"->@char i->size_t) == i);
  for (let i int = 5000; i < 6000; i++) assert(! hashmap_get map "no such key"->@char);
  for (let i int = 6000; i < 7000; i++) {
    let wat = format "key %d"->@char i;
    hashmap_put map wat i->size_t->@;;
  assert(! hashmap_get map "no such key"->@char);
  printf "OK\n"->@char;;
