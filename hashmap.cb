// This is an implementation of the open-addressing hash table.

#include "chub.hb"

// Initial hash bucket size
#define INIT_SIZE 16ul

// Rehash if the usage exceeds 70%.
#define HIGH_WATERMARK 70

// We'll keep the usage below 50% after rehashing.
#define LOW_WATERMARK 50

// Represents a deleted hash entry
#define TOMBSTONE -1 to @char

fnv_hash(s@ char len int) uint64_t =
  let hash = 0xcbf29ce484222325;
  for (let i int = 0; i < len; i += 1) {
    (hash *= 0x100000001b3);
    (hash ^= s[i] to unsigned char);
  ;
  return hash;
;

// Make room for new entires in a given hashmap by removing
// tombstones and possibly extending the bucket size.
rehash(map@ HashMap)  =
  // Compute the size of the new hashmap.
  let nkeys = 0;
  for (let i int = 0; i < map.capacity; i += 1)
    if (!!map.buckets[i].key && map.buckets[i].key != TOMBSTONE)
      (nkeys += 1);

  let cap = map.capacity;
  while ((nkeys * 100) / cap >= LOW_WATERMARK)
    (cap = cap * 2);
  assert(cap > 0);

  // Create a new hashmap and copy all key-values.
  let map2 = new HashMap {;;
  (map2.buckets = (calloc cap to unsigned long sizeof HashEntry as @HashEntry));
  (map2.capacity = cap);

  for (let i int = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[i];
    let a = &map2;
    if (!!ent.key && ent.key != TOMBSTONE) hashmap_put2 a ent.key ent.keylen ent.val;;
  assert(map2.used == nkeys);
  (map@ = map2);;

match(ent@ HashEntry key@ char keylen int) bool =
  return !!ent.key && ent.key != TOMBSTONE && ent.keylen == keylen && !memcmp ent.key to @ key to @ keylen to unsigned long;;
get_entry(map@ HashMap key@ char keylen int)@ HashEntry =
  if !map.buckets return 0 to @HashEntry;
  let hash = fnv_hash key keylen;
  for (let i int = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[(hash + i) % map.capacity];
    if match ent key keylen return ent;
    if !ent.key return 0 to @HashEntry;;
  unreachable;;
get_or_insert_entry(map@ HashMap key@ char keylen int)@ HashEntry =
  if !map.buckets {
    (map.buckets = (calloc INIT_SIZE sizeof HashEntry as @HashEntry));
    (map.capacity = INIT_SIZE as int);;
  else if ((map.used * 100) / map.capacity >= HIGH_WATERMARK) rehash map;
  let hash = fnv_hash key keylen;
  for (let i int = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[(hash + i) % map.capacity];
    if match ent key keylen return ent;
    if (ent.key == TOMBSTONE) {
      (ent.key = key);
      (ent.keylen = keylen);
      return ent;;
    if !ent.key {
      (ent.key = key);
      (ent.keylen = keylen);
      (map.used += 1);
      return ent;;;
  unreachable;;
export hashmap_get(map@ HashMap key@ char)@ = { return hashmap_get2 map key (strlen key) to int;;;
export hashmap_get2(map@ HashMap key@ char keylen int)@ =
  let ent = get_entry map key keylen;
  return !!ent ? ent.val : 0 to @;;
export hashmap_put(map@ HashMap key@ char val@) =
  hashmap_put2 map key (strlen key) to int val;;
export hashmap_put2(map@HashMap key@ char keylen int val@) =
  let ent = get_or_insert_entry map key keylen;
  (ent.val = val);;
export hashmap_delete(map@HashMap key@ char) =
  hashmap_delete2 map key (strlen key) to int;;
export hashmap_delete2(map@HashMap key@ char keylen int) =
  let ent = get_entry map key keylen;
  if ent (ent.key = TOMBSTONE);;