// This is an implementation of the open-addressing hash table.

#include "chub.hb"

fnv_hash(s@ char len int) unsigned long =
  let hash = 0xcbf29ce484222325;
  for (let i int = 0; i < len; i += 1) {
    (hash *= 0x100000001b3ul);
    (hash ^= cast unsigned long cast unsigned char s[i]);
  ;
  return hash;
;

// Make room for new entires in a given hashmap by removing
// /* TOMBSTONE */ cast @char -1s and possibly extending the bucket size.
rehash(map@ HashMap)  =
  // Compute the size of the new hashmap.
  let nkeys = 0;
  for (let i int = 0; i < map.capacity; i += 1)
    if (!!map.buckets[i].key && map.buckets[i].key != /* TOMBSTONE */ cast @char -1)
      (nkeys += 1);

  let cap = map.capacity;
  while ((nkeys * 100) / cap >= /* Low_WATERMARK */ 50)
    (cap = cap * 2);

  // Create a new hashmap and copy all key-values.
  let map2 = new HashMap {;;
  (map2.buckets = cast @HashEntry calloc cast unsigned long cap sizeof HashEntry);
  (map2.capacity = cap);

  for (let i int = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[i];
    let a = &map2;
    if (!!ent.key && ent.key != /* TOMBSTONE */ cast @char -1) hashmap_put2 a ent.key ent.keylen ent.val;;
  (map@ = map2);;

match(ent@ HashEntry key@ char keylen int) bool =
  return !!ent.key && ent.key != /* TOMBSTONE */ cast @char -1 && ent.keylen == keylen && !memcmp cast @ ent.key cast @ key cast unsigned long keylen;;
get_entry(map@ HashMap key@ char keylen int)@ HashEntry =
  if !map.buckets return cast @HashEntry 0;
  let hash = fnv_hash key keylen;
  for (let i int = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[(hash + cast unsigned long i) % cast unsigned long map.capacity];
    if match ent key keylen return ent;
    if !ent.key return cast @HashEntry 0;;
  none;;
get_or_insert_entry(map@ HashMap key@ char keylen int)@ HashEntry =
  if !map.buckets {
    (map.buckets = (calloc /* INIT_SIZE */ 16ul sizeof HashEntry as @HashEntry));
    (map.capacity = /* INIT_SIZE */ 16ul as int);;
  else if ((map.used * 100) / map.capacity >= /* HIGH_WATERMARK */ 70) rehash map;
  let hash = fnv_hash key keylen;
  for (let i int = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[(hash + cast unsigned long i) % cast unsigned long map.capacity];
    if match ent key keylen return ent;
    if (ent.key == /* TOMBSTONE */ cast @char -1) {
      (ent.key = key);
      (ent.keylen = keylen);
      return ent;;
    if !ent.key {
      (ent.key = key);
      (ent.keylen = keylen);
      (map.used += 1);
      return ent;;;
  none;;
export hashmap_get(map@ HashMap key@ char)@ = { return hashmap_get2 map key cast int strlen key;;;
export hashmap_get2(map@ HashMap key@ char keylen int)@ =
  let ent = get_entry map key keylen;
  return !!ent ? ent.val : cast @ 0;;
export hashmap_put(map@ HashMap key@ char val@) =
  hashmap_put2 map key cast int strlen key val;;
export hashmap_put2(map@HashMap key@ char keylen int val@) =
  let ent = get_or_insert_entry map key keylen;
  (ent.val = val);;
export hashmap_delete(map@HashMap key@ char) =
  hashmap_delete2 map key cast int strlen key;;
export hashmap_delete2(map@HashMap key@ char keylen int) =
  let ent = get_entry map key keylen;
  if ent (ent.key = /* TOMBSTONE */ cast @char -1);;