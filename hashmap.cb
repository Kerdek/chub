// This is an implementation of the open-addressing hash table.

#include "chub.hb"

// Initial hash bucket size
#define INIT_SIZE 16ul

// Rehash if the usage exceeds 70%.
#define HIGH_WATERMARK 70ul

// We'll keep the usage below 50% after rehashing.
#define LOW_WATERMARK 50ul

// Represents a deleted hash entry
#define TOMBSTONE -1ul->@char

fnv_hash(s@ char len unsigned long) unsigned long =
  let hash = 0xcbf29ce484222325;
  for (let i unsigned long = 0ul; i < len; i++) {
    hash *= 0x100000001b3;
    hash ^= s[i]->unsigned char;
  ;
  return hash;
;

// Make room for new entires in a given hashmap by removing
// tombstones and possibly extending the bucket size.
rehash(map@ HashMap)  =
  // Compute the size of the new hashmap.
  let nkeys = 0ul;
  for (let i unsigned long = 0ul; i < map.capacity; i++)
    if (map.buckets[i].key && map.buckets[i].key != TOMBSTONE)
      nkeys++;

  let cap = map.capacity;
  while ((nkeys * 100) / cap >= LOW_WATERMARK)
    cap = cap * 2;
  assert(cap > 0ul);

  // Create a new hashmap and copy all key-values.
  let map2 = (let HashMap){;;
  map2.buckets = calloc cap sizeof HashEntry as @HashEntry;
  map2.capacity = cap;

  for (let i unsigned long = 0ul; i < map.capacity; i++) {
    let ent = &map.buckets[i];
    let a = &map2;
    if (ent.key && ent.key != TOMBSTONE) hashmap_put2 a ent.key ent.keylen ent.val;;
  assert(map2.used == nkeys);
  map@ = map2;;

match(ent@ HashEntry key@ char keylen unsigned long) bool =
  return (ent.key && ent.key != TOMBSTONE &&
         ent.keylen == keylen && ! memcmp ent.key->@ key->@ keylen)->bool;;
get_entry(map@ HashMap key@ char keylen unsigned long)@ HashEntry =
  if !map.buckets return 0->@HashEntry;
  let hash = fnv_hash key keylen;
  for (let i unsigned long = 0ul; i < map.capacity; i++) {
    let ent = &map.buckets[(hash + i) % map.capacity];
    if match ent key keylen return ent;
    if !ent.key return 0->@HashEntry;;
  unreachable;;
get_or_insert_entry(map@ HashMap key@ char keylen unsigned long)@ HashEntry =
  if !map.buckets {
    map.buckets = calloc INIT_SIZE sizeof HashEntry as @HashEntry;
    map.capacity = INIT_SIZE;;
  else if ((map.used * 100) / map.capacity >= HIGH_WATERMARK) rehash map;
  let hash = fnv_hash key keylen;
  for (let i unsigned long = 0ul; i < map.capacity; i++) {
    let ent = &map.buckets[(hash + i) % map.capacity];
    if match ent key keylen return ent;
    if (ent.key == TOMBSTONE) {
      ent.key = key;
      ent.keylen = keylen;
      return ent;;
    if !ent.key {
      ent.key = key;
      ent.keylen = keylen;
      map.used++;
      return ent;;;
  unreachable;;
export hashmap_get(map@ HashMap key@ char)@ = { return hashmap_get2 map key strlen key;;;
export hashmap_get2(map@ HashMap key@ char keylen unsigned long)@ =
  let ent = get_entry map key keylen;
  return ent ? ent.val : 0 as @;;
export hashmap_put(map@ HashMap key@ char val@) =
  hashmap_put2 map key strlen key val;;
export hashmap_put2(map@HashMap key@ char keylen unsigned long val@) =
  let ent = get_or_insert_entry map key keylen;
  ent.val = val;;
export hashmap_delete(map@HashMap key@ char) =
  hashmap_delete2 map key strlen key;;
export hashmap_delete2(map@HashMap key@ char keylen unsigned long) =
  let ent = get_entry map key keylen;
  if ent ent.key = TOMBSTONE;;