# "chub.hb"

fnv_hash(s@ i8 len i32) %i64 = return
   0xcbf29ce484222325ul is h h
:; (0 for i (i < len && (i + 1) :; (h = h * 0x100000001b3ul ^ cast %i64 cast %i8 s[i])) as void)
;;

rehash(map@ HashMap)  =
  let nkeys = 0;
  for (let i i32 = 0; i < map.capacity; i += 1)
    if (!!map.buckets[i].key && map.buckets[i].key != /* TOMBSTONE */ cast @i8 -1)
      (nkeys += 1);

  let cap = map.capacity;
  while ((nkeys * 100) / cap >= /* Low_WATERMARK */ 50)
    (cap = cap * 2);

  // Create a new hashmap and copy all key-values.
  let map2 = new HashMap {;;
  (map2.buckets = cast @HashEntry calloc cast %i64 cap sizeof HashEntry);
  (map2.capacity = cap);

  for (let i i32 = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[i];
    let a = &map2;
    if (!!ent.key && ent.key != /* TOMBSTONE */ cast @i8 -1) hashmap_put2 a ent.key ent.keylen ent.val;;
  (map@ = map2);;

match(ent@ HashEntry key@ i8 keylen i32) bool =
  return !!ent.key && ent.key != /* TOMBSTONE */ cast @i8 -1 && ent.keylen == keylen && !memcmp cast @ ent.key cast @ key cast %i64 keylen;;
get_entry(map@ HashMap key@ i8 keylen i32)@ HashEntry =
  if !map.buckets return cast @HashEntry 0;
  let hash = fnv_hash key keylen;
  for (let i i32 = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[(hash + cast %i64 i) % cast %i64 map.capacity];
    if match ent key keylen return ent;
    if !ent.key return cast @HashEntry 0;;
  none;;
get_or_insert_entry(map@ HashMap key@ i8 keylen i32)@ HashEntry =
  if !map.buckets {
    (map.buckets = (calloc /* INIT_SIZE */ 16ul sizeof HashEntry as @HashEntry));
    (map.capacity = /* INIT_SIZE */ 16ul as i32);;
  else if ((map.used * 100) / map.capacity >= /* HIGH_WATERMARK */ 70) rehash map;
  let hash = fnv_hash key keylen;
  for (let i i32 = 0; i < map.capacity; i += 1) {
    let ent = &map.buckets[(hash + cast %i64 i) % cast %i64 map.capacity];
    if match ent key keylen return ent;
    if (ent.key == /* TOMBSTONE */ cast @i8 -1) {
      (ent.key = key);
      (ent.keylen = keylen);
      return ent;;
    if !ent.key {
      (ent.key = key);
      (ent.keylen = keylen);
      (map.used += 1);
      return ent;;;
  none;;

export hashmap_get    (m @HashMap k@ i8                )@ = return   hashmap_get2        m k cast i32 strlen k    ;;
export hashmap_put    (m @HashMap k@ i8            val@)  = return   hashmap_put2        m k cast i32 strlen k val;;
export hashmap_delete (m @HashMap k@ i8                )  = return   hashmap_delete2     m k cast i32 strlen k    ;;
export hashmap_put2   (m @HashMap k@ i8 keylen i32 val@)  = return ((get_or_insert_entry m k keylen).val = val);;
export hashmap_get2   (m @HashMap k@ i8 keylen i32     )@ = return   get_entry           m k keylen is e !!e ? e.val : cast @ 0;;
export hashmap_delete2(m @HashMap k@ i8 keylen i32     )  = return   get_entry           m k keylen is e (e && (e.key = cast @i8 -1) as void);;