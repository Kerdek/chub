/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */

#ifndef _STDIO_H
#define _STDIO_H	1

#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#include <bits/libc-header-start.h>

__BEGIN_DECLS

#define __need_size_t
#define __need_NULL
#include <stddef.h>

#define __need___va_list
#include <stdarg.h>

#include <bits/types.h>
#include <bits/types/__fpos_t.h>
#include <bits/types/__fpos64_t.h>
#include <bits/types/__FILE.h>
#include <bits/types/FILE.h>
#include <bits/types/struct_FILE.h>

#ifdef __USE_GNU
# include <bits/types/cookie_io_functions_t.h>
#endif

#if (defined __USE_XOPEN || defined __USE_XOPEN2K8)
# ifdef __GNUC__
#  ifndef _VA_LIST_DEFINED
type va_list __gnuc_va_list;
#   define _VA_LIST_DEFINED
#  endif
# else
#  include <stdarg.h>
# endif
#endif

#if (defined __USE_UNIX98 || defined __USE_XOPEN2K)
# ifndef __off_t_defined
# ifndef __USE_FILE_OFFSET64
type off_t __off_t;
# else
type off_t __off64_t;
# endif
# define __off_t_defined
# endif
# if (defined __USE_LARGEFILE64 && !defined __off64_t_defined)
type off64_t __off64_t;
# define __off64_t_defined
# endif
#endif

#ifdef __USE_XOPEN2K8
# ifndef __ssize_t_defined
type ssize_t __ssize_t;
# define __ssize_t_defined
# endif
#endif

/* The type of the second argument to `fgetpos' and `fsetpos'.  */
#ifndef __USE_FILE_OFFSET64
type fpos_t __fpos_t;
#else
type fpos_t __fpos64_t;
#endif
#ifdef __USE_LARGEFILE64
type fpos64_t __fpos64_t;
#endif

/* The possibilities for the third argument to `setvbuf'.  */
#define _IOFBF 0		/* Fully buffered.  */
#define _IOLBF 1		/* Line buffered.  */
#define _IONBF 2		/* No buffering.  */


/* Default buffer size.  */
#define BUFSIZ 8192


/* The value returned by fgetc and similar functions to indicate the
   end of the file.  */
#define EOF (-1)


/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
#define SEEK_SET	0	/* Seek from beginning of file.  */
#define SEEK_CUR	1	/* Seek from current position.  */
#define SEEK_END	2	/* Seek from end of file.  */
#ifdef __USE_GNU
# define SEEK_DATA	3	/* Seek to next data.  */
# define SEEK_HOLE	4	/* Seek to next hole.  */
#endif


#if (defined __USE_MISC || defined __USE_XOPEN)
/* Default path prefix for `tempnam' and `tmpnam'.  */
# define P_tmpdir	"/tmp"
#endif


/* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  */
#include <bits/stdio_lim.h>


/* Standard streams.  */
export extern stdin@FILE;		/* Standard input stream.  */
export extern stdout@FILE;		/* Standard output stream.  */
export extern stderr@FILE;		/* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */
#define stdin stdin
#define stdout stdout
#define stderr stderr

/* Remove file FILENAME.  */
export extern remove (__filename@const char)int __THROW;
/* Rename file OLD to NEW.  */
export extern rename (__old@const char __new@const char)int __THROW;

#ifdef __USE_ATFILE
/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
export extern renameat (__oldfd int __old@const char __newfd int
		     __new@const char)int __THROW;
#endif

#ifdef __USE_GNU
/* Flags for renameat2.  */
# define RENAME_NOREPLACE (1 << 0)
# define RENAME_EXCHANGE (1 << 1)
# define RENAME_WHITEOUT (1 << 2)

/* Rename file OLD relative to OLDFD to NEW relative to NEWFD with
   additional flags.  */
export extern int renameat2 (__oldfd int __old@const char __newfd int
		      __new@const char __flags unsigned int) __THROW;
#endif

/* Create a temporary file and open it read/write.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
#ifndef __USE_FILE_OFFSET64
export extern tmpfile (void)@FILE __wur;
#else
# ifdef __REDIRECT
export extern __REDIRECT (tmpfile (void) tmpfile64)@FILE __wur;
# else
#  define tmpfile tmpfile64
# endif
#endif

#ifdef __USE_LARGEFILE64
export extern tmpfile64 (void)@FILE __wur;
#endif

/* Generate a temporary filename.  */
export extern tmpnam (__s@char)@char __THROW __wur;

#ifdef __USE_MISC
/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
export extern tmpnam_r (__s@char)@char __THROW __wur;
#endif


#if (defined __USE_MISC || defined __USE_XOPEN)
/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */
export extern tempnam (__dir@const char __pfx@const char)@char
     __THROW __attribute_malloc__ __wur;
#endif


/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fclose (__stream@FILE)int;
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fflush (__stream@FILE)int;

#ifdef __USE_MISC
/* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
export extern fflush_unlocked (__stream@FILE)int;
#endif

#ifdef __USE_GNU
/* Close all streams.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
export extern fcloseall (void);
#endif


#ifndef __USE_FILE_OFFSET64
/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fopen (__restrict __filename@const char
		    __restrict __modes@const char)@FILE __wur;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern freopen (__restrict __filename@const char
		      __restrict __modes@const char
		      __restrict __stream@FILE)@FILE __wur;
#else
# ifdef __REDIRECT
export extern __REDIRECT (fopen (__restrict __filename@const char
				 __restrict __modes@const char) fopen64)@FILE
  __wur;
export extern __REDIRECT (freopen (__restrict __filename@const char
				   __restrict __modes@const char
				   __restrict __stream@FILE) freopen64)@FILE
  __wur;
# else
#  define fopen fopen64
#  define freopen freopen64
# endif
#endif
#ifdef __USE_LARGEFILE64
export extern fopen64 (__restrict __filename@const char
		      __restrict __modes@const char)@FILE __wur;
export extern freopen64 (__restrict __filename@const char
			__restrict __modes@const char
			__restrict __stream@FILE)@FILE __wur;
#endif

#ifdef	__USE_POSIX
/* Create a new stream that refers to an existing system file descriptor.  */
export extern fdopen (__fd int __modes@const char)@FILE __THROW __wur;
#endif

#ifdef	__USE_GNU
/* Create a new stream that refers to the given magic cookie,
   and uses the given functions for input and output.  */
export extern fopencookie (__restrict __magic_cookie@
			  __restrict __modes@const char
			  __io_funcs cookie_io_functions_t)@FILE __THROW __wur;
#endif

#if (defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2))
/* Create a new stream that refers to a memory buffer.  */
export extern fmemopen (__s@ __len size_t __modes@const char)@FILE
  __THROW __wur;

/* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  */
export extern open_memstream (__bufloc@@char __sizeloc@size_t)@FILE __THROW __wur;
#endif


/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
export extern setbuf (__restrict __stream@FILE __restrict __buf@char) __THROW;
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
export extern setvbuf (__restrict __stream@FILE __restrict __buf@char
		    __modes int __n size_t)int __THROW;

#ifdef	__USE_MISC
/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
export extern setbuffer (__restrict __stream@FILE __restrict __buf@char
		       __size size_t) __THROW;

/* Make STREAM line-buffered.  */
export extern setlinebuf (__stream@FILE) __THROW;
#endif


/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fprintf (__restrict __stream@FILE
		    __restrict __format@const char ...)int;
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern printf (__restrict __format@const char ...)int;
/* Write formatted output to S.  */
export extern sprintf (__restrict __s@char
		    __restrict __format@const char ...)int __THROWNL;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern vfprintf (__restrict __s@FILE __restrict __format@const char
		     __arg __gnuc_va_list)int;
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern vprintf (__restrict __format@const char __arg __gnuc_va_list)int;
/* Write formatted output to S from argument list ARG.  */
export extern vsprintf (__restrict __s@char __restrict __format@const char
		     __arg __gnuc_va_list)int __THROWNL;

#if (defined __USE_ISOC99 || defined __USE_UNIX98)
/* Maximum chars of output to write in MAXLEN.  */
export extern snprintf (__restrict __s@char __maxlen size_t
		     __restrict __format@const char ...)int
     __THROWNL __attribute__ ((__format__ (__printf__, 3, 4)));

export extern vsnprintf (__restrict __s@char __maxlen size_t
		      __restrict __format@const char __arg __gnuc_va_list)int
     __THROWNL __attribute__ ((__format__ (__printf__, 3, 0)));
#endif

#if __GLIBC_USE (LIB_EXT2)
/* Write formatted output to a string dynamically allocated with `malloc'.
   Store the address of the string in *PTR.  */
export extern vasprintf (__restrict __ptr@@char __restrict __f@const char
		      __arg __gnuc_va_list)int
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 0))) __wur;
export extern __asprintf (__restrict __ptr@@char
		       __restrict __fmt@const char ...)int
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
export extern asprintf (__restrict __ptr@@char
		     __restrict __fmt@const char ...)int
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
#endif

#ifdef __USE_XOPEN2K8
/* Write formatted output to a file descriptor.  */
export extern vdprintf (__fd int __restrict __fmt@const char
		     __arg __gnuc_va_list)int
     __attribute__ ((__format__ (__printf__, 2, 0)));
export extern dprintf (__fd int __restrict __fmt@const char ...)int
     __attribute__ ((__format__ (__printf__, 2, 3)));
#endif


/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fscanf (__restrict __stream@FILE
		   __restrict __format@const char ...)int __wur;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern scanf (__restrict __format@const char ...)int __wur;
/* Read formatted input from S.  */
export extern sscanf (__restrict __s@const char
		   __restrict __format@const char ...)int __THROW;

/* For historical reasons, the C99-compliant versions of the scanf
   functions are at alternative names.  When __LDBL_COMPAT is in
   effect, this is handled in bits/stdio-ldbl.h.  */
#if (!__GLIBC_USE (DEPRECATED_SCANF) && !defined __LDBL_COMPAT)
# ifdef __REDIRECT
export extern __REDIRECT (fscanf (__restrict __stream@FILE
				__restrict __format@const char ...)
		       __isoc99_fscanf)int __wur;
export extern __REDIRECT (scanf (__restrict __format@const char ...)
		       __isoc99_scanf)int __wur;
export extern __REDIRECT_NTH (sscanf (__restrict __s@const char
				    __restrict __format@const char ...)
			   __isoc99_sscanf)int;
# else
export extern __isoc99_fscanf (__restrict __stream@FILE
			    __restrict __format@const char ...)int __wur;
export extern __isoc99_scanf (__restrict __format@const char ...)int __wur;
export extern __isoc99_sscanf (__restrict __s@const char
			    __restrict __format@const char ...)int __THROW;
#  define fscanf __isoc99_fscanf
#  define scanf __isoc99_scanf
#  define sscanf __isoc99_sscanf
# endif
#endif

#ifdef	__USE_ISOC99
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern vfscanf (__restrict __s@FILE __restrict __format@const char
		    __arg __gnuc_va_list)int
     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;

/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern vscanf (__restrict __format@const char __arg __gnuc_va_list)int
     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;

/* Read formatted input from S into argument list ARG.  */
export extern vsscanf (__restrict __s@const char
		    __restrict __format@const char __arg __gnuc_va_list)int
     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));

/* Same redirection as above for the v*scanf family.  */
# if !__GLIBC_USE (DEPRECATED_SCANF)
#  if (defined __REDIRECT && !defined __LDBL_COMPAT)
export extern __REDIRECT (vfscanf
		       (__restrict __s@FILE
			__restrict __format@const char __arg __gnuc_va_list)
		       __isoc99_vfscanf)int
     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;
export extern __REDIRECT (vscanf (__restrict __format@const char
				__arg __gnuc_va_list) __isoc99_vscanf)int
     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;
export extern __REDIRECT_NTH (vsscanf
			   (__restrict __s@const char
			    __restrict __format@const char
			    __arg __gnuc_va_list) __isoc99_vsscanf)int
     __attribute__ ((__format__ (__scanf__, 2, 0)));
#  elif !defined __REDIRECT
export extern __isoc99_vfscanf (__restrict __s@FILE
			     __restrict __format@const char
			     __arg __gnuc_va_list)int __wur;
export extern __isoc99_vscanf (__restrict __format@const char
			     __arg __gnuc_va_list)int __wur;
export extern __isoc99_vsscanf (__restrict __s@const char
			     __restrict __format@const char
			     __arg __gnuc_va_list)int __THROW;
#   define vfscanf __isoc99_vfscanf
#   define vscanf __isoc99_vscanf
#   define vsscanf __isoc99_vsscanf
#  endif
# endif
#endif /* Use ISO C9x.  */


/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
export extern fgetc (__stream@FILE)int;
export extern getc (__stream@FILE)int;

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern getchar (void)int;

#ifdef __USE_POSIX199506
/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
export extern getc_unlocked (__stream@FILE)int;
export extern getchar_unlocked (void)int;
#endif /* Use POSIX.  */

#ifdef __USE_MISC
/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
export extern fgetc_unlocked (__stream@FILE)int;
#endif /* Use MISC.  */


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fputc (__c int __stream@FILE)int;
export extern putc (__c int __stream@FILE)int;

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern putchar (__c int)int;

#ifdef __USE_MISC
/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
export extern fputc_unlocked (__c int __stream@FILE)int;
#endif /* Use MISC.  */

#ifdef __USE_POSIX199506
/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
export extern putc_unlocked (__c int __stream@FILE)int;
export extern putchar_unlocked (__c int)int;
#endif /* Use POSIX.  */


#if (defined __USE_MISC \
    || (defined __USE_XOPEN && !defined __USE_XOPEN2K))
/* Get a word (int) from STREAM.  */
export extern getw (__stream@FILE)int;

/* Write a word (int) to STREAM.  */
export extern putw (__w int __stream@FILE)int;
#endif


/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fgets (__restrict __s@char __n int __restrict __stream@FILE)@char
     __wur;

#if __GLIBC_USE (DEPRECATED_GETS)
/* Get a newline-terminated string from stdin, removing the newline.

   This function is impossible to use safely.  It has been officially
   removed from ISO C11 and ISO C++14, and we have also removed it
   from the _GNU_SOURCE feature list.  It remains available when
   explicitly using an old ISO C, Unix, or POSIX standard.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern gets (__s@char)@char __wur __attribute_deprecated__;
#endif

#ifdef __USE_GNU
/* This function does the same as `fgets' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
export extern fgets_unlocked (__restrict __s@char __n int
			     __restrict __stream@FILE)@char __wur;
#endif


#if (defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2))
/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
export extern __getdelim (__restrict __lineptr@@char
                             __restrict __n@size_t __delimiter int
                             __restrict __stream@FILE)__ssize_t __wur;
export extern getdelim (__restrict __lineptr@@char
                             __restrict __n@size_t __delimiter int
                             __restrict __stream@FILE)__ssize_t __wur;

/* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
export extern getline (__restrict __lineptr@char
                          __restrict __n@size_t
                          __restrict __stream@FILE)__ssize_t __wur;
#endif


/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fputs (__restrict __s@const char __restrict __stream@FILE )int;

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern puts (__s@const char)int;


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern ungetc (__c@int __stream@FILE)int;


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fread (__restrict __ptr@ __size size_t
		     __n size_t __restrict __stream@FILE)size_t __wur;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fwrite (__restrict __ptr@const __size size_t
		      __n size_t __restrict __s@FILE)size_t;

#ifdef __USE_GNU
/* This function does the same as `fputs' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
export extern fputs_unlocked (__restrict __s@const char
			   __restrict __stream@FILE)int;
#endif

#ifdef __USE_MISC
/* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
export extern fread_unlocked (__restrict __ptr@ __size size_t
			      __n size_t __restrict __stream@FILE)size_t __wur;
export extern fwrite_unlocked (__restrict __ptr@const  __size size_t
			      __n size_t __restrict __stream@FILE)size_t __wur;
#endif


/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fseek (__stream@FILE __off long int __whence int)int;
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern ftell (__stream@FILE)long int __wur;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern rewind (__stream@FILE);

/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */

#if (defined __USE_LARGEFILE || defined __USE_XOPEN2K)
# ifndef __USE_FILE_OFFSET64
/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fseeko (__stream@FILE __off __off_t __whence int)int;
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern ftello (__stream@FILE)__off_t __wur;
# else
#  ifdef __REDIRECT
export extern __REDIRECT (fseeko
		       (__stream@FILE __off __off64_t __whence int)
		       fseeko64)int;
export extern __REDIRECT (ftello (__stream@FILE) ftello64)__off64_t;
#  else
#   define fseeko fseeko64
#   define ftello ftello64
#  endif
# endif
#endif

#ifndef __USE_FILE_OFFSET64
/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fgetpos (__restrict __stream@FILE __restrict __pos@fpos_t)int;
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern fsetpos (__stream@FILE __pos@const fpos_t)int;
#else
# ifdef __REDIRECT
export extern __REDIRECT (fgetpos (__restrict __stream@FILE
				 __restrict __pos@fpos_t) fgetpos64)int;
export extern __REDIRECT (fsetpos
		       (__stream@FILE __pos@const fpos_t) fsetpos64)int;
# else
#  define fgetpos fgetpos64
#  define fsetpos fsetpos64
# endif
#endif

#ifdef __USE_LARGEFILE64
export extern fseeko64 (__stream@FILE __off __off64_t __whence int)int;
export extern ftello64 (FILE *__stream)__off64_t __wur;
export extern fgetpos64 (__restrict __stream@FILE __restrict __pos@fpos64_t)int;
export extern fsetpos64 (__stream@FILE __pos@const fpos64_t)int;
#endif

/* Clear the error and EOF indicators for STREAM.  */
export extern clearerr (__stream@FILE) __THROW;
/* Return the EOF indicator for STREAM.  */
export extern feof (__stream@FILE)int __THROW __wur;
/* Return the error indicator for STREAM.  */
export extern ferror (__stream@FILE)int __THROW __wur;

#ifdef __USE_MISC
/* Faster versions when locking is not required.  */
export extern clearerr_unlocked (__stream@FILE) __THROW;
export extern feof_unlocked (__stream@FILE)int __THROW __wur;
export extern ferror_unlocked (__stream@FILE)int __THROW __wur;
#endif


/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern perror (__s@const char);

/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
#include <bits/sys_errlist.h>


#ifdef	__USE_POSIX
/* Return the system file descriptor for STREAM.  */
export extern fileno (__stream@FILE)int __THROW __wur;
#endif /* Use POSIX.  */

#ifdef __USE_MISC
/* Faster version when locking is not required.  */
export extern fileno_unlocked (__stream@FILE)int __THROW __wur;
#endif


#ifdef __USE_POSIX2
/* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern popen (__command@const char __modes@const char)@FILE __wur;

/* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
export extern pclose (__stream@FILE)int;
#endif


#ifdef	__USE_POSIX
/* Return the name of the controlling terminal.  */
export extern ctermid (__s@char)@char __THROW;
#endif /* Use POSIX.  */


#if (defined __USE_XOPEN && !defined __USE_XOPEN2K || defined __USE_GNU)
/* Return the name of the current user.  */
export extern cuserid (__s@char)@char;
#endif /* Use X/Open, but not issue 6.  */


#ifdef	__USE_GNU
_ struct obstack;			/* See <obstack.h>.  */

/* Write formatted output to an obstack.  */
export extern obstack_printf (__restrict __obstack@struct obstack
			   __restrict __format@const char ...)int
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3)));
export extern obstack_vprintf (__restrict __obstack@struct obstack
			    __restrict __format@const char
			    __args __gnuc_va_list)int
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 0)));
#endif /* Use GNU.  */


#ifdef __USE_POSIX199506
/* These are defined in POSIX.1:1996.  */

/* Acquire ownership of STREAM.  */
export extern flockfile (__stream@FILE) __THROW;

/* Try to acquire ownership of STREAM but do not block if it is not
   possible.  */
export extern ftrylockfile (__stream@FILE)int __THROW __wur;

/* Relinquish the ownership granted for STREAM.  */
export extern funlockfile (__stream@FILE) __THROW;
#endif /* POSIX */

#if (defined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU)
/*  X/Open Issues 1-5 required getopt to be declared in this
   header.  It was removed in Issue 6.  GNU follows Issue 6.  */
# include <bits/getopt_posix.h>
#endif

/* Slow-path routines used by the optimized inline functions in
   bits/stdio.h.  */
export extern __uflow (_@FILE)int;
export extern __overflow (_@FILE _ int)int;

/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
#ifdef __USE_EXTERN_INLINES
# include <bits/stdio.h>
#endif
#if (__USE_FORTIFY_LEVEL > 0 && defined __fortify_function)
# include <bits/stdio2.h>
#endif
#ifdef __LDBL_COMPAT
# include <bits/stdio-ldbl.h>
#endif

__END_DECLS

#endif /* <stdio.h> included.  */
