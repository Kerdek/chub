type

  Crumb {
    s @Crumb
    d nat
  }

  necl (e E c nat) nat
;

tree(k K t T q @necl) E = {
  cast E alloc sizeof Expr is e
  (e.k = k)
  (e.t = t)
  (e.q = q)
  e
}

gcast(a T b T) none = {
  (b.q == &TNONE) ?
    gtz     "eax"
    { (b.q == &TBYTE) then
      gpromote  "eax" }
}

gaddr(t T n nat s @byte d @byte) none = {
  (n or !strcmp s d) then
  gs "lea " { n then gn n } gs "(%" gs s gs "),%" gs d glf
}
gload(t T n nat s @byte d @byte) none = {
  (t.q == &TBYTE) ?
    { gs  "movzbq " gn n gs "(%" gs s gs "),%" gs  d glf }
    { gs  "mov "    gn n gs "(%" gs s gs "),%" gs  d glf }
}
gstore(t T d @byte) none = {
  (t.q == &TBYTE) ?
    { gs "mov %al,(%"  gs d gc ')' glf }
    { gs "mov %rax,(%" gs d gc ')' glf }
}

export gexpr necl  = { e.q@ e c }

export gdrop (e E c nat    ) none = { cast none gexpr e c }
export geval (e E c nat l nat) none = {
  gexpr e c for l1
  (l1 > l) then
  (l1 == 1 and l == 0) ?
    (e.t.q == &TFUNC or e.t.q == &TSTCT or gload e.t 0 "rax" "rax")
    { gs "mov (%rax),%rax" glf }
  (l1 - 1)
}

ge1     (e E c nat gop @() none) nat = {
  geval  e.a c 0
  gop@
  0
}

ge2     (e E c nat gop @() none) nat = {
  geval  e.a    c 0
  gpush        &c "rax"
  geval  e.a.s  c 0
  gt0  "mov %rax,%rdi"
  gpop         &c "rax"
  gop@
  0
}

gegneg  () none = gtneg  "rax"
geglnot () none = glnot  "rax" "eax"
gegadd  () none = gadd   "rdi" "rax"
gegsub  () none = gsub   "rdi" "rax"
gegmul  () none = gmul   "rdi"

export ebrace   exok  = p5 x o
export eparen   exok  = p7 x o

genat    necl  = { gs "mov $" gk e.k gs ",%rax" glf 0 }
export enat     exok   = tree k nnat  &genat

gebyte   necl  = { gs "mov $" gk e.k ((e.k.p^1 == '\\') ? 3 2) gs ",%rax" glf 0 }
export ebyte    exok   = tree k nbyte &gebyte

gesize   necl  = {
  gtlit e.u.size "rax"
  0
}
export esize    exok   = {
  tree k nnat &gesize is e
  (e.u = ptype x o)
  e
}

gederef  necl  = (gexpr e.a c + 1)
export ederef   exoka  = {
  tree k a.t.a &gederef is e
  (e.a = a)
  e
}

geaddr   necl  = (gexpr e.a c - 1)
export eaddr    exok   = {
  p2 x o is a
  tree k nptr a.t &geaddr is e
  (e.a = a)
  e
}

gecast  necl  = {
  geval  e.a c 0
  gcast  e.a.t e.t
  0
}
export eas      exoka  = {
  tree k ptype x o &gecast is e
  (e.a = a)
  e
}
export ecast    exok   = {
  ptype x o is u
  tree k u &gecast is e
  (e.a = p4 x o)
  e
}

gestr necl  = {
  gs "mov .s" gn (e.k.line * 10000 + e.k.col) gs "@GOTPCREL(%rip),%rax" glf
  0
}
export estr   exok  = {
  tree k nptr nbyte &gestr
}

geid   necl  = {
  e.a ?
    { gaddr e.a.u (c - e.a.c << 3) "rsp" "rax" }
    { gs "mov " gk e.t.k gs "@GOTPCREL(%rip),%rax" glf }
  1
}
export eid    exok  = {
  (search_scope x o k.p k.n) is s
  (s.is_type and kdiag k "not a variable")
  cast E alloc sizeof Expr is e
  (e.s = 0    )
  (e.q = &geid)
  (e.k = x.k@    )
  s.e ? {
    (e.a = s.e  )
    (e.t = s.e.u)
  }{(e.a = 0    )
    (e.t = s.t  ) }
  e
}

gelnot necl  = ge1 e c &geglnot export elnot exok  = { tree k nnat &gelnot is e (e.a = p3 x o ) e }
geneg  necl  = ge1 e c &gegneg  export eneg  exok  = { tree k nnat &geneg  is e (e.a = p3 x o ) e }
gediv  necl  = ge2 e c &gdiv    export ediv  exoka = { tree k nnat &gediv  is e (e.a = a) (e.a.s = p4    x o) e }
gemod  necl  = ge2 e c &gmod    export emod  exoka = { tree k nnat &gemod  is e (e.a = a) (e.a.s = p4    x o) e }
geadd  necl  = ge2 e c &gegadd  export eadd  exoka = { tree k nnat &geadd  is e (e.a = a) (e.a.s = pmul  x o) e }
gesub  necl  = ge2 e c &gegsub  export esub  exoka = { tree k nnat &gesub  is e (e.a = a) (e.a.s = pmul  x o) e }
gemul  necl  = ge2 e c &gegmul  export emul  exoka = { tree k nnat &gemul  is e (e.a = a) (e.a.s = p4    x o) e }
geshl  necl  = ge2 e c &gshl    export eshl  exoka = { tree k nnat &geshl  is e (e.a = a) (e.a.s = padd  x o) e }
geshr  necl  = ge2 e c &gshr    export eshr  exoka = { tree k nnat &geshr  is e (e.a = a) (e.a.s = padd  x o) e }
gee    necl  = ge2 e c &ge      export ee    exoka = { tree k nnat &gee    is e (e.a = a) (e.a.s = psh   x o) e }
gene   necl  = ge2 e c &gne     export ene   exoka = { tree k nnat &gene   is e (e.a = a) (e.a.s = psh   x o) e }
geae   necl  = ge2 e c &gae     export eae   exoka = { tree k nnat &geae   is e (e.a = a) (e.a.s = psh   x o) e }
gea    necl  = ge2 e c &ga      export ea    exoka = { tree k nnat &gea    is e (e.a = a) (e.a.s = psh   x o) e }
geb    necl  = ge2 e c &gb      export eb    exoka = { tree k nnat &geb    is e (e.a = a) (e.a.s = psh   x o) e }
gebe   necl  = ge2 e c &gbe     export ebe   exoka = { tree k nnat &gebe   is e (e.a = a) (e.a.s = psh   x o) e }

geelem necl   = {
  geval  e.a    c 0
  gpush        &c "rax"
  geval  e.a.s  c 0
  gpop         &c "rdi"
  gs  "lea (%rdi,%rax," gn  e.a.t.a.size gs  "),%rax" glf 
  1
}
export eelem  exoka = {
  tree k a.t.a &geelem is e
  (e.a = a)
  (e.a.s = p3 x o)
  e
}

gemem   necl  = {
  geval  e.a c 0
  { e.a.t for t
    (t.q == &TPTR) then
    (t.a.q == &TSTCT) ?
      gaddr t.a 0 "rax" "rax"
      gload t.a 0 "rax" "rax"
    t.a }
  gindex e.t.offset
  1
}
export emem  exoka  = {
  jadv x
  { a.t for t (t.q == &TPTR) then t.a } is t
  (t.q != &TSTCT and kdiag k "not a struct")
  cast T 0 is g
  { t.a for a
    { (a.k.n == k.s.n) then strncmp a.k.p k.s.p k.s.n }
    ? { (g = a) cast T 0 }
      a.s }
  { !g then kdiag k "no such member" }
  tree k.s g &gemem is e
  (e.a = a)
  e
}

geseq  necl  = {
  gdrop  e.a   c
  geval  e.a.s c 0
  0
}
export eseq   exoka  = {
  p5 x o is b
  tree k b.t &geseq is e
  (e.a = a)
  (e.a.s = b)
  e
}

geret necl  = {
  geval  e.a    c 0
  gpush        &c "rax"
  gdrop  e.a.s  c
  gpop         &c "rax"
  0
}
export eret  exoka  = {
  tree k a.t &geret is e
  (e.a = a)
  (e.a.s = p5 x o)
  e
}

gecond necl   = {
  geval   e.a     c 0
  gtcz              "rax"
  gje     e.k       "a"
  geval   e.a.s   c 0
  gj      e.k       "b"
  glabel  e.k       "a"
  geval   e.a.s.s c 0
  glabel  e.k       "b"
  0
}
export econd  exoka = {
  p4 x o is b
  tree k b.t &gecond is e
  (e.a = a)
  (e.a.s = b)
  (e.a.s.s = p4 x o)
  e
}

geland necl  = {
  (e.a.s.t.q == &TNONE) is keep
  geval  e.a c 0
  gtcz              "rax"
  gje    e.k        "a"
  gpush        &c "rax"
  geval  e.a.s c 0
  gpop         &c (keep ? "rax" "rdx")
  glabel e.k        "a"
  0
}
export ethen  exoka  = {
  p5 x o is b
  tree k b.t &geland is e
  (e.a = a)
  (e.a.s = b)
  e
}
export eland  exoka  = {
  pcmp x o is b
  tree k b.t &geland is e
  (e.a = a)
  (e.a.s = b)
  e
}

gelor  necl  = {
  (e.a.s.t.q == &TNONE) is keep
  geval    e.a   c  0
  gtcz              "rax"
  gjne     e.k      "a"
  gpush        &c "rax"
  geval    e.a.s  c 0
  gpop         &c (keep ? "rax" "rdx")
  glabel   e.k      "a"
  0
}
export eelse  exoka  = {
  tree k a.t &gelor is e
  (e.a = a)
  (e.a.s = p5    x o)
  e
}
export elor   exoka  = {
  tree k a.t &gelor is e
  (e.a = a)
  (e.a.s = pland x o)
  e
}

gescratch necl = {
  (e.u.size + 7 >> 3) is d
  gfpush    &c d
  (e.c = c)
  geval e.a  c   0
  gfpop     &c d
  0
}
export escratch  exok   = {
  cast E alloc sizeof Expr is e
  (e.s   = 0         )
  (e.q   = &gescratch)
  (e.k   = k        )
  (e.u   = ptype x o )
  scratch Scope o1
  (o1.s  = o         )
  (o1.k  = jadv x    )
  (o1.e  = e         )
  (o1.is_type = 0    )
  (e.a   = p5 x &o1  )
  (e.t   = e.a.t     )
  e
}

geis   necl = {
  (e.u.size + 7 >> 3) is d
  geval    e.a    c   0
  gfpush         &c d
  (e.c = c)
  gstore   e.u          "rsp"
  geval    e.a.s  c   0
  gfpop          &c d
  0
}
export eis    exoka = {
  cast E alloc sizeof Expr is e
  (e.s   = 0      )
  (e.q   = &geis  )
  (e.k   = k     )
  (e.a   = a      )
  (e.u   = a.t    )
  scratch Scope o1
  (o1.s  = o      )
  (o1.k  = jadv x )
  (o1.e  = e      )
  (o1.is_type = 0 )
  (e.a.s = p5 x &o1)
  (e.t   = e.a.s.t)
  e
}

gefor  necl = {
  (e.u.size + 7 >> 3) is d
  geval     e.a    c   0
  gfpush          &c d
  (e.c = c)
  gstore    e.u          "rsp"
  gj        e.k          "b"
  glabel    e.k          "a"
  gstore    e.u          "rsp"
  glabel    e.k          "b"
  geval     e.a.s  c   0
  gtcz                   "rax"
  gjne      e.k          "a"
  gload     e.u      0   "rsp" "rax"
  gfpop           &c d
  0
}
export efor   exoka = {
  cast E alloc sizeof Expr is e
  (e.s   = 0      )
  (e.q   = &gefor )
  (e.k   = k     )
  (e.a   = a      )
  (e.u   = a.t    )
  scratch Scope o1
  (o1.s  = o      )
  (o1.k  = jadv x )
  (o1.e  = e      )
  (o1.is_type = 0 )
  (e.a.s = p5 x &o1)
  (e.t   = e.a.s.t)
  e
}

geass  necl  = {
  geval   e.a    c 1
  gpush         &c   "rax"
  geval   e.a.s  c 0
  gpop          &c   "rdi"
  gstore  e.a.t      "rdi"
  gtz                "eax"
  0
}
export eass   exoka  = {
  tree k nnone &geass is e
  (e.a = a)
  (e.a.s = p7 x o)
  e
}

gecall necl  = {
  geval e.a    c 0
  0 is stack
  e.a.t is tf
  { tf.a.s then
    tf.a.s for u
    (stack = stack + 1)
    u.s }
  gfpush &c stack
  gpush &c "rax"
  8 is off
  e.a.s is b
  { tf.a.s then
    tf.a.s for u
    geval b c 0
    gs "mov %rax," gn off gs "(%rsp)" glf
    (off = off + 8)
    (b = b.s)
    u.s }
  gpop &c "rax"
  0 is d
  { tf.a.s then
    tf.a.s for u
    (d < 6) then
    gpop &c argreg d
    (d = d + 1)
    u.s }
  gt0 "call *%rax"
  0
}
export ecall exoka = {
  a.t.a.s is u
  { a for b
    u then
    (b.s = p3 x o)
    { !type_equal b.s.t u then kdiag k "asymmetric argument" }
    (u = u.s)
    b.s }
  tree x.k@ a.t.a &gecall is e
  (e.a = a)
  e
}

geexit necl = {
  geval e.a c 0
  gt2 "mov" "rax" "rdi"
  gtlit 60 "rax"
  gt0 "syscall"
  0
}
export eexit  exok  = { tree k nnone &geexit is e (e.a = p3 x o) e }

geibrk  necl = {
  gtlit 0  "rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov %rax,.scurbrk"
  0
}
export eibrk   exok  = { tree k nnone &geibrk }

gebrk  necl = {
  geval e.a c 0
  gt0 "mov .scurbrk,%rdi"
  gt0 "add %rax,%rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov .scurbrk,%rax"
  gt0 "mov %rdi,.scurbrk"
  0
}
export ebrk   exok  = { tree k nnat &gebrk is e (e.a = p3 x o) e }

gegsys3 (n nat a0 nat e E c nat) none = {
  geval e.a    c 0
  gpush       &c "rax"
  geval e.a.s  c 0
  gpop        &c "rsi"
  gt2 "mov" "rax" "rdx"
  gtlit a0 "rdi"
  gtlit n "rax"
  gt0 "syscall"
  0
}

geread  necl = gegsys3 0 0 e c
export eread   exok  = { tree k nnat &geread  is e (e.a = p3 x o) (e.a.s = p3 x o) e }

gewrite necl = gegsys3 1 1 e c
export ewrite  exok  = { tree k nnat &gewrite is e (e.a = p3 x o) (e.a.s = p3 x o) e }

geerr   necl = gegsys3 1 2 e c
export eerr    exok  = { tree k nnat &geerr   is e (e.a = p3 x o) (e.a.s = p3 x o) e }
