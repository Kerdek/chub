tree(k K t T q @necl) E = {
  cast E alloc sizeof Expr is e
  (e.k = k)
  (e.t = t)
  (e.q = q)
  e
}

t0  (k K t T q @necl            ) E = {tree k t q}
t1  (k K t T q @necl         a E) E = {tree k t q is e e ret (e.a = a)}
t2  (k K t T q @necl     b E a E) E = {tree k t q is e e ret (e.a = a)  (e.a.s = b)}
t3  (k K t T q @necl c E b E a E) E = {tree k t q is e e ret (e.a = a)  (e.a.s = b)  (e.a.s.s = c)}
tt  (k K t T q @necl u T        ) E = {t0   k t q is e e ret (e.u = u)}

gcast(a T b T) none = {
  (b.q == &TNONE) ?
    gtz     "eax"
    { (b.q == &TBYTE) then
      gpromote  "eax" }
}

gaddr(t T n N s S d S) none = {
  (n or !strcmp s d) then
  gs "lea " { n then gn n } gs "(%" gs s gs "),%" gs d glf
}
gload(t T n N s S d S) none = {
  (t.q == &TBYTE) ?
    { gs  "movzbq " gn n gs "(%" gs s gs "),%" gs  d glf }
    { gs  "mov "    gn n gs "(%" gs s gs "),%" gs  d glf }
}
gstore(t T d S) none = {
  (t.q == &TBYTE) ?
    { gs "mov %al,(%"  gs d gc ')' glf }
    { gs "mov %rax,(%" gs d gc ')' glf }
}

export gexpr necl  = { e.q@ e c l }

export gdrop (e E c N    ) none = { cast none gexpr e c 0 }
export geval (e E c N l N) none = {
  gexpr e c l is l1
  l1 then
  l1 for l2
  (l2 == 1 and not l) ?
    { (e.t.q == &TFUNC) else gload e.t 0 "rax" "rax" }
    { gs "mov (%rax),%rax" glf }
  (l2 - 1)
}

ge1     (e E c N l N gop @() none) N = {
  geval  e.a c 0
  gop@
  0
}

ge2     (e E c N l N gop @() none) N = {
  geval  e.a.s  c 0
  gpush        &c "rax"
  geval  e.a    c 0
  gpop         &c "rdi"
  gop@
  0
}

gegneg  () none = gtneg  "rax"
geglnot () none = glnot  "rax" "eax"
gegadd  () none = gadd   "rdi" "rax"
gegsub  () none = gsub   "rdi" "rax"
gegmul  () none = gmul   "rdi"

export ebrace   ekok  = p5 x o
export eparen   ekok  = p7 x o

genat    necl  = { gs "mov $" gk e.k gs ",%rax" glf 0 }
export enat     ekok   = t0 k nnat  &genat

gebyte   necl  = { gs "mov $" gk e.k ((e.k.p^1 == '\\') ? 3 2) gs ",%rax" glf 0 }
export ebyte    ekok   = t0 k nbyte &gebyte

gesize   necl  = { gtlit e.u.size "rax" 0 }
export esize    ekok   = tt k nnat &gesize ptype x o

gederef  necl  = (gexpr e.a c 0 + 1 - l)
export ederef   ekoka  = t1 k a.t.a &gederef a

geaddr   necl  = gexpr e.a c 1
export eaddr    ekok   = {
  p2 x o is a
  t1 k nptr a.t &geaddr a
}

gecast  necl  = {
  geval  e.a c 0
  gcast  e.a.t e.t
  0
}
export eas      ekoka  = t1 k ptype x o &gecast a
export ecast    ekok   = {
  ptype x o is u
  t1 k u &gecast p4 x o
}

gestr necl  = {
  gs "mov .s" gn cast nat e.k gs "@GOTPCREL(%rip),%rax" glf
  0
}
export estr   ekok  = t0 k nptr nbyte &gestr

geid   necl  = {
  e.a ?
    (l or e.a.u.q == &TSTCT) ?
      { gaddr e.a.u (c - e.a.c << 3) "rsp" "rax" }
      { gload e.a.u (c - e.a.c << 3) "rsp" "rax" }
    { gs "mov " gk e.t.k gs "@GOTPCREL(%rip),%rax" glf }
  0
}
export eid    ekok  = {
  (search_scope x o k.p k.n) is s
  (s.is_type and diag "not a variable")
  cast E alloc sizeof Expr is e
  (e.s = 0    )
  (e.q = &geid)
  (e.k = x    )
  s.e ? {
    (e.a = s.e  )
    (e.t = s.e.u)
  }{(e.a = 0    )
    (e.t = s.t  ) }
  e
}

gelnot necl  = ge1 e c l &geglnot export elnot ekok  = t1 k nnat &gelnot p3    x o
geneg  necl  = ge1 e c l &gegneg  export eneg  ekok  = t1 k nnat &geneg  p3    x o
gediv  necl  = ge2 e c l &gdiv    export ediv  ekoka = t2 k nnat &gediv  p4    x o a
gemod  necl  = ge2 e c l &gmod    export emod  ekoka = t2 k nnat &gemod  p4    x o a
geadd  necl  = ge2 e c l &gegadd  export eadd  ekoka = t2 k nnat &geadd  pmul  x o a
gesub  necl  = ge2 e c l &gegsub  export esub  ekoka = t2 k nnat &gesub  pmul  x o a
gemul  necl  = ge2 e c l &gegmul  export emul  ekoka = t2 k nnat &gemul  p4    x o a
geshl  necl  = ge2 e c l &gshl    export eshl  ekoka = t2 k nnat &geshl  padd  x o a
geshr  necl  = ge2 e c l &gshr    export eshr  ekoka = t2 k nnat &geshr  padd  x o a
gee    necl  = ge2 e c l &ge      export ee    ekoka = t2 k nnat &gee    psh   x o a
gene   necl  = ge2 e c l &gne     export ene   ekoka = t2 k nnat &gene   psh   x o a
geae   necl  = ge2 e c l &gae     export eae   ekoka = t2 k nnat &geae   psh   x o a
gea    necl  = ge2 e c l &ga      export ea    ekoka = t2 k nnat &gea    psh   x o a
geb    necl  = ge2 e c l &gb      export eb    ekoka = t2 k nnat &geb    psh   x o a
gebe   necl  = ge2 e c l &gbe     export ebe   ekoka = t2 k nnat &gebe   psh   x o a

geelem necl   = {
  geval  e.a    c 0
  gpush        &c "rax"
  geval  e.a.s  c 0
  gpop         &c "rdx"
  gs  "lea (%rdx,%rax," gn  e.a.t.a.size gs  "),%rax" glf 
  (1 - l)
}
export eelem  ekoka = t2 k a.t.a &geelem p3 x o a

gemem   necl  = {
  geval  e.a c 0
  { e.a.t for t
    (t.q == &TPTR) then
    t.a ret
    (t.a.q == &TSTCT) ?
      gaddr t.a 0 "rax" "rax"
      gload t.a 0 "rax" "rax" }
  gindex e.t.offset
  (1 - l)
}
export emem  ekoka  = {
  jadv x
  { a.t for t (t.q == &TPTR) then t.a } is t
  (t.q != &TSTCT and diag "not a struct")
  cast T 0 is g
  { t.a for a
    { (a.k.n == k.s.n) then strncmp a.k.p k.s.p k.s.n }
    ? { (g = a) cast T 0 }
      a.s }
  { !g then diag "no such member" }
  t1 k.s g &gemem a
}

geseq  necl  = {
  gdrop  e.a   c
  geval  e.a.s c l
  0
}
export eseq   ekoka  = {
  p5 x o is b
  t2 k b.t &geseq b a
}

geret necl  = {
  geval  e.a    c l
  gpush        &c "rax"
  gdrop  e.a.s  c
  gpop         &c "rax"
  0
}
export eret  ekoka  = t2 k a.t &geret p5 x o a

gecond necl   = {
  geval   e.a     c 0
  gtcz              "rax"
  gje     e         "a"
  geval   e.a.s   c l
  gj      e         "b"
  glabel  e         "a"
  geval   e.a.s.s c l
  glabel  e         "b"
  0
}
export econd  ekoka = {
  p4 x o is b
  t3 k b.t &gecond p4 x o b a
}

geland necl  = {
  (e.a.s.t.q == &TNONE) is keep
  geval  e.a c 0
  gtcz              "rax"
  gje    e          "a"
  { keep then
    gpush        &c "rax" }
  geval  e.a.s c 0
  { keep then
    gpop         &c "rax" }
  glabel  e         "a"
  0
}
export ethen  ekoka  = {
  p5 x o is b
  t2 k b.t &geland b a
}
export eland  ekoka  = {
  pcmp x o is b
  t2 k b.t &geland b a
}

gelor  necl  = {
  (e.a.s.t.q == &TNONE) is keep
  geval    e.a   c  0
  gtcz              "rax"
  gjne     e        "a"
  { keep then
    gpush        &c "rax" }
  geval    e.a.s  c 0
  { keep then
    gpop         &c "rax" }
  glabel   e        "a"
  0
}
export eelse  ekoka  = t2 k a.t &gelor p5    x o a
export elor   ekoka  = t2 k a.t &gelor pland x o a

gescratch necl = {
  (e.u.size + 7 >> 3) is d
  gfpush    &c d
  (e.c = c)
  geval e.a  c   l
  gfpop     &c d
  0
}
export escratch  ekok   = {
  cast E alloc sizeof Expr is e
  (e.s   = 0         )
  (e.q   = &gescratch)
  (e.k   = k        )
  (e.u   = ptype x o )
  scratch Scope o1
  (o1.s  = o         )
  (o1.k  = jadv x    )
  (o1.e  = e         )
  (o1.is_type = 0    )
  (e.a   = p5 x &o1  )
  (e.t   = e.a.t     )
  e
}

geis   necl = {
  (e.u.size + 7 >> 3) is d
  geval    e.a    c   0
  gfpush         &c d
  (e.c = c)
  gstore   e.u          "rsp"
  geval    e.a.s  c   l
  gfpop          &c d
  0
}
export eis    ekoka = {
  cast E alloc sizeof Expr is e
  (e.s   = 0      )
  (e.q   = &geis  )
  (e.k   = k     )
  (e.a   = a      )
  (e.u   = a.t    )
  scratch Scope o1
  (o1.s  = o      )
  (o1.k  = jadv x )
  (o1.e  = e      )
  (o1.is_type = 0 )
  (e.a.s = p5 x &o1)
  (e.t   = e.a.s.t)
  e
}

gefor  necl = {
  (e.u.size + 7 >> 3) is d
  geval     e.a    c   0
  gfpush          &c d
  (e.c = c)
  gstore    e.u          "rsp"
  gj        e            "b"
  glabel    e            "a"
  gstore    e.u          "rsp"
  glabel    e            "b"
  geval     e.a.s  c   0
  gtcz                   "rax"
  gjne      e            "a"
  gload     e.u      0   "rsp" "rax"
  gfpop           &c d
  0
}
export efor   ekoka = {
  cast E alloc sizeof Expr is e
  (e.s   = 0      )
  (e.q   = &gefor )
  (e.k   = k     )
  (e.a   = a      )
  (e.u   = a.t    )
  scratch Scope o1
  (o1.s  = o      )
  (o1.k  = jadv x )
  (o1.e  = e      )
  (o1.is_type = 0 )
  (e.a.s = p5 x &o1)
  (e.t   = e.a.s.t)
  e
}

geass  necl  = {
  geval   e.a    c 1
  gpush         &c   "rax"
  geval   e.a.s  c 0
  gpop          &c   "rdi"
  gstore  e.a.t      "rdi"
  gtz                "eax"
  0
}
export eass   ekoka  = t2 k nnone &geass p7 x o a


gargs(e E c @N) none = {
  !!e then
  gargs e.s c
  geval e c@ 0
  gpush c "rax"
}
gecall necl  = {
  gargs e.a.s &c
  geval e.a    c 0
  0 is d
  { !!e.a.s then
    e.a.s for e (d < 6) then e.s ret
    gpop &c argreg8 d
    (d = d + 1) }
  gs "call *%rax" glf
  0
}
export ecall ekoka = {
  a.t.a.s is u
  { a for b
    u then
    (b.s = p3 x o)
    { !type_equal b.s.t u then diag "asymmetric argument" }
    (u = u.s)
    b.s }
  t1 x@ a.t.a &gecall a
}

geexit necl = {
  geval e.a c 0
  gt2 "mov" "rax" "rdi"
  gtlit 60 "rax"
  gt0 "syscall"
  0
}
export eexit  ekok  = t1 k nnone &geexit p3 x o

geibrk  necl = {
  gtlit 0  "rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov %rax,.scurbrk"
  0
}
export eibrk   ekok  = t0 k nnone &geibrk

gebrk  necl = {
  geval e.a c 0
  gt0 "mov .scurbrk,%rdi"
  gt0 "add %rax,%rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov .scurbrk,%rax"
  gt0 "mov %rdi,.scurbrk"
  0
}
export ebrk   ekok  = t1 k nnat &gebrk p3 x o

gegsys3 (n N a0 N e E c N) none = {
  geval e.a    c 0
  gpush       &c "rax"
  geval e.a.s  c 0
  gpop        &c "rsi"
  gt2 "mov" "rax" "rdx"
  gtlit a0 "rdi"
  gtlit n "rax"
  gt0 "syscall"
  0
}

geread  necl = gegsys3 0 0 e c
export eread   ekok  = t2 k nnat &geread p3 x o p3 x o

gewrite necl = gegsys3 1 1 e c
export ewrite  ekok  = t2 k nnat &gewrite p3 x o p3 x o

geerr   necl = gegsys3 1 2 e c
export eerr    ekok  = t2 k nnat &geerr p3 x o p3 x o
