
gcast(x X t T) none = {
  (t.q == &TNONE) ?
    gtz x     "eax"
    { (t.q == &TBYTE) then
      gpromote x  "eax" }
}

gaddr(x X t T n nat s @byte d @byte) none = {
  (n or !strcmp s d) then
  gs x "lea " { n then gn x n } gs x "(%" gs x s gs x "),%" gs x d glf x
}
gload(x X t T n nat s @byte d @byte) none = {
  (t.q == &TBYTE) ?
    { gs x  "movzbq " gn x n gs x "(%" gs x s gs x "),%" gs x  d glf x }
    { gs x  "mov "    gn x n gs x "(%" gs x s gs x "),%" gs x  d glf x }
}
gstore(x X t T d @byte) none = {
  (t.q == &TBYTE) ?
    { gs x "mov %al,(%"  gs x d gc x ')' glf x }
    { gs x "mov %rax,(%" gs x d gc x ')' glf x }
}

export geval (x X l nat) none = {
  x.l for l2
  (l2 > l) then
  (l2 == 1 and l == 0) ?
    (x.t.q == &TFUNC or x.t.q == &TSTCT or gload x x.t 0 "rax" "rax")
    { gt0 x "mov (%rax),%rax" }
  (l2 - 1)
}

export ebrace   ex  = { p5 x expect x "}" }
export eparen   ex  = { p8 x expect x ")" }

export enat     ex   = {
  gs x "mov $" gsn x x.kp x.kn gs x ",%rax" glf x
  jadv x
  (x.t = nnat x)
  (x.l = 0)
}

export ebyte    ex   = {
  gs x "mov $" gsn x x.kp x.kn ((x.kp^1 == '\\') ? 3 2) gs x ",%rax" glf x
  jadv x
  (x.t = nbyte x)
  (x.l = 0)
}

export esize    ex   = {
  ptype x is t
  gtlit x t.size "rax"
  (x.t = nnat x)
  (x.l = 0)
}

export ederef   ex  = {
  (x.t = x.t.a)
  (x.l = x.l + 1)
}

export eaddr ex = {
  p2 x
  (x.t = nptr x x.t)
  (x.l = x.l - 1)
}

export eas ex = {
  geval x 0
  ptype x is t
  gcast x t
  (x.t = t)
  (x.l = 0)
}

export ecast ex = {
  ptype x is t
  p4 x
  geval x 0
  gcast x t
  (x.t = t)
  (x.l = 0)
}

export estr ex = {
  gs x "mov .s" gn x (x.line * 10000 + x.col) gs x "@GOTPCREL(%rip),%rax" glf x
  jadv x
  (x.t = nptr x nbyte x)
  (x.l = 0)
}

export eid ex = {
  search_scope x is o
  (o.is_type and kdiag x "not a variable")
  o.is_local ?
    { gaddr x o.t (x.c - o.c << 3) "rsp" "rax" }
    { gs x "mov " gsn x o.kp o.kn gs x "@GOTPCREL(%rip),%rax" glf x }
  jadv x
  (x.t = o.t)
  (x.l = 1  )
}

g1ops (x X p@ (x X) nat) none = {
  p@ x
  geval x 0
  (x.t = nnat x)
  (x.l = 0)
}

g2ops (x X p@ (x X) nat) none = {
  geval x 0
  gpush x &x.c "rax"
  p@ x
  geval x 0
  gt0 x "mov %rax,%rdi"
  gpop x &x.c "rax"
  (x.t = nnat x)
  (x.l = 0)
}

export elnot ex = {
  g1ops x &p3
  glnot x "rax" "eax"
}

export eneg ex = {
  g1ops x &p3
  gtneg x "rax"
}

export eadd ex = {
  g2ops x &pmul
  gadd x "rdi" "rax"
}

export esub ex = {
  g2ops x &pmul
  gsub x "rdi" "rax"
}

export emul ex = {
  g2ops x &p4
  gmul x "rdi"
}

export ediv ex = {
  g2ops x &p4
  gdiv x
}

export emod ex = {
  g2ops x &p4
  gmod x
}

export eshl ex = {
  g2ops x &padd
  gshl x
}

export eshr ex = {
  g2ops x &padd
  gshr x
}

export ee ex = {
  g2ops x &psh
  ge x
}

export ene ex = {
  g2ops x &psh
  gne x
}

export eae ex = {
  g2ops x &psh
  gae x
}

export ea ex = {
  g2ops x &psh
  ga x
}

export eb ex = {
  g2ops x &psh
  gb x
}

export ebe ex = {
  g2ops x &psh
  gbe x
}

export eelem  ex = {
  x.t is a
  geval x 0
  gpush x &x.c "rax"
  p3 x
  geval x 0
  gpop x &x.c "rdi"
  gs x "lea (%rdi,%rax," gn x a.a.size gs x "),%rax" glf x
  (x.t = a.a)
  (x.l = 1  )
}

export emem  ex  = {
  geval x 0
  { x.t for t
    (t.q == &TPTR) then
    (t.a.q == &TSTCT) ?
      gaddr x t.a 0 "rax" "rax"
      gload x t.a 0 "rax" "rax"
    t.a
  } is t
  (t.q != &TSTCT and kdiag x "not a struct")
  cast T 0 is g
  { t.a for a
    { (a.kn == x.kn) then strncmp a.kp x.kp x.kn }
    ? { (g = a) cast T 0 }
      a.s }
  (g or kdiag x "no such member")
  jadv x
  gindex x g.offset
  (x.t = g)
  (x.l = 1)
}

export eseq   ex  = p5 x

export eret  ex  = {
  x.t is t
  x.l is l
  geval x 0
  gpush x &x.c "rax"
  p5 x
  gpop x &x.c "rax"
  (x.l = 0)
  (x.t = t)
}

export econd  ex = {
  (x.line * 10000 + x.col) is n
  geval x 0
  gtcz x "rax"
  gje x n "a"
  p4 x
  geval x 0
  gj x n "b"
  glabel x n "a"
  p4 x
  geval x 0
  glabel x n "b"
  (x.l = 0)
}

export ethen  ex  = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gje x n "a"
  gpush x &x.c "rax"
  p5 x
  geval x 0
  gpop x &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel x n "a"
  (x.l = 0)
}

export eland  ex  = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gje x n "a"
  gpush x &x.c "rax"
  pcmp x
  geval x 0
  gpop x &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel x n "a"
  (x.l = 0)
}

export eelse  ex  = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gjne x n "a"
  gpush x &x.c "rax"
  p5 x
  geval x 0
  gpop x &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel x n "a"
  (x.t = a)
  (x.l = 0)
}

export elor ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gjne x n "a"
  gpush x &x.c "rax"
  pland x
  geval x 0
  gpop x &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel x n "a"
  (x.t = a)
  (x.l = 0)
}

export escratch ex = {
  ptype x is t
  (t.size + 7 >> 3) is d
  gfpush x &x.c d
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.kp = x.kp   )
  (o1.kn = x.kn   )
  (o1.c  = x.c    )
  (o1.t  = t      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  jadv x
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  geval x 0
  gfpop x &x.c d
  (x.l = 0)
}

export eis ex = {
  x.t is a
  (a.size + 7 >> 3) is d
  geval x 0
  gfpush x &x.c d
  gstore x a "rsp"
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.kp = x.kp   )
  (o1.kn = x.kn   )
  (o1.c  = x.c    )
  (o1.t  = a      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  jadv x
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  geval x 0
  gfpop x &x.c d
  (x.l = 0)
}

export efor ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  (a.size + 7 >> 3) is d
  geval x 0
  gfpush x &x.c d
  gstore x a "rsp"
  gj x n "b"
  glabel x n "a"
  gstore x a "rsp"
  glabel x n "b"
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.kp = x.kp   )
  (o1.kn = x.kn   )
  (o1.c  = x.c    )
  (o1.t  = a      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  jadv x
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  geval x 0
  gtcz x "rax"
  gjne x n "a"
  gload x a 0 "rsp" "rax"
  gfpop x &x.c d
  (x.l = 0)
}

export eass ex  = {
  x.t is a
  geval x 1
  gpush x &x.c "rax"
  p7 x
  geval x 0
  gpop x &x.c "rdi"
  gstore x a "rdi"
  gtz x "eax"
  (x.t = nnone x)
  (x.l = 0    )
}

export ecall ex = {
  geval x 0
  x.c is c
  0 is stack
  x.t is tf
  { tf.a.s then
    tf.a.s for u
    (stack = stack + 1)
    u.s }
  gfpush x &x.c stack
  gpush x &x.c "rax"
  8 is off
  { tf.a.s then
    tf.a.s for u
    p3 x
    (type_equal x.t u or kdiag x "asymmetric argument")
    geval x 0
    gs x "mov %rax," gn x off gs x "(%rsp)" glf x
    (off = off + 8)
    u.s }
  gpop x &x.c "rax"
  0 is d
  { tf.a.s then
    tf.a.s for u
    (d < 6) then
    gpop x &x.c argreg d
    (d = d + 1)
    u.s }
  gt0 x "call *%rax"
  (x.t = tf.a )
  (x.l = 0    )
  (x.c = c)
}

export eexit  ex  = {
  p3 x
  geval x 0
  gt2 x "mov" "rax" "rdi"
  gtlit x 60 "rax"
  gt0 x "syscall"
  (x.t = nnone x)
  (x.l = 0    )
}

export ebrk ex = {
  p3 x
  geval x 0
  gt0 x "mov %rax,%rdi"
  gtlit x 12 "rax"
  gt0 x "syscall"
  (x.t = nnat x)
  (x.l = 0     )
}

gsys3 (x X fd nat id nat) none = {
  p3 x
  geval x 0
  gpush x &x.c "rax"
  p3 x
  geval x 0
  gpop x &x.c "rsi"
  gt2 x "mov" "rax" "rdx"
  gtlit x fd "rdi"
  gtlit x id "rax"
  gt0 x "syscall"
  (x.t = nnat x)
  (x.l = 0    )
}

export eread  ex  = gsys3 x 0 0
export ewrite ex  = gsys3 x 1 1
export eerr   ex  = gsys3 x 2 1
