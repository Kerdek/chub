
gcast(t T) none = {
  (t.q == &TNONE) ?
    gtz     "eax"
    { (t.q == &TBYTE) then
      gpromote  "eax" }
}

gaddr(t T n nat s @byte d @byte) none = {
  (n or !strcmp s d) then
  gs "lea " { n then gn n } gs "(%" gs s gs "),%" gs d glf
}
gload(t T n nat s @byte d @byte) none = {
  (t.q == &TBYTE) ?
    { gs  "movzbq " gn n gs "(%" gs s gs "),%" gs  d glf }
    { gs  "mov "    gn n gs "(%" gs s gs "),%" gs  d glf }
}
gstore(t T d @byte) none = {
  (t.q == &TBYTE) ?
    { gs "mov %al,(%"  gs d gc ')' glf }
    { gs "mov %rax,(%" gs d gc ')' glf }
}

export geval (x X l nat) none = {
  x.l for l2
  (l2 > l) then
  (l2 == 1 and l == 0) ?
    (x.t.q == &TFUNC or x.t.q == &TSTCT or gload x.t 0 "rax" "rax")
    { gt0 "mov (%rax),%rax" }
  (l2 - 1)
}

export ebrace   ex  = { p5 x expect x "}" }
export eparen   ex  = { p8 x expect x ")" }

export enat     ex   = {
  gs "mov $" gsn x.kp x.kn gs ",%rax" glf
  jadv x
  (x.t = nnat x)
  (x.l = 0)
}

export ebyte    ex   = {
  gs "mov $" gsn x.kp x.kn ((x.kp^1 == '\\') ? 3 2) gs ",%rax" glf
  jadv x
  (x.t = nbyte x)
  (x.l = 0)
}

export esize    ex   = {
  ptype x is t
  gtlit t.size "rax"
  (x.t = nnat x)
  (x.l = 0)
}

export ederef   ex  = {
  (x.t = x.t.a)
  (x.l = x.l + 1)
}

export eaddr ex = {
  p2 x
  (x.t = nptr x x.t)
  (x.l = x.l - 1)
}

export eas ex = {
  geval x 0
  ptype x is t
  gcast t
  (x.t = t)
  (x.l = 0)
}

export ecast ex = {
  ptype x is t
  p4 x
  geval x 0
  gcast t
  (x.t = t)
  (x.l = 0)
}

export estr ex = {
  gs "mov .s" gn (x.line * 10000 + x.col) gs "@GOTPCREL(%rip),%rax" glf
  jadv x
  (x.t = nptr x nbyte x)
  (x.l = 0)
}

export eid ex = {
  search_scope x is o
  (o.is_type and kdiag x "not a variable")
  o.is_local ?
    { gaddr o.t (x.c - o.c << 3) "rsp" "rax" }
    { gs "mov " gsn o.kp o.kn gs "@GOTPCREL(%rip),%rax" glf }
  jadv x
  (x.t = o.t)
  (x.l = 1  )
}

g1ops (x X p@ (x X) nat) none = {
  p@ x
  geval x 0
  (x.t = nnat x)
  (x.l = 0)
}

g2ops (x X p@ (x X) nat) none = {
  geval x 0
  gpush &x.c "rax"
  p@ x
  geval x 0
  gt0 "mov %rax,%rdi"
  gpop &x.c "rax"
  (x.t = nnat x)
  (x.l = 0)
}

export elnot ex = {
  g1ops x &p3
  glnot "rax" "eax"
}

export eneg ex = {
  g1ops x &p3
  gtneg "rax"
}

export eadd ex = {
  g2ops x &pmul
  gadd "rdi" "rax"
}

export esub ex = {
  g2ops x &pmul
  gsub "rdi" "rax"
}

export emul ex = {
  g2ops x &p4
  gmul "rdi"
}

export ediv ex = {
  g2ops x &p4
  gdiv
}

export emod ex = {
  g2ops x &p4
  gmod
}

export eshl ex = {
  g2ops x &padd
  gshl
}

export eshr ex = {
  g2ops x &padd
  gshr
}

export ee ex = {
  g2ops x &psh
  ge
}

export ene ex = {
  g2ops x &psh
  gne
}

export eae ex = {
  g2ops x &psh
  gae
}

export ea ex = {
  g2ops x &psh
  ga
}

export eb ex = {
  g2ops x &psh
  gb
}

export ebe ex = {
  g2ops x &psh
  gbe
}

export eelem  ex = {
  x.t is a
  geval x 0
  gpush &x.c "rax"
  p3 x
  geval x 0
  gpop &x.c "rdi"
  gs "lea (%rdi,%rax," gn a.a.size gs "),%rax" glf
  (x.t = a.a)
  (x.l = 1  )
}

export emem  ex  = {
  geval x 0
  { x.t for t
    (t.q == &TPTR) then
    (t.a.q == &TSTCT) ?
      gaddr t.a 0 "rax" "rax"
      gload t.a 0 "rax" "rax"
    t.a
  } is t
  (t.q != &TSTCT and kdiag x "not a struct")
  cast T 0 is g
  { t.a for a
    { (a.kn == x.kn) then strncmp a.kp x.kp x.kn }
    ? { (g = a) cast T 0 }
      a.s }
  (g or kdiag x "no such member")
  jadv x
  gindex g.offset
  (x.t = g)
  (x.l = 1)
}

export eseq   ex  = p5 x

export eret  ex  = {
  x.t is t
  x.l is l
  geval x 0
  gpush &x.c "rax"
  p5 x
  gpop &x.c "rax"
  (x.l = 0)
  (x.t = t)
}

export econd  ex = {
  (x.line * 10000 + x.col) is n
  geval x 0
  gtcz "rax"
  gje n "a"
  p4 x
  geval x 0
  gj n "b"
  glabel n "a"
  p4 x
  geval x 0
  glabel n "b"
  (x.l = 0)
}

export ethen  ex  = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz "rax"
  gje n "a"
  gpush &x.c "rax"
  p5 x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel n "a"
  (x.l = 0)
}

export eland  ex  = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz "rax"
  gje n "a"
  gpush &x.c "rax"
  pcmp x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel n "a"
  (x.l = 0)
}

export eelse  ex  = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz "rax"
  gjne n "a"
  gpush &x.c "rax"
  p5 x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel n "a"
  (x.t = a)
  (x.l = 0)
}

export elor ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz "rax"
  gjne n "a"
  gpush &x.c "rax"
  pland x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel n "a"
  (x.t = a)
  (x.l = 0)
}

export escratch ex = {
  ptype x is t
  (t.size + 7 >> 3) is d
  gfpush &x.c d
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.kp = x.kp   )
  (o1.kn = x.kn   )
  (o1.c  = x.c    )
  (o1.t  = t      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  jadv x
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  geval x 0
  gfpop &x.c d
  (x.l = 0)
}

export eis ex = {
  x.t is a
  (a.size + 7 >> 3) is d
  geval x 0
  gfpush &x.c d
  gstore a "rsp"
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.kp = x.kp   )
  (o1.kn = x.kn   )
  (o1.c  = x.c    )
  (o1.t  = a      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  jadv x
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  geval x 0
  gfpop &x.c d
  (x.l = 0)
}

export efor ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  (a.size + 7 >> 3) is d
  geval x 0
  gfpush &x.c d
  gstore a "rsp"
  gj n "b"
  glabel n "a"
  gstore a "rsp"
  glabel n "b"
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.kp = x.kp   )
  (o1.kn = x.kn   )
  (o1.c  = x.c    )
  (o1.t  = a      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  jadv x
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  geval x 0
  gtcz "rax"
  gjne n "a"
  gload a 0 "rsp" "rax"
  gfpop &x.c d
  (x.l = 0)
}

export eass ex  = {
  x.t is a
  geval x 1
  gpush &x.c "rax"
  p7 x
  geval x 0
  gpop &x.c "rdi"
  gstore a "rdi"
  gtz "eax"
  (x.t = nnone x)
  (x.l = 0    )
}

export ecall ex = {
  geval x 0
  x.c is c
  0 is stack
  x.t is tf
  { tf.a.s then
    tf.a.s for u
    (stack = stack + 1)
    u.s }
  gfpush &x.c stack
  gpush &x.c "rax"
  8 is off
  { tf.a.s then
    tf.a.s for u
    p3 x
    (type_equal x.t u or kdiag x "asymmetric argument")
    geval x 0
    gs "mov %rax," gn off gs "(%rsp)" glf
    (off = off + 8)
    u.s }
  gpop &x.c "rax"
  0 is d
  { tf.a.s then
    tf.a.s for u
    (d < 6) then
    gpop &x.c argreg d
    (d = d + 1)
    u.s }
  gt0 "call *%rax"
  (x.t = tf.a )
  (x.l = 0    )
  (x.c = c)
}

export eexit  ex  = {
  p3 x
  geval x 0
  gt2 "mov" "rax" "rdi"
  gtlit 60 "rax"
  gt0 "syscall"
  (x.t = nnone x)
  (x.l = 0    )
}

export ebrk ex = {
  p3 x
  geval x 0
  gt0 "mov %rax,%rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  (x.t = nnat x)
  (x.l = 0     )
}

gsys3 (x X fd nat id nat) none = {
  p3 x
  geval x 0
  gpush &x.c "rax"
  p3 x
  geval x 0
  gpop &x.c "rsi"
  gt2 "mov" "rax" "rdx"
  gtlit fd "rdi"
  gtlit id "rax"
  gt0 "syscall"
  (x.t = nnat x)
  (x.l = 0    )
}

export eread  ex  = gsys3 x 0 0
export ewrite ex  = gsys3 x 1 1
export eerr   ex  = gsys3 x 2 1
