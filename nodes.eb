export ebrace ex  = { p5 x expect x "}" }
export eparen ex  = { p8 x expect x ")" }

export enat ex = {
  gs x "mov $" gsn x x gs x ",%rax" glf x
  xret x nnat x 0
  jadv x
}

export ebyte ex = {
  gs x "mov $" gsn x x
  (x.q = &x.q^(-1))
  gs x ",%rax" glf x
  xret x nbyte x 0
  jadv x
}

export esize ex = {
  ptype x is t
  gtlit x cast nat t.size "rax"
  xret x nnat x 0
}

export ederef ex  = xret x x.t.a (x.l + 1)

export eaddr ex = {
  p2 x
  xret x nptr x x.t (x.l - 1)
}

export eas ex = {
  geval x 0
  xret x ptype x 0
  gcast x
}

export ecast ex = {
  ptype x is t
  p4 x
  geval x 0
  xret x t 0
  gcast x
}

export estr ex = {
  gs x "mov .s" gn x (x.line * 10000 + x.col) gs x "@GOTPCREL(%rip),%rax" glf x
  jadv x
  xret x nptr x nbyte x 0
}

export eid ex = {
  search_scope x is x1
  (x1.is_type and kdiag x "not a variable")
  xret x x1.t 1
  x1.is_local ?
    { gaddr x x.t (x.c - x1.c << 3) "rsp" "rax" }
    { gs x "mov " gsn x x gs x "@GOTPCREL(%rip),%rax" glf x }
  jadv x
}

export elnot ex = {
  g1ops x &p3
  glnot x "rax" "eax"
}

export eneg ex = {
  g1ops x &p3
  gtneg x "rax"
}

export eadd ex = {
  g2ops x &pmul
  gadd x "rdi" "rax"
}

export esub ex = {
  g2ops x &pmul
  gsub x "rdi" "rax"
}

export emul ex = {
  g2ops x &p4
  gmul x "rdi"
}

export ediv ex = {
  g2ops x &p4
  gdiv x
}

export emod ex = {
  g2ops x &p4
  gmod x
}

export eshl ex = {
  g2ops x &padd
  gshl x
}

export eshr ex = {
  g2ops x &padd
  gshr x
}

export ee ex = {
  g2ops x &psh
  ge x
}

export ene ex = {
  g2ops x &psh
  gne x
}

export eae ex = {
  g2ops x &psh
  gae x
}

export ea ex = {
  g2ops x &psh
  ga x
}

export eb ex = {
  g2ops x &psh
  gb x
}

export ebe ex = {
  g2ops x &psh
  gbe x
}

export eelem ex = {
  x.t is a
  geval x 0
  gpush x "rax"
  p3 x
  geval x 0
  gpop x "rdi"
  gs x "lea (%rdi,%rax," gn x cast nat a.a.size gs x "),%rax" glf x
  xret x a.a 1
}

export emem ex = {
  geval x 0
  { x.t for t
    (t.kind == 4) then
    (t.a.kind == 3) ?
      gaddr x t.a 0 "rax" "rax"
      gload x t.a 0 "rax" "rax"
    t.a
  } is t
  (t.kind != 3 and kdiag x "not a struct")
  cast T 0 is g
  { t.a for a
    { (a.kn == x.kn) then strncmp a.kp x.kp cast nat x.kn }
    ? { (g = a) cast T 0 }
      a.s }
  (g or kdiag x "no such member")
  jadv x
  gindex x cast nat g.offset
  xret x g 1
}

export eseq ex = p5 x

export eret ex = {
  x.t is t
  x.l is l
  geval x 0
  gpush x "rax"
  p5 x
  gpop x "rax"
  xret x t 0
}

export econd ex = {
  (x.line * 10000 + x.col) is n
  geval x 0
  gtcz x "rax"
  gje x n "a"
  p4 x
  geval x 0
  gj x n "b"
  glabel x n "a"
  p4 x
  geval x 0
  glabel x n "b"
  xret x x.t 0
}

export ethen ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gje x n "a"
  gpush x "rax"
  p5 x
  geval x 0
  gpop x ((x.t.kind== 0) ? "rax" "rdx")
  glabel x n "a"
  xret x x.t 0
}

export eland ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gje x n "a"
  gpush x "rax"
  pcmp x
  geval x 0
  gpop x ((x.t.kind== 0) ? "rax" "rdx")
  glabel x n "a"
  xret x x.t 0
}

export eelse ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gjne x n "a"
  gpush x "rax"
  p5 x
  geval x 0
  gpop x ((x.t.kind== 0) ? "rax" "rdx")
  glabel x n "a"
  xret x a 0
}

export elor ex = {
  (x.line * 10000 + x.col) is n
  x.t is a
  geval x 0
  gtcz x "rax"
  gjne x n "a"
  gpush x "rax"
  pland x
  geval x 0
  gpop x ((x.t.kind== 0) ? "rax" "rdx")
  glabel x n "a"
  xret x a 0
}

export escratch ex = {
  (x.t = ptype x)
  (x.t.size + 7 >> 3) is d
  gfpush x d
  scratch Ctx x1
  xcpy &x1 x
  (x.s.is_type  = 0)
  (x.s.is_local = 1)
  jadv x
  p5 x
  (x.s = x.s.s)
  geval x 0
  gfpop x d
  xret x x.t 0
}

export eis ex = {
  (x.t.size + 7 >> 3) is d
  geval x 0
  gfpush x d
  gstore x x.t "rsp"
  scratch Ctx x1
  xcpy &x1 x
  (x.s.is_type  = 0)
  (x.s.is_local = 1)
  jadv x
  p5 x
  (x.s = x.s.s)
  geval x 0
  gfpop x d
  xret x x.t 0
}

export efor ex = {
  (x.line * 10000 + x.col) is n
  (x.t.size + 7 >> 3) is d
  geval x 0
  gfpush x d
  gstore x x.t "rsp"
  gj x n "b"
  glabel x n "a"
  gstore x x.t "rsp"
  glabel x n "b"
  scratch Ctx x1
  xcpy &x1 x
  (x.s.is_type  = 0)
  (x.s.is_local = 1)
  jadv x
  p5 x
  geval x 0
  gtcz x "rax"
  gjne x n "a"
  (x.s = x.s.s)
  gload x x.t 0 "rsp" "rax"
  gfpop x d
  xret x x.t 0
}

export eass ex = {
  x.t is a
  geval x 1
  gpush x "rax"
  p7 x
  geval x 0
  gpop x "rdi"
  gstore x a "rdi"
  gtz x "eax"
  xret x nnone x 0
}

export ecall ex = {
  geval x 0
  x.c is c
  0 is stack
  x.t is tf
  { tf.a.s then
    tf.a.s for u
    (stack = stack + 1)
    u.s }
  gfpush x stack
  gpush x "rax"
  8 is off
  { tf.a.s then
    tf.a.s for u
    p3 x
    (type_equal x.t u or kdiag x "asymmetric argument")
    geval x 0
    gs x "mov %rax," gn x off gs x "(%rsp)" glf x
    (off = off + 8)
    u.s }
  gpop x "rax"
  0 is d
  { tf.a.s then
    tf.a.s for u
    (d < 6) then
    gpop x argreg d
    (d = d + 1)
    u.s }
  gt0 x "call *%rax"
  (x.c = c)
  xret x tf.a 0
}

export eexit ex = {
  p3 x
  geval x 0
  gt2 x "mov" "rax" "rdi"
  gtlit x 60 "rax"
  gt0 x "syscall"
  xret x nnone x 0
}

export eclock_gettime ex = {
  p3 x
  geval x 0
  gpush x "rax"
  p3 x
  geval x 0
  gt2 x "mov" "rax" "rsi"
  gpop x "rdi"
  gtlit x 228 "rax"
  gt0 x "syscall"
  xret x nnat x 0
}

export ebrk ex = {
  p3 x
  geval x 0
  gt0 x "mov %rax,%rdi"
  gtlit x 12 "rax"
  gt0 x "syscall"
  xret x nptr x nbyte x 0
}

gsys3 (x X fd nat id nat) none = {
  p3 x
  geval x 0
  gpush x "rax"
  p3 x
  geval x 0
  gpop x "rsi"
  gt2 x "mov" "rax" "rdx"
  gtlit x fd "rdi"
  gtlit x id "rax"
  gt0 x "syscall"
  xret x nnat x 0
}

export eread  ex  = gsys3 x 0 0
export ewrite ex  = gsys3 x 1 1
export eerr   ex  = gsys3 x 2 1
