
gcast(t T) none = {
  (t.q == &TNONE) ?
    gtz     "eax"
    { (t.q == &TBYTE) then
      gpromote  "eax" }
}

gaddr(t T n nat s @byte d @byte) none = {
  (n or !strcmp s d) then
  gs "lea " { n then gn n } gs "(%" gs s gs "),%" gs d glf
}
gload(t T n nat s @byte d @byte) none = {
  (t.q == &TBYTE) ?
    { gs  "movzbq " gn n gs "(%" gs s gs "),%" gs  d glf }
    { gs  "mov "    gn n gs "(%" gs s gs "),%" gs  d glf }
}
gstore(t T d @byte) none = {
  (t.q == &TBYTE) ?
    { gs "mov %al,(%"  gs d gc ')' glf }
    { gs "mov %rax,(%" gs d gc ')' glf }
}

export geval (x X l nat) none = {
  x.l for l2
  (l2 > l) then
  (l2 == 1 and l == 0) ?
    (x.t.q == &TFUNC or x.t.q == &TSTCT or gload x.t 0 "rax" "rax")
    { gt0 "mov (%rax),%rax" }
  (l2 - 1)
}

export ebrace   exk  = { p5 x expect x "}" }
export eparen   exk  = { p8 x expect x ")" }

export enat     exk   = {
  gs "mov $" gk k gs ",%rax" glf
  (x.t = nnat)
  (x.l = 0)
}

export ebyte    exk   = {
  gs "mov $" gk k ((k.p^1 == '\\') ? 3 2) gs ",%rax" glf
  (x.t = nbyte)
  (x.l = 0)
}

export esize    exk   = {
  ptype x is t
  gtlit t.size "rax"
  (x.t = nnat)
  (x.l = 0)
}

export ederef   exk  = {
  (x.t = x.t.a)
  (x.l = x.l + 1)
}

export eaddr exk = {
  p2 x
  (x.t = nptr x.t)
  (x.l = x.l - 1)
}

export eas exk = {
  geval x 0
  ptype x is t
  gcast t
  (x.t = t)
  (x.l = 0)
}

export ecast exk = {
  ptype x is t
  p4 x
  geval x 0
  gcast t
  (x.t = t)
  (x.l = 0)
}

export estr exk = {
  gs "mov .s" gn cast nat k gs "@GOTPCREL(%rip),%rax" glf
  (x.t = nptr nbyte)
  (x.l = 0)
}

export eid exk = {
  search_scope x k.p k.n is s
  (s.is_type and kdiag k "not a variable")
  s.is_local ?
    { gaddr s.t (x.c - s.c << 3) "rsp" "rax" }
    { gs "mov " gk s.t.k gs "@GOTPCREL(%rip),%rax" glf }
  (x.t = s.t)
  (x.l = 1  )
}

g1ops (x X p@ (x X) nat) none = {
  p@ x
  geval x 0
  (x.t = nnat)
  (x.l = 0)
}

g2ops (x X p@ (x X) nat) none = {
  geval x 0
  gpush &x.c "rax"
  p@ x
  geval x 0
  gt0 "mov %rax,%rdi"
  gpop &x.c "rax"
  (x.t = nnat)
  (x.l = 0)
}

export elnot exk = {
  g1ops x &p3
  glnot "rax" "eax"
}

export eneg exk = {
  g1ops x &p3
  gtneg "rax"
}

export eadd exk = {
  g2ops x &pmul
  gadd "rdi" "rax"
}

export esub exk = {
  g2ops x &pmul
  gsub "rdi" "rax"
}

export emul exk = {
  g2ops x &p4
  gmul "rdi"
}

export ediv exk = {
  g2ops x &p4
  gdiv
}

export emod exk = {
  g2ops x &p4
  gmod
}

export eshl exk = {
  g2ops x &padd
  gshl
}

export eshr exk = {
  g2ops x &padd
  gshr
}

export ee exk = {
  g2ops x &psh
  ge
}

export ene exk = {
  g2ops x &psh
  gne
}

export eae exk = {
  g2ops x &psh
  gae
}

export ea exk = {
  g2ops x &psh
  ga
}

export eb exk = {
  g2ops x &psh
  gb
}

export ebe exk = {
  g2ops x &psh
  gbe
}

export eelem  exk = {
  x.t is a
  g2ops x &p3
  gs "lea (%rdi,%rax," gn a.a.size gs "),%rax" glf
  (x.t = a.a)
  (x.l = 1  )
}

export emem  exk  = {
  geval x 0
  { x.t for t
    (t.q == &TPTR) then
    (t.a.q == &TSTCT) ?
      gaddr t.a 0 "rax" "rax"
      gload t.a 0 "rax" "rax"
    t.a
  } is t
  (t.q != &TSTCT and kdiag k "not a struct")
  jadv x
  cast T 0 is g
  { t.a for a
    { (a.k.n == k.s.n) then strncmp a.k.p k.s.p k.s.n }
    ? { (g = a) cast T 0 }
      a.s }
  (g or kdiag k "no such member")
  gindex g.offset
  (x.t = g)
  (x.l = 1)
}

export eseq   exk  = p5 x

export eret  exk  = {
  x.t is t
  x.l is l
  gpush &x.c "rax"
  p5 x
  gpop &x.c "rax"
  (x.l = l)
  (x.t = t)
}

export econd  exk = {
  geval x 0
  gtcz "rax"
  gje k "a"
  p4 x
  geval x 0
  gj k "b"
  glabel k "a"
  p4 x
  geval x 0
  glabel k "b"
  (x.l = 0)
}

export ethen  exk  = {
  x.t is a
  geval x 0
  gtcz "rax"
  gje k "a"
  gpush &x.c "rax"
  p5 x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel k "a"
  (x.t = a)
  (x.l = 0)
}

export eland  exk  = {
  x.t is a
  geval x 0
  gtcz "rax"
  gje k "a"
  gpush &x.c "rax"
  pcmp x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel k "a"
  (x.t = a)
  (x.l = 0)
}

export eelse  exk  = {
  x.t is a
  geval x 0
  gtcz "rax"
  gjne k "a"
  gpush &x.c "rax"
  p5 x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel k "a"
  (x.t = a)
  (x.l = 0)
}

export elor exk = {
  x.t is a
  geval x 0
  gtcz "rax"
  gjne k "a"
  gpush &x.c "rax"
  pland x
  geval x 0
  gpop &x.c ((x.t.q == &TNONE) ? "rax" "rdx")
  glabel k "a"
  (x.t = a)
  (x.l = 0)
}

export escratch exk = {
  ptype x is t
  (t.size + 7 >> 3) is d
  gfpush &x.c d
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.k  = jadv x )
  (o1.c  = x.c    )
  (o1.t  = t      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  gfpop &x.c d
}

export eis exk = {
  x.t is a
  (a.size + 7 >> 3) is d
  geval x 0
  gfpush &x.c d
  gstore a "rsp"
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.k  = jadv x )
  (o1.c  = x.c    )
  (o1.t  = a      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  gfpop &x.c d
}

export efor exk = {
  x.t is a
  (a.size + 7 >> 3) is d
  geval x 0
  gfpush &x.c d
  gstore a "rsp"
  gj k "b"
  glabel k "a"
  gstore a "rsp"
  glabel k "b"
  scratch Scope o1
  (o1.s  = x.o    )
  (o1.k  = jadv x )
  (o1.c  = x.c    )
  (o1.t  = a      )
  (o1.is_type  = 0)
  (o1.is_local = 1)
  x.o is o
  (x.o = &o1)
  p5 x
  (x.o = o)
  geval x 0
  gtcz "rax"
  gjne k "a"
  gload a 0 "rsp" "rax"
  gfpop &x.c d
  (x.t = a)
  (x.l = 0)
}

export eass exk  = {
  x.t is a
  geval x 1
  gpush &x.c "rax"
  p7 x
  geval x 0
  gpop &x.c "rdi"
  gstore a "rdi"
  gtz "eax"
  (x.t = nnone)
  (x.l = 0    )
}

export ecall exk = {
  geval x 0
  x.c is c
  0 is stack
  x.t is tf
  { tf.a.s then
    tf.a.s for u
    (stack = stack + 1)
    u.s }
  gfpush &x.c stack
  gpush &x.c "rax"
  8 is off
  { tf.a.s then
    tf.a.s for u
    p3 x
    (type_equal x.t u or kdiag k "asymmetric argument")
    geval x 0
    gs "mov %rax," gn off gs "(%rsp)" glf
    (off = off + 8)
    u.s }
  gpop &x.c "rax"
  0 is d
  { tf.a.s then
    tf.a.s for u
    (d < 6) then
    gpop &x.c argreg d
    (d = d + 1)
    u.s }
  gt0 "call *%rax"
  (x.t = tf.a )
  (x.l = 0    )
  (x.c = c)
}

export eexit  exk  = {
  p3 x
  geval x 0
  gt2 "mov" "rax" "rdi"
  gtlit 60 "rax"
  gt0 "syscall"
  (x.t = nnone)
  (x.l = 0    )
}

export eibrk   exk  = {
  gtlit 0 "rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov %rax,.scurbrk"
  (x.t = nnone)
  (x.l = 0    )
}

export ebrk exk = {
  p3 x
  geval x 0
  gt0 "mov .scurbrk,%rdi"
  gt0 "add %rax,%rdi"
  gtlit 12 "rax"
  gt0 "syscall"
  gt0 "mov .scurbrk,%rax"
  gt0 "mov %rdi,.scurbrk"
  (x.t = nnat )
  (x.l = 0    )
}

gsys3 (x X fd nat id nat) none = {
  p3 x
  geval x 0
  gpush &x.c "rax"
  p3 x
  geval x 0
  gpop &x.c "rsi"
  gt2 "mov" "rax" "rdx"
  gtlit fd "rdi"
  gtlit id "rax"
  gt0 "syscall"
  (x.t = nnat )
  (x.l = 0    )
}

export eread  exk  = gsys3 x 0 0
export ewrite exk  = gsys3 x 1 1
export eerr   exk  = gsys3 x 2 1
