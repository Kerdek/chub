#include "chub.hb"

current_file@ File
input_files@@ File
at_bol bool
has_space bool;

export error(fmt@ char ...) =
  let ap = (let va_list){;;
  va_start(ap, fmt);
  vfprintf stderr fmt &ap;
  fprintf stderr "\n";
  raise SIGTRAP;
  exit 1;;
verror_at(filename@ char input@ char line_no int loc@ char fmt@ char ap @va_list)  =
  let line = loc;
  while (input < line && line[-1] != '\n') line--;
  let end = loc;
  while (end@ && end@ != '\n') end++;
  let indent = fprintf stderr "./%s:(%d,%d): " filename line_no (loc - line + 1);
  fprintf stderr "%.*s\n" (end - line) line;
  fprintf stderr "%*s" (display_width line (loc - line)->int + indent) "";
  fprintf stderr "^ ";
  vfprintf stderr fmt ap;
  fprintf stderr "\n";;
export error_at(loc@ char fmt@ char ...) =
  let line_no = 1;
  for (let p @ char= current_file.contents; p < loc; p++) if (p@ == '\n') line_no++;
  let ap = (let va_list){;;
  va_start(ap, fmt);
  verror_at current_file.name current_file.contents line_no loc fmt &ap;
  raise SIGTRAP;
  exit 1;;
export error_tok(tok@ Token fmt@ char ...)  =
  let ap = &(let va_list){;;
  va_start(ap@, fmt);
  verror_at tok.file.name tok.file.contents tok.line_no tok.loc fmt ap;
  raise SIGTRAP;
  exit 1;;
export warn_tok(tok@ Token fmt@ char ...) =
  let ap = &(let va_list){;;
  va_start(ap@, fmt);
  verror_at tok.file.name tok.file.contents tok.line_no tok.loc fmt ap;
  va_end(ap@);
export equal(tok@ Token op@ char) bool = return ! memcmp tok.loc->@ op->@ tok.len->unsigned long && !op[tok.len];;
export advance(k @@Token) @Token = return k@ :: j (k@ = k.next)->, j;;
export expect(tok@@ Token op@ char) =
  if ! equal tok@ op error_tok tok@ "expected '%s'" op;
  tok@ = tok.next;
  return none;;
export skip(tok@ Token op@ char)@ Token =
  if ! equal tok op error_tok tok "expected '%s'" op;
  return tok.next;;
export consume(rest@@ Token tok@ Token str@ char) bool =
  if equal tok str {
    rest@ = tok.next;
    return true;;
  rest@ = tok;
  return false;;
new_token(kind typeof 0->@Token.kind start@ char end@ char)@ Token =
  let tok            = (calloc 1->unsigned long sizeof Token)->@Token;
  tok.kind           = kind;
  tok.loc            = start;
  tok.len            = end - start;
  tok.file           = current_file;
  tok.filename       = current_file.display_name;
  tok.at_bol         = at_bol;
  tok.has_space      = has_space;
  at_bol = has_space = false;
  return tok;;
startswith(p@ char q@ char) bool = return ! strncmp p->@ q strlen q;;
read_ident(start@ char) int =
  let p = start;
  let c = decode_utf8 &p p;
  if !is_ident1 c return 0;
  for (;;) {
    let q = 0->@char;
    c = decode_utf8 &q p;
    if !is_ident2 c return (p - start)->int;
    p = q;;;
from_hex(c char) int =
  if ('0' <= c && c <= '9') return c - '0';
  if ('a' <= c && c <= 'f') return c - 'a' + 10;
  return c - 'A' + 10;;
rpkw[]@ char = {
  "<<=" ">>=" "..." "=="
  "!="  "<="  ">="  "->"
  "+="  "-="  "*="  "/="
  "++"  "--"  "%="  "&="
  "|="  "^="  "&&"  "||"
  "<<"  ">>"  "##"  "::"         "as";;
read_punct(p@ char) int =
  for (let i  int= 0; i < (sizeof typeof rpkw) / (sizeof typeof rpkw@); i++) if startswith p rpkw[i] return (strlen rpkw[i])->int;
  return ispunct(p@) ? 1 : 0;;
ikmap HashMap
ikkw[]@ char = {
  "let"        "return"       "if"            "else"         "for"
  "while"      "int"          "sizeof"        "same"         "char"
  "struct"     "union"        "short"         "long"         "void"
  "typedef"    "_Bool"        "enum"          "static"       "export"
  "goto"       "break"        "continue"      "switch"       "case"
  "default"    "extern"       "alignof"       "align"        "do"
  "signed"     "unsigned"     "const"         "volatile"     "auto"
  "register"   "restrict"     "_Noreturn"     "until"
  "float"      "double"       "typeof"        "asm"          "_Thread_local"
  "__thread"   "_Atomic"      "__attribute__" "bool"         "true"
  "false"      "none";;
is_keyword(tok@ Token) bool =
  if !ikmap.capacity for (let i int = 0; i < (sizeof typeof ikkw) / (sizeof typeof ikkw@); i++) hashmap_put &ikmap ikkw[i] 1->@;
  return (hashmap_get2 &ikmap tok.loc tok.len)->bool;;
read_escaped_char(new_pos@@ char p@ char) int =
  if ('0' <= p@ && p@ <= '7') {
    let c = (p++@ - '0');
    if ('0' <= p@ && p@ <= '7') {
      c = (c << 3) + (p++@ - '0');
      if ('0' <= p@ && p@ <= '7') c = (c << 3) + (p++@ - '0');;
    new_pos@ = p;
    return c;;
  if (p@ == 'x') {
    p++;
    if ! isxdigit p@->int error_at p "invalid hex escape sequence";
    let c = 0;
    for (; isxdigit p@->int; p++) c = (c << 4) + from_hex p@;
    new_pos@ = p;
    return c;;
  new_pos@ = p + 1;
  return
    p@ == 'a' ? '\a'   :
    p@ == 'b' ? '\b'   :
    p@ == 't' ? '\t'   :
    p@ == 'n' ? '\n'   :
    p@ == 'v' ? '\v'   :
    p@ == 'f' ? '\f'   :
    p@ == 'r' ? '\r'   :
                p@->int;;
string_literal_end(p@ char)@ char =
  let start = p;
  for (; p@ != '"'; p++) {
    if (p@ == '\n' || p@ == '\0') error_at start "unclosed string literal";
    if (p@ == '\\') p++;;
  return p;;
read_string_literal(start@ char quote@ char)@ Token =
  let end = string_literal_end (quote + 1);
  let buf = (calloc 1ul (end - quote)->unsigned long)->@char;
  let len = 0;
  for (let p @ char = (quote + 1); p < end;) {
    if (p@ == '\\') 
      buf[len++] = read_escaped_char &p (p + 1);
    else buf[len++] = p++@;;
  let tok = new_token TK_STR start (end + 1);
  tok.ty = array_of ty_char (len + 1);
  tok.str = buf;
  return tok;;
read_utf16_string_literal(start@ char quote@ char)@ Token =
  let end = string_literal_end (quote + 1);
  let buf = (calloc 2ul (end - start)->unsigned long)->@uint16_t;
  let len = 0;
  for (let p @char = (quote + 1); p < end;) {
    if (p@ == '\\') {
      buf[len++] = read_escaped_char &p (p + 1);;
    else {
      let c = decode_utf8 &p p;
      if (c < 0x10000) buf[len++] = c;
      else {
        c -= 0x10000;
        buf[len++] = 0xd800 + ((c >> 10) & 0x3ff);
        buf[len++] = 0xdc00 + (c & 0x3ff);;;;
  let tok = new_token TK_STR start (end + 1);
  tok.ty = array_of ty_ushort (len + 1);
  tok.str = buf->@ char;
  return tok;;
read_utf32_string_literal(start@ char quote@ char ty@ Type)@ Token =
  let end = string_literal_end (quote + 1);
  let buf = (calloc 4ul (end - quote)->unsigned long)->@uint32_t;
  let len = 0;
  for (let p @ char = (quote + 1); p < end;) {
    if (p@ == '\\') {
      buf[len++] = read_escaped_char &p (p + 1);;
    else buf[len++] = decode_utf8 &p p;;
  let tok = new_token TK_STR start (end + 1);
  tok.ty = array_of ty (len + 1);
  tok.str = buf->@ char;
  return tok;;
read_char_literal(start@ char quote@ char ty@ Type)@ Token =
  let p = (quote + 1);
  if (p@ == '\0') error_at start "unclosed literal char";
  let c = 0;
  if (p@ == '\\') {
    c = read_escaped_char &p (p + 1);;
  else c = decode_utf8 &p p;
  let end = strchr p '\'';
  if !end error_at p "unclosed literal char";
  let tok = new_token TK_NUM start (end + 1);
  tok.val = c;
  tok.ty = ty;
  return tok;;
convert_pp_int(tok@ Token) bool =
  let p = tok.loc;
  let base = 10;
  if (! strncasecmp p "0x" 2->unsigned long && isxdigit p[2]->int) {
    p += 2;
    base = 16;;
  else if (! strncasecmp p "0b" 2->unsigned long && (p[2] == '0' || p[2] == '1')) {
    p += 2;
    base = 2;;
  else if !p@ base = 8;
  let q = &p;
  let val = strtoul p q base;
  let l = false;
  let u = false;
  if (startswith p "LLU" || startswith p "LLu" ||
     startswith p "llU" || startswith p "llu" ||
     startswith p "ULL" || startswith p "Ull" ||
     startswith p "uLL" || startswith p "ull") {
    p += 3;
    l = u = true;;
  else if (! strncasecmp p "lu" 2ul || ! strncasecmp p "ul" 2ul) {
    p += 2;
    l = u = true;;
  else if (startswith p "LL" || startswith p "ll") {
    p += 2;
    l = true;;
  else if (p@ == 'L' || p@ == 'l') {
    p++;
    l = true;;
  else if (p@ == 'U' || p@ == 'u') {
    p++;
    u = true;;

  if (p != tok.loc + tok.len) return false;
  let ty = (
    base == 10 ? l && u    ? ty_ulong    :
                 l         ? ty_long     :
                 u         ? val >> 32   ? ty_ulong :
                                           ty_uint  :
                 val >> 31 ? ty_long     :
                             ty_int      :

                 l && u    ? ty_ulong    :
                 l         ?  val >> 63  ? ty_ulong :
                                           ty_long  :
                 u         ?  val >> 32  ? ty_ulong :
                                           ty_uint  :
                 val >> 63 ? ty_ulong    :
                 val >> 32 ? ty_long     :
                 val >> 31 ? ty_uint     :
                             ty_int                 );
  tok.kind = TK_NUM;
  tok.val  = val;
  tok.ty   = ty;
  return true;;

convert_pp_number(tok@ Token)  =
  if convert_pp_int tok return;
  let end = 0->@char;
  let val = strtold tok.loc &end;
  let ty = 0->@Type;
  if (end@ == 'f' || end@ == 'F') {
    ty = ty_float;
    end++;;
  else if (end@ == 'l' || end@ == 'L') {
    ty = ty_ldouble;
    end++;;
  else ty = ty_double;
  if (tok.loc + tok.len != end) error_tok tok "invalid numeric constant";
  tok.kind = TK_NUM;
  tok.fval = val;
  tok.ty = ty;;

export convert_pp_tokens(tok@ Token)  =
  for (let t @ Token= tok; t.kind != TK_EOF; t = t.next) {
    if is_keyword t t.kind = TK_KEYWORD;
    else if (t.kind == TK_PP_NUM) convert_pp_number t;;;

add_line_numbers(tok@ Token)  =
  let p = current_file.contents;
  let n = 1;
  do {
    if (p == tok.loc) {
      tok.line_no = n;
      tok = tok.next; ;
    if (p@ == '\n') n++;;
    while (p++@);;

export tokenize_string_literal(tok@ Token basety@ Type)@ Token =
  let t = 0->@Token;
  if (basety.size == 2) t = read_utf16_string_literal tok.loc tok.loc;
  else t = read_utf32_string_literal tok.loc tok.loc basety;
  t.next = tok.next;
  return t;;

export tokenize(file@ File)@ Token =
  current_file = file;
  let
    p = file.contents
    head = (let Token){;
    cur = &head;
  at_bol = true;
  has_space = false;
  while p@ {
    if startswith p "//" {
      p += 2;
      while (p@ != '\n') p++;
      has_space = true;;
    else if startswith p "/*" {
      let q = strstr (p + 2) "*/" ;
      if !q error_at p "unclosed block comment";
      p = q + 2;
      has_space = true;;
    else if (p@ == '\n') {
      p++;
      at_bol = true;
      has_space = false;;
    else if (isspace p@->int) {
      p++;
      has_space = true;;
    else if (isdigit(p@) || (p@ == '.' && isdigit(p[1]))) {
      let q = p++;
      while (
        p[0] && p[1] && strchr "eEpP" p[0]->int && strchr "+-" p[1]->int ? (p += 2), true :
        (isalnum(p@) || p@ == '.')                                                       ? p++->, true :
                                                                                                     false);
      cur = cur.next = new_token TK_PP_NUM q p;;
    else if (p@ == '"') {
      cur = cur.next = read_string_literal p p;
      p += cur.len;;
    else if startswith p "u8\"" {
      cur = cur.next = read_string_literal p (p + 2);
      p += cur.len;;
    else if startswith p "u\"" {
      cur = cur.next = read_utf16_string_literal p (p + 1);
      p += cur.len;;
    else if startswith p "L\"" {
      cur = cur.next = read_utf32_string_literal p (p + 1) ty_int;
      p += cur.len;;
    else if startswith p "U\"" {
      cur = cur.next = read_utf32_string_literal p (p + 1) ty_uint;
      p += cur.len;;
    else if (p@ == '\'') {
      cur = cur.next = read_char_literal p p ty_int;
      cur.val = cur.val->char;
      p += cur.len;;
    else if startswith p "u'" {
      cur = cur.next = read_char_literal p (p + 1) ty_ushort;
      cur.val &= 0xffff;
      p += cur.len;;
    else if startswith p "L'" {
      cur = cur.next = read_char_literal p (p + 1) ty_int;
      p += cur.len;;
    else if startswith p "U'" {
      cur = cur.next = read_char_literal p (p + 1) ty_uint;
      p += cur.len;;
    else {
      let ident_len = read_ident p;
      if ident_len {
        cur = cur.next = new_token TK_IDENT p (p + ident_len);
        p += cur.len;;
      else {
        let punct_len = read_punct p;
        if punct_len {
          cur = cur.next = new_token TK_PUNCT p (p + punct_len);
          p += cur.len;;
        else error_at p "invalid token";;;;
  cur = cur.next = new_token TK_EOF p p;
  add_line_numbers head.next;
  return head.next;;

rfbuf2 [4096]char;
read_file(path@ char)@ char =
  let fp = 0->@FILE;
  if ! strcmp path->@ "-" fp = stdin;
  else {
    fp = fopen path "r";
    if !fp return 0->@char;;
  let buf = 0->@char;
  let buflen = 0->size_t;
  let b = &buflen;
  let out = open_memstream &buf b;
  for (let k bool = true;k;) {
    let
      m = (sizeof typeof rfbuf2)
      n = fread rfbuf2->@ 1->unsigned long m fp;
    if (n == 0) k = false;
    else fwrite rfbuf2->@ 1->unsigned long n out;;
  if (fp != stdin) fclose fp;
  fflush out;
  if (buflen == 0 || buf[buflen - 1] != '\n') fputc '\n' out;
  fputc '\0' out;
  fclose out;
  return buf;;

export get_input_files(void)@@ File =
  return input_files;;

export new_file(name@ char file_no int contents@ char)@ File =
  let file = (calloc 1ul sizeof File)->@File;
  file.name = name;
  file.display_name = name;
  file.file_no = file_no;
  file.contents = contents;
  return file;;

canonicalize_newline(p@ char)  =
  let
    i = 0
    j = 0;
  while p[i] {
    if (p[i] == '\r' && p[i + 1] == '\n') {
      i += 2;
      p[j++] = '\n';;
    else if (p[i] == '\r') {
      i++;
      p[j++] = '\n';;
    else p[j++] = p[i++];;
  p[j] = '\0';;

remove_backslash_newline(p@ char)  =
  let
    i = 0
    j = 0
    n = 0;
  while p[i] {
    if (p[i] == '\\' && p[i + 1] == '\n') {
      i += 2;
      n++;;
    else if (p[i] == '\n') {
      p[j++] = p[i++];
      for (; n > 0; n--) p[j++] = '\n';;
    else p[j++] = p[i++];;
  for (; n > 0; n--) p[j++] = '\n';
  p[j] = '\0';;

read_universal_char(p@ char len int) uint32_t =
  let c = 0;
  for (let i  int= 0; i < len; i++) {
    if !isxdigit(p[i]) return 0->unsigned int;
    c = (c << 4) | from_hex p[i];;
  return c->unsigned int;;

convert_universal_chars(p@ char) =
  let q = p;
  while p@ {
    if startswith p "\\u" {
      let c = read_universal_char (p + 2) 4;
      if c {
        p += 6;
        q += encode_utf8 q c;;
      else q++@ = p++@;;
    else if startswith p "\\U" {
      let c = read_universal_char (p + 2) 8;
      if c {
        p += 10;
        q += encode_utf8 q c;;
      else q++@ = p++@;;
    else if (p[0] == '\\') {
      q++@ = p++@;
      q++@ = p++@;;
    else q++@ = p++@;;
  q@ = '\0';;

tffile_no int;
export tokenize_file(path@ char)@ Token =
  let p = read_file path;
  if !p return 0->@Token;

  if ! memcmp p->@ "\xef\xbb\xbf"->@ 3->unsigned long p += 3;

  canonicalize_newline p;
  remove_backslash_newline p;
  convert_universal_chars p;

  let file = new_file path (tffile_no + 1) p;

  input_files = realloc (input_files->@) (sizeof @char * (tffile_no + 2));
  input_files[tffile_no] = file;
  input_files[tffile_no + 1] = 0;
  tffile_no++;

  return tokenize file;
;
