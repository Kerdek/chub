# "chub.hb"

vdiag(filename@ i8 input@ i8 line_no i32 loc@ i8 fmt@ i8 ap @va_list) = return
   (loc for q (input < q && q[-1] != '\n' && (q - 1))) is line
   (loc for q (!!q@      && q@    != '\n' && (q + 1))) is end
   (printf "./%s:(%d,%d): " filename line_no (loc - line + 1)) is indent
   (printf "%.*s\n" (end - line) line)
;: (printf "%*s" ((loc - line as i32) + indent) "")
;: (printf "^ ")
;: vprintf fmt ap
;: (printf "\n")
;: none
;;
export error_at(loc@ i8 file @File fmt@ i8 ...) = return
   1 is line_no
   (file.contents for p (p < loc && (p + 1) :; ((p@ == '\n') && (line_no = line_no + 1) as void)) as void)
;: vdiag file.name file.contents line_no loc fmt cast @va_list __va_area__
;: exit 1
;;
export error_tok(j@ Token fmt@ i8 ...) = return vdiag j.file.name j.file.contents j.line_no j.loc fmt cast @va_list __va_area__ ;: exit 1 ;;
export warn_tok(j@ Token fmt@ i8 ...) = return vdiag j.file.name j.file.contents j.line_no j.loc fmt cast @va_list __va_area__;;
export equal(j @Token op @i8) bool = return ! memcmp cast @ j.loc cast @ op cast %i64 j.len && !op[j.len];;
export advance(k @@Token) @Token = return k@ :; (k@ = k.s) ;;
export expect(j @@Token op@ i8) = return
   (!equal j@ op && (error_tok j@ "expected '%s'" op) as void)
;: (j@ = j.s)
;;
export consume(rest@@ Token j@ Token str@ i8) bool = return
  equal j str is c c :; (rest@ = c ? j.s : j);;
new_token(kind typeof TK_ID start@ i8 end@ i8 file @File)@ Token = return
  cast @Token calloc 1ul sizeof Token is j j
:; (j.kind = kind              )
;: (j.loc  = start             )
;: (j.len  = end - start as i32)
;: (j.file = file              )
;;
startswith(p@ i8 q@ i8) bool = return ! strncmp p q strlen q;;
isident(c i8) bool = return 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' || c == '_';;
read_ident(p@ i8) i32 = return
   0 is r
   (p for q (isident q@ && q + 1 || cast @i8 0 :; (r = q - p as i32) ) as void)
;: r;;
from_hex(c i8) i8 = return c - ( ('0' <= c && c <= '9') ? '0' : ('a' + cast i8 10) );;
rpkw[]@ i8 = {
  "<<="  ">>="  "&&="  "||="  "..."
  "=="  "!="  "<="  ">="  "+="  "-="  "*="  "/="  "%="
  "&="  "|="  "^="  "&&"  "||"  "<<"  ">>"  ":;"  ";:"  "="
  "<"  ">"  "+"  "-"  "*"  "/"  "&"  "|"  "@"  "#"  "{"  "}"  "("
  ")"  "["  "]"  "!"  "?"  ":"  ";"  ","  "."  "~"  "^"  "%"
;;
rpkwn %i64 = (sizeof typeof rpkw / sizeof typeof rpkw[0]);
read_punct(p@ i8) i32 = return 0 is c (0 for i (i != rpkwn && !(startswith p rpkw[i] && true :; (c = cast i32 strlen rpkw[i])) && (i + 1)) as void) ;: c ;;
escape(c @i8 file @File) i8 = return 
   (c@ == '0') ? '\0'
:  (c@ == 'a') ? '\a'
:  (c@ == 'b') ? '\b'
:  (c@ == 'f') ? '\f'
:  (c@ == 'n') ? '\n'
:  (c@ == 'r') ? '\r'
:  (c@ == 't') ? '\t'
:  (c@ == 'v') ? '\v'
:  (c@ == 'p') ? '\p'
:  (c@ == 'q') ? '\q'
:  (c@ == 's') ? '\s'
:  (error_at c file "invalid escape sequence")
;: '\0'
;;
string_literal_end(file @File p@ i8)@ i8 = return p for q (q@ != '"' && (q + 1) :; (q@ == '\0' && (error_at p file "unclosed string literal") as void)) ;;
read_string_literal(file @File start@ i8 quote@ i8)@ Token = return
   string_literal_end file (quote + 1) is end
   cast @i8 calloc 1ul (end - quote as %i64) is buf
   0 is len
  ( (quote + 1) for p (p < end &&
    (p@ == '\s') ? (buf[(len:;(len = len + 1))] = (p = p + 1) ;: escape p file :; (p = p + 1)) ;: p :
    (buf[(len:;(len = len + 1))] = p@) ;:
    (p + 1) ) as void)
;: new_token TK_STR start (end + 1) file is j
   (j.t = array_of ty_i8 (len + 1) as @)
;: (j.str = buf)
;: j
;;
read_char_literal(file @File start@ i8 quote@ i8)@ Token = return
   (quote + 1) is p
   (p@ == '\0' && (error_at start file "unclosed literal i8") as void)
;: ((p@ == '\s') ? (p = p + 1) ;: (p@ == '\0' && (error_at start file "unclosed literal i8") as void) ;: escape p file : p@) is c
   (p = p + 1) 
;: (p@ != '\p' && (error_at start file "unclosed literal i8") as void)
;: new_token TK_NUM start (p + 1) file is j
   (j.val = c as i64)
;: (j.t = cast @void ty_i8)
;: j
;;

add_line_numbers(file @File j@ Token) = return
   1 is n
   file.contents for p
  (  !!p@
  && (p + 1)
  :; (j = (p == j.loc) ? (j.line_no = n) ;: j.s : j)
  :; (n = n + ((p@ == '\n') ? 1 : 0)) )
as void
;;

tokenizefr(file@ File)@ Token =
  let
    p = file.contents
    head = new Token {;
    cur = &head;
  while p@ {
    if startswith p "/*" {
      let q = strstr (p + 2) "*/" ;
      if !q (error_at p file "unclosed block comment");
      (p = q + 2);;
    else if (p@ == '\n' || cast bool isspace cast i32 p@) (p = p + 1);
    else if (isdigit cast i32 p@ || (p@ == '.' && isdigit cast i32 p[1])) {
       ((p + 1) for q ( !!isalnum cast i32 q@ && q + 1 )) is q
       (cur.s = new_token TK_NUM p q file)
    ;: (cur.s.loc is p
  10 is base
  (  (!strncasecmp p "0x" 2ul && !!isxdigit cast i32 p[2])
  ?  (p = p + 2)
  ;: (base = 16)
  :  none )
;: &p is q
   strtoul p q base is v
   false is l
   false is u
   ( (startswith p "ull") ? (p = p + 3) ;: (l = true) ;: (u = true):
     (startswith p "ul" ) ? (p = p + 2) ;: (l = true) ;: (u = true):
     (startswith p "ll" ) ? (p = p + 2) ;: (l = true) :
     (startswith p "l"  ) ? (p = p + 1) ;: (l = true) :
     (startswith p "u"  ) ? (p = p + 1) ;: (u = true) : none )
;: (p != cur.s.loc + cur.s.len) ? false :
   ( (l && u)  ? ring_of ty_i64  :
      l        ?         ty_i64  :
           u   ? ring_of ty_i32  :
                         ty_i32  )
   is t
   (cur.s.val  = v as i64 ) ;:
   (cur.s.t    = t as @   ) ;:
   true)
    ;: (cur = cur.s)
    ;: (p = q)
    ;;
    else if (p@ == '"') {
      (cur.s = read_string_literal file p p);
      (cur = cur.s);
      (p = p + cur.len);;
    else if (p@ == '\p') {
      (cur.s = read_char_literal file p p);
      (cur = cur.s);
      (cur.val = cur.val as i8 as i64);
      (p = p + cur.len);;
    else {
      let ident_len = read_ident p;
      if ident_len {
        (cur.s = new_token TK_ID p (p + ident_len) file);
        (cur = cur.s);
        (p = p + cur.len);;
      else {
        let punct_len = read_punct p;
        if punct_len {
          (cur.s = new_token TK_PCT p (p + punct_len) file);
          (cur = cur.s);
          (p = p + cur.len);;
        else (error_at p file "invalid token");;;;
      (cur.s = new_token TK_EOF p p file);
      (cur = cur.s);
  add_line_numbers file head.s;
  return head.s;;

read_file(path@ i8)@ i8 =
  let rfbuf2 [4096]i8;
  let fp = cast @FILE 0;
  (fp = fopen path "r");
  if !fp return cast @i8 0;
  let buf = cast @i8 0;
  let buflen = 0ul;
  let b = &buflen;
  let out = open_memstream &buf b;
  for (let k bool = true;k;) {
    let
      m = (sizeof typeof rfbuf2)
      n = fread cast @ rfbuf2 1ul m fp;
    if (n == 0) (k = false);
    else fwrite cast @ rfbuf2 1ul n out;;
  return
   (fclose fp as void)
;: fflush out
;: ((buflen == 0 || buf[buflen - 1ul] != '\n') && fputc cast i32 '\n' out as void)
;: fputc 0 out
;: fclose out
;: buf
;;

export new_file(name@ i8 file_no i32 contents@ i8)@ File = return
   cast @File calloc 1ul sizeof File is file
   (file.name = name)
;: (file.file_no = file_no)
;: (file.contents = contents)
;: file
;;

export tokenize(path @i8 file_n i32 files @@@File) @Token = return
   read_file path is p
  (  !p
  ?  cast @Token 0
  :  new_file path (file_n + 1) p is f
     (files@ = cast @@File realloc (cast @ files@) (sizeof @File * cast %i64 (file_n + 1)))
  ;: (files@[file_n] = f)
  ;: (files@[file_n + 1] = cast @File 0)
  ;: tokenizefr f )
;;