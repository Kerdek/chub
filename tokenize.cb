#include "chub.hb"

// Input file
current_file@ File;

// A list of all input files.
input_files@@ File;

// True if the current position is at the beginning of a line
at_bol bool;

// True if the current position follows a space character
has_space bool;

// Reports an error and exit.
export error(fmt@ char ...) =
  let ap = (let va_list){;;
  va_start(ap, fmt);
  let pap = &ap;
  vfprintf(stderr fmt pap);
  fprintf(stderr "\n"->@char);
  raise(SIGTRAP);
  exit(1);
;

// Reports an error message in the following format.
//
// foo.c:10: x = y + 1;
//               ^ <error message here>
verror_at(filename@ char input@ char line_no int loc@ char locb @char fmt@ char ap @va_list)  =
  // Find a line containing `loc`.
  let line = loc;
  while input < line && line[-1] != '\n'
    line--;

  let end = loc;
  while end@ && end@ != '\n'
    end++;

  let indent = fprintf(stderr "./%s:(%d,%d)::./%s:(%d,%d): "->@char filename line_no loc - line + 1 filename line_no locb - line + 1);

  fprintf(stderr "%.*s\n"->@char end - line line);

  // Show the error message.
  let b = loc - line;
  let pos = display_width(line b->int) + indent;

  fprintf(stderr "%*s"->@char pos ""->@char); // prpos  intspaces.
  fprintf(stderr "^ "->@char);
  vfprintf(stderr fmt ap);
  fprintf(stderr "\n"->@char);
;

export error_at(loc@ char locb @char fmt@ char ...)  =
  let line_no = 1;
  for (let p @ char= current_file@.contents; p < loc; p++)
    if p@ == '\n'
      line_no++;

  let ap = (let va_list){;;
  va_start(ap, fmt);
  let pap = &ap;
  verror_at(current_file@.name current_file@.contents line_no loc locb fmt pap);
  raise(SIGTRAP);
  exit(1);
;

export error_tok(tok@ Token fmt@ char ...)  =
  let ap = (let va_list){;;
  va_start(ap, fmt);
  let pap = &ap;
  verror_at(tok@.file@.name tok@.file@.contents tok@.line_no tok@.loc tok@.loc + tok@.len fmt pap);
  raise(SIGTRAP);
  exit(1);
;

export warn_tok(tok@ Token fmt@ char ...) =
  let ap = (let va_list){;;
  va_start(ap, fmt);
  let pap = &ap;
  verror_at(tok@.file@.name tok@.file@.contents tok@.line_no tok@.loc tok@.loc + tok@.len fmt pap);
  va_end(ap)
;

export equal(tok@ Token op@ char) bool =
  return (memcmp(tok@.loc->@ op->@ tok@.len->unsigned long) == 0 && op[tok@.len] == '\0')->bool;
;

export expect(tok@@ Token op@ char)  =
  if !equal(tok@ op) {
    error_tok(tok@ "expected '%s'"->@char op);
  ;
  tok@ = tok@@.next;
;

export skip(tok@ Token op@ char)@ Token =
  if !equal(tok op) {
    error_tok(tok "expected '%s'"->@char op);
  ;
  return tok@.next;
;

export consume(rest@@ Token tok@ Token str@ char) bool =
  if equal(tok str) {
    rest@ = tok@.next;
    return true;
  ;
  rest@ = tok;
  return false;
;

// Create a new token.
new_token(kind typeof 0->@Token@.kind start@ char end@ char)@ Token =
  let tok = calloc(1->unsigned long sizeof Token)->@Token;
  tok@.kind = kind;
  tok@.loc = start;
  tok@.len = end - start;
  tok@.file = current_file;
  tok@.filename = current_file@.display_name;
  tok@.at_bol = at_bol;
  tok@.has_space = has_space;

  at_bol = has_space = false;
  return tok;
;

startswith(p@ char q@ char) bool =
  return (!strncmp(p->@ q strlen(q)))->bool;
;

// Read an identifier and returns the length of it.
// If p does not poto  inta valid identifier, 0 is returned.
read_ident(start@ char) int =
  let p = start;
  let c = decode_utf8(&p p);
  if !is_ident1(c)
    return 0;

  for (;;) {
    let q = 0->@char;
    c = decode_utf8(&q p);
    if !is_ident2(c)
      return (p - start)->int;
    p = q;
  ;
;

from_hex(c char) int =
  if '0' <= c && c <= '9'
    return c - '0';
  if 'a' <= c && c <= 'f'
    return c - 'a' + 10;
  return c - 'A' + 10;
;

rpkw[]@ char = {
  "<<="->@char ">>="->@char "..."->@char "=="->@char
  "!=" ->@char "<=" ->@char ">=" ->@char "->"->@char
  "+=" ->@char "-=" ->@char "*=" ->@char "/="->@char
  "++" ->@char "--" ->@char "%=" ->@char "&="->@char
  "|=" ->@char "^=" ->@char "&&" ->@char "||"->@char
  "<<" ->@char ">>" ->@char "##" ->@char
;;
read_punct(p@ char) int =
  for (let i  int= 0; i < (sizeof typeof rpkw) / (sizeof typeof rpkw@); i++)
    if startswith(p rpkw[i])
      return strlen(rpkw[i])->int;

  return ispunct(p@) ? 1 : 0;
;

ikmap HashMap
ikkw[]@ char = {
  "let"       ->@char "return"      ->@char "if"           ->@char "else"    ->@char "for"          ->@char "while"   ->@char "int"     ->@char "sizeof"       ->@char "same"        ->@char "char"     ->@char
  "struct"    ->@char "union"       ->@char "short"        ->@char "long"    ->@char "void"         ->@char "typedef" ->@char "_Bool"   ->@char "enum"         ->@char "static"      ->@char "export"   ->@char
  "goto"      ->@char "break"       ->@char "continue"     ->@char "switch"  ->@char "case"         ->@char "default" ->@char "extern"  ->@char "alignof"      ->@char "align"       ->@char "do"       ->@char
  "signed"    ->@char "unsigned"    ->@char "const"        ->@char "volatile"->@char "auto"         ->@char "register"->@char "restrict"->@char "__restrict"   ->@char "__restrict__"->@char "_Noreturn"->@char
  "float"     ->@char "double"      ->@char "typeof"       ->@char "asm"     ->@char "_Thread_local"->@char "__thread"->@char "_Atomic" ->@char "__attribute__"->@char "bool"        ->@char "true"     ->@char
  "false"     ->@char
;;
is_keyword(tok@ Token) bool =
  if ikmap.capacity == 0 {


    for (let i  int= 0; i < (sizeof typeof ikkw) / (sizeof typeof ikkw@); i++)
      hashmap_put(&ikmap ikkw[i] 1->@ );
  ;

  return hashmap_get2(&ikmap tok@.loc tok@.len)->bool;
;

read_escaped_char(new_pos@@ char p@ char) int =
  if '0' <= p@ && p@ <= '7' {
    // Read an octal number.
    let c = p++@ - '0';
    if '0' <= p@ && p@ <= '7' {
      c = (c << 3) + (p++@ - '0');
      if '0' <= p@ && p@ <= '7'
        c = (c << 3) + (p++@ - '0');
    ;
    new_pos@ = p;
    return c;
  ;

  if p@ == 'x' {
    // Read a hexadecimal number.
    p++;
    if !isxdigit(p@)
      error_at(p "invalid hex escape sequence"->@char);

    let c = 0;
    for (; isxdigit(p@); p++)
      c = (c << 4) + from_hex(p@);
    new_pos@ = p;
    return c;
  ;

  new_pos@ = p + 1;

  // Escape sequences are defined using themselves here. E.g.
  // '\n' is implemented using '\n'. This tautological definition
  // works because the compiler that compiles our compiler knows
  // what '\n' actually is. In other words, we "inherit" the ASCII
  // code of '\n' from the compiler that compiles our compiler,
  // so we don't have to teach the actual code here.
  //
  // This fact has huge implications not only for the correctness
  // of the compiler but also for the security of the generated code.
  // For more info, read "Reflections on Trusting Trust" by Ken Thompson.
  // https://github.com/rui314/chibicc/wiki/thompson1984.pdf
  switch (p@) {
  case 'a': return '\a';
  case 'b': return '\b';
  case 't': return '\t';
  case 'n': return '\n';
  case 'v': return '\v';
  case 'f': return '\f';
  case 'r': return '\r';
  // [GNU] \e for the ASCII escape character is a GNU C extension.
  case 'e': return 27;
  default: return p@->int;
  ;
;

// Find a closing double-quote.
string_literal_end(p@ char)@ char =
  let start = p;
  for (; p@ != '"'; p++) {
    if p@ == '\n' || p@ == '\0'
      error_at(start "unclosed string literal"->@char);
    if p@ == '\\'
      p++;
  ;
  return p;
;

read_string_literal(start@ char quote@ char)@ Token =
  let end = string_literal_end(quote + 1);
  let b = end - quote;
  let buf = calloc(1->unsigned long b->unsigned long)->@char;
  let len = 0;

  for (let p @ char= quote + 1; p < end;) {
    if p@ == '\\'
      buf[len++] = read_escaped_char(&p p + 1);
    else
      buf[len++] = p++@;
  ;

  let tok = new_token(TK_STR->typeof 0->@ Token@.kind start end + 1);
  tok@.ty = array_of(ty_char len + 1);
  tok@.str = buf;
  return tok;
;

// Read a UTF-8-encoded string literal and transcode it in UTF-16.
//
// UTF-16 is yet another variable-width encoding for Unicode. Code
// points smaller than U+10000 are encoded in 2 bytes. Code points
// equal to or larger than that are encoded in 4 bytes. Each 2 bytes
// in the 4 byte sequence is called "surrogate", and a 4 byte sequence
// is called a "surrogate pair".
read_utf16_string_literal(start@ char quote@ char)@ Token =
  let end = string_literal_end(quote + 1);
  let b = end - start;
  let buf = calloc(2->unsigned long b->unsigned long)->@uint16_t;
  let len = 0;

  for (let p @char = quote + 1; p < end;) {
    if p@ == '\\' {
      buf[len++] = read_escaped_char(&p p + 1);
      continue;
    ;

    let c = decode_utf8(&p p);
    if c < 0x10000 {
      // Encode a code poin  int2 bytes.
      buf[len++] = c;
    ; else {
      // Encode a code poin  int4 bytes.
      c -= 0x10000;
      buf[len++] = 0xd800 + ((c >> 10) & 0x3ff);
      buf[len++] = 0xdc00 + (c & 0x3ff);
    ;
  ;

  let tok = new_token(TK_STR->typeof 0->@ Token@.kind start end + 1);
  tok@.ty = array_of(ty_ushort len + 1);
  tok@.str = buf->@ char;
  return tok;
;

// Read a UTF-8-encoded string literal and transcode it in UTF-32.
//
// UTF-32 is a fixed-width encoding for Unicode. Each code point is
// encoded in 4 bytes.
read_utf32_string_literal(start@ char quote@ char ty@ Type)@ Token =
  let end = string_literal_end(quote + 1);
  let b = end - quote;
  let buf = calloc(4->unsigned long b->unsigned long)->@uint32_t;
  let len = 0;

  for (let p @ char= quote + 1; p < end;) {
    if p@ == '\\'
      buf[len++] = read_escaped_char(&p p + 1);
    else
      buf[len++] = decode_utf8(&p p);
  ;

  let tok = new_token(TK_STR->typeof 0->@ Token@.kind start end + 1);
  tok@.ty = array_of(ty len + 1);
  tok@.str = buf->@ char;
  return tok;
;

read_char_literal(start@ char quote@ char ty@ Type)@ Token =
  let p = quote + 1;
  if p@ == '\0'
    error_at(start "unclosed literal char"->@char);

  let c = 0;
  if p@ == '\\'
    c = read_escaped_char(&p p + 1);
  else
    c = decode_utf8(&p p);

  let end = strchr(p '\'');
  if !end
    error_at(p "unclosed literal char"->@char);

  let tok = new_token(TK_NUM->typeof 0->@ Token@.kind start end + 1);
  tok@.val = c;
  tok@.ty = ty;
  return tok;
;

convert_pp_int(tok@ Token) bool =
  let p = tok@.loc;

  // Read a binary, octal, decimal or hexadecimal number.
  let base = 10;
  if !strncasecmp(p "0x"->@char 2->unsigned long) && isxdigit(p[2]) {
    p += 2;
    base = 16;
  ; else if !strncasecmp(p "0b"->@char 2->unsigned long) && (p[2] == '0' || p[2] == '1') {
    p += 2;
    base = 2;
  ; else if p@ == '0' {
    base = 8;
  ;

  let q = &p;
  let val = strtoul(p q base);

  // Read U, L or LL suffixes.
  let l = false;
  let u = false;

  if startswith(p "LLU"->@char) || startswith(p "LLu"->@char) ||
      startswith(p "llU"->@char) || startswith(p "llu"->@char) ||
      startswith(p "ULL"->@char) || startswith(p "Ull"->@char) ||
      startswith(p "uLL"->@char) || startswith(p "ull"->@char) {
    p += 3;
    l = u = true;
  ; else if !strncasecmp(p "lu"->@char 2->unsigned long) || !strncasecmp(p "ul"->@char 2->unsigned long) {
    p += 2;
    l = u = true;
  ; else if startswith(p "LL"->@char) || startswith(p "ll"->@char) {
    p += 2;
    l = true;
  ; else if p@ == 'L' || p@ == 'l' {
    p++;
    l = true;
  ; else if p@ == 'U' || p@ == 'u' {
    p++;
    u = true;
  ;

  if p != tok@.loc + tok@.len
    return false;

  // Infer a type.
  let ty = 0->@Type;
  if base == 10 {
    if l && u
      ty = ty_ulong;
    else if l
      ty = ty_long;
    else if u
      ty = (val >> 32) ? ty_ulong : ty_uint;
    else
      ty = (val >> 31) ? ty_long : ty_int;
  ; else {
    if l && u
      ty = ty_ulong;
    else if l
      ty = (val >> 63) ? ty_ulong : ty_long;
    else if u
      ty = (val >> 32) ? ty_ulong : ty_uint;
    else if val >> 63
      ty = ty_ulong;
    else if val >> 32
      ty = ty_long;
    else if val >> 31
      ty = ty_uint;
    else
      ty = ty_int;
  ;

  tok@.kind = TK_NUM;
  tok@.val = val;
  tok@.ty = ty;
  return true;
;

// The definition of the numeric literal at the preprocessing stage
// is more relaxed than the definition of that at the later stages.
// In order to handle that, a numeric literal is tokenized as a
// "pp-number" token first and then converted to a regular number
// token after preprocessing.
//
// This function converts a pp-number token to a regular number token.
convert_pp_number(tok@ Token)  =
  // Try to parse as an integer constant.
  if convert_pp_int(tok)
    return;

  let end = 0->@char;
  let fnd = &end;
  let val = strtold(tok@.loc fnd);

  let ty = 0->@Type;
  if end@ == 'f' || end@ == 'F' {
    ty = ty_float;
    end++;
  ; else if end@ == 'l' || end@ == 'L' {
    ty = ty_ldouble;
    end++;
  ; else {
    ty = ty_double;
  ;

  if tok@.loc + tok@.len != end
    error_tok(tok "invalid numeric constant"->@char);

  tok@.kind = TK_NUM;
  tok@.fval = val;
  tok@.ty = ty;
;

export convert_pp_tokens(tok@ Token)  =
  for (let t @ Token= tok; t@.kind != TK_EOF; t = t@.next) {
    if is_keyword(t)
      t@.kind = TK_KEYWORD;
    else if t@.kind == TK_PP_NUM
      convert_pp_number(t);
  ;
;

// Initialize line info for all tokens.
add_line_numbers(tok@ Token)  =
  let p = current_file@.contents;
  let n = 1;

  do {
    if p == tok@.loc {
      tok@.line_no = n;
      tok = tok@.next;
    ;
    if p@ == '\n'
      n++;
  ; while (p++@);
;

export tokenize_string_literal(tok@ Token basety@ Type)@ Token =
  let t = 0->@Token;
  if basety@.size == 2
    t = read_utf16_string_literal(tok@.loc tok@.loc);
  else
    t = read_utf32_string_literal(tok@.loc tok@.loc basety);
  t@.next = tok@.next;
  return t;
;

export tokenize(file@ File)@ Token =
  current_file = file;

  let
    p = file@.contents
    head = (let Token){;
    cur = &head;

  at_bol = true;
  has_space = false;

  while p@ {
    // Skip line comments.
    if startswith(p "//"->@char) {
      p += 2;
      while p@ != '\n'
        p++;
      has_space = true;
      continue;
    ;

    // Skip block comments.
    if startswith(p "/*"->@char) {
      let q = strstr(p + 2 "*/"->@char);
      if !q
        error_at(p "unclosed block comment"->@char);
      p = q + 2;
      has_space = true;
      continue;
    ;

    // Skip newline.
    if p@ == '\n' {
      p++;
      at_bol = true;
      has_space = false;
      continue;
    ;

    // Skip whitespace characters.
    if isspace(p@) {
      p++;
      has_space = true;
      continue;
    ;

    // Numeric literal
    if (isdigit(p@) || (p@ == '.' && isdigit(p[1]))) {
      let q = p++;
      for (;;) {
        if p[0] && p[1] && strchr("eEpP"->@char p[0]->int) && strchr("+-"->@char p[1]->int)
          p += 2;
        else if (isalnum(p@) || p@ == '.')
          p++;
        else
          break;
      ;
      cur = cur@.next = new_token(TK_PP_NUM->typeof 0->@ Token@.kind q p);
      continue;
    ;

    // String literal
    if p@ == '"' {
      cur = cur@.next = read_string_literal(p p);
      p += cur@.len;
      continue;
    ;

    // UTF-8 string literal
    if startswith(p "u8\""->@char) {
      cur = cur@.next = read_string_literal(p p + 2);
      p += cur@.len;
      continue;
    ;

    // UTF-16 string literal
    if startswith(p "u\""->@char) {
      cur = cur@.next = read_utf16_string_literal(p p + 1);
      p += cur@.len;
      continue;
    ;

    // Wide string literal
    if startswith(p "L\""->@char) {
      cur = cur@.next = read_utf32_string_literal(p p + 1 ty_int);
      p += cur@.len;
      continue;
    ;

    // UTF-32 string literal
    if startswith(p "U\""->@char) {
      cur = cur@.next = read_utf32_string_literal(p p + 1 ty_uint);
      p += cur@.len;
      continue;
    ;

    // Character literal
    if p@ == '\'' {
      cur = cur@.next = read_char_literal(p p ty_int);
      cur@.val = cur@.val->char;
      p += cur@.len;
      continue;
    ;

    // UTF-16 character literal
    if startswith(p "u'"->@char) {
      cur = cur@.next = read_char_literal(p p + 1 ty_ushort);
      cur@.val &= 0xffff;
      p += cur@.len;
      continue;
    ;

    // Wide character literal
    if startswith(p "L'"->@char) {
      cur = cur@.next = read_char_literal(p p + 1 ty_int);
      p += cur@.len;
      continue;
    ;

    // UTF-32 character literal
    if startswith(p "U'"->@char) {
      cur = cur@.next = read_char_literal(p p + 1 ty_uint);
      p += cur@.len;
      continue;
    ;

    // Identifier or keyword
    let ident_len = read_ident(p);
    if ident_len {
      cur = cur@.next = new_token(TK_IDENT->typeof 0->@ Token@.kind p p + ident_len);
      p += cur@.len;
      continue;
    ;

    // Punctuators
    let punct_len = read_punct(p);
    if punct_len {
      cur = cur@.next = new_token(TK_PUNCT->typeof 0->@ Token@.kind p p + punct_len);
      p += cur@.len;
      continue;
    ;

    error_at(p "invalid token"->@char);
  ;

  cur = cur@.next = new_token(TK_EOF->typeof 0->@ Token@.kind p p);
  add_line_numbers(head.next);
  return head.next;
;

rfbuf2[4096]char;
read_file(path@ char)@ char =
  let fp = 0->@FILE;

  if strcmp(path->@ "-"->@char) == 0 {
    // By convention, read from stdin if a given filename is "-".
    fp = stdin;
  ; else {
    fp = fopen(path "r"->@char);
    if !fp
      return 0->@char;
  ;

  let buf = 0->@char;
  let buflen = 0->size_t;
  let b = &buflen;
  let out = open_memstream(&buf b);

  for (;;) {
    let
      m = (sizeof typeof rfbuf2)
      n = fread(rfbuf2->@ 1->unsigned long m fp);
    if n == 0 break;
    fwrite(rfbuf2->@ 1->unsigned long n out);
  ;

  if fp != stdin fclose(fp);

  // Make sure that the last line is properly terminated with '\n'.
  fflush(out);
  if buflen == 0 || buf[buflen - 1] != '\n'
    fputc('\n' out);
  fputc('\0' out);
  fclose(out);
  return buf;
;

export get_input_files(void)@@ File =
  return input_files;
;

export new_file(name@ char file_no int contents@ char)@ File =
  let file = calloc(1->unsigned long sizeof File)->@File;
  file@.name = name;
  file@.display_name = name;
  file@.file_no = file_no;
  file@.contents = contents;
  return file;
;

// Replaces \r or \r\n with \n.
canonicalize_newline(p@ char)  =
  let
    i = 0
    j = 0;

  while p[i] {
    if p[i] == '\r' && p[i + 1] == '\n' {
      i += 2;
      p[j++] = '\n';
    ; else if p[i] == '\r' {
      i++;
      p[j++] = '\n';
    ; else {
      p[j++] = p[i++];
    ;
  ;

  p[j] = '\0';
;

// Removes backslashes followed by a newline.
  // We want to keep the number of newline characters so that
  // the logical line number matches the physical one.
  // `n` maintains the number of newlines we have removed.
remove_backslash_newline(p@ char)  =
  let
    i = 0
    j = 0
    n = 0;

  while p[i] {
    if p[i] == '\\' && p[i + 1] == '\n' {
      i += 2;
      n++;
    ; else if p[i] == '\n' {
      p[j++] = p[i++];
      for (; n > 0; n--)
        p[j++] = '\n';
    ; else {
      p[j++] = p[i++];
    ;
  ;

  for (; n > 0; n--)
    p[j++] = '\n';
  p[j] = '\0';
;

read_universal_char(p@ char len int) uint32_t =
  let c = 0;
  for (let i  int= 0; i < len; i++) {
    if !isxdigit(p[i])
      return 0->unsigned int;
    c = (c << 4) | from_hex(p[i]);
  ;
  return c->unsigned int;
;

// Replace \u or \U escape sequences with corresponding UTF-8 bytes.
convert_universal_chars(p@ char) =
  let q = p;

  while p@ {
    if startswith(p "\\u"->@char) {
      let c = read_universal_char(p + 2 4);
      if c {
        p += 6;
        q += encode_utf8(q c);
      ; else {
        q++@ = p++@;
      ;
    ; else if startswith(p "\\U"->@char) {
      let c = read_universal_char(p + 2 8);
      if c {
        p += 10;
        q += encode_utf8(q c);
      ; else {
        q++@ = p++@;
      ;
    ; else if p[0] == '\\' {
      q++@ = p++@;
      q++@ = p++@;
    ; else {
      q++@ = p++@;
    ;
  ;

  q@ = '\0';
;

tffile_no int;
export tokenize_file(path@ char)@ Token =
  let p = read_file(path);
  if !p
    return 0->@Token;

  // UTF-8 texts may start with a 3-byte "BOM" marker sequence.
  // If exists, just skip them because they are useless bytes.
  // (It is actually not recommended to add BOM markers to UTF-8
  // texts, but it's not uncommon particularly on Windows.)
  if !memcmp(p->@ "\xef\xbb\xbf"->@ 3->unsigned long)
    p += 3;

  canonicalize_newline(p);
  remove_backslash_newline(p);
  convert_universal_chars(p);

  // Save the filename for assembler .file directive.
  let file = new_file(path tffile_no + 1 p);

  // Save the filename for assembler .file directive.
  input_files = realloc(input_files->@ sizeof@ char * (tffile_no + 2));
  input_files[tffile_no] = file;
  input_files[tffile_no + 1] = 0->@char;
  tffile_no++;

  return tokenize(file);
;
