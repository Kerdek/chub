# "chub.hb"

new_token(kind typeof TK_ID start@ i8 end@ i8 file @File)@ Token = return
   cast @Token calloc 1ul sizeof Token is j j
:; (j.kind = kind              )
;: (j.loc  = start             )
;: (j.len  = end - start as i32)
;: (j.in = file              )
;;

startswith(p@ i8 q@ i8) bool = return
   true is r
  (  true for _
    (  (!q@)
    ?  false
    :  (p@ != q@)
    ?  (r = false)
    ;: false
    :  (p = p + 1)
    ;: (q = q + 1)
    ;: true )
  as none )
;: r
;;

issp(c i8) bool = return ' '  == c ;;
istb(c i8) bool = return '\t' == c ;;
islf(c i8) bool = return '\n' == c ;;
iscr(c i8) bool = return '\r' == c ;;
is_ (c i8) bool = return '_'  == c ;;
isin(c i8 a i8 b i8) bool = return a <= c && c <= b ;;
isAZ(c i8) bool = return isin c 'A' 'Z' ;;
isaz(c i8) bool = return isin c 'a' 'z' ;;
is09(c i8) bool = return isin c '0' '9' ;;
isaf(c i8) bool = return isin c 'a' 'f' ;;
isws(c i8) bool = return
   issp c
|| istb c
|| islf c
|| iscr c
;;
is0f(c i8) bool = return 
   is09 c
|| isaf c
;;
isid(c i8) bool = return
   isAZ c
|| isaz c 
|| is09 c
|| is_  c
;;

read_ident(p@ i8) i32 = return
   0 is r
   (p for q (isid q@ && q + 1 || cast @i8 0 :; (r = q - p as i32)) as none)
;: r
;;

read_punct(p@ i8) i32 = return
&startswith is f
(  f@ p "<<="
|| f@ p ">>="
|| f@ p "&&="
|| f@ p "||="
|| f@ p "..." ) ? 3 :
(  f@ p "==" 
|| f@ p "!=" 
|| f@ p "<=" 
|| f@ p ">=" 
|| f@ p "+=" 
|| f@ p "-=" 
|| f@ p "*=" 
|| f@ p "/=" 
|| f@ p "%=" 
|| f@ p "&=" 
|| f@ p "|=" 
|| f@ p "^=" 
|| f@ p "&&" 
|| f@ p "||" 
|| f@ p "<<" 
|| f@ p ">>" 
|| f@ p ";:" 
|| f@ p ":;" ) ? 2 :
(  f@ p "=" 
|| f@ p "<"
|| f@ p ">"
|| f@ p "+"
|| f@ p "-"
|| f@ p "*"
|| f@ p "/"
|| f@ p "&"
|| f@ p "|"
|| f@ p "@"
|| f@ p "#"
|| f@ p "{"
|| f@ p "}"
|| f@ p "("
|| f@ p ")"
|| f@ p "["
|| f@ p "]"
|| f@ p "!"
|| f@ p "?"
|| f@ p ":"
|| f@ p ";"
|| f@ p ","
|| f@ p "."
|| f@ p "~"
|| f@ p "^"
|| f@ p "%" ) ? 1 : 0;;

escape_one(c i8 ca i8 cb i8) i8 = return c == ca && cb ;;

escape(c @i8 file @File) i8 = return
&escape_one is f
(  f@ c@ 'a' '\a'
|| f@ c@ 'b' '\b'
|| f@ c@ 'f' '\f'
|| f@ c@ 'n' '\n'
|| f@ c@ 'r' '\r'
|| f@ c@ 't' '\t'
|| f@ c@ 'v' '\v'
|| f@ c@ 'p' '\p'
|| f@ c@ 'q' '\q'
|| f@ c@ 's' '\s'
|| '\0' :; (c@ != '0' && (diag c file "invalid escape sequence") as none) )
;;

read_string_literal(file @File start@ i8 quote@ i8)@ Token = return
  (  (quote + 1) for q
    (  q@ != '"'
    && (q + 1)
    :; (q@ == '\0' && (diag quote file "unclosed string literal") as none) ) )
is end
   cast @i8 calloc 1ul (end - quote as %i64) is buf
   0 is len
  (  (quote + 1) for p
    (  p < end
    && (p@ == '\s')
    ? (  buf[(len:;(len = len + 1))] = (p = p + 1)
      ;: escape p file
      :; (p = p + 1) )
    ;: p
    :  (buf[(len:;(len = len + 1))] = p@)
    ;: (p + 1) )
  as none )
;: new_token TK_STR start (end + 1) file is j
   (j.t = array_of ty_i8 (len + 1) as @)
;: (j.str = buf)
;: j
;;

read_char_literal(in @File p@ i8)@ Token = return
   (p + 1) is q
   (q@ == '\0' && (diag p in "unclosed literal i8") as none)
;:(  (q@ == '\s')
  ?  (q = q + 1)
  ;: (q@ == '\0' && (diag p in "unclosed literal i8") as none)
  ;: escape q in
  :  q@ )
is c
   (q = q + 1)
;: (q@ != '\p' && (diag p in "unclosed literal i8") as none)
;: new_token TK_NUM p (q + 1) in is j
   (j.val = c as i64)
;: (j.t = cast @none ty_i8)
;: j
;;

tokenshit(file @File p @i8 cur @Token) = return
   (true for _ (p@ &&
    startswith p "/*"
    ?  strstr (p + 2) "*/" is q
       (!q && (diag p file "unclosed block comment") as none)
    ;: (p = q + 2)
    :  (p@ == '\n' || isws p@) ? (p = p + 1)
    :  (is09 p@ || (p@ == '.' && is09 p[1]))
    ?  ((p + 1) for q ( isid q@ && q + 1 )) is q
       (cur.s = new_token TK_NUM p q file)
    ;: (cur.s.loc is p
  10 is base
  (  (!strncasecmp p "0x" 2ul && is0f p[2])
  ?  (p = p + 2)
  ;: (base = 16)
  :  none )
;: &p is q
   strtoul p q base is v
   false is l
   false is u
   ( (startswith p "ull") ? (p = p + 3) ;: (l = true) ;: (u = true):
     (startswith p "ul" ) ? (p = p + 2) ;: (l = true) ;: (u = true):
     (startswith p "ll" ) ? (p = p + 2) ;: (l = true) :
     (startswith p "l"  ) ? (p = p + 1) ;: (l = true) :
     (startswith p "u"  ) ? (p = p + 1) ;: (u = true) : none )
;: (p != cur.s.loc + cur.s.len) ? false :
   ( (l && u)  ? ring_of ty_i64  :
      l        ?         ty_i64  :
           u   ? ring_of ty_i32  :
                         ty_i32  )
   is t
   (cur.s.val  = v as i64 ) ;:
   (cur.s.t    = t as @   ) ;:
   true)
    ;: (cur = cur.s)
    ;: (p = q)
    :  (p@ == '"')
    ?  (cur.s = read_string_literal file p p)
    ;: (cur = cur.s)
    ;: (p = p + cur.len)
    :  (p@ == '\p')
    ?  (cur.s = read_char_literal file p)
    ;: (cur = cur.s)
    ;: (cur.val = cur.val as i8 as i64)
    ;: (p = p + cur.len)
    :  read_ident p is ident_len
       !!ident_len
    ?  (cur.s = new_token TK_ID p (p + ident_len) file)
    ;: (cur = cur.s)
    ;: (p = p + cur.len)
    :  read_punct p is punct_len
       !!punct_len
    ?  (cur.s = new_token TK_PCT p (p + punct_len) file)
    ;: (cur = cur.s)
    ;: (p = p + cur.len)
    :  (diag p file "invalid token")) as none) ;:
 (cur.s = new_token TK_EOF p p file);;

read_file(path@ i8)@ i8 = return
   new [4096]i8 is rfbuf2
   cast @FILE 0 is fp
   (fp = fopen path "r")
;: !fp ? cast @i8 0
:  cast @i8 0 is buf
   0ul is buflen
   &buflen is b
   open_memstream &buf b is out
   (true for k
    sizeof typeof rfbuf2 is m
    fread cast @ rfbuf2 1ul m fp is n
    ((n == 0) ? (k = false) : cast none fwrite cast @ rfbuf2 1ul n out)
    ;: k as none)
;: (fclose fp as none)
;: fflush out
;: ((buflen == 0 || buf[buflen - 1ul] != '\n') && fputc cast i32 '\n' out as none)
;: fputc 0 out
;: fclose out
;: buf
;;

export tokenize(path @i8 file_n i32 files @@@File) @Token = return
   read_file path is p
   !p
?  cast @Token 0
:  cast @File calloc 1ul sizeof File is f
   (f.name = path)
;: (f.file_no = file_n + 1)
;: (f.contents = p)
;: (files@ = cast @@File realloc (cast @ files@) (sizeof @File * cast %i64 (file_n + 1)))
;: (files@[file_n] = f)
;: (files@[file_n + 1] = cast @File 0)
;: f.contents is p
   new Token is head
   tokenshit f p &head
;: head.s is j
   1 is n
  ( f.contents for p
    (  !!p@
    && (p + 1)
    :; (j = (p == j.loc) ? (j.line_no = n) ;: j.s : j)
    :; (n = n + ((p@ == '\n') ? 1 : 0)) )
  as none )
;: head.s 
;;