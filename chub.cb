type
  va_list struct {}
  FILE    struct {}
;

export __errno_location    ( ) @nat ;

export open_memstream      (p    @@byte n    @nat) @FILE ;
export fopen               (path  @byte mode @ byte ) @FILE ;

export fclose              (io @FILE) nat ;
export fflush              (io @FILE) nat ;

export fread               (ptr @none m nat n nat io @FILE) nat ;
export fwrite              (ptr @none m nat n nat io @FILE) nat ;
export fputc               (c nat io @FILE) nat ;

export printf              (         fmt @byte ...          ) nat ;
export vprintf             (         fmt @byte args @va_list) nat ;
export fprintf             (io @FILE fmt @byte ...          ) nat ;
export vfprintf            (io @FILE fmt @byte args @va_list) nat ;

export exit                (status nat) none ;

export calloc              (m nat  n nat) @none ;
export free                (p @none) none ;

export memcmp              (p @none q @none n nat) nat ;

export strtoul             (p @byte q @@byte  b  nat) nat ;
export strcat              (p @byte q  @byte        ) @byte  ;
export strstr              (p @byte q  @byte        ) @byte  ;
export strcmp              (p @byte q  @byte        )  nat ;
export strncmp             (p @byte q  @byte  n nat)  nat ;
export strndup             (p @byte         n nat) @byte  ;
export strlen              (p @byte               ) nat ;

export strerror            (errnum  nat) @byte ;

/* end preamble */

type
  NodeKind enum
    EADD       ESUB     EMUL     EDIV       ETHE
    ENEG       EMOD     EBAND  EBOR     EBXOR
    ESHL       ESHR     EEQ      ENE        ELT
    ELE        EGT      EGE      EASS    ECOND
    ESEQ     EMEM  EADDR    EDEREF     ENOT
    EBNOT    ELAND  ELOR   ETHEN      ECALL
    EIS       EVAR     ELIT     ECAST      EZ
    EFOR    ESIZE    EALIGN   EELEM      ENEW
  ;

  TypeKind enum
    TY_VOID    TY_BOOL    TY_BYTE
    TY_INT     TY_FUNC    TY_ARRAY
    TY_ENUM    TY_STRUCT  TY_PTR
    TY_NAT
  ;

  TokenKind enum
    TK_ID  TK_PCT
    TK_KEY TK_STR TK_NUM
  ;

  File struct {
    name         @byte
    contents     @byte
  }

  Token struct {
    q           TokenKind
    s          @same
    l           nat
    loc        @byte
    n          nat
    t          @none
    str        @byte
    in         @File
    line_no     nat
  }

  Type struct  {
    q          TypeKind
    size          nat
    align         nat
    offset        nat
    n             nat
    s            @same
    o            @same
    a            @same
    params       @same
    name         @Token
    is_variadic   bit
  }

  Obj struct {
    s               @same
    name            @byte
    t               @Type
    j               @Token
    offset           nat
    is_local         bit
    is_definition    bit
    is_export        bit
    init_data       @byte
    params          @same
    body            @none
    locals          @same
    va_area         @same
  }

  Node struct {
    s @same
    a @same
    q  NodeKind
    j @Token
    t @Type
    o @Obj
    l  nat
  }

  Scope struct {
    s @same
    c @byte
    o @Obj
    t @Type
    v  nat
  }

  VarAttr struct {
    is_type    bit
    is_export  bit
  }

  Ctx struct {
    j @Token
    locals         @Obj
    globals        @Obj
    s @Scope
    t @Type
    n  nat
  }

  J @Token
  O @Obj
  K @Ctx
  E @Node
  T @Type
  N nat
  C byte
  S @byte
  Y @FILE
;

type cis  (c C        ) bit;
type ekt  (k K t T    ) E;
type ekta (k K t T a E) E;

issp cis = (' '  == c)
istb cis = ('\t' == c)
islf cis = ('\n' == c)
iscr cis = ('\r' == c)
is_  cis = ('_'  == c)

isin(c C a C b C) bit =
((a <= c) && (c <= b))

isAZ cis = isin c 'A' 'Z'
isaz cis = isin c 'a' 'z'
is09 cis = isin c '0' '9'
isaf cis = isin c 'a' 'f'

isws cis =
(  issp c
|| istb c
|| islf c
|| iscr c )
is0f cis =
(  is09 c
|| isaf c )
isid cis =
(  isAZ c
|| isaz c
|| is09 c
|| is_  c )


read_ident(p S) N =
(  0 is r
   cast none (p for q ((isid q@ && &q^1) || '\0' ret (r = q - p as N)))
   r )

startswith(p S q S) bit =
(  1b is r
  cast none (  1b for _
    (  !q@
    ?  0b
    :  (p@ != q@)
    ?  (r = 0b)
       0b
    :  (p = &p^1)
       (q = &q^1)
       1b ) )
   r )

read_punct(p S) N =
(  &startswith is f
  (  f@ p "..." ) ? 3 :
  (  f@ p "=="
  || f@ p "!="
  || f@ p "<="
  || f@ p ">="
  || f@ p "&&"
  || f@ p "||"
  || f@ p "<<"
  || f@ p ">>" ) ? 2 :
  (  f@ p "=" 
  || f@ p "<"
  || f@ p ">"
  || f@ p "+"
  || f@ p "-"
  || f@ p "*"
  || f@ p "/"
  || f@ p "&"
  || f@ p "|"
  || f@ p "@"
  || f@ p "#"
  || f@ p "{"
  || f@ p "}"
  || f@ p "("
  || f@ p ")"
  || f@ p "["
  || f@ p "]"
  || f@ p "!"
  || f@ p "?"
  || f@ p ":"
  || f@ p ";"
  || f@ p ","
  || f@ p "."
  || f@ p "~"
  || f@ p "^"
  || f@ p "$"
  || f@ p "`"
  || f@ p "%" ) ? 1 : 0 )


p1    ekt ;
p2    ekt ;
p3    ekt ;
p4    ekt ;
p5    ekt ;
pseq  ekt ;
pmul  ekt ;
padd  ekt ;
psh   ekt ;
pcmp  ekt ;
pband ekt ;
pbor  ekt ;
pland ekt ;
plor  ekt ;

type_suffix(k K) T ;

grval(y Y e E c @N) nat;
glval(y Y e E c @N) nat;

maxl (a N b N) N = ((a > b) ? a : b)
minl (a N b N) N = ((a < b) ? a : b)
maxul(a N b N) N = ((a > b) ? a : b)
minul(a N b N) N = ((a < b) ? a : b)

align_to(n N a N) N = ((n + a - 1) / a * a)

vdiag(in S c S line_n N p S fmt S args @va_list) none =
(  (p for q ((c < q) && (q^-1 != '\n') && &q^-1)) is line
   (p for q (!!q@  && (q@ != '\n') && &q^1)) is end
   (printf "./%s:(%ld,%ld): " in line_n (cast N (p - line) + 1)) is indent
   (cast none printf "%.*s\n%*s^ " (end - line) line ((p - line as N) + indent) "")
    cast none vprintf fmt args
   (cast none printf "\n") )

diag(p S in @File fmt S ...) none =
(  1 is line_no
   (in.contents for p (&p^1 ret ((p@ == '\n') && (line_no = line_no + 1) as none)) as none)
   vdiag in.name in.contents line_no p fmt cast @va_list __va_area__
   exit 1 )

jdiag(j J fmt S ...) none =
(  vdiag j.in.name j.in.contents j.line_no j.loc fmt cast @va_list __va_area__
   exit 1 )

ntype(q TypeKind size N align N) T = (
  cast T calloc 1 sizeof Type is t t ret
  (t.q     = q     )
  (t.size  = size  )
  (t.align = align )
)

format_type_b(q1 TypeKind q2 TypeKind s1 S s2 S) bit =
((q1 == q2) && strcat s1 s2)

format_type_a(t T s S) none =
(  &strcat        is f
   &format_type_a is a
   &format_type_b is b
   t.q            is q
   !t ? strcat              s "null"
: (  b@ q TY_VOID           s "none"
  || b@ q TY_BOOL           s "bit"
  || b@ q TY_BYTE           s "byte"
  || b@ q TY_NAT            s "nat"
  || b@ q TY_ENUM           s "enum"
  || b@ q TY_STRUCT         s "struct"
  || ( q == TY_ARRAY ) ? f@ s "^"      ret a@ t.a s :
     ( q == TY_PTR   ) ? f@ s "@"      ret a@ t.a s :
     ( q == TY_FUNC  ) ? f@ s "("      ret
              (t.a.s for p (!!p && p.s ret a@ p   s ) as none)   
                         f@ s ")"      ret a@ t.a s :
                         f@ s "???"

  as none ) )

format_type(t T) S =
(  cast S calloc 1 1 is s s
ret format_type_a t s )

type_equal(t T u T) bit =
(  !!t
&& !!u
&& t.q is c
  (  (t == u)
  ||(
      !!t.o ? type_equal t.o u
    : !!u.o ? type_equal t u.o
    : (  (c == u.q)
      &&(  (c == TY_VOID)
        || (c == TY_BOOL)
        || (c == TY_BYTE)
        || (c == TY_INT)
        || (c == TY_NAT)
        || (c == TY_FUNC)
          ?  !type_equal t.a u.a
          ?  0b
          :  u.a.s is p
             t.a.s is q (1b for _ (!!p && !!q && type_equal p q && (p = p.s)    (q = q.s) ) as none)
             (p == q)
          :  (c == TY_ARRAY)
          ?  !type_equal t.a u.a
          ?  0b
          :  (t.n == u.n)
          :  (c == TY_PTR)
          ?  type_equal t.a u.a
          :  0b ) ) ) ) )

nnull () T = cast T 0
nnone () T = ntype TY_VOID 1 1
nbit  () T = ntype TY_BOOL 1 1
nbyte () T = ntype TY_BYTE 1 1
nnat  () T = ntype TY_NAT  8 8

copy_type(t T) T =
(  cast T calloc 1 sizeof Type is u u
ret (u@ = t@)
   (u.o = t) )

nptr   (a T    ) T = (ntype TY_PTR    8            8       is t t ret (t.a = a)             )
func_of  (a T    ) T = (ntype TY_FUNC   1            1       is t t ret (t.a = a)             )
array_of (a T n N) T = (ntype TY_ARRAY  (a.size * n) a.align is t t ret (t.a = a)    (t.n = n))
struct_of(       ) T =  ntype TY_STRUCT 0            1

ntoken(q TokenKind a S b S in @File) J =
(  cast J calloc 1 sizeof Token is j j
ret (j.q   = q    )
   (j.loc = a    )
   (j.n   = b - a)
   (j.in  = in   ) )

escape_one(c C ca C cb C) C =
((c == ca) && cb)

escape(c S in @File) C =
(  &escape_one is f
  (  f@ c@ 'a' '\a'
  || f@ c@ 'b' '\b'
  || f@ c@ 'f' '\f'
  || f@ c@ 'n' '\n'
  || f@ c@ 'r' '\r'
  || f@ c@ 't' '\t'
  || f@ c@ 'v' '\v'
  || f@ c@ 'p' '\p'
  || f@ c@ 'q' '\q'
  || f@ c@ 's' '\s'
  || '\0'
  ret ((c@ != '0') && (diag c in "invalid escape sequence") as none) ) )

string_literal(in @File start S quote S) J =
( (  &quote^1 for q
    (  (q@ != '"')
    && &q^1
    ret ((q@ == '\0') && (diag quote in "unclosed string literal") as none) ) )
is end
   cast S calloc 1 (end - quote as N) is buf
   0 is n
  (  &quote^1 for p
    (  (p < end)
    && (p@ == '\s')
    ? (  buf^(n ret (n = n + 1)) = (p = &p^1)
         escape p in
      ret (p = &p^1) )
       p
    :  (buf^(n ret (n = n + 1)) = p@)
       &p^1 )
  as none )
   ntoken TK_STR start &end^1 in is j
   (j.t = array_of nbyte cast nat (n + 1))
   (j.str = buf)
   j )

byte_literal(in @File p S) J =
(  &p^1 is q
   ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
  (  (q@ == '\s')
  ?  (q = &q^1)
     ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
     escape q in
  :  q@ )
is c
   (q = &q^1)
   ((q@ != '\p') && (diag p in "unclosed literal byte") as none)
   ntoken TK_NUM p &q^1 in is j
   (j.l = c as N)
   (j.t = cast @none nbyte)
   j )

open_file(path S mode S) Y =
(fopen path mode || cast none (printf "cannot open file '%s' with mode '%s': %s" mode path strerror (__errno_location)@))

read_file(path S) S =
(  cast S calloc 1 4096 is rfbuf2
   open_file path "r" is fp
   cast S 0 is buf
   0 is buflen
   &buflen is b
   open_memstream &buf b is y
   (1b for k
    sizeof typeof rfbuf2 is m
    fread cast @none rfbuf2 1 m fp is n
    ((n == 0) ? (k = 0b) : cast none fwrite cast @none rfbuf2 1 n y)
       k as none)
   free cast @none rfbuf2
   (fclose fp as none)
   fflush y
   (((buflen == 0) || (buf^(buflen - 1) != '\n')) && fputc cast N '\n' y as none)
   fputc 0 y
   fclose y
   buf )

tokenize(path S) J =
(  read_file path is p
   !p
?  cast J 0
:  cast @File calloc 1 sizeof File is in
   (in.name = path)
   (in.contents = p)
   new Token is j
   (in.contents is p &j is j
   (1b for _ (p@ &&
    startswith p "/*"
    ?  strstr &p^2 "*/" is q
       (!q && (diag p in "unclosed block comment") as none)
       (p = &q^2)
    :  ((p@ == '\n') || isws p@) ? (p = &p^1)
    :  (is09 p@ || ((p@ == '.') && is09 p^1))
    ?  (&p^1 for q ( isid q@ && &q^1 )) is q
       (j.s = ntoken TK_NUM p q in)
       (j.s.loc is p
  10 is a
  (  (!strncmp p "0x" 2 && is0f p^2)
  && (p = &p^2)
     (a = 16)
  as none )
   strtoul p &p a is v
   ( (startswith p "b"  ) ? (p = &p^1)            nbit :
                                                  nnat ) is t
   (j.s.l = v as N )   
   (j.s.t = t as @none   )   
   1b)
       (j = j.s)
       (p = q)
    :  (p@ == '"')
    ?  (j.s = string_literal in p p)
       (j = j.s)
       (p = &p^j.n)
    :  (p@ == '\p')
    ?  (j.s = byte_literal in p)
       (j = j.s)
       (j.l = j.l as C as N)
       (p = &p^j.n)
    :  0 is n
       (p for q ((isid q@ && &q^1) || cast S 0 ret (n = q - p as N)) as none)
       !!n
    ?  (j.s = ntoken TK_ID p &p^n in)
       (j = j.s)
       (p = &p^j.n)
    :  read_punct p is n
       !!n
    ?  (j.s = ntoken TK_PCT p &p^n in)
       (j = j.s)
       (p = &p^j.n)
    :  (diag p in "invalid token")) as none )  )
   j.s is j2
   1 is n
  ( in.contents for p
    (  !!p@
    && !!j2
    && &p^1 ret
       (j2 = (p == j2.loc) ? (j2.line_no = n)    j2.s : j2)
       (n = n + ((p@ == '\n') ? 1 : 0)) )
  as none )
   j.s )

push_scope  (k K c S    ) @Scope
= (cast @Scope calloc 1 sizeof Scope is s s ret (s.c = c)    (s.s = k.s)    (k.s = s))

search_scope(k K c S n N) @Scope
= (cast @Scope 0 is r (!!k.s && k.s for s ((n != strlen s.c )|| !!strncmp s.c c n) ? s.s : (r = s)    cast @Scope 0 as none)    r)

type o_kst (k K s S t T) O;

nvar o_kst =
(  cast O calloc 1 sizeof Obj is o
   (o.name = s) 
   (o.t = t) 
   ((push_scope k s).o = o) 
   o )

nlvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   (o.s = k.locals)
   (k.locals = o)
   o )

ngvar o_kst =
(  nvar k s t is o
   (o.s = k.globals)
   (o.is_definition = 1b)
   (k.globals = o)
   o )

nstr o_kst =
(  cast S 0 is s2
   cast N 0 is n
   open_memstream &s2 &n is y
   (fprintf y ".L.%ld" k.n)
   fclose y
   (k.n = k.n + 1)
   ngvar k s2 t is o (o.init_data = s)
   o )

expect_type(j J t T u T) none =
(  !!t
&& !type_equal t u
&& (jdiag j "expected %s but found %s" format_type t format_type u) as none )

get_ident(j J) S =
(  ((!!j && (j.q != TK_ID)) && (jdiag j "expected an nonymousifier") as none)
   strndup j.loc cast N j.n )

find_type(k K c S n N) T =
(  (!!k.j && (k.j.q != TK_ID)) ? nnull
:  search_scope k c n is s
   (!!s && s.t) )

jadv   (k K    ) J    = (k.j ret (k.j = k.j.s))
jeq    (k K c S) bit  = (!!k.j && (!memcmp cast @none k.j.loc cast @none c cast N k.j.n && !c^k.j.n))
expect (k K c S) none = ((!jeq k c && (jdiag k.j "expected '%s'" c) as none)    (k.j = k.j.s))
consume(k K c S) bit  = (jeq k c is r r ret (r && (k.j = k.j.s) as none) )

type tk   (k K        ) T;
type tke  (k K e E    ) T;
type tkt  (k K t T    ) T;
type tktn (k K t T n N) T;
type tkst (k K s S t T) T;

enumerators_a tktn =
( (  1b for _
    (  !consume k ";"
    && get_ident k.j is c
       jadv k
       push_scope k c is s
       (s.t = t)
       (s.v = n)
       (n = n + 1) )
  as none )
   t )

enumerators    tkt = enumerators_a k t 0
enum_specifier tk  = enumerators k ntype TY_ENUM 1 1

declarator tk =
(  jadv k is j
   copy_type type_suffix k is t t
ret (t.name = j) )

struct_decl tk =
(  struct_of is t
   expect k "{"
   (k.t = t)
   new Type is head
   &head is cur
  (  1b for _ 
    (  !consume k "}"
    && (calloc 1 sizeof Type as T) is g
       (g@ = declarator k)
       (cur.s = g)
       (cur = cur.s) )
  as none )
   (t.a = head.s)
   (k.t = 0 as T)
   (t.q = TY_STRUCT)
   (t.size < 0) ? t
:  0 is bits
  (  !!t.a && t.a for g g.s
  ret (bits = align_to bits (g.align * 8))
     (g.offset = bits / 8)
     (bits = bits + g.size * 8)
     ((t.align < g.align) && (t.align = g.align) as none)
  as none)
   (t.size = align_to bits (t.align * 8) / 8)
   t )

type_specifier_a tkst = (consume k s && t)

type_specifier tk =
(  consume k "none"   ? nnone
:  consume k "bit"    ? nbit
:  consume k "byte"   ? nbyte
:  consume k "nat"    ? nnat
:  consume k "struct" ? struct_decl      k
:  consume k "enum"   ? enum_specifier   k
:  consume k "typeof" ? (p3 k nnull).t
:  consume k "same"   ? k.t
: (  (find_type k k.j.loc cast N k.j.n
  && cast none jadv k)
  || nnone ret (jdiag k.j "invalid type specifier") ) )

func_params tk =
(  new Type is head
   0b is is_variadic
   &head is cur
   (1b for _ (!jeq k ")" && !(consume k "..."
?  (is_variadic = 1b)
   1b
:  (cur.s = declarator k)
   (cur = cur.s)
   0b))
as none)
   jadv k
   func_of type_suffix k is t
   (t.params = head.s)
   (t.is_variadic = is_variadic)
   t )

array_dimensions tk = array_of type_suffix k (p1 k nnat).l

type_suffix tk =
(  consume k "@" ? nptr     type_suffix k
:  consume k "^" ? array_dimensions       k
:  consume k "(" ? func_params            k
:  type_specifier k )

nnode (j J t T q NodeKind            ) E = (cast E calloc 1 sizeof Node is e e ret (e.j = j)  (e.t = t)  (e.q = q))
n0ary (j J t T q NodeKind            ) E = (nnode j t q)
n1ary (j J t T q NodeKind a E        ) E = (nnode j t q is e e ret (e.a   = a))
n2ary (j J t T q NodeKind a E b E    ) E = (nnode j t q is e e ret (e.a   = a)  (e.a.s = b))
n3ary (j J t T q NodeKind a E b E c E) E = (nnode j t q is e e ret (e.a   = a)  (e.a.s = b)  (e.a.s.s = c))
ntary (j J t T q NodeKind u T        ) E = (n0ary j t q is e e ret (e.t.s = u))
noary (j J t T q NodeKind o O        ) E = (n0ary j t q is e e ret (e.o   = o))
nlary (j J t T q NodeKind l N        ) E = (n0ary j t q is e e ret (e.l   = l))

type njtu  (j J t T u T        ) E;
type njtua (j J t T u T a E    ) E;
type njta  (j J t T     a E    ) E;
type njtab (j J t T     a E b E) E;

nsizeof     njtu  = ntary j nnat     ESIZE  u
nnew        njtu  = ntary j u        ENEW   u
nthe        njtua = n1ary j a.t      ETHE   a
ncast       njtua = n1ary j u        ECAST  a
ncall       njta  = n1ary j a.t.a    ECALL  a
nneg        njta  = n1ary j nnat     ENEG   a
naddressof  njta  = n1ary j nptr a.t EADDR  a
nlognot     njta  = n1ary j nbit     ENOT   a
nbitnot     njta  = n1ary j nnat     EBNOT  a
nderef      njta  = n1ary j a.t.a    EDEREF a
nassign     njtab = n2ary j nnone    EASS   a b
npbor       njtab = n2ary j nnat     EBOR   a b
nbitxor     njtab = n2ary j nnat     EBXOR  a b
npband      njtab = n2ary j nnat     EBAND  a b
neq         njtab = n2ary j nbit     EEQ    a b
nneq        njtab = n2ary j nbit     ENE    a b
ngt         njtab = n2ary j nbit     EGT    a b
nlt         njtab = n2ary j nbit     ELT    a b
nge         njtab = n2ary j nbit     EGE    a b
nle         njtab = n2ary j nbit     ELE    a b
nshl        njtab = n2ary j nnat     ESHL   a b
nshr        njtab = n2ary j nnat     ESHR   a b
nmul        njtab = n2ary j nnat     EMUL   a b
ndiv        njtab = n2ary j nnat     EDIV   a b
nmod        njtab = n2ary j nnat     EMOD   a b
nthen       njtab = n2ary j a.t      ETHEN  a b
nneth       njtab = n2ary j b.t      ESEQ   a b
nlogor      njtab = n2ary j a.t      ELOR   a b
npland      njtab = n2ary j b.t      ELAND  a b
nsubscript  njtab = n2ary j a.t.a    EELEM  a b
nadd        njtab = n2ary j nnat     EADD   a b
nsub        njtab = n2ary j nnat     ESUB   a b

/* oddballs */

nreference  (j J t T                 o O ) E = (noary j o.t EVAR     o)
nlit        (j J t T u T             l N ) E = (nlary j u   ELIT     l)
nlet        (j J t T         a E b E o O ) E = (n2ary j b.t EIS    a b is e e ret (e.o = o))
nrepeat     (j J t T         a E b E o O ) E = (n2ary j b.t EFOR a b is e e ret (e.o = o))
nconditional(j J t T         a E b E c E ) E = (n3ary j b.t ECOND   a b c)

earr ekta =
(  jadv k is j
   p3 k nnat is b
   nsubscript j t a b )

get_struct_member(t T j J) T =
(  nnull is r
  (  t.a for g
     ((g.name.n == j.n) && !strncmp g.name.loc j.loc j.n)
  ?  (r = g)
     nnull
  :  g.s
  as none )
   r )

esize  ekt  = (jadv k is j type_suffix k is u                                                        nsizeof      j   t   u)
eaddr  ekt  = (jadv k is j                                                  p2 k t       is a naddressof   j   t     a)
ethe   ekt  = (jadv k is j type_suffix k is u                                p3 k t       is a nthe         j   t   u a)
ecast  ekt  = (jadv k is j type_suffix k is u                                p3 k t       is a ncast        j   t   u a)
eneg   ekt  = (jadv k is j                                                   p3 k t       is a nneg         j   t     a)
elnot  ekt  = (jadv k is j                                                   p3 k t       is a nlognot      j   t     a)
ebnot  ekt  = (jadv k is j                                                   p3 k t       is a nbitnot      j   t     a)
enew   ekt  = (jadv k is j type_suffix k is u nlvar k "" u is o                                   nnode        k.j nnone EZ is b (b.o = o)    nneth k.j t b nreference k.j t o)
eas    ekta = (jadv k is j type_suffix k is u                                                        ncast        j   t   u a ret (t = u))
efrom  ekta = (jadv k is j type_suffix k is u                                                        nthe         j   t   u a ret (t = u))
ederef ekta = (jadv k is j                                                                           nderef       j a.t.a   a)
ethen  ekta = (jadv k is j                                                        pseq k nnone is b nthen        j a.t     a b)
econd  ekta = (jadv k is j                                                        pseq k t       is b
                                                              expect k ":"    pseq k t       is c nconditional j   t     a b c)
eis    ekta = (jadv k is j k.s is s nlvar k get_ident jadv k a.t is o       pseq k t       is b nlet         j   t     a b   o ret (k.s = s))
efor   ekta = (jadv k is j k.s is s nlvar k get_ident jadv k a.t is o       pseq k t       is b nrepeat      j   t     a b   o ret (k.s = s))
eass   ekta = (jadv k is j                                                      p4 k a.t     is b nassign      j   t     a b)



emul  ekta = (jadv k is j nmul   j t a pseq  k a.t  )
ediv  ekta = (jadv k is j ndiv   j t a pseq  k a.t  )
emod  ekta = (jadv k is j nmod   j t a pseq  k a.t  )
eadd  ekta = (jadv k is j nadd   j t a pmul  k a.t  )
esub  ekta = (jadv k is j nsub   j t a pmul  k a.t  )
eshl  ekta = (jadv k is j nshl   j t a padd  k a.t  )
eshr  ekta = (jadv k is j nshr   j t a padd  k a.t  )
elt   ekta = (jadv k is j nlt    j t a psh   k nnull)
egt   ekta = (jadv k is j ngt    j t a psh   k nnull)
ele   ekta = (jadv k is j nle    j t a psh   k nnull)
ege   ekta = (jadv k is j nge    j t a psh   k nnull)
eeq   ekta = (jadv k is j neq    j t a psh   k nnull)
ene   ekta = (jadv k is j nneq   j t a psh   k nnull)
eband ekta = (jadv k is j npband j t a pcmp  k a.t  )
ebor  ekta = (jadv k is j npbor  j t a pband k a.t  )
eland ekta = (jadv k is j npland j t a pseq  k a.t  )
elor  ekta = (jadv k is j nlogor j t a pseq  k a.t  )

emem  ekta =
(  cast none jadv k
   jadv k is j
   (a.t for t ((t.q == TY_PTR) && t.a)) is t
   ((t.q != TY_STRUCT) && (jdiag j "%s is not a struct" format_type t) as none)
   get_struct_member t j is g
  (  !g
  &&(  jdiag j "(%s . %.*s) no such member" format_type t j.s.n j.s.loc ) as none )
   n1ary j g EMEM a )

es ekta =
(  (  jeq k ")"
   || jeq k ":"
   || jeq k "?"
   || jeq k "*"
   || jeq k "/"
   || jeq k "%"
   || jeq k "+"
   || jeq k "-"
   || jeq k "<<"
   || jeq k ">>"
   || jeq k "<"
   || jeq k ">"
   || jeq k "<="
   || jeq k ">="
   || jeq k "=="
   || jeq k "!="
   || jeq k "|"
   || jeq k "&&"
   || jeq k "||"
   || jeq k "="
   || jeq k "as"
   || jeq k "from" )
?  a
:  k.j is j
   pseq k t is b
   nneth j b.t a b )

ec ekta =
(  (a.t.q == TY_FUNC)
  && a.t.params is u
    (  a for b
      (  (!!u || a.t.is_variadic && ! jeq k ")")
      && (b.s = p3 k u)
         (  !!u 
         && (!type_equal b.s.t u && (jdiag k.j "asymmetric argument from %s to %s" format_type b.s.t format_type u) as none)
            (u = u.s)
         as none)
         b.s )
    as none )
     ncall k.j t a )

el(k K t T     c S e@ ekt ) E = (jeq k c && e@ k t  )
er(k K t T a E c S e@ ekta) E = (jeq k c && e@ k t a)

p1 ekt =
( jeq k "new" ? enew k t :
  consume k "(" ? p5 k t ret expect k ")" :
  (!!k.j && (k.j.q == TK_ID)) ?
    search_scope k k.j.loc k.j.n is s
    jadv k  
    (!!s ? !!s.o ? nreference k.j t s.o : nlit k.j t s.t cast N s.v :
    (jdiag k.j "lookup failed")    cast E 0) :
  (!!k.j && (k.j.q == TK_STR)) ?
    cast T k.j.t is u
    nstr k k.j.str u is o
    ncast k.j t nptr u.a nthe k.j u o.t nreference k.j u o ret
    cast none jadv k :
  (!!k.j && (k.j.q == TK_NUM)) ?
    ( nlit k.j t cast T k.j.t k.j.l ret cast none jadv k ) :
  (jdiag k.j "expected an expression")    cast E 0)

p2    ekt = (                      el k t   "cast"    &ecast  ||
                                   el k t   "the"     &ethe   ||
                                   el k t   "&"       &eaddr  ||
                                   el k t   "sizeof"  &esize  ||
             p1    k t     for a ( er k t a "^"       &earr   ||
                                   er k t a "."       &emem   ||
                                   er k t a "@"       &ederef    ) )
p3    ekt = (                      el k t   "-"       &eneg   ||
                                   el k t   "!"       &elnot  ||
                                   el k t   "~"       &ebnot  ||
             p2    k nnull for a   ec k t a                      )
pseq  ekt = (p3    k nnull  is a ( er k t a "ret"     &ethen  ||
                                   er k t a "is"      &eis    ||
                                   er k t a "for"     &efor   ||
                                   er k t a "&&"      &eland  ||
                                   er k t a "||"      &elor   ||
                                   er k t a "?"       &econd  ||
                                   es k t a                      ) )
pmul  ekt = (pseq  k t     for a ( er k t a "*"       &emul   ||
                                   er k t a "/"       &ediv   ||
                                   er k t a "%"       &emod      ) )
padd  ekt = (pmul  k t     for a ( er k t a "+"       &eadd   ||
                                   er k t a "-"       &esub      ) )
psh   ekt = (padd  k t     for a ( er k t a "<<"      &eshl   ||
                                   er k t a ">>"      &eshr      ) )
pcmp  ekt = (psh   k nnull for a ( er k t a "<"       &elt    ||
                                   er k t a ">"       &egt    ||
                                   er k t a "<="      &ele    ||
                                   er k t a ">="      &elt    ||
                                   er k t a "=="      &eeq    ||
                                   er k t a "!="      &ene       ) )
pband ekt = (pcmp  k t     for a   er k t a "&"       &eband     )
pbor  ekt = (pband k t     for a   er k t a "|"       &ebor      )
pcast ekta= (                      er k t a "as"      &eas    ||
                                   er k t a "from"    &efrom     )
p4    ekt = (pbor  k t     for a   pcast k t a                   )
p5    ekt = (p4    k nnull for a ( er k t a "="       &eass   ||
                                   pcast k t a                   ) )

typedecl(k K) J =
(  k.j for j
  (  !consume k ";"
  &&(  declarator k is t
       ((push_scope k get_ident t.name).t = t)
       k.j ) ) )

create_lvars(k K t T) none =
(  !!t
&& create_lvars k t.s
   (nlvar k get_ident t.name t as none)
as none )

fiEfunc(k K c S n N) O =
(  search_scope k c n is s
   (!!s && !!s.o && (s.o.t.q == TY_FUNC) && s.o) )

function(k K v @VarAttr) none =
(  declarator k is t
  fiEfunc k t.name.loc cast N t.name.n is o
  (  !!o
  ?  ((o.t.q != TY_FUNC)             && (jdiag k.j "redeclared as a different q of symbol") as none)
     (o.is_definition && jeq k "=" && (jdiag k.j "redefinition of %s" o.name) as none)
     ((o.is_export != v.is_export )  && (jdiag k.j "mismatched visibility") as none)
     (o.is_definition = o.is_definition || jeq k "=")
  :  (o = ngvar k get_ident t.name t)
     (o.is_definition = jeq k "=")
     (o.is_export = v.is_export) )
  (  !consume k ";"
  && (k.locals = cast O 0)
     k.s is s
     create_lvars k t.params
     (o.params = k.locals)
     (t.is_variadic && (o.va_area = nlvar k "__va_area__" array_of nbyte 136) as none)
     expect k "="
     (o.body = p3 k t.a as @none)
     (o.locals = k.locals)
     (k.s = s) ) )

parse(j J) O =
(  new Ctx is k
   (k.j        = j            )
   (k.locals   = cast O   0)
   (k.globals  = cast O   0)
   (k.s        = cast @Scope 0)
   (k.t        = cast T  0)
   k.s is s
  (  !!k.j && k.j for j
    (  !!j
    && new VarAttr is v
       (1b for i
  (  (consume &k "type"    && 1b ret (v.is_type   = 1b))
  || (consume &k "export"  && 1b ret (v.is_export = 1b)) )
as none)
       v.is_type
    ?  typedecl &k
    :  function &k &v
       k.j)
  as none)
   (k.s = s)
   k.globals )

argreg1(d N) S =
(  (d == 0) ? "%dil" :
   (d == 1) ? "%sil" :
   (d == 2) ? "%dl"  :
   (d == 3) ? "%cl"  :
   (d == 4) ? "%r8b" :
              "%r9b" )

argreg8(d N) S =
( (d == 0) ? "di" :
  (d == 1) ? "si" :
  (d == 2) ? "dx" :
  (d == 3) ? "cx" :
  (d == 4) ? "8"  :
             "9"  )

gln(y Y fmt S ...) none =
(  vfprintf y fmt cast @va_list __va_area__
   (cast none fprintf y "\n") )

gbin (y Y s S) none = (gln y "  %s  %%rdi, %%rax" s)
gzero(y Y s S) none = (gln y "  xor %%e%s, %%e%s" s s)
glit (y Y l N) none = (!!l ? (gln y "  mov $%ld , %%rax" l) : gzero y "ax")
gcmpz(y Y    ) none = (gln y "  test %%rax, %%rax"  )
gnot (y Y    ) none = (gln y "  not %%eax"         )
gneg (y Y    ) none = (gln y "  neg %%rax"         )
gmul (y Y    ) none = (gln y "  mul %%rdi"         )
gdiv (y Y    ) none = ( gzero y "dx"
                        (gln y "  div %%rdi"         ) )
gmod (y Y    ) none = ( gdiv y
                        (gln y "  mov %%rdx, %%rax") )
gshx (y Y x C) none = ( (gln y "  mov %%dil, %%cl"   )
                        (gln y "  sh%c %%cl, %%rax" x) )

gadd (y Y    ) none = (gbin y "add")
gsub (y Y    ) none = (gbin y "sub")
gand (y Y    ) none = (gbin y "and")
gor  (y Y    ) none = (gbin y "or ")
gxor (y Y    ) none = (gbin y "xor")
gcmp (y Y    ) none = (gbin y "cmp")
gshr (y Y    ) none = (gshx y 'r')
gshl (y Y    ) none = (gshx y 'l')

gpromote(y Y) none = (gln y "  movzbl %%al , %%eax")

gsetf     (y Y         s S) none = ((gln y "  set%s  %%al" s) gpromote y)
gcmp_setf (y Y         s S) none = (gcmp  y gsetf y s)
gcmpz_setf(y Y         s S) none = (gcmpz y gsetf y s)
gj        (y Y e E l S    ) none = (gln y "  jmp %s%ld$"   l e)
gjc       (y Y e E l S s S) none = (gln y "  j%s %s%ld$" s l e)
glabel    (y Y e E l S    ) none = (gln y "%s%ld$:"        l e)

gje  (y Y e E l S) none = gjc y e l "e "
gjne (y Y e E l S) none = gjc y e l "ne"
gjb  (y Y e E l S) none = gjc y e l "b "
gjbe (y Y e E l S) none = gjc y e l "be"
gja  (y Y e E l S) none = gjc y e l "a "
gjae (y Y e E l S) none = gjc y e l "ae"

ge  (y Y) none = gcmp_setf y "e "
gne (y Y) none = gcmp_setf y "ne"
gb  (y Y) none = gcmp_setf y "b "
gbe (y Y) none = gcmp_setf y "be"
ga  (y Y) none = gcmp_setf y "a "
gae (y Y) none = gcmp_setf y "ae"

gcast(y Y a T b T) none =
(  (b.q == TY_VOID) ?  gzero    y "ax"
:  (b.q == TY_BYTE) && gpromote y)

gfpush(y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gln y "  sub $%ld, %%rsp" l1) (c@ = c@ + l1))
gfpop (y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gln y "  add $%ld, %%rsp" l1) (c@ = c@ - l1))
gpush (y Y c @N      ) none = ((gln y "  push %%rax")    (c@ = c@ + 8))
gpop  (y Y c @N  s S ) none = ((gln y "  pop %%r%s" s  )    (c@ = c@ - 8))
gindex(y Y       l N ) none = (!!l && (gln y "  add $%ld, %%rax" l))

gload(y Y t T) none =
(  (t.q == TY_ARRAY)
|| (t.q == TY_STRUCT)
|| (t.q == TY_FUNC)
|| (t.size == 1)
?  (gln y "  movzbl (%%rax), %%eax")
:  (gln y "  mov    (%%rax), %%rax")
as none )

gstore(y Y t T c @N) none =
(  gpop y c "di"
   ((t.q == TY_STRUCT) || (t.q == TY_ARRAY)) ? (0 for i ((i < t.size) && (i + 1)
ret (gln y "  mov %ld(%%rax), %%r8b    " i)
    (gln y "  mov %%r8b    , %ld(%%rdi)" i)) as none)
:  (t.size == 1) ? (gln y "  mov %%al , (%%rdi)")
:                  (gln y "  mov %%rax, (%%rdi)") )

gvar_local (y Y e E c @N s S) none = ((gln y "  lea %ld(%%rsp), %%r%s" (e.o.offset + c@) s))
gvar_global(y Y e E c @N s S) none = (gln y "  mov %s@GOTPCREL(%%rip), %%r%s" e.o.name   s)
gvar       (y Y e E c @N s S) none = (e.o.is_local ? &gvar_local : &gvar_global)@ y e c s

push_args2(y Y e E c @N d N) none =
(  !!e
&&(  (d < 6)
  && push_args2 y e.s c (d + 1) )
   cast none /*gmuster*/ grval y e c
   gpush y c
as none )

type gexpr    (y Y e E c @N            ) nat;
type gexprexpr(y Y e E c @N            ) @gexpr;
type gexprcat (y Y e E c @N gcat @gexpr) nat;

gdrop (y Y e E c @N gcat @gexpr) none = cast none gcat@ y e c
geval (y Y e E c @N gcat @gexpr) none = cast none gcat@ y e c

gltor gexprcat = (
  (1 + glval y e   c)
  gload y e.t
  0
)

gelit   gexprcat = (glit  y e.l          0)
gesize  gexprcat = (glit  y e.t.s.size   0)
geref   gexprcat = (gvar  y e   c "ax"   0)
gderef  gexprcat = (geval y e.a c &grval 0)
geaddr  gexprcat = glval y e.a c
gethe   gexprcat = gcat@ y e.a c

geelem  gexprcat = (
  geval y e.a   c &grval
  gpush y       c
  geval y e.a.s c &grval
  gpop  y       c "dx"
  (gln y "  lea (%%rdx, %%rax, %ld), %%rax" e.a.t.a.size)
  0
)

gemem   gexprcat = (
  geval y e.a c &grval
  ( e.a.t for t
    ( (t.q == TY_PTR) &&
      t.a ret
      gload y t.a
    as none )
  as none )
  gindex y e.t.offset
  0
)

geseq gexprcat = (
  gdrop y e.a   c &grval
  gcat@ y e.a.s c
)

geret gexprcat = (
  gcat@ y e.a   c ret
  gpush y       c
  gdrop y e.a.s c &grval
  gpop  y       c "ax"
)

gecond gexprcat = (
  geval  y e.a     c &grval
  gcmpz  y
  gje    y e         "a"
  geval  y e.a.s   c gcat
  gj     y e         "b"
  glabel y e         "a"
  geval  y e.a.s.s c gcat
  glabel y e         "b"
  0
)

geland  gexprcat = (
  (e.a.s.t.q == TY_VOID) is keep
  geval y e.a c &grval
  gcmpz y
  gje   y e         "a"
  ( keep &&
    gpush y       c      )
  geval y e.a.s c &grval
  ( keep &&
    gpop  y       c "ax" )
  glabel y e        "a"
  0
)

gelor gexprcat = (
  (e.a.s.t.q == TY_VOID) is keep
  geval   y e.a   c &grval
  gcmpz   y
  gjne    y e       "a"
  ( keep &&
    gpush y       c      )
  geval   y e.a.s c &grval
  ( keep &&
    gpop  y       c "ax" )
  glabel  y e       "a"
  0
)

geneg   gexprcat = (
  geval y e.a c &grval
  gneg  y
  0
)

gecast  gexprcat =  (
  geval y e.a c &grval
  gcast y e.a.t e.t
  0
)

gelnot  gexprcat =  (
  geval      y e.a c &grval
  gcmpz_setf y       "e"
  0
)

gebnot  gexprcat =  (
  geval y e.a c &grval
  gnot  y
  0
)

geass   gexprcat = (
  geval  y e.a   c &glval
  gpush  y       c
  geval  y e.a.s c &grval
  gstore y e.a.t c
  gzero  y         "ax"
  0
)

gelet   gexprcat = (
  gvar   y e     c "ax"
  gpush  y       c
  geval  y e.a   c &grval
  gstore y e.a.t c
  gcat@  y e.a.s c
)

gefor   gexprcat = (
  gvar   y e     c "ax"
  gpush  y       c
  geval  y e.a   c &grval
  glabel y e       "a"
  gstore y e.a.t c
  gvar   y e     c "ax"
  gpush  y       c
  geval  y e.a.s c &grval
  gcmpz  y
  gjne   y e       "a"
  gpop   y       c "ax"
  gload  y e.a.t
  0
)

gecall gexprcat = (
  0 is stack
  0 is d
  ( ( (c@ + stack) % 16 != 0) &&
    gfpush y c 1
    (stack = stack + 8)
  as none )
  push_args2  y e.a.s c 0
  geval y e.a   c &grval
  0 is d
  (!!e.a.s && e.a.s for e e.s ret ((d < 6) && gpop y c argreg8 d ret (d = d + 1)) as none)
  (gln y "  call *%%rax")
  gfpop y c (stack >> 3)
  0
)

gez gexprcat = (
  (gln y "  mov $%ld, %%rcx" e.o.t.size)
  gvar y e c "di"
  (gln y "  mov $0, %%al")
  (gln y "  rep stosb")
  0
)

ge2arya (y Y e E c @N) @(y Y) none = (
  (e.q == EDIV ) ? &gdiv :
  (e.q == EMOD ) ? &gmod :
  (e.q == EEQ  ) ? &ge   :
  (e.q == ENE  ) ? &gne  :
  (e.q == ELT  ) ? &gb   :
  (e.q == ELE  ) ? &gbe  :
  (e.q == EGT  ) ? &ga   :
  (e.q == EGE  ) ? &gae  :
  (e.q == EADD ) ? &gadd :
  (e.q == ESUB ) ? &gsub :
  (e.q == EMUL ) ? &gmul :
  (e.q == EBAND) ? &gand :
  (e.q == EBOR ) ? &gor  :
  (e.q == EBXOR) ? &gxor :
  (e.q == ESHL ) ? &gshl :
                   &gshr
)

ge2ary  gexprcat = (
  geval    y e.a.s c &grval
  gpush    y       c
  geval    y e.a   c &grval
  gpop     y       c "di"
  (ge2arya y e     c       )
  @        y
  0
)

glval(y Y e E c @N) nat = (
  e.q     is q
  &glval  is g

  (q == EELEM  ) ? geelem y e c g :
  (q == EMEM   ) ? gemem  y e c g :
  (q == EDEREF ) ? gderef y e c g :
  (q == EVAR   ) ? geref  y e c g :

  (q == ESEQ   ) ? geseq  y e c g :
  (q == ETHEN  ) ? geret  y e c g :
  (q == ETHE   ) ? gethe  y e c g :
  (q == ECOND  ) ? gecond y e c g :

  (jdiag e.j "not an lvalue")
)

grval(y Y e E c @N) nat = (
  e.q     is q
  &grval  is g

  (q == EVAR  ) ? gltor  y e c g :
  (q == EMEM  ) ? gltor  y e c g :
  (q == EELEM ) ? gltor  y e c g :
  (q == EDEREF) ? gltor  y e c g :
  (q == ELIT  ) ? gelit  y e c g :
  (q == ESIZE ) ? gesize y e c g :
  (q == ECALL ) ? gecall y e c g :

  (q == ESEQ  ) ? geseq  y e c g :
  (q == ETHEN ) ? geret  y e c g :
  (q == ETHE  ) ? gethe  y e c g :
  (q == ECOND ) ? gecond y e c g :
  (q == EADDR ) ? geaddr y e c g :
  (q == ELAND ) ? geland y e c g :
  (q == ELOR  ) ? gelor  y e c g :
  (q == ENEG  ) ? geneg  y e c g :
  (q == ECAST ) ? gecast y e c g :
  (q == ENOT  ) ? gelnot y e c g :
  (q == EBNOT ) ? gebnot y e c g :
  (q == EASS  ) ? geass  y e c g :
  (q == EIS   ) ? gelet  y e c g :
  (q == EFOR  ) ? gefor  y e c g :
  (q == EZ    ) ? gez    y e c g :

                  ge2ary y e c g
)

gdata(y Y o O) none = (
  (gln y "  .data"                             )
  (gln y "  .type %s, @object" o.name          )
  (gln y "  .size %s, %ld"     o.name o.t.size )
  (gln y "  .align %ld"               o.t.align)
  (gln y "%s:" o.name                          )
  ( 0 for i (i < o.t.size) && (i + 1) ret
    (gln y "  .byte %ld" o.init_data^i)
  as none )
)

gstoreva(y Y o O c N) none = (
  0 is d
  (!!o.params && o.params for o o.s ret (d = d + 8))
  (gln y "  movl $%ld , 24(%%rsp)" d       )
  (gln y "  movq %%rsp, 32(%%rsp)"         )
  (gln y "  addq $%ld , 32(%%rsp)" (c + 16))
  (gln y "  movq %%rsp, 40(%%rsp)"         )
  (gln y "  addq $48  , 40(%%rsp)"         )
  (gln y "  movq %%rdi, 48(%%rsp)"         )
  (gln y "  movq %%rsi, 56(%%rsp)"         )
  (gln y "  movq %%rdx, 64(%%rsp)"         )
  (gln y "  movq %%rcx, 72(%%rsp)"         )
  (gln y "  movq %%r8 , 80(%%rsp)"         )
  (gln y "  movq %%r9 , 88(%%rsp)"         )
)

gtext(y Y o O) none =
( (  !!o.params
  && 16 is t
      0 is g
     o.params for o o.s
  ret (!((g ret (g = g + 1)) < 6)
  && (t        = align_to t 8)
     (o.offset = t           )
     (t        = t + o.t.size) ) )
   0 is bottom
  (  !!o.locals
  && o.locals for o o.s
  ret(  !o.offset
    && (bottom = bottom + o.t.size)
       (bottom = align_to bottom o.t.align)
       (o.offset = -bottom)
    as none )
  as none )
  (bottom = align_to bottom 16) /* abi says bottom of frame is aligned to 16 */
  (gln y "  .text")
  (gln y "  .type %s, @function" o.name)
  (gln y "%s:" o.name)
  (gln y "  enter $%ld, $0" bottom)
  bottom is c
  ( o.t.is_variadic && gstoreva y o c)
  (  0 is d
     o.params for o
    (  !!o
    && o.s
    ret(  (o.offset > (-1 >> 1))
      && o.t is t
         ((t.size == 1)
      ?  (gln y "  mov %s   , %ld(%%rsp)" argreg1 d (o.offset + c))
      :  (gln y "  mov %%r%s, %ld(%%rsp)" argreg8 d (o.offset + c)))
      ret (d = d + 1)
      as none ) )
  as none )
  gdrop y cast E o.body &c &grval
  (gln y "  leave")
  (gln y "  ret")
)

gsym(y Y o O) none = (
  !!o.is_definition &&
  (gln y "  .%s %s" (!o.is_export ? "local" : "globl" ) o.name)
  ((o.t.q == TY_FUNC) ? &gtext : &gdata)@ y o
)

codegen(o O y Y in S) none = (
  (gln y "  .file 0 \q%s\q" in)
  !!o &&
  o for o
  o.s ret gsym y o
)

export main(argc N argv @S) N =
(  open_file argv^2 "w" is y
   (!y ? 1 : 0 ret codegen parse tokenize argv^1 y argv^1)
ret cast none fclose y )