type
  va_list struct {}
  FILE    struct {}
;

export __errno_location    ( ) @nat ;

export open_memstream      (p    @@byte n    @nat) @FILE ;
export fopen               (path  @byte mode @ byte ) @FILE ;

export fclose              (io @FILE) nat ;
export fflush              (io @FILE) nat ;

export fread               (ptr @none m nat n nat io @FILE) nat ;
export fwrite              (ptr @none m nat n nat io @FILE) nat ;
export fputc               (c nat io @FILE) nat ;

export printf              (         fmt @byte ...          ) nat ;
export vprintf             (         fmt @byte args @va_list) nat ;
export fprintf             (io @FILE fmt @byte ...          ) nat ;
export vfprintf            (io @FILE fmt @byte args @va_list) nat ;

export exit                (status nat) none ;

export calloc              (m nat  n nat) @none ;
export free                (p @none) none ;

export memcmp              (p @none q @none n nat) nat ;

export strtoul             (p @byte q @@byte  b  nat) nat ;
export strcat              (p @byte q  @byte        ) @byte  ;
export strstr              (p @byte q  @byte        ) @byte  ;
export strcmp              (p @byte q  @byte        )  nat ;
export strncmp             (p @byte q  @byte  n nat)  nat ;
export strncasecmp         (p @byte q  @byte  n nat)  nat ;
export strndup             (p @byte         n nat) @byte  ;
export strlen              (p @byte               ) nat ;

export strerror            (errnum  nat) @byte ;

/* end preamble */

type
  NodeKind enum
    ND_ADD       ND_SUB     ND_MUL     ND_DIV       ND_THE
    ND_NEG       ND_MOD     ND_BITAND  ND_BITOR     ND_BITXOR
    ND_SHL       ND_SHR     ND_EQ      ND_NE        ND_LT
    ND_LE        ND_GT      ND_GE      ND_ASSIGN    ND_COND
    ND_COMMA     ND_MEMBER  ND_ADDR    ND_DEREF     ND_NOT
    ND_BITNOT    ND_LOGAND  ND_LOGOR   ND_THEN      ND_FUNCALL
    ND_LET       ND_VAR     ND_LIT     ND_CAST      ND_MEMZERO
    ND_REPEAT    ND_SIZE    ND_ALIGN   ND_ELEM      ND_NEW
  ;

  TypeKind enum
    TY_VOID    TY_BOOL    TY_BYTE
    TY_INT     TY_FUNC    TY_ARRAY
    TY_ENUM    TY_STRUCT  TY_PTR
    TY_NAT
  ;

  TokenKind enum
    TK_ID  TK_PCT
    TK_KEY TK_STR TK_NUM
  ;

  File struct {
    name         @byte
    contents     @byte
  }

  Token struct {
    q           TokenKind
    s          @same
    l           nat
    loc        @byte
    n          nat
    t          @none
    str        @byte
    in         @File
    line_no     nat
  }

  Type struct  {
    q          TypeKind
    size          nat
    align         nat
    offset        nat
    n             nat
    s            @same
    o            @same
    a            @same
    params       @same
    name         @Token
    is_variadic   bit
  }

  Obj struct {
    s               @same
    name            @byte
    t               @Type
    j               @Token
    offset           nat
    is_local         bit
    is_definition    bit
    is_export        bit
    init_data       @byte
    params          @same
    body            @none
    locals          @same
    va_area         @same
  }

  Node struct {
    s @same
    a @same
    q  NodeKind
    j @Token
    t @Type
    o @Obj
    l  nat
  }

  Scope struct {
    s @same
    c @byte
    o @Obj
    t @Type
    v  nat
  }

  VarAttr struct {
    is_type    bit
    is_export  bit
  }

  Ctx struct {
    j @Token
    locals         @Obj
    globals        @Obj
    s @Scope
    t @Type
    n  nat
  }

  J @Token
  O @Obj
  K @Ctx
  E @Node
  T @Type
  N nat
  C byte
  S @byte
;

type cis  (c C        ) bit;
type ekt  (k K t T    ) E;
type ekta (k K t T a E) E;

issp cis = (' '  == c)
istb cis = ('\t' == c)
islf cis = ('\n' == c)
iscr cis = ('\r' == c)
is_  cis = ('_'  == c)

isin(c C a C b C) bit =
((a <= c) && (c <= b))

isAZ cis = isin c 'A' 'Z'
isaz cis = isin c 'a' 'z'
is09 cis = isin c '0' '9'
isaf cis = isin c 'a' 'f'

isws cis =
(  issp c
|| istb c
|| islf c
|| iscr c )
is0f cis =
(  is09 c
|| isaf c )
isid cis =
(  isAZ c
|| isaz c
|| is09 c
|| is_  c )


read_ident(p S) N =
(  0 is r
   cast none (p for q ((isid q@ && &q^1) || '\0' ret (r = q - p as N)))
   r )

startswith(p S q S) bit =
(  1b is r
  cast none (  1b for _
    (  !q@
    ?  0b
    :  (p@ != q@)
    ?  (r = 0b)
       0b
    :  (p = &p^1)
       (q = &q^1)
       1b ) )
   r )

read_punct(p S) N =
(  &startswith is f
  (  f@ p "..." ) ? 3 :
  (  f@ p "=="
  || f@ p "!="
  || f@ p "<="
  || f@ p ">="
  || f@ p "&&"
  || f@ p "||"
  || f@ p "<<"
  || f@ p ">>" ) ? 2 :
  (  f@ p "=" 
  || f@ p "<"
  || f@ p ">"
  || f@ p "+"
  || f@ p "-"
  || f@ p "*"
  || f@ p "/"
  || f@ p "&"
  || f@ p "|"
  || f@ p "@"
  || f@ p "#"
  || f@ p "{"
  || f@ p "}"
  || f@ p "("
  || f@ p ")"
  || f@ p "["
  || f@ p "]"
  || f@ p "!"
  || f@ p "?"
  || f@ p ":"
  || f@ p ";"
  || f@ p ","
  || f@ p "."
  || f@ p "~"
  || f@ p "^"
  || f@ p "$"
  || f@ p "`"
  || f@ p "%" ) ? 1 : 0 )


p1    ekt ;
p2    ekt ;
p3    ekt ;
pseq  ekt ;
pmul  ekt ;
padd  ekt ;
psh   ekt ;
pcmp  ekt ;
pband ekt ;
pbor  ekt ;
pland ekt ;
plor  ekt ;
p4    ekt ;

type_suffix(k K) T ;

grval(out @FILE e E c @N) nat;

maxl (a N b N) N = ((a > b) ? a : b)
minl (a N b N) N = ((a < b) ? a : b)
maxul(a N b N) N = ((a > b) ? a : b)
minul(a N b N) N = ((a < b) ? a : b)

align_to(n N a N) N = ((n + a - 1) / a * a)

vdiag(in S c S line_n N p S fmt S args @va_list) none =
(  (p for q ((c < q) && (q^-1 != '\n') && &q^-1)) is line
   (p for q (!!q@  && (q@ != '\n') && &q^1)) is end
   (printf "./%s:(%ld,%ld): " in line_n (cast N (p - line) + 1)) is indent
   (cast none printf "%.*s\n%*s^ " (end - line) line ((p - line as N) + indent) "")
    cast none vprintf fmt args
   (cast none printf "\n") )

diag(p S in @File fmt S ...) none =
(  1 is line_no
   (in.contents for p (&p^1 ret ((p@ == '\n') && (line_no = line_no + 1) as none)) as none)
   vdiag in.name in.contents line_no p fmt cast @va_list __va_area__
   exit 1 )

jdiag(j J fmt S ...) none =
(  vdiag j.in.name j.in.contents j.line_no j.loc fmt cast @va_list __va_area__
   exit 1 )

ntype(q TypeKind size N align N) T =
(  cast T calloc 1 sizeof Type is t t
ret (t.q     = q    )
ret (t.size  = size )
ret (t.align = align) )

format_type_b(q1 TypeKind q2 TypeKind s1 S s2 S) bit =
((q1 == q2) && strcat s1 s2)

format_type_a(t T s S) none =
(  &strcat        is f
   &format_type_a is a
   &format_type_b is b
   t.q            is q
   !t ? strcat              s "null"
: (  b@ q TY_VOID           s "none"
  || b@ q TY_BOOL           s "bit"
  || b@ q TY_BYTE           s "byte"
  || b@ q TY_NAT            s "nat"
  || b@ q TY_ENUM           s "enum"
  || b@ q TY_STRUCT         s "struct"
  || ( q == TY_ARRAY ) ? f@ s "^"      ret a@ t.a s :
     ( q == TY_PTR   ) ? f@ s "@"      ret a@ t.a s :
     ( q == TY_FUNC  ) ? f@ s "("      ret
              (t.a.s for p (!!p && p.s ret a@ p   s ) as none)   
                         f@ s ")"      ret a@ t.a s :
                         f@ s "???"

  as none ) )

format_type(t T) S =
(  cast S calloc 1 1 is s s
ret format_type_a t s )

type_equal(t T u T) bit =
(  !!t
&& !!u
&& t.q is c
  (  (t == u)
  ||(
      !!t.o ? type_equal t.o u
    : !!u.o ? type_equal t u.o
    : (  (c == u.q)
      &&(  (c == TY_VOID)
        || (c == TY_BOOL)
        || (c == TY_BYTE)
        || (c == TY_INT)
        || (c == TY_NAT)
        || (c == TY_FUNC)
          ?  !type_equal t.a u.a
          ?  0b
          :  u.a.s is p
             t.a.s is q (1b for _ (!!p && !!q && type_equal p q && (p = p.s)    (q = q.s) ) as none)
             (p == q)
          :  (c == TY_ARRAY)
          ?  !type_equal t.a u.a
          ?  0b
          :  (t.n == u.n)
          :  (c == TY_PTR)
          ?  type_equal t.a u.a
          :  0b ) ) ) ) )

nnull () T = cast T 0
nnone () T = ntype TY_VOID 1 1
nbit  () T = ntype TY_BOOL 1 1
nbyte () T = ntype TY_BYTE 1 1
nnat  () T = ntype TY_NAT  8 8

copy_type(t T) T =
(  cast T calloc 1 sizeof Type is u u
ret (u@ = t@)
   (u.o = t) )

ptr_of   (a T    ) T = (ntype TY_PTR    8            8       is t t ret (t.a = a)             )
func_of  (a T    ) T = (ntype TY_FUNC   1            1       is t t ret (t.a = a)             )
array_of (a T n N) T = (ntype TY_ARRAY  (a.size * n) a.align is t t ret (t.a = a)    (t.n = n))
struct_of(       ) T =  ntype TY_STRUCT 0            1

ntoken(q TokenKind a S b S in @File) J =
(  cast J calloc 1 sizeof Token is j j
ret (j.q   = q    )
   (j.loc = a    )
   (j.n   = b - a)
   (j.in  = in   ) )

escape_one(c C ca C cb C) C =
((c == ca) && cb)

escape(c S in @File) C =
(  &escape_one is f
  (  f@ c@ 'a' '\a'
  || f@ c@ 'b' '\b'
  || f@ c@ 'f' '\f'
  || f@ c@ 'n' '\n'
  || f@ c@ 'r' '\r'
  || f@ c@ 't' '\t'
  || f@ c@ 'v' '\v'
  || f@ c@ 'p' '\p'
  || f@ c@ 'q' '\q'
  || f@ c@ 's' '\s'
  || '\0'
  ret ((c@ != '0') && (diag c in "invalid escape sequence") as none) ) )

string_literal(in @File start S quote S) J =
( (  &quote^1 for q
    (  (q@ != '"')
    && &q^1
    ret ((q@ == '\0') && (diag quote in "unclosed string literal") as none) ) )
is end
   cast S calloc 1 (end - quote as N) is buf
   0 is n
  (  &quote^1 for p
    (  (p < end)
    && (p@ == '\s')
    ? (  buf^(n ret (n = n + 1)) = (p = &p^1)
         escape p in
      ret (p = &p^1) )
       p
    :  (buf^(n ret (n = n + 1)) = p@)
       &p^1 )
  as none )
   ntoken TK_STR start &end^1 in is j
   (j.t = array_of nbyte cast nat (n + 1))
   (j.str = buf)
   j )

byte_literal(in @File p S) J =
(  &p^1 is q
   ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
  (  (q@ == '\s')
  ?  (q = &q^1)
     ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
     escape q in
  :  q@ )
is c
   (q = &q^1)
   ((q@ != '\p') && (diag p in "unclosed literal byte") as none)
   ntoken TK_NUM p &q^1 in is j
   (j.l = c as N)
   (j.t = cast @none nbyte)
   j )

open_file(path S mode S) @FILE =
(fopen path mode || cast none (printf "cannot open file '%s' with mode '%s': %s" mode path strerror (__errno_location)@))

read_file(path S) S =
(  cast S calloc 1 4096 is rfbuf2
   open_file path "r" is fp
   cast S 0 is buf
   0 is buflen
   &buflen is b
   open_memstream &buf b is out
   (1b for k
    sizeof typeof rfbuf2 is m
    fread cast @none rfbuf2 1 m fp is n
    ((n == 0) ? (k = 0b) : cast none fwrite cast @none rfbuf2 1 n out)
       k as none)
   free cast @none rfbuf2
   (fclose fp as none)
   fflush out
   (((buflen == 0) || (buf^(buflen - 1) != '\n')) && fputc cast N '\n' out as none)
   fputc 0 out
   fclose out
   buf )

tokenize(path S) J =
(  read_file path is p
   !p
?  cast J 0
:  cast @File calloc 1 sizeof File is in
   (in.name = path)
   (in.contents = p)
   new Token is j
   (in.contents is p &j is j
   (1b for _ (p@ &&
    startswith p "/*"
    ?  strstr &p^2 "*/" is q
       (!q && (diag p in "unclosed block comment") as none)
       (p = &q^2)
    :  ((p@ == '\n') || isws p@) ? (p = &p^1)
    :  (is09 p@ || ((p@ == '.') && is09 p^1))
    ?  (&p^1 for q ( isid q@ && &q^1 )) is q
       (j.s = ntoken TK_NUM p q in)
       (j.s.loc is p
  10 is a
  (  (!strncasecmp p "0x" 2 && is0f p^2)
  && (p = &p^2)
     (a = 16)
  as none )
   strtoul p &p a is v
   ( (startswith p "b"  ) ? (p = &p^1)            nbit :
                                                  nnat ) is t
   (j.s.l = v as N )   
   (j.s.t = t as @none   )   
   1b)
       (j = j.s)
       (p = q)
    :  (p@ == '"')
    ?  (j.s = string_literal in p p)
       (j = j.s)
       (p = &p^j.n)
    :  (p@ == '\p')
    ?  (j.s = byte_literal in p)
       (j = j.s)
       (j.l = j.l as C as N)
       (p = &p^j.n)
    :  0 is n
       (p for q ((isid q@ && &q^1) || cast S 0 ret (n = q - p as N)) as none)
       !!n
    ?  (j.s = ntoken TK_ID p &p^n in)
       (j = j.s)
       (p = &p^j.n)
    :  read_punct p is n
       !!n
    ?  (j.s = ntoken TK_PCT p &p^n in)
       (j = j.s)
       (p = &p^j.n)
    :  (diag p in "invalid token")) as none )  )
   j.s is j2
   1 is n
  ( in.contents for p
    (  !!p@
    && !!j2
    && &p^1 ret
       (j2 = (p == j2.loc) ? (j2.line_no = n)    j2.s : j2)
       (n = n + ((p@ == '\n') ? 1 : 0)) )
  as none )
   j.s )

push_scope  (k K c S    ) @Scope
= (cast @Scope calloc 1 sizeof Scope is s s ret (s.c = c)    (s.s = k.s)    (k.s = s))

search_scope(k K c S n N) @Scope
= (cast @Scope 0 is r (!!k.s && k.s for s ((n != strlen s.c )|| !!strncmp s.c c n) ? s.s : (r = s)    cast @Scope 0 as none)    r)

type o_kst (k K s S t T) O;

nvar o_kst =
(  cast O calloc 1 sizeof Obj is o
   (o.name = s) 
   (o.t = t) 
   ((push_scope k s).o = o) 
   o )

nlvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   (o.s = k.locals)
   (k.locals = o)
   o )

ngvar o_kst =
(  nvar k s t is o
   (o.s = k.globals)
   (o.is_definition = 1b)
   (k.globals = o)
   o )

nstr o_kst =
(  cast S 0 is s2
   cast N 0 is n
   open_memstream &s2 &n is out
   (fprintf out ".L..%ld" k.n)
   fclose out
   (k.n = k.n + 1)
   ngvar k s2 t is o (o.init_data = s)
   o )

expect_type(j J t T u T) none =
(  !!t
&& !type_equal t u
&& (jdiag j "expected %s but found %s" format_type t format_type u) as none )

get_ident(j J) S =
(  ((!!j && (j.q != TK_ID)) && (jdiag j "expected an nonymousifier") as none)
   strndup j.loc cast N j.n )

find_type(k K c S n N) T =
(  (!!k.j && (k.j.q != TK_ID)) ? nnull
:  search_scope k c n is s
   (!!s && s.t) )

jadv   (k K    ) J    = (k.j ret (k.j = k.j.s))
jeq    (k K c S) bit  = (!!k.j && (!memcmp cast @none k.j.loc cast @none c cast N k.j.n && !c^k.j.n))
expect (k K c S) none = ((!jeq k c && (jdiag k.j "expected '%s'" c) as none)    (k.j = k.j.s))
consume(k K c S) bit  = (jeq k c is r r ret (r && (k.j = k.j.s) as none) )

type tk   (k K        ) T;
type tke  (k K e E    ) T;
type tkt  (k K t T    ) T;
type tktn (k K t T n N) T;
type tkst (k K s S t T) T;

enumerators_a tktn =
( (  1b for _
    (  !consume k ";"
    && get_ident k.j is c
       jadv k
       push_scope k c is s
       (s.t = t)
       (s.v = n)
       (n = n + 1) )
  as none )
   t )

enumerators    tkt = enumerators_a k t 0
enum_specifier tk  = enumerators k ntype TY_ENUM 1 1

declarator tk =
(  jadv k is j
   copy_type type_suffix k is t t
ret (t.name = j) )

struct_decl tk =
(  struct_of is t
   expect k "{"
   (k.t = t)
   new Type is head
   &head is cur
  (  1b for _ 
    (  !consume k "}"
    && (calloc 1 sizeof Type as T) is g
       (g@ = declarator k)
       (cur.s = g)
       (cur = cur.s) )
  as none )
   (t.a = head.s)
   (k.t = 0 as T)
   (t.q = TY_STRUCT)
   (t.size < 0) ? t
:  0 is bits
  (  !!t.a && t.a for g g.s
  ret (bits = align_to bits (g.align * 8))
     (g.offset = bits / 8)
     (bits = bits + g.size * 8)
     ((t.align < g.align) && (t.align = g.align) as none)
  as none)
   (t.size = align_to bits (t.align * 8) / 8)
   t )

type_specifier_a tkst = (consume k s && t)

type_specifier tk =
(  consume k "none"   ? nnone
:  consume k "bit"    ? nbit
:  consume k "byte"   ? nbyte
:  consume k "nat"   ? nnat
:  consume k "struct" ? struct_decl      k
:  consume k "enum"   ? enum_specifier   k
:  consume k "typeof" ? (p3 k nnull).t
:  consume k "same"   ? k.t
: (  (find_type k k.j.loc cast N k.j.n
  && cast none jadv k)
  || nnone ret (jdiag k.j "invalid type specifier") ) )

func_params tk =
(  new Type is head
   0b is is_variadic
   &head is cur
   (1b for _ (!jeq k ")" && !(consume k "..."
?  (is_variadic = 1b)
   1b
:  (cur.s = declarator k)
   (cur = cur.s)
   0b))
as none)
   jadv k
   func_of type_suffix k is t
   (t.params = head.s)
   (t.is_variadic = is_variadic)
   t )

array_dimensions tk = array_of type_suffix k (p1 k nnat).l

type_suffix tk =
(  consume k "@" ? ptr_of     type_suffix k
:  consume k "^" ? array_dimensions       k
:  consume k "(" ? func_params            k
:  type_specifier k )

nnode (j J t T q NodeKind            ) E = (cast E calloc 1 sizeof Node is e e ret (e.j = j)  (e.t = t)  (e.q = q))
n0ary (j J t T q NodeKind            ) E = (nnode j t q)
n1ary (j J t T q NodeKind a E        ) E = (nnode j t q is e e ret (e.a   = a))
n2ary (j J t T q NodeKind a E b E    ) E = (nnode j t q is e e ret (e.a   = a)  (e.a.s = b))
n3ary (j J t T q NodeKind a E b E c E) E = (nnode j t q is e e ret (e.a   = a)  (e.a.s = b)  (e.a.s.s = c))
ntary (j J t T q NodeKind u T        ) E = (n0ary j t q is e e ret (e.t.s = u))
noary (j J t T q NodeKind o O        ) E = (n0ary j t q is e e ret (e.o   = o))
nlary (j J t T q NodeKind l N        ) E = (n0ary j t q is e e ret (e.l   = l))

type njtu  (j J t T u T        ) E;
type njtua (j J t T u T a E    ) E;
type njta  (j J t T     a E    ) E;
type njtab (j J t T     a E b E) E;

nsizeof     njtu  = ntary j nnat  ND_SIZE    u
nalignof    njtu  = ntary j nnat  ND_ALIGN   u
nnew        njtu  = ntary j         u     ND_NEW     u
nthe        njtua = n1ary j         a.t   ND_THE     a
ncast       njtua = (n1ary j        u     ND_CAST    a )
ncall       njta  = n1ary j         a.t.a ND_FUNCALL a
nneg        njta  = n1ary j         nnat  ND_NEG     a
naddressof  njta  = n1ary j ptr_of  a.t   ND_ADDR    a
nlognot     njta  = n1ary j         nbit  ND_NOT     a
nbitnot     njta  = n1ary j         nnat  ND_BITNOT  a
nderef      njta  = n1ary j         a.t.a ND_DEREF   a
nassign     njtab = n2ary j         nnone ND_ASSIGN  a b
npbor       njtab = n2ary j         nnat  ND_BITOR   a b
nbitxor     njtab = n2ary j         nnat  ND_BITXOR  a b
npband      njtab = n2ary j         nnat  ND_BITAND  a b
neq         njtab = n2ary j         nbit  ND_EQ      a b
nneq        njtab = n2ary j         nbit  ND_NE      a b
ngt         njtab = n2ary j         nbit  ND_GT      a b
nlt         njtab = n2ary j         nbit  ND_LT      a b
nge         njtab = n2ary j         nbit  ND_GE      a b
nle         njtab = n2ary j         nbit  ND_LE      a b
nshl        njtab = n2ary j         nnat  ND_SHL     a b
nshr        njtab = n2ary j         nnat  ND_SHR     a b
nmul        njtab = n2ary j         nnat  ND_MUL     a b
ndiv        njtab = n2ary j         nnat  ND_DIV     a b
nmod        njtab = n2ary j         nnat  ND_MOD     a b
nthen       njtab = n2ary j         a.t   ND_THEN    a b
nneth       njtab = n2ary j         b.t   ND_COMMA   a b
nlogor      njtab = n2ary j         a.t   ND_LOGOR   a b
npland      njtab = n2ary j         b.t   ND_LOGAND  a b
nsubscript  njtab = n2ary j         a.t.a ND_ELEM    a b
nadd        njtab = n2ary j         nnat  ND_ADD     a b
nsub        njtab = n2ary j         nnat  ND_SUB     a b

/* oddballs */

nreference  (j J t T                 o O ) E = (noary j o.t ND_VAR     o)
nlit        (j J t T u T             l N ) E = (nlary j u   ND_LIT     l)
nlet        (j J t T         a E b E o O ) E = (n2ary j b.t ND_LET    a b is e e ret (e.o = o))
nrepeat     (j J t T         a E b E o O ) E = (n2ary j b.t ND_REPEAT a b is e e ret (e.o = o))
nconditional(j J t T         a E b E c E ) E = (n3ary j b.t ND_COND   a b c)

earr ekta =
(  jadv k is j
   p3 k nnat is b
   nsubscript j t a b )

get_struct_member(t T j J) T =
(  nnull is r
  (  t.a for g
     ((g.name.n == j.n) && !strncmp g.name.loc j.loc j.n)
  ?  (r = g)
     nnull
  :  g.s
  as none )
   r )

esize  ekt  = (jadv k is j type_suffix k is u                                                        nsizeof      j   t   u)
ealign ekt  = (jadv k is j type_suffix k is u                                                        nalignof     j   t   u)
eaddr  ekt  = (jadv k is j                                                  p2 k t       is a naddressof   j   t     a)
ethe   ekt  = (jadv k is j type_suffix k is u                                p3 k t       is a nthe         j   t   u a)
ecast  ekt  = (jadv k is j type_suffix k is u                                p3 k t       is a ncast        j   t   u a)
eneg   ekt  = (jadv k is j                                                   p3 k t       is a nneg         j   t     a)
elnot  ekt  = (jadv k is j                                                   p3 k t       is a nlognot      j   t     a)
ebnot  ekt  = (jadv k is j                                                   p3 k t       is a nbitnot      j   t     a)
enew   ekt  = (jadv k is j type_suffix k is u nlvar k "" u is o                                   nnode        k.j nnone ND_MEMZERO is b (b.o = o)    nneth k.j t b nreference k.j t o)
eas    ekta = (jadv k is j type_suffix k is u                                                        ncast        j   t   u a ret (t = u))
efrom  ekta = (jadv k is j type_suffix k is u                                                        nthe         j   t   u a ret (t = u))
ederef ekta = (jadv k is j                                                                           nderef       j a.t.a   a)
ethen  ekta = (jadv k is j                                                        pseq k nnone is b nthen        j a.t     a b)
econd  ekta = (jadv k is j                                                        pseq k t       is b
                                                              expect k ":"    pseq k t       is c nconditional j   t     a b c)
eis    ekta = (jadv k is j k.s is s nlvar k get_ident jadv k a.t is o       pseq k t       is b nlet         j   t     a b   o ret (k.s = s))
efor   ekta = (jadv k is j k.s is s nlvar k get_ident jadv k a.t is o       pseq k t       is b nrepeat      j   t     a b   o ret (k.s = s))
eass   ekta = (jadv k is j                                                      p4 k a.t     is b nassign      j   t     a b)



emul  ekta = (jadv k is j nmul   j t a pseq  k a.t  )
ediv  ekta = (jadv k is j ndiv   j t a pseq  k a.t  )
emod  ekta = (jadv k is j nmod   j t a pseq  k a.t  )
eadd  ekta = (jadv k is j nadd   j t a pmul  k a.t  )
esub  ekta = (jadv k is j nsub   j t a pmul  k a.t  )
eshl  ekta = (jadv k is j nshl   j t a padd  k a.t  )
eshr  ekta = (jadv k is j nshr   j t a padd  k a.t  )
elt   ekta = (jadv k is j nlt    j t a psh   k nnull)
egt   ekta = (jadv k is j ngt    j t a psh   k nnull)
ele   ekta = (jadv k is j nle    j t a psh   k nnull)
ege   ekta = (jadv k is j nge    j t a psh   k nnull)
eeq   ekta = (jadv k is j neq    j t a psh   k nnull)
ene   ekta = (jadv k is j nneq   j t a psh   k nnull)
eband ekta = (jadv k is j npband j t a pcmp  k a.t  )
ebor  ekta = (jadv k is j npbor  j t a pband k a.t  )
eland ekta = (jadv k is j npland j t a pseq  k a.t  )
elor  ekta = (jadv k is j nlogor j t a pseq  k a.t  )

emem  ekta =
(  cast none jadv k
   jadv k is j
   (a.t for t ((t.q == TY_PTR) && t.a)) is t
   ((t.q != TY_STRUCT) && (jdiag j "%s is not a struct" format_type t) as none)
   get_struct_member t j is g
  (  !g
  &&(  jdiag j "(%s . %.*s) no such member" format_type t j.s.n j.s.loc ) as none )
   n1ary j g ND_MEMBER a )

es ekta =
(  (  jeq k ")"
   || jeq k ":"
   || jeq k "?"
   || jeq k "*"
   || jeq k "/"
   || jeq k "%"
   || jeq k "+"
   || jeq k "-"
   || jeq k "<<"
   || jeq k ">>"
   || jeq k "<"
   || jeq k ">"
   || jeq k "<="
   || jeq k ">="
   || jeq k "=="
   || jeq k "!="
   || jeq k "|"
   || jeq k "&&"
   || jeq k "||"
   || jeq k "="
   || jeq k "as"
   || jeq k "from" )
?  a
:  k.j is j
   pseq k t is b
   nneth j b.t a b )

ec ekta =
(  (a.t.q == TY_FUNC)
  && a.t.params is u
    (  a for b
      (  (!!u || a.t.is_variadic && ! jeq k ")")
      && (b.s = p3 k u)
         (  !!u 
         && (!type_equal b.s.t u && (jdiag k.j "asymmetric argument from %s to %s" format_type b.s.t format_type u) as none)
            (u = u.s)
         as none)
         b.s )
    as none )
     ncall k.j t a )

el(k K t T     c S e@ ekt ) E = (jeq k c && e@ k t  )
er(k K t T a E c S e@ ekta) E = (jeq k c && e@ k t a)

p1 ekt =
( jeq k "new" ? enew k t :
  consume k "(" ? p4 k t ret expect k ")" :
  (!!k.j && (k.j.q == TK_ID)) ?
    search_scope k k.j.loc k.j.n is s
    jadv k  
    (!!s ? !!s.o ? nreference k.j t s.o : nlit k.j t s.t cast N s.v :
    (jdiag k.j "lookup failed")    cast E 0) :
  (!!k.j && (k.j.q == TK_STR)) ?
    cast T k.j.t is u
    nstr k k.j.str u is o
    ncast k.j t ptr_of u.a nthe k.j u o.t nreference k.j u o ret
    cast none jadv k :
  (!!k.j && (k.j.q == TK_NUM)) ?
    ( nlit k.j t cast T k.j.t k.j.l ret cast none jadv k ) :
  (jdiag k.j "expected an expression")    cast E 0)

p2    ekt = (                      el k t   "cast"    &ecast  ||
                                   el k t   "the"     &ethe   ||
                                   el k t   "&"       &eaddr  ||
                                   el k t   "sizeof"  &esize  ||
                                   el k t   "alignof" &ealign ||
             p1    k t     for a ( er k t a "^"       &earr   ||
                                   er k t a "."       &emem   ||
                                   er k t a "@"       &ederef    ) )
p3    ekt = (                      el k t   "-"       &eneg   ||
                                   el k t   "!"       &elnot  ||
                                   el k t   "~"       &ebnot  ||
             p2    k nnull for a   ec k t a                      )
pseq  ekt = (p3    k nnull  is a ( er k t a "ret"     &ethen  ||
                                   er k t a "is"      &eis    ||
                                   er k t a "for"     &efor   ||
                                   er k t a "&&"      &eland  ||
                                   er k t a "||"      &elor   ||
                                   er k t a "?"       &econd  ||
                                   es k t a                      ) )
pmul  ekt = (pseq  k t     for a ( er k t a "*"       &emul   ||
                                   er k t a "/"       &ediv   ||
                                   er k t a "%"       &emod      ) )
padd  ekt = (pmul  k t     for a ( er k t a "+"       &eadd   ||
                                   er k t a "-"       &esub      ) )
psh   ekt = (padd  k t     for a ( er k t a "<<"      &eshl   ||
                                   er k t a ">>"      &eshr      ) )
pcmp  ekt = (psh   k nnull for a ( er k t a "<"       &elt    ||
                                   er k t a ">"       &egt    ||
                                   er k t a "<="      &ele    ||
                                   er k t a ">="      &elt    ||
                                   er k t a "=="      &eeq    ||
                                   er k t a "!="      &ene       ) )
pband ekt = (pcmp  k t     for a   er k t a "&"       &eband )
pbor  ekt = (pband k t     for a   er k t a "|"       &ebor )
p4    ekt = (pbor  k nnull for a ( er k t a "="       &eass   ||
                                   er k t a "as"      &eas    ||
                                   er k t a "from"    &efrom     ) )

typedecl(k K) J =
(  k.j for j
  (  !consume k ";"
  &&(  declarator k is t
       ((push_scope k get_ident t.name).t = t)
       k.j ) ) )

create_lvars(k K t T) none =
(  !!t
&& create_lvars k t.s
   (nlvar k get_ident t.name t as none)
as none )

find_func(k K c S n N) O =
(  search_scope k c n is s
   (!!s && !!s.o && (s.o.t.q == TY_FUNC) && s.o) )

function(k K v @VarAttr) none =
(  declarator k is t
  find_func k t.name.loc cast N t.name.n is o
  (  !!o
  ?  ((o.t.q != TY_FUNC)             && (jdiag k.j "redeclared as a different q of symbol") as none)
     (o.is_definition && jeq k "=" && (jdiag k.j "redefinition of %s" o.name) as none)
     ((o.is_export != v.is_export )  && (jdiag k.j "mismatched visibility") as none)
     (o.is_definition = o.is_definition || jeq k "=")
  :  (o = ngvar k get_ident t.name t)
     (o.is_definition = jeq k "=")
     (o.is_export = v.is_export) )
  (  !consume k ";"
  && (k.locals = cast O 0)
     k.s is s
     create_lvars k t.params
     (o.params = k.locals)
     (t.is_variadic && (o.va_area = nlvar k "__va_area__" array_of nbyte 136) as none)
     expect k "="
     (o.body = p3 k t.a as @none)
     (o.locals = k.locals)
     (k.s = s) ) )

parse(j J) O =
(  new Ctx is k
   (k.j        = j            )
   (k.locals   = cast O   0)
   (k.globals  = cast O   0)
   (k.s        = cast @Scope 0)
   (k.t        = cast T  0)
   k.s is s
  (  !!k.j && k.j for j
    (  !!j
    && new VarAttr is v
       (1b for i
  (  (consume &k "type"    && 1b ret (v.is_type   = 1b))
  || (consume &k "export"  && 1b ret (v.is_export = 1b)) )
as none)
       v.is_type
    ?  typedecl &k
    :  function &k &v
       k.j)
  as none)
   (k.s = s)
   k.globals )

argreg1(d N) S =
(  (d == 0) ? "%dil" :
   (d == 1) ? "%sil" :
   (d == 2) ? "%dl"  :
   (d == 3) ? "%cl"  :
   (d == 4) ? "%r8b" :
              "%r9b" )

argreg8(d N) S =
( (d == 0) ? "di" :
  (d == 1) ? "si" :
  (d == 2) ? "dx" :
  (d == 3) ? "cx" :
  (d == 4) ? "8"  :
             "9"  )

gln(out @FILE fmt S ...) none =
(  vfprintf out fmt cast @va_list __va_area__
   (cast none fprintf out "\n") )

gbin (out @FILE s S) none = (gln out "  %s  %%rdi, %%rax" s)
gzero(out @FILE r C) none = (gln out "  xor %%e%cx, %%e%cx" r r)
glit (out @FILE l N) none = (!!l ? (gln out "  mov $%ld , %%rax" l) : gzero out 'a')
gcmpz(out @FILE    ) none = (gln out "  test %%rax, %%rax"  )
gnot (out @FILE    ) none = (gln out "  not %%eax"         )
gneg (out @FILE    ) none = (gln out "  neg %%rax"         )
gadd (out @FILE    ) none = (gbin out "add")
gsub (out @FILE    ) none = (gbin out "sub")
gand (out @FILE    ) none = (gbin out "and")
gor  (out @FILE    ) none = (gbin out "or ")
gxor (out @FILE    ) none = (gbin out "xor")
gcmp (out @FILE    ) none = (gbin out "cmp")
gshx (out @FILE x C) none = ( (gln out "  mov %%dil, %%cl"   )
                                 (gln out "  sh%c %%cl, %%rax" x) )
gshr (out @FILE    ) none = (gshx out 'r')
gshl (out @FILE    ) none = (gshx out 'l')
gmul (out @FILE    ) none = (gln out "  mul %%rdi"         )
gdiv (out @FILE    ) none = ( gzero out 'd'
                                 (gln out "  div %%rdi"         ) )
gmod (out @FILE    ) none = ( gdiv out
                                 (gln out "  mov %%rdx, %%rax") )

gpromote(out @FILE) none = (gln out "  movzbl %%al , %%eax")

gsetf     (out @FILE         s S) none = ((gln out "  set%s  %%al" s) gpromote out)
gcmp_setf (out @FILE         s S) none = (gcmp  out gsetf out s)
gcmpz_setf(out @FILE         s S) none = (gcmpz out gsetf out s)
gj        (out @FILE e E l S    ) none = (gln out "  jmp .L.%s.%ld"   l e)
gjc       (out @FILE e E l S s S) none = (gln out "  j%s .L.%s.%ld" s l e)

gje  (out @FILE e E l S) none = gjc out e l "e "
gjne (out @FILE e E l S) none = gjc out e l "ne"
gjb  (out @FILE e E l S) none = gjc out e l "b "
gjbe (out @FILE e E l S) none = gjc out e l "be"
gja  (out @FILE e E l S) none = gjc out e l "a "
gjae (out @FILE e E l S) none = gjc out e l "ae"

ge  (out @FILE) none = gcmp_setf out "e "
gne (out @FILE) none = gcmp_setf out "ne"
gb  (out @FILE) none = gcmp_setf out "b "
gbe (out @FILE) none = gcmp_setf out "be"
ga  (out @FILE) none = gcmp_setf out "a "
gae (out @FILE) none = gcmp_setf out "ae"

gcast(out @FILE a T b T) none =
(  (b.q == TY_VOID) ?  gzero    out 'a'
:  (b.q == TY_BYTE) && gpromote out)

gfpush(out @FILE c @N  l N ) none = (!!l && (gln out "  sub $%ld, %%rsp" (8 * l))    (c@ = c@ + l))
gfpop (out @FILE c @N  l N ) none = (!!l && (gln out "  add $%ld, %%rsp" (8 * l))    (c@ = c@ - l))
gpush (out @FILE c @N      ) none = ((gln out "  push %%rax")    (c@ = c@ + 1))
gpop  (out @FILE c @N  s S ) none = ((gln out "  pop %%r%s" s  )    (c@ = c@ - 1))
gindex(out @FILE       l N ) none = (!!l && (gln out "  add $%ld, %%rax" l))
glabel(out @FILE e E   l S ) none = ((gln out ".L.%s.%ld:" l e))

gload(out @FILE t T) none =
(  (t.q == TY_ARRAY)
|| (t.q == TY_STRUCT)
|| (t.q == TY_FUNC)
|| (t.size == 1)
?  (gln out "  movzbl (%%rax), %%eax")
:  (gln out "  mov    (%%rax), %%rax")
as none )

gstore(out @FILE t T c @N) none =
(  gpop out c "di"
   ((t.q == TY_STRUCT) || (t.q == TY_ARRAY)) ? (0 for i ((i < t.size) && (i + 1)
ret (gln out "  mov %ld(%%rax), %%r8b    " i)
    (gln out "  mov %%r8b    , %ld(%%rdi)" i)) as none)
:  (t.size == 1) ? (gln out "  mov %%al , (%%rdi)")
:                  (gln out "  mov %%rax, (%%rdi)") )

gvar_local (out @FILE e E c @N s S) none = ((gln out "  lea %ld(%%rsp), %s"          (e.o.offset + 8 * c@) s))
gvar_global(out @FILE e E c @N s S) none = (gln out "  mov %s@GOTPCREL(%%rip), %s" e.o.name   s)
gvar       (out @FILE e E c @N s S) none = (e.o.is_local ? &gvar_local : &gvar_global)@ out e c s

push_args2(out @FILE e E c @N d N) none =
(  !!e
&&(  (d < 6)
  && push_args2 out e.s c (d + 1) )
   cast none /*gmuster*/ grval out e c
   gpush out c
as none )

type gexpr     (out @FILE e E c @N            ) nat;
type gexprkind (out @FILE e E c @N gcat @gexpr) nat;

gcomma gexprkind = (cast none /*gdisacrd*/ grval out e.a c                                          gcat@ out e.a.s c                    )
gthen  gexprkind = (                       gcat@ out e.a c       ret gpush out c  cast none /*gdiscard*/ grval out e.a.s c  gpop out c "ax")
gthe   gexprkind = (gcat@ out e.a c)
gcond  gexprkind = (cast none /*gmuster*/  grval out e.a c     0 ret gcmpz out gje out e "a" cast none /*gmustger*/ gcat@ out e.a.s c gj out e "b" glabel out e "a" cast none /*gmuster*/ gcat@ out e.a.s.s c glabel out e "b")

glval(out @FILE e E c @N) nat =
(  ( e.q    == ND_ELEM    ) ? cast none /*gmuster*/ grval out e.a c    gpush out c    cast none /*gmuster*/ grval out e.a.s c   0 ret (gln out "  imul $%ld, %%rax" e.a.t.a.size) gpop out c "dx"    (gln out "  add %%rdx, %%rax")
:  ( e.q    == ND_MEMBER  ) ? cast none /*gmuster*/ grval out e.a c    (e.a.t for t ((t.q == TY_PTR) && t.a ret gload out t.a as none) as none)    gindex out e.t.offset
:  ( e.q    == ND_DEREF   ) ? cast none /*gmuster*/ grval out e.a c 0
:  ( e.q    == ND_COMMA   ) ? gcomma out e c &glval
:  ( e.q    == ND_THEN    ) ? gthen  out e c &glval
:  ( e.q    == ND_THE     ) ? gthe   out e c &glval
:  ( e.q    == ND_COND    ) ? gcond  out e c &glval
:  ( e.q    == ND_VAR     ) ? gvar  out e   c "%rax"
                            :  (jdiag e.j "not an lvalue") )

grval(out @FILE e E c @N) nat =
(  (e.q == ND_LIT   )    ? glit   out e.l
:  (e.q == ND_SIZE  )    ? glit   out e.t.s.size
:  (e.q == ND_ALIGN )    ? glit   out e.t.s.align
:  (e.q == ND_COMMA )    ? gcomma out e c &grval
:  (e.q == ND_THEN  )    ? gthen  out e c &grval
:  (e.q == ND_THE   )    ? gthe   out e c &grval
:  (e.q == ND_COND  )    ? gcond  out e c &grval
:  (e.q == ND_ADDR  )    ? glval out e.a c
:  (  (e.q == ND_VAR)
   || (e.q == ND_MEMBER)
   || (e.q == ND_ELEM)
   || (e.q == ND_DEREF)  )? cast none /*gmuster*/  glval out e c 0 ret gload out e.t
:  (e.q == ND_NEG   )    ?                                             cast none /*gmuster*/  grval out e.a c     0 ret gneg       out
:  (e.q == ND_CAST  )    ?                                             cast none /*gmuster*/  grval out e.a c     0 ret gcast      out e.a.t e.t
:  (e.q == ND_NOT   )    ?                                             cast none /*gmuster*/  grval out e.a c     0 ret gcmpz_setf out "e"
:  (e.q == ND_BITNOT)    ?                                             cast none /*gmuster*/  grval out e.a c     0 ret gnot       out
:  (e.q == ND_ASSIGN)    ?                                             cast none /*gmuster*/  glval out e.a c           gpush      out c      grval  out e.a.s c    gstore out e.a.t c    gzero out 'a'
:  (e.q == ND_LET   )    ? gvar out e c "%rax"    gpush out c    cast none /*gmuster*/  grval out e.a c                                    gstore out e.a.t c    grval out e.a.s c
:  (e.q == ND_REPEAT)    ? gvar out e c "%rax"    gpush out c    cast none /*gmuster*/  grval out e.a c           glabel     out e ""   gstore out e.a.t c    gvar out e c "%rax"    gpush out c    cast none /*gmuster*/ grval out e.a.s c  0 ret   gcmpz out    (gln out "  jne .L..%ld" e)    gpop out c "ax"    gload out e.a.t
:  (e.q == ND_MEMZERO)   ? (gln out "  mov $%ld, %%rcx" e.o.t.size)    gvar out e c "%rdi"    (gln out "  mov $0, %%al")    (gln out "  rep stosb")
:  ((e.q == ND_LOGAND) || (e.q ==  ND_LOGOR))
?  cast none /*gmuster*/ grval out e.a c
   gcmpz out
   (gln out "  j%se .L..%ld" ((e.q == ND_LOGAND) ? "" : "n") e)
   ((e.a.s.t.q == TY_VOID) && gpush out c)
   cast none /*gmuster*/ 0 ret grval out e.a.s c
   ((e.a.s.t.q == TY_VOID) && gpop out c "ax")
   glabel out e ""
:  (e.q == ND_FUNCALL)
?  0 is stack
   0 is d
  (  ((c@ + stack) % 2 == 1)
  && gfpush out c 1
     (stack = stack + 1)
  as none )
   push_args2 out e.a.s c 0
   cast none /*gmuster*/ grval out e.a c
   0 is d
   (!!e.a.s && e.a.s for e e.s ret ((d < 6) && gpop out c argreg8 d ret (d = d + 1)) as none)
   (gln out "  call *%%rax")
   gfpop out c stack
:  cast none /*gmuster*/ grval out e.a.s c
   gpush out c
   cast none /*gmuster*/ grval out e.a c
   gpop out c "di"
    ( (e.q == ND_DIV    ) ? &gdiv :
      (e.q == ND_MOD    ) ? &gmod :
      (e.q == ND_EQ     ) ? &ge   :
      (e.q == ND_NE     ) ? &gne  :
      (e.q == ND_LT     ) ? &gb   :
      (e.q == ND_LE     ) ? &gbe  :
      (e.q == ND_GT     ) ? &ga   :
      (e.q == ND_GE     ) ? &gae  :
      (e.q == ND_ADD    ) ? &gadd :
      (e.q == ND_SUB    ) ? &gsub :
      (e.q == ND_MUL    ) ? &gmul :
      (e.q == ND_BITAND ) ? &gand :
      (e.q == ND_BITOR  ) ? &gor  :
      (e.q == ND_BITXOR ) ? &gxor :
      (e.q == ND_SHL    ) ? &gshl :
                            &gshr )@ out )

emit_datum_data(out @FILE o O) none =
(  (gln out "  .data")
   (gln out "  .type %s, @object" o.name)
   (gln out "  .size %s, %ld" o.name o.t.size)
   (gln out "  .align %ld" o.t.align)
   (gln out "%s:" o.name)
   0 is pos
  (  1b for _
    (  (pos < o.t.size)
    && (gln out "  .byte %ld" o.init_data^((pos ret (pos = pos + 1)))) )
  as none ) )

emit_datum_text(out @FILE o O) none =
( (  !!o.params
  && 16 is t
      0 is g
     o.params for o o.s
  ret (!((g ret (g = g + 1)) < 6)
  && (t        = align_to t 8)
     (o.offset = t           )
     (t        = t + o.t.size) ) )
   0 is bottom
  (  !!o.locals
  && o.locals for o o.s
  ret(  !o.offset
    && (bottom = bottom + o.t.size)
       (bottom = align_to bottom o.t.align)
       (o.offset = -bottom)
    as none )
  as none )
   (gln out "  .text")
   (gln out "  .type %s, @function" o.name)
   (gln out "%s:" o.name)
   (bottom = align_to bottom 16) /* abi says bottom of frame is aligned to 16 */
   (gln out "  enter $%ld, $0" bottom)
   (  o.va_area
  && 0 is d
     (!!o.params && o.params for o o.s ret (d = d + 1) as none)
     o.va_area.offset is off
     (gln out "  movl $%ld , %ld(%%rbp)" (d   *  8) (off     ))
     (gln out "  movq %%rbp, %ld(%%rbp)" (off +  8)           )
     (gln out "  addq $16  , %ld(%%rbp)" (off +  8)           )
     (gln out "  movq %%rbp, %ld(%%rbp)" (off + 16)           )
     (gln out "  addq $%ld , %ld(%%rbp)" (off + 24) (off + 16))
     (gln out "  movq %%rdi, %ld(%%rbp)" (off + 24)           )
     (gln out "  movq %%rsi, %ld(%%rbp)" (off + 32)           )
     (gln out "  movq %%rdx, %ld(%%rbp)" (off + 40)           )
     (gln out "  movq %%rcx, %ld(%%rbp)" (off + 48)           )
     (gln out "  movq %%r8 , %ld(%%rbp)" (off + 56)           )
     (gln out "  movq %%r9 , %ld(%%rbp)" (off + 64)           ) as none )
   (bottom / 8) is c
  (  0 is d
     o.params for o
    (  !!o
    && o.s
    ret(  (o.offset > (-1 >> 1))
      && o.t is t
         ((t.size == 1)
      ?  (gln out "  mov %s   , %ld(%%rsp)" argreg1 d (o.offset + 8 * c))
      :  (gln out "  mov %%r%s, %ld(%%rsp)" argreg8 d (o.offset + 8 * c)))
      ret (d = d + 1)
      as none ) )
  as none )
   cast none /*gdiscard*/ grval out cast E o.body &c
   (gln out "  leave")
   (gln out "  ret") )

emit_datum(out @FILE o O) none =
(  !!o.is_definition
&& (  !o.is_export
   ?  (gln out "  .local %s" o.name)
   :  (gln out "  .globl %s" o.name) )
   (o.t.q == TY_FUNC)
?  emit_datum_text out o
:  emit_datum_data out o )

codegen(o O out @FILE in S) none =
(  (gln out "  .file 0 \q%s\q" in)
   (!!o && o for o o.s ret emit_datum out o as none) )

export main(argc N argv @S) N =
(  open_file argv^2 "w" is out
   (!out ? 1 : 0 ret codegen parse tokenize argv^1 out argv^1)
ret cast none fclose out )