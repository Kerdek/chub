type
  va_list struct {}
  FILE    struct {}
;

export __errno_location    ( ) @nat ;

export open_memstream      (p    @@byte n    @nat) @FILE ;
export fopen               (path  @byte mode @ byte ) @FILE ;

export fclose              (io @FILE) nat ;
export fflush              (io @FILE) nat ;

export fread               (ptr @none m nat n nat io @FILE) nat ;
export fwrite              (ptr @none m nat n nat io @FILE) nat ;
export fputc               (c nat io @FILE) nat ;

export printf              (         fmt @byte ...          ) nat ;
export vprintf             (         fmt @byte args @va_list) nat ;
export fprintf             (io @FILE fmt @byte ...          ) nat ;
export vfprintf            (io @FILE fmt @byte args @va_list) nat ;

export exit                (status nat) none ;

export calloc              (m nat  n nat) @none ;
export free                (p @none) none ;

export memcmp              (p @none q @none n nat) nat ;

export strtoul             (p @byte q @@byte  b  nat) nat ;
export strcat              (p @byte q  @byte        ) @byte  ;
export strstr              (p @byte q  @byte        ) @byte  ;
export strncmp             (p @byte q  @byte  n nat)  nat ;
export strndup             (p @byte         n nat) @byte  ;
export strlen              (p @byte               ) nat ;

export strerror            (errnum  nat) @byte ;

/* end preamble */

type
  TokenKind @()none

  File struct {
    name         @byte
    contents     @byte
  }

  Token struct {
    q           TokenKind
    s          @same
    l           nat
    loc        @byte
    n          nat
    t          @none
    str        @byte
    in         @File
    line_no     nat
  }

  Type struct  {
    size          nat
    align         nat
    offset        nat
    n             nat
    s            @same
    o            @same
    a            @same
    params       @same
    name         @Token
    is_variadic   bit
    format @(t @same s @byte) none
  }

  Obj struct {
    s               @same
    name            @byte
    t               @Type
    j               @Token
    offset           nat
    is_local         bit
    is_definition    bit
    is_export        bit
    init_data       @byte
    params          @same
    body            @none
    locals          @same
    va_area         @same
    sp nat
  }

  Node struct {
    s @same
    a @same
    j @Token
    t @Type
    o @Obj
    l  nat
    gen @(y @FILE e @same c nat l nat) nat
  }

  Scope struct {
    s @same
    c @byte
    o @Obj
    t @Type
  }

  Ctx struct {
    j @Token
    locals   @Obj
    globals  @Obj
    s @Scope
    t @Type
  }

  J @Token
  O @Obj
  K @Ctx
  E @Node
  T @Type
  N nat
  C byte
  S @byte
  Y @FILE
;

JID  () none = (0)
JPCT () none = (0)
JSTR () none = (0)
JNUM () none = (0)

type cis  (c C        ) bit;

issp cis = (' '  == c)
istb cis = ('\t' == c)
islf cis = ('\n' == c)
iscr cis = ('\r' == c)
is_  cis = ('_'  == c)

isin(c C a C b C) bit =
((a <= c) && (c <= b))

isAZ cis = isin c 'A' 'Z'
isaz cis = isin c 'a' 'z'
is09 cis = isin c '0' '9'
isaf cis = isin c 'a' 'f'

isws cis =
(  issp c
|| istb c
|| islf c
|| iscr c )
is0f cis =
(  is09 c
|| isaf c )
isid cis =
(  isAZ c
|| isaz c
|| is09 c
|| is_  c )


read_ident(p S) N =
(  0 is r
   cast none (p for q ((isid q@ && &q^1) || '\0' ret (r = q - p as N)))
   r )

startswith(p S q S) bit =
(  1b is r
  cast none (  1b for _
    (  !q@
    ?  0b
    :  (p@ != q@)
    ?  (r = 0b)
       0b
    :  (p = &p^1)
       (q = &q^1)
       1b ) )
   r )

read_punct(p S) N =
(  &startswith is f
  (  f@ p "..." ) ? 3 :
  (  f@ p "=="
  || f@ p "!="
  || f@ p "<="
  || f@ p ">="
  || f@ p "&&"
  || f@ p "||"
  || f@ p "<<"
  || f@ p ">>" ) ? 2 :
  (  f@ p "=" 
  || f@ p "<"
  || f@ p ">"
  || f@ p "+"
  || f@ p "-"
  || f@ p "*"
  || f@ p "/"
  || f@ p "&"
  || f@ p "|"
  || f@ p "@"
  || f@ p "#"
  || f@ p "{"
  || f@ p "}"
  || f@ p "("
  || f@ p ")"
  || f@ p "["
  || f@ p "]"
  || f@ p "!"
  || f@ p "?"
  || f@ p ":"
  || f@ p ";"
  || f@ p ","
  || f@ p "."
  || f@ p "~"
  || f@ p "^"
  || f@ p "$"
  || f@ p "`"
  || f@ p "%" ) ? 1 : 0 )

ptype(k K) T ;

maxl (a N b N) N = ((a > b) ? a : b)
minl (a N b N) N = ((a < b) ? a : b)
maxul(a N b N) N = ((a > b) ? a : b)
minul(a N b N) N = ((a < b) ? a : b)

align_to(n N a N) N = ((n + a - 1) / a * a)

vdiag(in S c S line_n N p S fmt S args @va_list) none =
(  (p for q ((c < q) && (q^-1 != '\n') && &q^-1)) is line
   (p for q (!!q@  && (q@ != '\n') && &q^1)) is end
   (printf "./%s:(%ld,%ld): " in line_n (cast N (p - line) + 1)) is indent
   (cast none printf "%.*s\n%*s^ " (end - line) line ((p - line as N) + indent) "")
    cast none vprintf fmt args
   (cast none printf "\n") )

diag(p S in @File fmt S ...) none =
(  1 is line_no
   (in.contents for p (&p^1 ret ((p@ == '\n') && (line_no = line_no + 1) as none)) as none)
   vdiag in.name in.contents line_no p fmt cast @va_list __va_area__
   exit 1 )

jdiag(j J fmt S ...) none =
(  vdiag j.in.name j.in.contents j.line_no j.loc fmt cast @va_list __va_area__
   exit 1 )

ntype(size N align N format @(t T s S) none) T = (
  cast T calloc 1 sizeof Type is t t ret
  (t.size  = size  )
  (t.align = align )
  (t.format = format)
)

type ftfn (t T s S) none ;
type gefn (y Y e E c N l N) N;
type tk   (k K        ) T;
type tke  (k K e E    ) T;
type tkt  (k K t T    ) T;
type tktn (k K t T n N) T;
type tkst (k K s S t T) T;
type pfn  (k K t T    ) E;
type efn  (k K t T  ) E;
type efna (k K t T a E) E;

ftnone ftfn ;
ftbit  ftfn ;
ftbyte ftfn ;
ftnat  ftfn ;
ftstct ftfn ;
ftptr  ftfn ;
ftfunc ftfn ;
ftarr  ftfn ;


gelit   gefn;
gesize  gefn;
gederef gefn;
geaddr  gefn;
gethe   gefn;
gecast  gefn;
geref   gefn;
gelnot  gefn;
gebnot  gefn;
geneg   gefn;
gediv   gefn;
gemod   gefn;
gee     gefn;
gene    gefn;
geb     gefn;
gebe    gefn;
gea     gefn;
geae    gefn;
geadd   gefn;
gesub   gefn;
gemul   gefn;
geband  gefn;
gebor   gefn;
gexor   gefn;
geshl   gefn;
geshr   gefn;
geelem  gefn;
gemem   gefn;
geseq   gefn;
geret   gefn;
gecond  gefn;
geland  gefn;
gelor   gefn;
geis    gefn;
gefor   gefn;
gecall  gefn;
geass   gefn;


format_type(t T) S =
(  cast S calloc 1 1 is s s
ret t.format@ t s )

type_equal(t T u T) bit =
(  !!t
&& !!u
&& t.format is c
  (  (t == u)
  ||(
      !!t.o ? type_equal t.o u
    : !!u.o ? type_equal t u.o
    : (  (c == u.format)
      &&(  (c == &ftnone)
        || (c == &ftbit )
        || (c == &ftbyte)
        || (c == &ftnat )
        || (c == &ftfunc)
          ?  !type_equal t.a u.a
          ?  0b
          :  u.a.s is p
             t.a.s is q (1b for _ (!!p && !!q && type_equal p q && (p = p.s)    (q = q.s) ) as none)
             (p == q)
          :  (c == &ftptr)
          ?  type_equal t.a u.a
          :  0b ) ) ) ) )

nnull () T = cast T 0
nnone () T = ntype 0 0 &ftnone
nbit  () T = ntype 1 1 &ftbit 
nbyte () T = ntype 1 1 &ftbyte
nnat  () T = ntype 8 8 &ftnat 
nptr   (a T    ) T = (ntype 8            8       &ftptr is t t ret (t.a = a)             )
nfunc  (a T    ) T = (ntype 1            1       &ftfunc  is t t ret (t.a = a)             )
array_of (a T n N) T = (ntype (a.size * n) a.align &ftarr is t t ret (t.a = a)    (t.n = n))
struct_of(       ) T =  ntype 0            1       &ftstct

copy_type(t T) T =
(  cast T calloc 1 sizeof Type is u u
ret (u@ = t@)
   (u.o = t) )

ntoken(q TokenKind a S b S in @File) J =
(  cast J calloc 1 sizeof Token is j j
ret (j.q   = q    )
   (j.loc = a    )
   (j.n   = b - a)
   (j.in  = in   ) )

escape_one(c C ca C cb C) C =
((c == ca) && cb)

escape(c S in @File) C =
(  &escape_one is f
  (  f@ c@ 'a' '\a'
  || f@ c@ 'b' '\b'
  || f@ c@ 'f' '\f'
  || f@ c@ 'n' '\n'
  || f@ c@ 'r' '\r'
  || f@ c@ 't' '\t'
  || f@ c@ 'v' '\v'
  || f@ c@ 'p' '\p'
  || f@ c@ 'q' '\q'
  || f@ c@ 's' '\s'
  || '\0'
  ret ((c@ != '0') && (diag c in "invalid escape sequence") as none) ) )

string_literal(in @File start S quote S) J =
( (  &quote^1 for q
    (  (q@ != '"')
    && &q^1
    ret ((q@ == '\0') && (diag quote in "unclosed string literal") as none) ) )
is end
   cast S calloc 1 (end - quote as N) is buf
   0 is n
  (  &quote^1 for p
    (  (p < end)
    && (p@ == '\s')
    ? (  buf^(n ret (n = n + 1)) = (p = &p^1)
         escape p in
      ret (p = &p^1) )
       p
    :  (buf^(n ret (n = n + 1)) = p@)
       &p^1 )
  as none )
   ntoken &JSTR start &end^1 in is j
   (j.t = array_of nbyte cast nat (n + 1))
   (j.str = buf)
   j )

byte_literal(in @File p S) J =
(  &p^1 is q
   ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
  (  (q@ == '\s')
  ?  (q = &q^1)
     ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
     escape q in
  :  q@ )
is c
   (q = &q^1)
   ((q@ != '\p') && (diag p in "unclosed literal byte") as none)
   ntoken &JNUM p &q^1 in is j
   (j.l = c as N)
   (j.t = cast @none nbyte)
   j )

open_file(path S mode S) Y =
(fopen path mode || cast none (printf "cannot open file '%s' with mode '%s': %s" mode path strerror (__errno_location)@))

read_file(path S) S =
(  cast S calloc 1 4096 is rfbuf2
   open_file path "r" is fp
   cast S 0 is buf
   0 is buflen
   &buflen is b
   open_memstream &buf b is y
   (1b for k
    fread cast @none rfbuf2 1 4096 fp is n
    ((n == 0) ? (k = 0b) : cast none fwrite cast @none rfbuf2 1 n y)
       k as none)
   free cast @none rfbuf2
   (fclose fp as none)
   fflush y
   (((buflen == 0) || (buf^(buflen - 1) != '\n')) && fputc cast N '\n' y as none)
   fputc 0 y
   fclose y
   buf )

tokenize(path S) J =
(  read_file path is p
   !p
?  cast J 0
:  cast @File calloc 1 sizeof File is in
   (in.name = path)
   (in.contents = p)
   cast J 0 is j
   &j is k
   (1b for _ p@ &&
    startswith p "/*"
    ?  strstr &p^2 "*/" is q
       (!q && (diag p in "unclosed block comment") as none)
       (p = &q^2)
    :  (isws p@) ? (p = &p^1)
    :  (is09 p@ || ((p@ == '.') && is09 p^1))
    ?  (&p^1 for q ( isid q@ && &q^1 )) is q
       (k@ = ntoken &JNUM p q in)
       (k.loc is p
           10 is a
           (  (!strncmp p "0x" 2 && is0f p^2)
           && (p = &p^2)
              (a = 16)
           as none )
            strtoul p &p a is v
            ( (startswith p "b"  ) ? (p = &p^1)            nbit :
                                                           nnat ) is t
            (k.l = v as N )   
            (k.t = t as @none   )   
            1b)
       (k = &k.s)
       (p = q)
    :  (p@ == '"')
    ?  (k@ = string_literal in p p)
       (p = &p^k.n)
       (k = &k.s)
    :  (p@ == '\p')
    ?  (k@ = byte_literal in p)
       (k.l = k.l as C as N)
       (p = &p^k.n)
       (k = &k.s)
    :  0 is n
       (p for q ((isid q@ && &q^1) || cast S 0 ret (n = q - p as N)) as none)
       !!n
    ?  (k@ = ntoken &JID p &p^n in)
       (p = &p^k.n)
       (k = &k.s)
    :  read_punct p is n
       !!n
    ?  (k@ = ntoken &JPCT p &p^n in)
       (p = &p^k.n)
       (k = &k.s)
    :  (diag p in "invalid token"))
   j ret
   1 is n
  ( in.contents for p
    !!p@ &&
    !!j &&
    ((p == j.loc) && (j.line_no = n) (j = j.s))
    ((p@ == '\n') && (n = n + 1))
    &p^1 ) )

push_scope  (k K c S    ) @Scope
= (cast @Scope calloc 1 sizeof Scope is s s ret (s.c = c)    (s.s = k.s)    (k.s = s))

try_search_scope(k K c S n N) @Scope = (
  cast @Scope 0 is r
  (!!k.s && k.s for s ((n != strlen s.c )|| !!strncmp s.c c n) ?
    s.s :
  (r = s)
  cast @Scope 0 as none )
  r
)

search_scope(k K c S n N) @Scope = (
  try_search_scope k c n ||
  (jdiag k.j "lookup failed")
)

type o_kst (k K s S t T) O;

nvar o_kst =
(  cast O calloc 1 sizeof Obj is o
   (o.name = s) 
   (o.t = t) 
   ((push_scope k s).o = o) 
   o )

nbetvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   o )

nlvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   (o.s = k.locals)
   (k.locals = o)
   o )

ngvar o_kst = (
  nvar k s t is o
  (o.s = k.globals)
  (o.is_definition = 1b)
  (k.globals = o)
  o
)

nstr o_kst = (
  cast S 0 is s2
  cast N 0 is n
  open_memstream &s2 &n is y
  (fprintf y ".s%ld" k.j)
  fclose y
  ngvar k s2 t is o (o.init_data = s)
  o
)

id(j J) S = (
  ( !!j &&
    (j.q != &JID) &&
    (jdiag j "expected <id>") )
  strndup j.loc cast N j.n
)

find_type(k K c S n N) T = (
  (!!k.j && (k.j.q != &JID)) ? nnull :
  search_scope k c n is s
  (!!s && s.t)
)

get_struct_member(t T j J) T =
(  nnull is r
  (  t.a for g
     ((g.name.n == j.n) && !strncmp g.name.loc j.loc j.n)
  ?  (r = g)
     nnull
  :  g.s
  as none )
   r )

jadv   (k K    ) J    = (k.j ret (k.j = k.j.s))
jeq    (k K c S) bit  = (!!k.j && (!memcmp cast @none k.j.loc cast @none c cast N k.j.n && !c^k.j.n))
expect (k K c S) none = ((!jeq k c && (jdiag k.j "expected '%s'" c) as none)    (k.j = k.j.s))
consume(k K c S) bit  = (jeq k c is r r ret (r && (k.j = k.j.s) as none) )

declarator tk =
(  jadv k is j
   copy_type ptype k is t t
ret (t.name = j) )

struct_decl tk =
(  struct_of is t
   expect k "{"
   (k.t = t)
   &t.a is u
  (  1b for _ 
    (  !consume k "}"
    && (calloc 1 sizeof Type as T) is g
       (g@ = declarator k)
       (u@ = g)
       (u = &u.s) )
  as none )
   (k.t = 0 as T)
   (t.format = &ftstct)
   (t.size < 0) ? t
:  0 is bits
  (  !!t.a && t.a for g g.s
  ret (bits = align_to bits (g.align * 8))
     (g.offset = bits / 8)
     (bits = bits + g.size * 8)
     ((t.align < g.align) && (t.align = g.align) as none)
  as none)
   (t.size = align_to bits (t.align * 8) / 8)
   t )

func_params tk =
(  0b is is_variadic
   cast T 0 is params
   &params is u
   (1b for _ (!jeq k ")" && !(consume k "..."
?  (is_variadic = 1b)
   1b
:  (u@ = declarator k)
   (u = &u.s)
   0b))
as none)
   jadv k
   nfunc ptype k is t
   (t.params = params)
   (t.is_variadic = is_variadic)
   t )

ptype tk = (
  consume k "none"   ? nnone               :
  consume k "same"   ? k.t                 :
  consume k "bit"    ? nbit                :
  consume k "byte"   ? nbyte               :
  consume k "nat"    ? nnat                :
  consume k "@"      ? nptr        ptype k :
  consume k "("      ? func_params       k :
  consume k "struct" ? struct_decl       k :
  search_scope k k.j.loc k.j.n is s
  !!s &&
  jadv k
  s.t
)

tree(j J t T gen @gefn            ) E = (cast E calloc 1 sizeof Node is e e ret (e.j = j)  (e.t = t) (e.gen = gen))
t0  (j J t T gen @gefn            ) E = (tree j t gen)
t1  (j J t T gen @gefn a E        ) E = (tree j t gen is e e ret (e.a   = a))
t2  (j J t T gen @gefn a E b E    ) E = (tree j t gen is e e ret (e.a   = a)  (e.a.s = b))
t3  (j J t T gen @gefn a E b E c E) E = (tree j t gen is e e ret (e.a   = a)  (e.a.s = b)  (e.a.s.s = c))
tt  (j J t T gen @gefn u T        ) E = (t0   j t gen is e e ret (e.t.s = u))
to  (j J t T gen @gefn o O        ) E = (t0   j t gen is e e ret (e.o   = o))
tl  (j J t T gen @gefn l N        ) E = (t0   j t gen is e e ret (e.l   = l))

type njtu  (j J t T u T        ) E;
type njtua (j J t T u T a E    ) E;
type njta  (j J t T     a E    ) E;
type njtab (j J t T     a E b E) E;

nsize       njtu  = tt j nnat     &gesize    u
nthe        njtua = t1 j a.t      &gethe     a
ncast       njtua = t1 j u        &gecast    a
ncall       njta  = t1 j a.t.a    &gecall    a
nneg        njta  = t1 j nnat     &geneg     a
naddr       njta  = t1 j nptr a.t &geaddr    a
nlnot       njta  = t1 j nbit     &gelnot    a
nbnot       njta  = t1 j nnat     &gebnot    a
nderef      njta  = t1 j a.t.a    &gederef   a
nass        njtab = t2 j nnone    &geass     a b
nbor        njtab = t2 j nnat     &gebor     a b
nband       njtab = t2 j nnat     &geband    a b
ne          njtab = t2 j nbit     &gee       a b
nne         njtab = t2 j nbit     &gene      a b
na          njtab = t2 j nbit     &gea       a b
nb          njtab = t2 j nbit     &geb       a b
nae         njtab = t2 j nbit     &geae      a b
nbe         njtab = t2 j nbit     &gebe      a b
nshl        njtab = t2 j nnat     &geshl     a b
nshr        njtab = t2 j nnat     &geshr     a b
nmul        njtab = t2 j nnat     &gemul     a b
ndiv        njtab = t2 j nnat     &gediv     a b
nmod        njtab = t2 j nnat     &gemod     a b
nret        njtab = t2 j a.t      &geret     a b
nseq        njtab = t2 j b.t      &geseq     a b
nlor        njtab = t2 j a.t      &gelor     a b
nland       njtab = t2 j b.t      &geland    a b
nelem       njtab = t2 j a.t.a    &geelem    a b
nadd        njtab = t2 j nnat     &geadd     a b
nsub        njtab = t2 j nnat     &gesub     a b

/* oddballs */

nreference  (j J t T                 o O ) E = (to j o.t &geref o)
nlit        (j J t T u T             l N ) E = (tl j u   &gelit l)
nbet        (j J t T         a E b E o O ) E = (t2 j b.t &geis a b is e e ret (e.o = o))
nrepeat     (j J t T         a E b E o O ) E = (t2 j b.t &gefor a b is e e ret (e.o = o))
ncond       (j J t T         a E b E c E ) E = (t3 j b.t &gecond a b c)

p1    pfn ;
p2    pfn ;
p4    pfn ;
p5    pfn ;
p7    pfn ;
pmul  pfn ;
padd  pfn ;
psh   pfn ;
pcmp  pfn ;
pband pfn ;
pbor  pfn ;
pland pfn ;
plor  pfn ;

esize  efn  = (jadv k is j ptype k is u nsize j t u       )
ethe   efn  = (jadv k is j ptype k is u nthe  j t u p4 k t)
ecast  efn  = (jadv k is j ptype k is u ncast j t u p4 k t)
eas    efna = (jadv k is j ptype k is u ncast j t u a     )
efrom  efna = (jadv k is j ptype k is u nthe  j t u a     )

elit   efn  = (jadv k is j nlit    j t cast T j.t j.l    )
eaddr  efn  = (jadv k is j naddr   j t     p2 k t        )
eelem  efna = (jadv k is j nelem   j t a   p4 k nnat )
eneg   efn  = (jadv k is j nneg    j t     p4 k t        )
elnot  efn  = (jadv k is j nlnot   j t     p4 k t        )
ebnot  efn  = (jadv k is j nbnot   j t     p4 k t        )
ederef efna = (jadv k is j nderef  j t a                 )
eseq   efna = (k.j    is j nseq    j t a   p5 k t        )
ethen  efna = (jadv k is j nret    j t a   p5 k nnone    )
emul   efna = (jadv k is j nmul    j t a   p5 k a.t      )
ediv   efna = (jadv k is j ndiv    j t a   p5 k a.t      )
emod   efna = (jadv k is j nmod    j t a   p5 k a.t      )
eland  efna = (jadv k is j nland   j t a   p5 k a.t      )
elor   efna = (jadv k is j nlor    j t a   p5 k a.t      )
econd  efna = (jadv k is j                 p5 k t is b expect k ":"
                           ncond   j t a b p5 k t        )
eadd   efna = (jadv k is j nadd    j t a   pmul  k a.t   )
esub   efna = (jadv k is j nsub    j t a   pmul  k a.t   )
eshl   efna = (jadv k is j nshl    j t a   padd  k a.t   )
eshr   efna = (jadv k is j nshr    j t a   padd  k a.t   )
elt    efna = (jadv k is j nb      j t a   psh   k nnull )
egt    efna = (jadv k is j na      j t a   psh   k nnull )
ele    efna = (jadv k is j nbe     j t a   psh   k nnull )
ege    efna = (jadv k is j nae     j t a   psh   k nnull )
eeq    efna = (jadv k is j ne      j t a   psh   k nnull )
ene    efna = (jadv k is j nne     j t a   psh   k nnull )
eband  efna = (jadv k is j nband   j t a   pcmp  k a.t   )
ebor   efna = (jadv k is j nbor    j t a   pband k a.t   )
eass   efna = (jadv k is j nass    j t a   p7    k a.t   )

eis    efna = (jadv k is j k.s is s nbetvar k id jadv k a.t is o       p5 k t       is b nbet         j   t     a b   o ret (k.s = s))
efor   efna = (jadv k is j k.s is s nbetvar k id jadv k a.t is o       p5 k t       is b nrepeat      j   t     a b   o ret (k.s = s))

eid    efn  = (jadv k is j
  search_scope k j.loc j.n is s
  nreference j t s.o
)

estr   efn  = ( jadv k is j
  cast T j.t is u
  nstr k j.str u is o
  ncast j t nptr u.a nthe j u o.t nreference j u o
)

emem  efna =
(  jadv k is j
   cast none jadv k
   (a.t for t ((t.format == &ftptr) && t.a)) is t
   ((t.format != &ftstct) && (jdiag j "%s is not a struct" format_type t) as none)
   get_struct_member t j.s is g
  (  !g
  &&(  jdiag j.s "(%s . %.*s) no such member" format_type t j.s.n j.s.loc ) as none )
   t1 j.s g &gemem a )

end_seq(k @Ctx) bit = (
   jeq k ")"
|| jeq k ":"
|| jeq k "?"
|| jeq k "*"
|| jeq k "/"
|| jeq k "%"
|| jeq k "+"
|| jeq k "-"
|| jeq k "<<"
|| jeq k ">>"
|| jeq k "<"
|| jeq k ">"
|| jeq k "<="
|| jeq k ">="
|| jeq k "=="
|| jeq k "!="
|| jeq k "|"
|| jeq k "&&"
|| jeq k "||"
|| jeq k "="
|| jeq k "as"
|| jeq k "from"
)

ecall efna = (
  a.t.params is u
  (  a for b
    (  (!!u || a.t.is_variadic && !end_seq k)
    && (b.s = p4 k u)
       (  !!u 
       && (!type_equal b.s.t u && (jdiag k.j "asymmetric argument from %s to %s" format_type b.s.t format_type u) as none)
          (u = u.s)
       as none)
       b.s )
  as none )
  ncall k.j t a
)

pj(k K t T     q TokenKind e @efn ) E = ((k.j.q == q) && e@ k t)
pl(k K t T     c S e @efn ) E = (jeq k c && e@ k t  )
pr(k K t T a E c S e @efna) E = (jeq k c && e@ k t a)

pcast efna = (                     pr    k t a "as"      &eas    ||
                                   pr    k t a "from"    &efrom     )

p2 efn = ( (
    consume k "(" ? (
      p7    k nnull for a
      pr    k t a "=" &eass ||
      pcast k t a ) ret expect k ")" :
    pj k t &JID  &eid  ||
    pj k t &JSTR &estr ||
    pj k t &JNUM &elit ||
    (jdiag k.j "expected an expression")
  ) for a
  pr    k t     a "^"       &eelem   ||
  pr    k t     a "."       &emem   ||
  pr    k t     a "@"       &ederef
)

p4 efn = (
  pl k t "-" &eneg   ||
  pl k t "!" &elnot  ||
  pl k t "~" &ebnot  || (
    pl k t     "cast"    &ecast  ||
    pl k t     "the"     &ethe   ||
    pl k t     "&"       &eaddr  ||
    pl k t     "sizeof"  &esize  ||
    p2 k nnull
  ) for a
  (a.t.format == &ftfunc) &&
  ecall k t a
)

p5  efn = (
  p4    k nnull  is a
  pr    k t a "ret"     &ethen  ||
  pr    k t a "is"      &eis    ||
  pr    k t a "for"     &efor   ||
  pr    k t a "&&"      &eland  ||
  pr    k t a "||"      &elor   ||
  pr    k t a "?"       &econd  ||
  end_seq k ? a : eseq k t a
)

pmul  efn = (p5  k t       for a ( pr    k t a "*"       &emul   ||
                                   pr    k t a "/"       &ediv   ||
                                   pr    k t a "%"       &emod      ) )
padd  efn = (pmul  k t     for a ( pr    k t a "+"       &eadd   ||
                                   pr    k t a "-"       &esub      ) )
psh   efn = (padd  k t     for a ( pr    k t a "<<"      &eshl   ||
                                   pr    k t a ">>"      &eshr      ) )
pcmp  efn = (psh   k nnull for a ( pr    k t a "<"       &elt    ||
                                   pr    k t a ">"       &egt    ||
                                   pr    k t a "<="      &ele    ||
                                   pr    k t a ">="      &elt    ||
                                   pr    k t a "=="      &eeq    ||
                                   pr    k t a "!="      &ene       ) )
pband efn = (pcmp  k t     for a   pr    k t a "&"       &eband     )
pbor  efn = (pband k t     for a   pr    k t a "|"       &ebor      )
p7    efn = (pbor  k t     for a   pcast k t a                   )

typedecl(k K) J =
(  k.j for j
  (  !consume k ";"
  &&(  declarator k is t
       ((push_scope k id t.name).t = t)
       k.j ) ) )

create_lvars(k K t T) none =
(  !!t
&& create_lvars k t.s
   (nlvar k id t.name t as none)
as none )

find_func(k K c S n N) O =
(  try_search_scope k c n is s
   (!!s && !!s.o && (s.o.t.format == &ftfunc) && s.o) )

type  VarAttr struct {
    is_type    bit
    is_export  bit
  };

function(k K v @VarAttr) none =
(  declarator k is t
  find_func k t.name.loc cast N t.name.n is o
  (  !!o
  ?  ((o.t.format != &ftfunc)             && (jdiag k.j "redeclared as a different q of symbol") as none)
     (o.is_definition && jeq k "=" && (jdiag k.j "redefinition of %s" o.name) as none)
     ((o.is_export != v.is_export )  && (jdiag k.j "mismatched visibility") as none)
     (o.is_definition = o.is_definition || jeq k "=")
  :  (o = ngvar k id t.name t)
     (o.is_definition = jeq k "=")
     (o.is_export = v.is_export) )
  (  !consume k ";"
  && (k.locals = cast O 0)
     k.s is s
     create_lvars k t.params
     (o.params = k.locals)
     (t.is_variadic && (o.va_area = nlvar k "__va_area__" array_of nbyte 136) as none)
     expect k "="
     (o.body = p4 k t.a as @none)
     (o.locals = k.locals)
     (k.s = s) ) )

parse(j J) O =
(  cast @Ctx calloc 1ul sizeof Ctx is k
   cast @VarAttr calloc 1ul sizeof VarAttr is v
   (k.j = j)
  (  !!k.j && k.j for j
    (  !!j && 
      (v.is_type = 0b)
      (v.is_export = 0b)
      (1b for i
    ((consume k "type"    && 1b ret (v.is_type   = 1b))
  || (consume k "export"  && 1b ret (v.is_export = 1b)) )
as none)
       v.is_type
    ?  typedecl k
    :  function k v
       k.j)
  as none)
   k.globals )

argreg1(d N) S =
(  (d == 0) ? "%dil" :
   (d == 1) ? "%sil" :
   (d == 2) ? "%dl"  :
   (d == 3) ? "%cl"  :
   (d == 4) ? "%r8b" :
              "%r9b" )

argreg8(d N) S =
( (d == 0) ? "di" :
  (d == 1) ? "si" :
  (d == 2) ? "dx" :
  (d == 3) ? "cx" :
  (d == 4) ? "8"  :
             "9"  )

gln(y Y fmt S ...) none =
(  vfprintf y fmt cast @va_list __va_area__
   (cast none fprintf y "\n") )

gbin (y Y s S) none = (gln y "  %s  %%rdi, %%rax" s)
gzero(y Y s S) none = (gln y "  xor %%e%s, %%e%s" s s)
glit (y Y l N) none = (!!l ? (gln y "  mov $%ld , %%rax" l) : gzero y "ax")
gcmpz(y Y    ) none = (gln y "  test %%rax, %%rax"  )
gbnot(y Y    ) none = (gln y "  not %%eax"         )
gneg (y Y    ) none = (gln y "  neg %%rax"         )
gmul (y Y    ) none = (gln y "  mul %%rdi"         )
gdiv (y Y    ) none = ( gzero y "dx"
                        (gln y "  div %%rdi"         ) )
gmod (y Y    ) none = ( gdiv y
                        (gln y "  mov %%rdx, %%rax") )
gshx (y Y x C) none = ( (gln y "  mov %%dil, %%cl"   )
                        (gln y "  sh%c %%cl, %%rax" x) )

gadd (y Y) none = (gbin y "add")
gsub (y Y) none = (gbin y "sub")
gand (y Y) none = (gbin y "and")
gor  (y Y) none = (gbin y "or ")
gxor (y Y) none = (gbin y "xor")
gcmp (y Y) none = (gbin y "cmp")
gshr (y Y) none = (gshx y 'r')
gshl (y Y) none = (gshx y 'l')

gpromote(y Y) none = (gln y "  movzbl %%al , %%eax")

gsetf     (y Y         s S) none = ((gln y "  set%s  %%al" s) gpromote y)
gcmp_setf (y Y         s S) none = (gcmp  y gsetf y s)
gcmpz_setf(y Y         s S) none = (gcmpz y gsetf y s)
glnot     (y Y            ) none = (gcmpz_setf y "e" )

gj        (y Y e E l S    ) none = (gln y "  jmp %s%ld$"   l e)
gjc       (y Y e E l S s S) none = (gln y "  j%s %s%ld$" s l e)
glabel    (y Y e E l S    ) none = (gln y "%s%ld$:"        l e)

gje  (y Y e E l S) none = gjc y e l "e "
gjne (y Y e E l S) none = gjc y e l "ne"
gjb  (y Y e E l S) none = gjc y e l "b "
gjbe (y Y e E l S) none = gjc y e l "be"
gja  (y Y e E l S) none = gjc y e l "a "
gjae (y Y e E l S) none = gjc y e l "ae"

ge  (y Y) none = gcmp_setf y "e "
gne (y Y) none = gcmp_setf y "ne"
gb  (y Y) none = gcmp_setf y "b "
gbe (y Y) none = gcmp_setf y "be"
ga  (y Y) none = gcmp_setf y "a "
gae (y Y) none = gcmp_setf y "ae"

gcast(y Y a T b T) none =
(  (b.format == &ftnone) ?  gzero    y "ax"
:  (b.format == &ftbyte) && gpromote y)

gfpush(y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gln y "  sub $%ld, %%rsp" l1) (c@ = c@ + l1))
gfpop (y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gln y "  add $%ld, %%rsp" l1) (c@ = c@ - l1))
gpush (y Y c @N      ) none = ((gln y "  push %%rax")    (c@ = c@ + 8))
gpop  (y Y c @N  s S ) none = ((gln y "  pop %%r%s" s  )    (c@ = c@ - 8))
gindex(y Y       l N ) none = (!!l && (gln y "  add $%ld, %%rax" l))

gaddr(y Y q @ftfn n N s S d S) none = (gln y "  lea    %lu(%%r%s), %%r%s" n s d)
gload(y Y q @ftfn n N s S d S) none =
( ((q == &ftarr)|| (q == &ftstct)|| (q == &ftfunc))
? gaddr y q n s d
: ((q == &ftbyte) || (q == &ftbit))
? (gln y "  movzbl %lu(%%r%s), %%e%s" n s d)
: (gln y "  mov    %lu(%%r%s), %%r%s" n s d)
as none )

gaddrg(y Y e E c @N d S) none = (gln y "  lea    %s, %%r%s" e.o.name d)
gloadg(y Y e E c @N d S) none =
( ((e.o.t.format == &ftarr)|| (e.o.t.format == &ftstct)|| (e.o.t.format == &ftfunc))
? gaddrg y e c d
: ((e.o.t.format == &ftbyte) || (e.o.t.format == &ftbit))
? (gln y "  movzbl %s, %%e%s" e.o.name d)
: (gln y "  mov    %s, %%r%s" e.o.name d)
as none )

gaddrl(y Y e E c @N d S) none = (gaddr y e.o.t.format (e.o.sp ? (gln y "#let from %lu at %lu" e.o.sp c@) (c@ - e.o.sp) : (e.o.offset + c@)) "sp" d)
gloadl(y Y e E c @N d S) none = (gload y e.o.t.format (e.o.sp ? (gln y "#let from %lu at %lu" e.o.sp c@) (c@ - e.o.sp) : (e.o.offset + c@)) "sp" d)


gloadsp(y Y q @ftfn d S) none =
(  ((q == &ftarr)|| (q == &ftstct)|| (q == &ftfunc))
? (gln y "  mov     %%rsp, %%r%s" d)
: ((q == &ftbyte) || (q == &ftbit))
? (gln y "  movzbl (%%rsp), %%e%s" d)
: (gln y "  mov    (%%rsp), %%r%s" d) )

gstoresp(y Y t T) none =
(  (gln y " mov %%rsp, %%rdi")
   ((t.format == &ftstct) || (t.format == &ftarr)) ? (0 for i ((i < t.size) && (i + 1)
ret (gln y "  mov %ld(%%rax), %%r8b    " i)
    (gln y "  mov %%r8b    , %ld(%%rdi)" i)) as none)
:  (t.size == 1) ? (gln y "  mov %%al , (%%rdi)")
:                  (gln y "  mov %%rax, (%%rdi)") )

gstore(y Y t T c @N) none =
(  gpop y c "di"
   ((t.format == &ftstct) || (t.format == &ftarr)) ? (0 for i ((i < t.size) && (i + 1)
ret (gln y "  mov %ld(%%rax), %%r8b    " i)
    (gln y "  mov %%r8b    , %ld(%%rdi)" i)) as none)
:  (t.size == 1) ? (gln y "  mov %%al , (%%rdi)")
:                  (gln y "  mov %%rax, (%%rdi)") )

glet(y Y o O c @N) none = (
  gfpush y c 8
  (o.sp = c@)
  gstoresp y o.t
)

gulet(y Y o O c @N d S) none = (
  gloadsp y o.t.format d
  (o.sp = 0)
  gfpop y c 8
)

gexpr gefn = (
  (gln y ".loc 0 %lu" e.j.line_no)
  e.gen@ y e c l
)

gdrop (y Y e E c N    ) none = (cast none gexpr y e c 0 is l (l && gln y "#elided loads: %ld" l))
geval (y Y e E c N l N) none = (
  gexpr y e c l is l1
  ((l1 > 1) && gln y "#compacted loads: %ld" (l - 1))
  !!l1 && l1 for l2
  gload y (((l2 == 1) && (l == 0)) ? e.t.format : &ftptr) 0 "ax" "ax"
  (l2 - 1)
)

gdata(y Y o O) none = (
  (gln y "  .data"                             )
  (gln y "  .type %s, @object" o.name          )
  (gln y "  .size %s, %ld"     o.name o.t.size )
  (gln y "  .align %ld"               o.t.align)
  (gln y "%s:" o.name                          )
  ( 0 for i (i < o.t.size) && (i + 1) ret
    (gln y "  .byte %ld" o.init_data^i)
  as none )
)

gstoreva(y Y o O c N) none = (
  0 is d
  (!!o.params && o.params for o o.s ret (d = d + 8))
  (gln y "  movl $%ld , 24(%%rsp)" d       )
  (gln y "  movq %%rsp, 32(%%rsp)"         )
  (gln y "  addq $%ld , 32(%%rsp)" (c + 16))
  (gln y "  movq %%rsp, 40(%%rsp)"         )
  (gln y "  addq $48  , 40(%%rsp)"         )
  (gln y "  movq %%rdi, 48(%%rsp)"         )
  (gln y "  movq %%rsi, 56(%%rsp)"         )
  (gln y "  movq %%rdx, 64(%%rsp)"         )
  (gln y "  movq %%rcx, 72(%%rsp)"         )
  (gln y "  movq %%r8 , 80(%%rsp)"         )
  (gln y "  movq %%r9 , 88(%%rsp)"         )
)

gtext(y Y o O) none =
( (  !!o.params
  && 16 is t
      0 is g
     o.params for o o.s
  ret (!((g ret (g = g + 1)) < 6)
  && (t        = align_to t 8)
     (o.offset = t           )
     (t        = t + o.t.size) ) )
   0 is c
  (  !!o.locals
  && o.locals for o o.s
  ret(  !o.offset
    && (c = c + o.t.size)
       (c = align_to c o.t.align)
       (o.offset = -c)
    as none )
  as none )
  (c = align_to c 16) /* abi says c of frame is aligned to 16 */
  (gln y "  .text")
  (gln y "  .type %s, @function" o.name)
  (gln y "%s:" o.name)
  (gln y "  enter $%ld, $0" c)
  ( o.t.is_variadic && gstoreva y o c)
  (  0 is d
     o.params for o
    (  !!o
    && o.s
    ret(  (o.offset > (-1 >> 1))
      && o.t is t
         ((t.size == 1)
      ?  (gln y "  mov %s   , %ld(%%rsp)" argreg1 d (o.offset + c))
      :  (gln y "  mov %%r%s, %ld(%%rsp)" argreg8 d (o.offset + c)))
      ret (d = d + 1)
      as none ) )
  as none )
  gdrop y cast E o.body c
  (gln y "  leave")
  (gln y "  ret")
)

gsym(y Y o O) none = (
  !!o.is_definition &&
  (gln y "  .%s %s" (!o.is_export ? "local" : "globl" ) o.name)
  ((o.t.format == &ftfunc) ? &gtext : &gdata)@ y o
)

codegen(o O y Y in S) none = (
  (gln y "  .file 0 \q%s\q" in)
  !!o &&
  o for o
  o.s ret gsym y o
)

export main(argc N argv @S) N =
(  open_file argv^2 "w" is y
   (!y ? 1 : 0 ret codegen parse tokenize argv^1 y argv^1)
ret cast none fclose y )



type gelfn (y Y v N) N;
type gegfn (y Y e E c N l N gop @(y Y) none) N;

ge0     gelfn = (
  glit  y v 0
)

ge1     gegfn = (
  geval y e.a c 0
  gop@  y
  0
)

ge2     gegfn = (
  geval y e.a.s  c 0
  gpush y       &c
  geval y e.a    c 0
  gpop  y       &c "di"
  gop@  y
  0
)

/* fundamentals */

gelit   gefn = ge0 y e.l
gesize  gefn = ge0 y e.t.s.size
gederef gefn = (gexpr y e.a c 0 + 1 - l)
geaddr  gefn = gexpr y e.a c 1
gethe   gefn = gexpr y e.a c l

gecast  gefn =  (
  geval y e.a c 0
  gcast y e.a.t e.t
  0
)

geref   gefn = (
  (e.o.is_local ? &gaddrl : &gaddrg) is gaddr
  (e.o.is_local ? &gloadl : &gloadg) is gload
  (!l ? gload : gaddr)
  @ y e &c "ax"
  0
)

/* arithmetic operations */

gelnot  gefn = ge1 y e c l &glnot
gebnot  gefn = ge1 y e c l &gbnot
geneg   gefn = ge1 y e c l &gneg
gediv   gefn = ge2 y e c l &gdiv
gemod   gefn = ge2 y e c l &gmod
gee     gefn = ge2 y e c l &ge
gene    gefn = ge2 y e c l &gne
geb     gefn = ge2 y e c l &gb
gebe    gefn = ge2 y e c l &gbe
gea     gefn = ge2 y e c l &ga
geae    gefn = ge2 y e c l &gae
geadd   gefn = ge2 y e c l &gadd
gesub   gefn = ge2 y e c l &gsub
gemul   gefn = ge2 y e c l &gmul
geband  gefn = ge2 y e c l &gand
gebor   gefn = ge2 y e c l &gor
geshl   gefn = ge2 y e c l &gshl
geshr   gefn = ge2 y e c l &gshr

/* pointer magic */

geelem  gefn = (
  geval y e.a    c 0
  gpush y       &c
  geval y e.a.s  c 0
  gpop  y       &c "dx"
  (gln y "  lea (%%rdx, %%rax, %ld), %%rax" e.a.t.a.size)
  (1 - l)
)

gemem   gefn = (
  geval y e.a c 0
  ( e.a.t for t
    ( (t.format == &ftptr) &&
      t.a ret
      gload y t.a.format 0 "ax" "ax"
    as none )
  as none )
  gindex y e.t.offset
  (1 - l)
)

/* sequencing */

geseq gefn = (
  gdrop y e.a   c
  geval y e.a.s c l
  0
)

geret gefn = (
  geval y e.a    c l
  gpush y       &c
  gdrop y e.a.s  c
  gpop  y       &c "ax"
  0
)

gecond gefn = (
  geval  y e.a     c 0
  gcmpz  y
  gje    y e         "a"
  geval  y e.a.s   c l
  gj     y e         "b"
  glabel y e         "a"
  geval  y e.a.s.s c l
  glabel y e         "b"
  0
)

geland  gefn = (
  (e.a.s.t.format == &ftnone) is keep
  geval y e.a c 0
  gcmpz y
  gje   y e         "a"
  ( keep &&
    gpush y       &c      )
  geval y e.a.s c 0
  ( keep &&
    gpop  y       &c "ax" )
  glabel y e        "a"
  0
)

gelor gefn = (
  (e.a.s.t.format == &ftnone) is keep
  geval   y e.a   c 0
  gcmpz   y
  gjne    y e       "a"
  ( keep &&
    gpush y       &c      )
  geval   y e.a.s c 0
  ( keep &&
    gpop  y       &c "ax" )
  glabel  y e       "a"
  0
)

geis    gefn = (
  geval  y e.a    c 0
  glet   y e.o   &c
  geval  y e.a.s  c l
  gulet  y e.o   &c "dx"
  0
)

gefor   gefn = (
  geval    y e.a    c 0
  glet     y e.o   &c
  gj       y e        "b"
  glabel   y e        "a"
  gstoresp y e.a.t
  glabel   y e        "b"
  geval    y e.a.s  c 0
  gcmpz    y
  gjne     y e        "a"
  gulet    y e.o   &c "ax"
  0
)

gargs(y Y e E c @N d N) none =
(  !!e
&&(  (d < 6)
  && gargs y e.s c (d + 1) )
   geval y e c@ 0
   gpush y c
as none )

gecall gefn = (
  0 is stack
  0 is d
  ( ( (c + stack) % 16 != 0) &&
    gfpush y &c 1
    (stack = stack + 8)
  as none )
  gargs y e.a.s &c 0
  geval y e.a   c 0
  0 is d
  (!!e.a.s && e.a.s for e e.s ret ((d < 6) && gpop y &c argreg8 d ret (d = d + 1)) as none)
  (gln y "  call *%%rax")
  gfpop y &c (stack >> 3)
  0
)

/* ass */

geass   gefn = (
  geval  y e.a    c 1
  gpush  y       &c
  geval  y e.a.s  c 0
  gstore y e.a.t &c
  gzero  y         "ax"
  0
)

ftnone ftfn = strcat s "none"
ftbit  ftfn = strcat s "bit"
ftbyte ftfn = strcat s "byte"
ftnat  ftfn = strcat s "nat"
ftstct ftfn = strcat s "struct"
ftarr  ftfn = strcat s "array"
ftptr  ftfn = (strcat s "@"  ret t.a.format@ t.a s)
ftfunc ftfn = (strcat s "("  ret
              (t.a.s for p (!!p && p.s ret p.format@ p s ) as none)
                         strcat s ")"  ret t.a.format@ t.a s)