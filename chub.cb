type
  va_list struct {}
  FILE    struct {}
;

export __errno_location    ( ) @nat

export open_memstream      (p    @@byte n    @nat) @FILE
export fopen               (path  @byte mode @ byte ) @FILE

export fclose              (io @FILE) nat
export fflush              (io @FILE) nat

export fread               (ptr @none m nat n nat io @FILE) nat
export fwrite              (ptr @none m nat n nat io @FILE) nat
export fputc               (c nat io @FILE) nat
export fputs               (s @byte io @FILE) nat

export exit                (status nat) none

export calloc              (m nat  n nat) @none
export free                (p @none) none

export memcmp              (p @none q @none n nat) nat

export strtoul             (p @byte q @@byte  b nat) nat
export strcat              (p @byte q  @byte       ) @byte
export strstr              (p @byte q  @byte       ) @byte
export strncmp             (p @byte q  @byte  n nat)  nat
export strndup             (p @byte           n nat) @byte
export strlen              (p @byte               ) nat

export strerror            (errnum  nat) @byte

/* end preamble */

type
  TokenKind @()none

  File struct {
    name     @byte
    contents @byte
  }

  Token struct {
    q        TokenKind
    s       @Token
    l        nat
    p     @byte
    n        nat
    t       @none
    str     @byte
    line  nat
  }

  Type struct  {
    size          nat
    align         nat
    offset        nat
    n             nat
    s            @Type
    o            @Type
    a            @Type
    params       @Type
    name         @Token
    format @(t @Type s @byte) none
  }

  Obj struct {
    s               @Obj
    name            @byte
    t               @Type
    j               @Token
    offset           nat
    is_local         bit
    is_definition    bit
    is_export        bit
    init_data       @byte
    params          @Obj
    body            @none
    locals          @Obj
    sp nat
  }

  Node struct {
    s @Node
    a @Node
    j @Token
    t @Type
    o @Obj
    l  nat
    gen @(y @FILE e @Node c nat l nat) nat
  }

  Scope struct {
    s @Scope
    c @byte
    o @Obj
    t @Type
  }

  Ctx struct {
    j @Token
    in @File
    locals   @Obj
    globals  @Obj
    s @Scope
  }

  J @Token
  O @Obj
  K @Ctx
  E @Node
  T @Type
  N nat
  C byte
  S @byte
  Y @FILE

  ftfn (t T s S) none

  cis  (c C    ) bit
  cisd (c C d C) bit

  tk   (k K                    ) T
  ek   (k K                ) E
  eka  (k K         a E    ) E
  ekj  (k K j J            ) E
  ekja (k K j J     a E    ) E
  eju  (j J u T            ) E
  ejua (j J u T a E        ) E
  eja  (j J     a E        ) E
  ejab (j J     a E b E    ) E
  ejul (j J u T         l N) E

  nyecl(y Y e E c N l N) N

  o_kst (k K s S t T) O

  gelfn (y Y v N) N
  geefn (y Y e E c N l N gop @(y Y) none) N
  gegfn (y Y) none
;

ftnone ftfn
ftbit  ftfn
ftbyte ftfn
ftnat  ftfn
ftstct ftfn
ftptr  ftfn
ftfunc ftfn

p2     ek
p3     ek
p5     ek
p7     ek
pmul   ek
padd   ek
psh    ek
pcmp   ek
pband  ek
pbor   ek
pland  ek
plor   ek

ptype  tk

gelit   nyecl
gesize  nyecl
gederef nyecl
geaddr  nyecl
gethe   nyecl
gecast  nyecl
geref   nyecl
gelnot  nyecl
gebnot  nyecl
geneg   nyecl
gediv   nyecl
gemod   nyecl
gee     nyecl
gene    nyecl
geb     nyecl
gebe    nyecl
gea     nyecl
geae    nyecl
geadd   nyecl
gesub   nyecl
gemul   nyecl
geband  nyecl
gebor   nyecl
gexor   nyecl
geshl   nyecl
geshr   nyecl
geelem  nyecl
gemem   nyecl
geseq   nyecl
geret   nyecl
gecond  nyecl
geland  nyecl
gelor   nyecl
geis    nyecl
gefor   nyecl
gecall  nyecl
geass   nyecl

esize  ekj
ethe   ekj
ecast  ekj
elit   ekj
eaddr  ekj
eneg   ekj
elnot  ekj
ebnot  ekj
eid    ekj
estr   ekj
ebrace ekj
eparen ekj

eas    ekja
efrom  ekja
eelem  ekja
ederef ekja
eseq   ekja
eret   ekja
emul   ekja
ediv   ekja
emod   ekja
ethen  ekja
eelse  ekja
econd  ekja
eadd   ekja
esub   ekja
eshl   ekja
eshr   ekja
eb     ekja
ea     ekja
ebe    ekja
eae    ekja
ee     ekja
ene    ekja
eband  ekja
ebor   ekja
eass   ekja
eis    ekja
efor   ekja
emem   ekja
ecall  ekja

JID  () none = (0)
JPCT () none = (0)
JSTR () none = (0)
JNUM () none = (0)

is cisd = (c == d)

issp cis = is c ' '
istb cis = is c '\t'
islf cis = is c '\n'
iscr cis = is c '\r'
is_  cis = is c '_'

isin(c C a C b C) bit = {(a <= c) then (c <= b)}

isAZ cis = isin c 'A' 'Z'
isaz cis = isin c 'a' 'z'
is09 cis = isin c '0' '9'
isaf cis = isin c 'a' 'f'

isws cis = {
   issp c else
   istb c else
   islf c else
   iscr c
}
is0f cis = {
   is09 c else
   isaf c
}
isid cis = {
   isAZ c else
   isaz c else
   is09 c else
   is_  c
}

read_ident(p S) N = {
  0 is r
  { p for q { isid q@ then &q^1 } else (r = q - p as N) '\0' }
  r
}

sw1(p S a C    ) bit = {(p^0 == a) then 1}
sw2(p S a C b C) bit = {(p^0 == a) then (p^1 == b) then 2}

read_punct(p S) N = {
  sw2 p '=' '=' else
  sw2 p '!' '=' else
  sw2 p '<' '=' else
  sw2 p '>' '=' else
  sw2 p '&' '&' else
  sw2 p '|' '|' else
  sw2 p '<' '<' else
  sw2 p '>' '>' else
  sw2 p '/' '/' else
  sw1 p '='     else
  sw1 p '<'     else
  sw1 p '>'     else
  sw1 p '+'     else
  sw1 p '-'     else
  sw1 p '*'     else
  sw1 p '/'     else
  sw1 p '&'     else
  sw1 p '|'     else
  sw1 p '@'     else
  sw1 p '#'     else
  sw1 p '{'     else
  sw1 p '}'     else
  sw1 p '('     else
  sw1 p ')'     else
  sw1 p '['     else
  sw1 p ']'     else
  sw1 p '!'     else
  sw1 p '?'     else
  sw1 p ':'     else
  sw1 p ';'     else
  sw1 p ','     else
  sw1 p '.'     else
  sw1 p '~'     else
  sw1 p '^'     else
  sw1 p '$'     else
  sw1 p '`'     else
  sw1 p '%'
}

gc (y Y c C) none = fputc cast N c y
gs (y Y s S) none = fputs s y
glf(y Y) none = gc y '\n'

gn1(y Y n N) none = { n then gn1 y (n / 10) gc y cast byte ('0' + n % 10) }
gn (y Y n N) none = { n ? (gn1 y n) (gc y '0') }

export stdout () none
cout () @FILE = (cast @@FILE &stdout)@

oc (c C) none = fputc cast N c cout
os (s S) none = fputs s cout
olf(   ) none = oc '\n'
on1(n N) none = { n then on1 (n / 10) oc cast byte ('0' + n % 10) }
on (n N) none = { n ? on1 n  oc '0' }

align(n N a N) N = ((n + a - 1) / a * a)

vdiag(in S c S line_n N p S s S) none = {
  {p for q {(c < q) then (q^-1 != '\n') then &q^-1}} is line
  os "./" os in os ":(" on line_n oc ',' on (p - line + 1) os "): " os s olf
}

diag(p S in @File s S) none = {
  1 is line
  { in.contents for p
    (p@ == '\n') then
    (line = line + 1)
    &p^1 }
  vdiag in.name in.contents line p s
  exit 1
}

jdiag(k K s S) none = {
  vdiag k.in.name k.in.contents k.j.line k.j.p s
  exit 1
}

format_type(t T) S = {
  cast S calloc 1 1 is s
  t.format@ t s
  s
}

gexpr nyecl = e.gen@ y e c l

type_equal(t T u T) bit = {
  !t else
  !u else
  t.format is c
  (t == u) else
  !!t.o ? type_equal t.o u
  !!u.o ? type_equal t u.o
  (c == u.format) then
  (c == &ftnone ) else
  (c == &ftbit  ) else
  (c == &ftbyte ) else
  (c == &ftnat  ) else
  (c == &ftptr  ) ? type_equal t.a u.a
    { (c == &ftfunc ) then
      type_equal t.a u.a then
      u.a.s is p
      t.a.s is q
      { 1b for _
        !!p then
        !!q then
        type_equal p q then
        (p = p.s)
        (q = q.s)
        1b }
      (p == q) }
}

ntype(size N align N format @(t T s S) none) T = {
  cast T calloc 1 sizeof Type is t t ret
  (t.size  = size  )
  (t.align = align )
  (t.format = format)
}

ntypea(size N align N format @(t T s S) none a T) T = {
  ntype size align format is t
  (t.a = a)
  t
}

nnone (   ) T = ntype  0 0 &ftnone
nbit  (   ) T = ntype  1 1 &ftbit
nbyte (   ) T = ntype  1 1 &ftbyte
nnat  (   ) T = ntype  8 8 &ftnat
nstct (   ) T = ntype  0 1 &ftstct
nptr  (a T) T = ntypea 8 8 &ftptr  a
nfunc (a T) T = ntypea 1 1 &ftfunc a

tree(j J t T gen @nyecl            ) E = {cast E calloc 1 sizeof Node is e e ret (e.j = j)  (e.t = t) (e.gen = gen)}
t0  (j J t T gen @nyecl            ) E = {tree j t gen}
t1  (j J t T gen @nyecl a E        ) E = {tree j t gen is e e ret (e.a   = a)}
t2  (j J t T gen @nyecl a E b E    ) E = {tree j t gen is e e ret (e.a   = a)  (e.a.s = b)}
t3  (j J t T gen @nyecl a E b E c E) E = {tree j t gen is e e ret (e.a   = a)  (e.a.s = b)  (e.a.s.s = c)}
tt  (j J t T gen @nyecl u T        ) E = {t0   j t gen is e e ret (e.t.s = u)}
to  (j J t T gen @nyecl o O        ) E = {t0   j t gen is e e ret (e.o   = o)}
tl  (j J t T gen @nyecl l N        ) E = {t0   j t gen is e e ret (e.l   = l)}

copy_type(t T) T = {
  cast T calloc 1 sizeof Type is u
  (u@ = t@)
  (u.o = t)
  u
}

ntoken(q TokenKind a S b S) J = {
  cast J calloc 1 sizeof Token is j
  (j.q = q    )
  (j.p = a    )
  (j.n = b - a)
  j
}

escape_one(c C ca C cb C) C = { (c == ca) then cb }

open_file(path S mode S) Y = {
  fopen path mode else
  os "cannot open file '" os path os "' with mode '" os mode os "': " os strerror (__errno_location)@ olf
}

read_file(path S) S = {
  calloc 1 4096 is rfbuf2
  open_file path "r" is fp
  cast S 0 is buf
  0 is buflen
  &buflen is b
  open_memstream &buf b is y
  { 1b for k
    fread rfbuf2 1 4096 fp is n
    { (n == 0) ?
        (k = 0b) 
      fwrite rfbuf2 1 n y }
    k }
  free rfbuf2
  fclose fp
  fflush y
  { {(buflen == 0) else (buf^(buflen - 1) != '\n')} then
    fputc cast N '\n' y }
  fputc 0 y
  fclose y
  buf
}

tokenize(path S in @File) J = {
  read_file path is p
  (in.name = path)
  (in.contents = p)
   cast J 0 is j
   &j is k
   {1b for _ p@ then
    {(p^0 == '/') then (p^1 == '*')}
    ?  {strstr &p^2 "*/" is q
       {!q then diag p in "unclosed block comment"}
       (p = &q^2)}
      (isws p@) ? (p = &p^1)
      {is09 p@ else {(p@ == '.') then is09 p^1}}
    ?  {{&p^1 for q isid q@ then &q^1 } is q
       (k@ = ntoken &JNUM p q)
       {k.p is p
           10 is a
           {  {!strncmp p "0x" 2 then is0f p^2}
           then (p = &p^2)
              (a = 16) }
            strtoul p &p a is v
            ( (p^0 == 'b') ? {(p = &p^1) nbit}  nnat ) is t
            (k.l = v as N )   
            (k.t = t as @none   )   
            1b}
       (k = &k.s)
       (p = q)}
      (p@ == '"')
    ?  { (k@ = {
  { &p^1 for q
    (q@ == '\\') ?
      &q^2
      { (q@ != '"') then
        { (q@ == '\0') then
          diag p in "unclosed string literal" }
        &q^1 }
   } is end
  cast S calloc 1 (end - p) is buf
  ntoken &JSTR p &end^1 is j
  (j.t = nptr nbyte)
  (j.str = buf)
  j
})
         (p = &p^k.n)
         (k = &k.s) }
      (p@ == '\'')
    ?  {(k@ = {
  &p^1 is q
  {(q@ == '\0') then diag p in "unclosed literal byte"}
  ( (q@ == '\\') ?
      { (q = &q^1)
      {(q@ == '\0') then diag p in "unclosed literal byte"}
      {
  &escape_one is f
  f@ q@ 'a' '\a' else
  f@ q@ 'b' '\b' else
  f@ q@ 'f' '\f' else
  f@ q@ 'n' '\n' else
  f@ q@ 'r' '\r' else
  f@ q@ 't' '\t' else
  f@ q@ 'v' '\v' else
  f@ q@ '\'' '\'' else
  f@ q@ '\"' '\"' else
  f@ q@ '\\' '\\' else
  '\0' ret
  (q@ != '0') then
  diag q in "invalid escape sequence"
} }
    q@
  ) is c
  (q = &q^1)
  {(q@ != '\'') then diag p in "unclosed literal byte"}
  ntoken &JNUM p &q^1 is j
  (j.l = c as N)
  (j.t = cast @none nbyte)
  j
})
       (k.l = k.l as C as N)
       (p = &p^k.n)
       (k = &k.s)}
      {0 is n
       {p for q {{isid q@ then &q^1} else cast S 0 ret (n = q - p as N)}}
       !!n
    ?  {(k@ = ntoken &JID p &p^n)
       (p = &p^k.n)
       (k = &k.s)}
      {read_punct p is n
       !!n
    ?  {(k@ = ntoken &JPCT p &p^n)
       (p = &p^k.n)
       (k = &k.s)}
      diag p in "invalid token" }}}
  1 is n
  j ret
  in.contents for p
  !!p@ then
  !!j then
  { (p == j.p) then
    (j.line = n)
    (j = j.s) }
  { (p@ == '\n') then
    (n = n + 1) }
  &p^1
}

push_scope  (k K c S    ) @Scope = {
  cast @Scope calloc 1 sizeof Scope is s
  (s.c = c)
  (s.s = k.s)
  (k.s = s)
  s
}

try_search_scope(k K c S n N) @Scope = {
  cast @Scope 0 is r
  { !!k.s then
    k.s for s
    {(n != strlen s.c ) else !!strncmp s.c c n} ?
      s.s 
    {(r = s)
    cast @Scope 0 }}
  r
}

search_scope(k K c S n N) @Scope = {
  try_search_scope k c n else
  jdiag k "lookup failed"
}

nvar o_kst = {
  cast O calloc 1 sizeof Obj is o
  (o.name = s) 
  (o.t = t) 
  ((push_scope k s).o = o) 
  o
}

nbetvar o_kst = {
  nvar k s t is o
  (o.is_local = 1b)
  o
}

nlvar o_kst = {
  nvar k s t is o
  (o.is_local = 1b)
  (o.s = k.locals)
  (k.locals = o)
  o
}

ngvar o_kst = {
  nvar k s t is o
  (o.s = k.globals)
  (o.is_definition = 0b)
  (k.globals = o)
  o
}

nstr (k K j J t T) O = {
  cast S 0 is s2
  cast N 0 is n
  open_memstream &s2 &n is y
  gs y ".s" gn y cast nat j
  fclose y
  ngvar k s2 t is o
  (o.j = j)
  (o.is_definition = 1b)
  o
}

id(k K) S = {
  { !!k.j then
    (k.j.q != &JID) then
    jdiag k "expected <id>" }
  strndup k.j.p k.j.n
}

get_struct_member(t T j J) T = {
  cast T 0 is r
  { t.a for g
    {(g.name.n == j.n) then !strncmp g.name.p j.p j.n}
    ? {(r = g)
      cast T 0}
    g.s }
  r
}

jadv   (k K    ) J    = {k.j ret (k.j = k.j.s)}
jeq    (k K c S) bit  = {!!k.j then !memcmp cast @none k.j.p cast @none c cast N k.j.n then !c^k.j.n}
expect (k K c S) none = {{!jeq k c then jdiag k "unexpected"} jadv k}
consume(k K c S) bit  = {jeq k c is r {r then jadv k} r}

declarator (k K t T) none = {
  jadv k is j
  ptype k is u
  (t@ = u@)
  (t.o = u)
  (t.name = j)
}

struct_decl tk = {
  nstct is t
  expect k "{"
  &t.a is u
  { 1b for _ 
     !consume k "}" then
      cast T calloc 1 sizeof Type is g
      declarator k g
      (u@ = g)
      (u = &u.s) }
  0 is bits
  { !!t.a then
    t.a for g
    (bits = align bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    {(t.align < g.align) then (t.align = g.align)}
    g.s }
  (t.size = align bits (t.align * 8) / 8)
  t
}

func_params tk = {
  cast T 0 is params
  &params is u
  { 1b for _
    !jeq k ")" then
    !jeq k "}" then
    (u@ = cast T calloc 1 sizeof Type)
    declarator k u@
    (u = &u.s)
    1b }
  jadv k
  nfunc ptype k is t
  (t.params = params)
  t
}

ptype tk = (
  consume k "none"   ? nnone               
  consume k "bit"    ? nbit                
  consume k "byte"   ? nbyte               
  consume k "nat"    ? nnat                
  consume k "@"      ? nptr        ptype k 
  consume k "("      ? func_params       k 
  consume k "struct" ? struct_decl       k 
  { search_scope k k.j.p k.j.n is s
    jadv k
    s.t }
)

pj(k K     q TokenKind e @ekj ) E = {(k.j.q == q) then jadv k is j e@ k j}
pl(k K     c S         e @ekj ) E = {jeq k c then jadv k is j e@ k j  }
pr(k K a E c S         e @ekja) E = {jeq k c then jadv k is j e@ k j a}
pu(k K a E c S         e @ekja) E = (consume k c ? a e@ k k.j a)

pcast eka = {
  pr k a "as"   &eas    else
  pr k a "from" &efrom
}

p1a    ek  = { pj k &JID  &eid  else
               pj k &JSTR &estr else
               pj k &JNUM &elit              }
p3a    eka = { (a.t.format == &ftfunc) then ecall k k.j a }

p4a    eka = { pr    k a "?"    &econd      }
p5a    eka = { pr    k a "ret"  &eret  else
               pr    k a "is"   &eis   else
               pr    k a "for"  &efor  else
               pr    k a "then" &ethen else
               pr    k a "else" &eelse else
               pu    k a "}"    &eseq       }
pmula  eka = { pr    k a "*"    &emul  else
               pr    k a "/"    &ediv  else
               pr    k a "%"    &emod       }
padda  eka = { pr    k a "+"    &eadd  else
               pr    k a "-"    &esub       }
psha   eka = { pr    k a "<<"   &eshl  else
               pr    k a ">>"   &eshr       }
pcmpa  eka = { pr    k a "<"    &eb    else
               pr    k a ">"    &ea    else
               pr    k a "<="   &ebe   else
               pr    k a ">="   &eae   else
               pr    k a "=="   &ee    else
               pr    k a "!="   &ene        }
pbanda eka = { pr    k a "&"    &eband      }
pbora  eka = { pr    k a "|"    &ebor       }
p7a    eka = { pcast k a                    }

p2 ek = {
  pl k "&"      &eaddr else
  pl k "-"      &eneg  else
  pl k "!"      &elnot else
  pl k "~"      &ebnot else
  pl k "cast"   &ecast else
  pl k "the"    &ethe  else
  pl k "sizeof" &esize else
  { consume k "(" ?
      { { p7    k for a
          pr    k a "=" &eass else
          pcast k a
        } ret
        expect k ")"                     }
    pl  k "{"  &ebrace else
    p1a k else
    jdiag k "expected an expression"
  } for a
  pr    k     a "^"       &eelem   else
  pr    k     a "."       &emem   else
  pr    k     a "@"       &ederef
}

p3    ek = { p2    k for a p3a    k a }
p4    ek = { p3    k for a p4a    k a }
p5    ek = { p4    k is  a p5a    k a }
pmul  ek = { p4    k for a pmula  k a }
padd  ek = { pmul  k for a padda  k a }
psh   ek = { padd  k for a psha   k a }
pcmp  ek = { psh   k for a pcmpa  k a }
pband ek = { pcmp  k for a pbanda k a }
pbor  ek = { pband k for a pbora  k a }
p7    ek = { pbor  k for a pcast  k a }

typedecl(k K) J = {
  k.j for j
  !consume k ";" then
  push_scope k id k is s
  (s.t = cast T calloc 1u sizeof Type)
  declarator k s.t
  k.j
}

create_lvars(k K t T) none = {
  !!t then
  create_lvars k t.s
  k.j is j
  (k.j = t.name)
  nlvar k id k t
  (k.j = j)
}

find_func(k K c S n N) O = {
  try_search_scope k c n is s
  {!!s then !!s.o then (s.o.t.format == &ftfunc) then s.o}
}

function(k K) none = {
  cast T calloc 1u sizeof Type is t
  consume k "export" is is_export
  declarator k t
  find_func k t.name.p cast N t.name.n is o
  ( !!o ?
    { {(o.t.format != &ftfunc)      then jdiag k "redeclared as a different type of symbol" }
      {o.is_definition then jeq k "=" then jdiag k "redefinition" }
      {(o.is_export != is_export )  then jdiag k "mismatched visibility" } }
    { k.j is j
       (k.j = t.name)
       (o = ngvar k id k t)
       (k.j = j)
       (o.is_export = is_export) } )
  { consume k "=" then
    (o.is_definition = 1b)
    (k.locals = cast O 0)
    k.s is s
    create_lvars k t.params
    (o.params = k.locals)
    (o.body = cast @none p4 k)
    (o.locals = k.locals)
    (k.s = s) }
}

parse(j J in @File) O = {
  cast @Ctx calloc 1ul sizeof Ctx is k
  (k.j = j)
  (k.in = in)
  { !!k.j then
    k.j for j
    ( consume k "type" ?
        &typedecl 
      &function
    )@ k
    k.j }
  k.globals
}

argreg1(d N) S = {
  (d == 0) ? "%dil"
  (d == 1) ? "%sil"
  (d == 2) ? "%dl"
  (d == 3) ? "%cl"
  (d == 4) ? "%r8b"
             "%r9b"
}

argreg8(d N) S = {
  (d == 0) ? "rdi"
  (d == 1) ? "rsi"
  (d == 2) ? "rdx"
  (d == 3) ? "rcx"
  (d == 4) ? "r8"
             "r9"
}

gtreg(y Y s S        ) none = { gc y '%' gs y s }
gt0  (y Y s S        ) none = { gs y s glf y }
gt1  (y Y s S a S    ) none = { gs y s gc y ' ' gtreg y a glf y }
gt2  (y Y s S a S b S) none = { gs y s gc y ' ' gtreg y a gc y ',' gtreg y b glf y }

gtz (y Y a S) none = gt2 y "xor"  a a
gtcz(y Y a S) none = gt2 y "test" a a

gtlit(y Y l N a S) none = (!!l ? { gs y "mov $" gn y l gs y ",%rax" glf y }  gtz y "eax")

gtnot(y Y     a S) none = gt1 y "not" a
gtneg(y Y     a S) none = gt1 y "neg" a
gmul (y Y     a S) none = gt1 y "mul" a
gdiv (y Y    ) none = { gtz y "edx" gt1 y "div" "rdi" }
gmod (y Y    ) none = { gdiv y
                        gs y "mov %rdx,%rax" glf y }
gshx (y Y x C) none = { gs y "mov %dil,%cl" glf y
                        gs y "sh" gc y x gs y " %cl,%rax" glf y }

gadd (y Y a S b S) none = gt2 y "add" a b
gsub (y Y a S b S) none = gt2 y "sub" a b
gand (y Y a S b S) none = gt2 y "and" a b
gor  (y Y a S b S) none = gt2 y "or"  a b
gxor (y Y a S b S) none = gt2 y "xor" a b
gcmp (y Y a S b S) none = gt2 y "cmp" a b
gshr (y Y) none = gshx y 'r'
gshl (y Y) none = gshx y 'l'

gpromote(y Y b S) none = (gt2 y "movzbl" "al" b)

gsetf     (y Y s S     b S    ) none = { gs y "set" gs y s gs y " %al" glf y gpromote y b }
gcmp_setf (y Y s S a S b S c S) none = { gcmp y a b gsetf y s c }
gcmpz_setf(y Y s S a S b S    ) none = { gtcz y a gsetf y s b }
glnot     (y Y     a S b S    ) none = { gcmpz_setf y "e" a b }

gj        (y Y e E l S    ) none = { gs y "jmp " gs y l gn y cast nat e gc y '$' glf y }
gjc       (y Y e E l S s S) none = { gs y "j" gs y s gc y ' ' gs y l gn y cast nat e gc y '$' glf y }
glabel    (y Y e E l S    ) none = { gs y l gn y cast nat e gs y "$:" glf y }

gje  (y Y e E l S) none = gjc y e l "e"
gjne (y Y e E l S) none = gjc y e l "ne"
gjb  (y Y e E l S) none = gjc y e l "b"
gjbe (y Y e E l S) none = gjc y e l "be"
gja  (y Y e E l S) none = gjc y e l "a"
gjae (y Y e E l S) none = gjc y e l "ae"

ge  (y Y) none = gcmp_setf y "e"  "rdi" "rax" "eax"
gne (y Y) none = gcmp_setf y "ne" "rdi" "rax" "eax"
gb  (y Y) none = gcmp_setf y "b"  "rdi" "rax" "eax"
gbe (y Y) none = gcmp_setf y "be" "rdi" "rax" "eax"
ga  (y Y) none = gcmp_setf y "a"  "rdi" "rax" "eax"
gae (y Y) none = gcmp_setf y "ae" "rdi" "rax" "eax"

gcast(y Y a T b T) none = (
  (b.format == &ftnone) ?  gtz    y "eax"
  { (b.format == &ftbyte) then
    gpromote y "eax" }
)

gfpush(y Y c @N  l N ) none = { !!l then gs y "sub $" gn y (l << 3)  gc y ',' gtreg y "rsp" glf y (c@ = c@ + l) }
gfpop (y Y c @N  l N ) none = { !!l then gs y "add $" gn y (l << 3)  gc y ',' gtreg y "rsp" glf y (c@ = c@ - l) }
gpush (y Y c @N      ) none = { gs y "push " gtreg y "rax" glf y    (c@ = c@ + 1) }
gpop  (y Y c @N  s S ) none = { gs y "pop " gtreg y s     glf y    (c@ = c@ - 1) }
gindex(y Y       l N ) none = { !!l then gs y "add $" gn y l gc y ',' gtreg y "rax" glf y }

gaddr(y Y q @ftfn n N s S d S) none = {gs y "lea " gn y n gs y "(%r" gs y s gs y "),%r" gs y d glf y}
gload(y Y q @ftfn n N s S d S) none = (
  {(q == &ftstct) else (q == &ftfunc)} ?
    gaddr y q n s d 
  {(q == &ftbyte) else (q == &ftbit)} ?
    {gs y "movzbl " gn y n gs y "(%r" gs y s gs y "),%e" gs y d glf y}
  {gs y "mov " gn y n gs y "(%r" gs y s gs y "),%r" gs y d glf y}
)

gaddrg(y Y e E c @N d S) none = { gs y "lea " gs y e.o.name gs y ",%r" gs y d glf y }

gaddrl(y Y e E c @N d S) none = { gaddr y e.o.t.format (e.o.sp ? ((c@ - e.o.sp) << 3)  (e.o.offset + (c@ << 3))) "sp" d }
gloadl(y Y e E c @N d S) none = { gload y e.o.t.format (e.o.sp ? ((c@ - e.o.sp) << 3)  (e.o.offset + (c@ << 3))) "sp" d }

gloadsp(y Y q @ftfn d S) none = (
  (q == &ftstct) ?
    { gs y "mov %rsp,%r" gs y d glf y }
  {(q == &ftbyte) else (q == &ftbit)} ?
    { gs y "movzbl (%rsp), %e" gs y d glf y }
  { gs y "mov (%rsp),%r" gs y d glf y }
)

gstoresp(y Y t T) none = {
  {(t.format == &ftbyte) else (t.format == &ftbit)} ?
    {gs y "mov %al,(%rsp)" glf y}
  {gs y "mov %rax,(%rsp)" glf y}
}

gstore(y Y t T c @N) none = {
  gpop y c "rdi"
  (t.format == &ftstct) ?
    { 0 for i
      (i < t.size) then
      (i + 1) ret
      gs y "mov " gn y i gs y "(%rax),%r8b" glf y
      gs y "mov %r8b," gn y i gs y "(%rdi)" glf y }
  {(t.format == &ftbyte) else (t.format == &ftbit)} ?
    {gs y "mov %al,(%rdi)" glf y}
  {gs y "mov %rax,(%rdi)" glf y}
}

glet(y Y o O c @N) none = {
  gfpush y c 1
  (o.sp = c@)
  gstoresp y o.t
}

gulet(y Y o O c @N d S) none = {
  gloadsp y o.t.format d
  gfpop y c 1
}

gdrop (y Y e E c N    ) none = { cast none gexpr y e c 0 }
geval (y Y e E c N l N) none = {
  gexpr y e c l is l1
  !!l1 then
  l1 for l2
  gload y ({(l2 == 1) then (l == 0)} ? e.t.format  &ftptr) 0 "ax" "ax"
  (l2 - 1)
}

gdata(y Y o O) none = {
  gs y ".data" glf y
  gs y o.name gc y ':' glf y
  gs y ".string \""
  &o.j.p^1 is a
  &o.j.p^(o.j.n - 1) is b
  { a for i
    (i < b) then
    gc y i@
    &i^1 }
  gs y "\""
  glf y
}

gtext(y Y o O) none = {
  { !!o.params then
    16 is t
     0 is g
    o.params for o
    { (g > 6) then
      (t        = align t 8)
      (o.offset = t           )
      (t        = t + o.t.size)
      (g        = g + 1       ) }
    o.s }
  0 is c
  { !!o.locals then
    o.locals for o
    { !o.offset then
      (c = c + o.t.size)
      (c = align c o.t.align)
      (o.offset = -c) }
    o.s }
  (c = align c 16)
  gs y ".text" glf y
  gs y o.name gc y ':' glf y
  gs y "enter $" gn y c gs y ",$0" glf y
  { 0 is d
    o.params for o
    !!o then
    o.s ret
    (o.offset > (-1 >> 1)) then
    o.t is t
    ( (t.size == 1) ?
        {gs y "mov " gs y argreg1 d gc y ',' gn y (o.offset + c) gs y "(%rsp)" glf y} 
      {gs y "mov %" gs y argreg8 d gc y ',' gn y (o.offset + c) gs y "(%rsp)" glf y} )
    (d = d + 1) }
  (c = c >> 3)
  gdrop y cast E o.body c
  gt0 y "leave"
  gt0 y "ret"
}

export main(argc N argv @S) N = {
  open_file argv^2 "w" is y cast @File calloc 1 sizeof File is in !y ? 1 
  {parse tokenize argv^1 in in for o
    { !!o.is_definition then
      gs y "." gs y (!o.is_export ? "local"  "globl") gc y ' ' gs y o.name glf y
      ((o.t.format == &ftfunc) ? &gtext  &gdata)@ y o }
    o.s }
  fclose y
  0
}

ge0     gelfn = {
  gtlit  y v "rax"
  0
}

ge1     geefn = {
  geval y e.a c 0
  gop@  y
  0
}

ge2     geefn = {
  geval y e.a.s  c 0
  gpush y       &c
  geval y e.a    c 0
  gpop  y       &c "rdi"
  gop@  y
  0
}

gegadd  gegfn = gadd  y "rdi" "rax"
gegsub  gegfn = gsub  y "rdi" "rax"
gegand  gegfn = gand  y "rdi" "rax"
gegor   gegfn = gor   y "rdi" "rax"
gegxor  gegfn = gxor  y "rdi" "rax"
gegcmp  gegfn = gcmp  y "rdi" "rax"
gegbnot gegfn = gtnot y "rax"
gegneg  gegfn = gtneg y "rax"
geglnot gegfn = glnot y "rax" "eax"
gegmul  gegfn = gmul  y "rdi"
gegdiv  gegfn = gdiv  y
gegmod  gegfn = gmod  y
gegshr  gegfn = gshr  y
gegshl  gegfn = gshl  y
gege    gegfn = ge    y
gegne   gegfn = gne   y
gegb    gegfn = gb    y
gegbe   gegfn = gbe   y
gega    gegfn = ga    y
gegae   gegfn = gae   y

/* oddballs */

eid    ekj  = { (search_scope k j.p j.n).o is o to j o.t &geref o }
estr   ekj  = { nstr k j cast T j.t is o to j o.t &geref o }

/* fundamentals */

ebrace ekj  = p5 k
eparen ekj  = p7 k

elit    ekj    = tl j cast T j.t &gelit j.l
gelit   nyecl  = ge0 y e.l

esize   ekj   = tt j nnat &gesize ptype k
gesize  nyecl = ge0 y e.t.s.size

ederef  ekja  = t1 j a.t.a &gederef a
gederef nyecl = (gexpr y e.a c 0 + 1 - l)

eaddr   ekj   = { p2 k is a t1 j nptr a.t &geaddr a }
geaddr  nyecl = gexpr y e.a c 1

efrom   ekja  = t1 j ptype k &gethe a
ethe    ekj   = { ptype k is u p4 k is a t1 j a.t &gethe a }
gethe   nyecl = gexpr y e.a c l

eas     ekja  = t1 j ptype k &gecast a
ecast   ekj   = { ptype k is u t1 j u &gecast p4 k }
gecast  nyecl = {
  geval y e.a c 0
  gcast y e.a.t e.t
  0
}

geref   nyecl = {
  (e.o.is_local ? (!l ? &gloadl &gaddrl) &gaddrg)
  @ y e &c "ax"
  0
}

/* arithmetic operations */

elnot  ekj   = t1 j nbit &gelnot p3 k
gelnot nyecl = ge1 y e c l &geglnot

ebnot  ekj   = t1 j nnat &gebnot p3 k
gebnot nyecl = ge1 y e c l &gegbnot

eneg   ekj   = t1 j nnat &geneg p3 k
geneg  nyecl = ge1 y e c l &gegneg

ediv   ekja  = t2 j nnat &gediv a p4 k
gediv  nyecl = ge2 y e c l &gegdiv

emod   ekja  = t2 j nnat &gemod a p4 k
gemod  nyecl = ge2 y e c l &gegmod

ee     ekja  = t2 j nbit &gee a psh k
gee    nyecl = ge2 y e c l &gege

ene    ekja  = t2 j nbit &gene a psh k
gene   nyecl = ge2 y e c l &gegne

eae    ekja  = t2 j nbit &geae a psh k
geae   nyecl = ge2 y e c l &gegae

ea     ekja  = t2 j nbit &gea a psh k
gea    nyecl = ge2 y e c l &gega

eb     ekja  = t2 j nbit &geb a psh k
geb    nyecl = ge2 y e c l &gegb

ebe    ekja  = t2  j nbit &gebe a psh k
gebe   nyecl = ge2 y e c l &gegbe

eadd   ekja  = t2 j nnat &geadd a pmul k
geadd  nyecl = ge2 y e c l &gegadd

esub   ekja  = t2 j nnat &gesub a pmul k
gesub  nyecl = ge2 y e c l &gegsub

emul   ekja  = t2 j nnat &gemul a p4 k
gemul  nyecl = ge2 y e c l &gegmul

eband  ekja  = t2 j nnat &geband a pcmp k
geband nyecl = ge2 y e c l &gegand

ebor   ekja  = t2 j nnat &gebor a pband k
gebor  nyecl = ge2 y e c l &gegor

eshl   ekja  = t2 j nnat &geshl a padd k
geshl  nyecl = ge2 y e c l &gegshl

eshr   ekja  = t2 j nnat &geshr a padd k
geshr  nyecl = ge2 y e c l &gegshr

/* pointer magic */

eelem  ekja = t2 j a.t.a &geelem a p3 k
geelem nyecl  = {
  geval y e.a    c 0
  gpush y       &c
  geval y e.a.s  c 0
  gpop  y       &c "rdx"
  gs y "lea (%rdx,%rax," gn y e.a.t.a.size gs y "),%rax" glf y
  (1 - l)
}

emem  ekja  = {
  jadv k
  { a.t for t (t.format == &ftptr) then t.a } is t
  { (t.format != &ftstct) then jdiag k "not a struct"}
  get_struct_member t j.s is g
  { !g then jdiag k "no such member" }
  t1 j.s g &gemem a
}

gemem   nyecl = {
  geval y e.a c 0
  { e.a.t for t
    (t.format == &ftptr) then
    t.a ret
    gload y t.a.format 0 "ax" "ax" }
  gindex y e.t.offset
  (1 - l)
}

/* sequencing */

eseq   ekja  = { p5 k is b t2 j b.t &geseq a b}
geseq  nyecl = {
  gdrop y e.a   c
  geval y e.a.s c l
  0
}

eret  ekja  = t2 j a.t &geret a p5 k
geret nyecl = {
  geval y e.a    c l
  gpush y       &c
  gdrop y e.a.s  c
  gpop  y       &c "rax"
  0
}

econd  ekja = {p4 k is b t3 j b.t &gecond a b p4 k}
gecond nyecl  = {
  geval  y e.a     c 0
  gtcz   y           "eax"
  gje    y e         "a"
  geval  y e.a.s   c l
  gj     y e         "b"
  glabel y e         "a"
  geval  y e.a.s.s c l
  glabel y e         "b"
  0
}

ethen  ekja  = { p5 k is b t2 j b.t &geland a b }
geland nyecl = {
  (e.a.s.t.format == &ftnone) is keep
  geval y e.a c 0
  gtcz y "eax"
  gje   y e         "a"
  { keep then
    gpush y       &c      }
  geval y e.a.s c 0
  { keep then
    gpop  y       &c "rax" }
  glabel y e        "a"
  0
}

eelse  ekja  = t2 j a.t &gelor a p5 k
gelor  nyecl = {
  (e.a.s.t.format == &ftnone) is keep
  geval   y e.a   c 0
  gtcz   y "eax"
  gjne    y e       "a"
  { keep then
    gpush y       &c      }
  geval   y e.a.s c 0
  { keep then
    gpop  y       &c "rax" }
  glabel  y e       "a"
  0
}

eis    ekja = {k.s is s nbetvar k id k a.t is o jadv k p5 k is b { t2 j b.t &geis a b is e (e.o = o) e } ret (k.s = s)}
geis    nyecl = {
  geval  y e.a    c 0
  glet   y e.o   &c
  geval  y e.a.s  c l
  gulet  y e.o   &c "dx"
  0
}

efor   ekja = {k.s is s nbetvar k id k a.t is o jadv k p5 k is b { t2 j b.t &gefor  a b is e (e.o = o) e } ret (k.s = s)}
gefor  nyecl  = {
  geval    y e.a    c 0
  glet     y e.o   &c
  gj       y e        "b"
  glabel   y e        "a"
  gstoresp y e.a.t
  glabel   y e        "b"
  geval    y e.a.s  c 0
  gtcz     y          "eax"
  gjne     y e        "a"
  gulet    y e.o   &c "ax"
  0
}

gargs(y Y e E c @N d N) none =
{ !!e
then{  (d < 6)
  then gargs y e.s c (d + 1) }
   geval y e c@ 0
   gpush y c }

ncall       eja  = t1 j a.t.a    &gecall    a
ecall ekja = {
  a.t.params is u
  { a for b
     !!u then
      (b.s = p3 k)
      { !type_equal b.s.t u then jdiag k "asymmetric argument" }
      (u = u.s)
      b.s }
  ncall k.j a
}

gecall nyecl = {
  c is c1
  gargs y e.a.s &c 0
  geval y e.a    c 0
  0 is d
  { !!e.a.s then
    e.a.s for e
    (d < 6) then
    gpop y &c argreg8 d
    (d = d + 1)
    e.s }
  gs y "call *%rax" glf y
  gfpop y &c (c - c1)
  0
}

/* ass */

eass   ekja  = t2 j nnone &geass a p7 k
geass  nyecl = {
  geval  y e.a    c 1
  gpush  y       &c
  geval  y e.a.s  c 0
  gstore y e.a.t &c
  gtz    y         "eax"
  0
}

ftnone ftfn = strcat s "none"
ftbit  ftfn = strcat s "bit"
ftbyte ftfn = strcat s "byte"
ftnat  ftfn = strcat s "nat"
ftstct ftfn = strcat s "struct"
ftptr  ftfn = {strcat s "@"  ret t.a.format@ t.a s}
ftfunc ftfn = {strcat s "("  ret
              {t.a.s for p !!p then p.s ret p.format@ p s }
                         strcat s ")"  ret t.a.format@ t.a s}