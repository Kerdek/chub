type
  va_list struct {}
  FILE    struct {}
;

export __errno_location    ( ) @nat ;

export open_memstream      (p    @@byte n    @nat) @FILE ;
export fopen               (path  @byte mode @ byte ) @FILE ;

export fclose              (io @FILE) nat ;
export fflush              (io @FILE) nat ;

export fread               (ptr @none m nat n nat io @FILE) nat ;
export fwrite              (ptr @none m nat n nat io @FILE) nat ;
export fputc               (c nat io @FILE) nat ;

export printf              (         fmt @byte ...          ) nat ;
export vprintf             (         fmt @byte args @va_list) nat ;
export fprintf             (io @FILE fmt @byte ...          ) nat ;
export vfprintf            (io @FILE fmt @byte args @va_list) nat ;

export exit                (status nat) none ;

export calloc              (m nat  n nat) @none ;
export free                (p @none) none ;

export memcmp              (p @none q @none n nat) nat ;

export strtoul             (p @byte q @@byte  b  nat) nat ;
export strcat              (p @byte q  @byte        ) @byte  ;
export strstr              (p @byte q  @byte        ) @byte  ;
export strcmp              (p @byte q  @byte        )  nat ;
export strncmp             (p @byte q  @byte  n nat)  nat ;
export strndup             (p @byte         n nat) @byte  ;
export strlen              (p @byte               ) nat ;

export strerror            (errnum  nat) @byte ;

/* end preamble */

type
  NodeKind enum
    EADD       ESUB     EMUL     EDIV       ETHE
    ENEG       EMOD     EBAND  EBOR     EBXOR
    ESHL       ESHR     EEQ      ENE        ELT
    ELE        EGT      EGE      EASS    ECOND
    ESEQ     EMEM  EADDR    EDEREF     ELNOT
    EBNOT    ELAND  ELOR   ETHEN      ECALL
    EIS       EVAR     ELIT     ECAST      EZ
    EFOR    ESIZE    EALIGN   EELEM      ENEW
  ;

  TypeKind enum
    TY_VOID    TY_BOOL    TY_BYTE
    TY_INT     TY_FUNC    TY_ARRAY
    TY_ENUM    TY_STRUCT  TY_PTR
    TY_NAT
  ;

  TokenKind enum
    TK_ID  TK_PCT
    TK_KEY TK_STR TK_NUM
  ;

  File struct {
    name         @byte
    contents     @byte
  }

  Token struct {
    q           TokenKind
    s          @same
    l           nat
    loc        @byte
    n          nat
    t          @none
    str        @byte
    in         @File
    line_no     nat
  }

  Type struct  {
    q          TypeKind
    size          nat
    align         nat
    offset        nat
    n             nat
    s            @same
    o            @same
    a            @same
    params       @same
    name         @Token
    is_variadic   bit
  }

  Obj struct {
    s               @same
    name            @byte
    t               @Type
    j               @Token
    offset           nat
    is_local         bit
    is_definition    bit
    is_export        bit
    init_data       @byte
    params          @same
    body            @none
    locals          @same
    va_area         @same
    sp nat
  }

  Node struct {
    s @same
    a @same
    q  NodeKind
    j @Token
    t @Type
    o @Obj
    l  nat
  }

  Scope struct {
    s @same
    c @byte
    o @Obj
    t @Type
    v  nat
  }

  VarAttr struct {
    is_type    bit
    is_export  bit
  }

  Ctx struct {
    j @Token
    locals         @Obj
    globals        @Obj
    s @Scope
    t @Type
    n  nat
  }

  J @Token
  O @Obj
  K @Ctx
  E @Node
  T @Type
  N nat
  C byte
  S @byte
  Y @FILE
;

type cis  (c C        ) bit;

issp cis = (' '  == c)
istb cis = ('\t' == c)
islf cis = ('\n' == c)
iscr cis = ('\r' == c)
is_  cis = ('_'  == c)

isin(c C a C b C) bit =
((a <= c) && (c <= b))

isAZ cis = isin c 'A' 'Z'
isaz cis = isin c 'a' 'z'
is09 cis = isin c '0' '9'
isaf cis = isin c 'a' 'f'

isws cis =
(  issp c
|| istb c
|| islf c
|| iscr c )
is0f cis =
(  is09 c
|| isaf c )
isid cis =
(  isAZ c
|| isaz c
|| is09 c
|| is_  c )


read_ident(p S) N =
(  0 is r
   cast none (p for q ((isid q@ && &q^1) || '\0' ret (r = q - p as N)))
   r )

startswith(p S q S) bit =
(  1b is r
  cast none (  1b for _
    (  !q@
    ?  0b
    :  (p@ != q@)
    ?  (r = 0b)
       0b
    :  (p = &p^1)
       (q = &q^1)
       1b ) )
   r )

read_punct(p S) N =
(  &startswith is f
  (  f@ p "..." ) ? 3 :
  (  f@ p "=="
  || f@ p "!="
  || f@ p "<="
  || f@ p ">="
  || f@ p "&&"
  || f@ p "||"
  || f@ p "<<"
  || f@ p ">>" ) ? 2 :
  (  f@ p "=" 
  || f@ p "<"
  || f@ p ">"
  || f@ p "+"
  || f@ p "-"
  || f@ p "*"
  || f@ p "/"
  || f@ p "&"
  || f@ p "|"
  || f@ p "@"
  || f@ p "#"
  || f@ p "{"
  || f@ p "}"
  || f@ p "("
  || f@ p ")"
  || f@ p "["
  || f@ p "]"
  || f@ p "!"
  || f@ p "?"
  || f@ p ":"
  || f@ p ";"
  || f@ p ","
  || f@ p "."
  || f@ p "~"
  || f@ p "^"
  || f@ p "$"
  || f@ p "`"
  || f@ p "%" ) ? 1 : 0 )

ptype(k K) T ;

maxl (a N b N) N = ((a > b) ? a : b)
minl (a N b N) N = ((a < b) ? a : b)
maxul(a N b N) N = ((a > b) ? a : b)
minul(a N b N) N = ((a < b) ? a : b)

align_to(n N a N) N = ((n + a - 1) / a * a)

vdiag(in S c S line_n N p S fmt S args @va_list) none =
(  (p for q ((c < q) && (q^-1 != '\n') && &q^-1)) is line
   (p for q (!!q@  && (q@ != '\n') && &q^1)) is end
   (printf "./%s:(%ld,%ld): " in line_n (cast N (p - line) + 1)) is indent
   (cast none printf "%.*s\n%*s^ " (end - line) line ((p - line as N) + indent) "")
    cast none vprintf fmt args
   (cast none printf "\n") )

diag(p S in @File fmt S ...) none =
(  1 is line_no
   (in.contents for p (&p^1 ret ((p@ == '\n') && (line_no = line_no + 1) as none)) as none)
   vdiag in.name in.contents line_no p fmt cast @va_list __va_area__
   exit 1 )

jdiag(j J fmt S ...) none =
(  vdiag j.in.name j.in.contents j.line_no j.loc fmt cast @va_list __va_area__
   exit 1 )

ntype(q TypeKind size N align N) T = (
  cast T calloc 1 sizeof Type is t t ret
  (t.q     = q     )
  (t.size  = size  )
  (t.align = align )
)

format_type_b(q1 TypeKind q2 TypeKind s1 S s2 S) bit =
((q1 == q2) && strcat s1 s2)

format_type_a(t T s S) none =
(  &strcat        is f
   &format_type_a is a
   &format_type_b is b
   t.q            is q
   !t ? strcat              s "null"
: (  b@ q TY_VOID           s "none"
  || b@ q TY_BOOL           s "bit"
  || b@ q TY_BYTE           s "byte"
  || b@ q TY_NAT            s "nat"
  || b@ q TY_ENUM           s "enum"
  || b@ q TY_STRUCT         s "struct"
  || ( q == TY_ARRAY ) ? f@ s "^"      ret a@ t.a s :
     ( q == TY_PTR   ) ? f@ s "@"      ret a@ t.a s :
     ( q == TY_FUNC  ) ? f@ s "("      ret
              (t.a.s for p (!!p && p.s ret a@ p   s ) as none)   
                         f@ s ")"      ret a@ t.a s :
                         f@ s "???"

  as none ) )

format_type(t T) S =
(  cast S calloc 1 1 is s s
ret format_type_a t s )

type_equal(t T u T) bit =
(  !!t
&& !!u
&& t.q is c
  (  (t == u)
  ||(
      !!t.o ? type_equal t.o u
    : !!u.o ? type_equal t u.o
    : (  (c == u.q)
      &&(  (c == TY_VOID)
        || (c == TY_BOOL)
        || (c == TY_BYTE)
        || (c == TY_INT)
        || (c == TY_NAT)
        || (c == TY_FUNC)
          ?  !type_equal t.a u.a
          ?  0b
          :  u.a.s is p
             t.a.s is q (1b for _ (!!p && !!q && type_equal p q && (p = p.s)    (q = q.s) ) as none)
             (p == q)
          :  (c == TY_ARRAY)
          ?  !type_equal t.a u.a
          ?  0b
          :  (t.n == u.n)
          :  (c == TY_PTR)
          ?  type_equal t.a u.a
          :  0b ) ) ) ) )

nnull () T = cast T 0
nnone () T = ntype TY_VOID 1 1
nbit  () T = ntype TY_BOOL 1 1
nbyte () T = ntype TY_BYTE 1 1
nnat  () T = ntype TY_NAT  8 8

copy_type(t T) T =
(  cast T calloc 1 sizeof Type is u u
ret (u@ = t@)
   (u.o = t) )

nptr   (a T    ) T = (ntype TY_PTR    8            8       is t t ret (t.a = a)             )
func_of  (a T    ) T = (ntype TY_FUNC   1            1       is t t ret (t.a = a)             )
array_of (a T n N) T = (ntype TY_ARRAY  (a.size * n) a.align is t t ret (t.a = a)    (t.n = n))
struct_of(       ) T =  ntype TY_STRUCT 0            1

ntoken(q TokenKind a S b S in @File) J =
(  cast J calloc 1 sizeof Token is j j
ret (j.q   = q    )
   (j.loc = a    )
   (j.n   = b - a)
   (j.in  = in   ) )

escape_one(c C ca C cb C) C =
((c == ca) && cb)

escape(c S in @File) C =
(  &escape_one is f
  (  f@ c@ 'a' '\a'
  || f@ c@ 'b' '\b'
  || f@ c@ 'f' '\f'
  || f@ c@ 'n' '\n'
  || f@ c@ 'r' '\r'
  || f@ c@ 't' '\t'
  || f@ c@ 'v' '\v'
  || f@ c@ 'p' '\p'
  || f@ c@ 'q' '\q'
  || f@ c@ 's' '\s'
  || '\0'
  ret ((c@ != '0') && (diag c in "invalid escape sequence") as none) ) )

string_literal(in @File start S quote S) J =
( (  &quote^1 for q
    (  (q@ != '"')
    && &q^1
    ret ((q@ == '\0') && (diag quote in "unclosed string literal") as none) ) )
is end
   cast S calloc 1 (end - quote as N) is buf
   0 is n
  (  &quote^1 for p
    (  (p < end)
    && (p@ == '\s')
    ? (  buf^(n ret (n = n + 1)) = (p = &p^1)
         escape p in
      ret (p = &p^1) )
       p
    :  (buf^(n ret (n = n + 1)) = p@)
       &p^1 )
  as none )
   ntoken TK_STR start &end^1 in is j
   (j.t = array_of nbyte cast nat (n + 1))
   (j.str = buf)
   j )

byte_literal(in @File p S) J =
(  &p^1 is q
   ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
  (  (q@ == '\s')
  ?  (q = &q^1)
     ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
     escape q in
  :  q@ )
is c
   (q = &q^1)
   ((q@ != '\p') && (diag p in "unclosed literal byte") as none)
   ntoken TK_NUM p &q^1 in is j
   (j.l = c as N)
   (j.t = cast @none nbyte)
   j )

open_file(path S mode S) Y =
(fopen path mode || cast none (printf "cannot open file '%s' with mode '%s': %s" mode path strerror (__errno_location)@))

read_file(path S) S =
(  cast S calloc 1 4096 is rfbuf2
   open_file path "r" is fp
   cast S 0 is buf
   0 is buflen
   &buflen is b
   open_memstream &buf b is y
   (1b for k
    sizeof typeof rfbuf2 is m
    fread cast @none rfbuf2 1 m fp is n
    ((n == 0) ? (k = 0b) : cast none fwrite cast @none rfbuf2 1 n y)
       k as none)
   free cast @none rfbuf2
   (fclose fp as none)
   fflush y
   (((buflen == 0) || (buf^(buflen - 1) != '\n')) && fputc cast N '\n' y as none)
   fputc 0 y
   fclose y
   buf )

tokenize(path S) J =
(  read_file path is p
   !p
?  cast J 0
:  cast @File calloc 1 sizeof File is in
   (in.name = path)
   (in.contents = p)
   cast J 0 is j
   &j is k
   (1b for _ p@ &&
    startswith p "/*"
    ?  strstr &p^2 "*/" is q
       (!q && (diag p in "unclosed block comment") as none)
       (p = &q^2)
    :  (isws p@) ? (p = &p^1)
    :  (is09 p@ || ((p@ == '.') && is09 p^1))
    ?  (&p^1 for q ( isid q@ && &q^1 )) is q
       (k@ = ntoken TK_NUM p q in)
       (k.loc is p
           10 is a
           (  (!strncmp p "0x" 2 && is0f p^2)
           && (p = &p^2)
              (a = 16)
           as none )
            strtoul p &p a is v
            ( (startswith p "b"  ) ? (p = &p^1)            nbit :
                                                           nnat ) is t
            (k.l = v as N )   
            (k.t = t as @none   )   
            1b)
       (k = &k.s)
       (p = q)
    :  (p@ == '"')
    ?  (k@ = string_literal in p p)
       (p = &p^k.n)
       (k = &k.s)
    :  (p@ == '\p')
    ?  (k@ = byte_literal in p)
       (k.l = k.l as C as N)
       (p = &p^k.n)
       (k = &k.s)
    :  0 is n
       (p for q ((isid q@ && &q^1) || cast S 0 ret (n = q - p as N)) as none)
       !!n
    ?  (k@ = ntoken TK_ID p &p^n in)
       (p = &p^k.n)
       (k = &k.s)
    :  read_punct p is n
       !!n
    ?  (k@ = ntoken TK_PCT p &p^n in)
       (p = &p^k.n)
       (k = &k.s)
    :  (diag p in "invalid token"))
   j ret
   1 is n
  ( in.contents for p
    !!p@ &&
    !!j &&
    ((p == j.loc) && (j.line_no = n) (j = j.s))
    ((p@ == '\n') && (n = n + 1))
    &p^1 ) )

push_scope  (k K c S    ) @Scope
= (cast @Scope calloc 1 sizeof Scope is s s ret (s.c = c)    (s.s = k.s)    (k.s = s))

search_scope(k K c S n N) @Scope
= (cast @Scope 0 is r (!!k.s && k.s for s ((n != strlen s.c )|| !!strncmp s.c c n) ? s.s : (r = s)    cast @Scope 0 as none)    r)

type o_kst (k K s S t T) O;

nvar o_kst =
(  cast O calloc 1 sizeof Obj is o
   (o.name = s) 
   (o.t = t) 
   ((push_scope k s).o = o) 
   o )

nletvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   o )

nlvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   (o.s = k.locals)
   (k.locals = o)
   o )

ngvar o_kst =
(  nvar k s t is o
   (o.s = k.globals)
   (o.is_definition = 1b)
   (k.globals = o)
   o )

nstr o_kst =
(  cast S 0 is s2
   cast N 0 is n
   open_memstream &s2 &n is y
   (fprintf y ".L.%ld" k.n)
   fclose y
   (k.n = k.n + 1)
   ngvar k s2 t is o (o.init_data = s)
   o )

expect_type(j J t T u T) none =
(  !!t
&& !type_equal t u
&& (jdiag j "expected %s but found %s" format_type t format_type u) as none )

get_ident(j J) S =
(  ((!!j && (j.q != TK_ID)) && (jdiag j "expected an nonymousifier") as none)
   strndup j.loc cast N j.n )

find_type(k K c S n N) T =
(  (!!k.j && (k.j.q != TK_ID)) ? nnull
:  search_scope k c n is s
   (!!s && s.t) )

get_struct_member(t T j J) T =
(  nnull is r
  (  t.a for g
     ((g.name.n == j.n) && !strncmp g.name.loc j.loc j.n)
  ?  (r = g)
     nnull
  :  g.s
  as none )
   r )

jadv   (k K    ) J    = (k.j ret (k.j = k.j.s))
jeq    (k K c S) bit  = (!!k.j && (!memcmp cast @none k.j.loc cast @none c cast N k.j.n && !c^k.j.n))
expect (k K c S) none = ((!jeq k c && (jdiag k.j "expected '%s'" c) as none)    (k.j = k.j.s))
consume(k K c S) bit  = (jeq k c is r r ret (r && (k.j = k.j.s) as none) )

type tk   (k K        ) T;
type tke  (k K e E    ) T;
type tkt  (k K t T    ) T;
type tktn (k K t T n N) T;
type tkst (k K s S t T) T;

enumerators_a tktn =
( (  1b for _
    (  !consume k ";"
    && get_ident k.j is c
       jadv k
       push_scope k c is s
       (s.t = t)
       (s.v = n)
       (n = n + 1) )
  as none )
   t )

enumerators    tkt = enumerators_a k t 0
enum_specifier tk  = enumerators k ntype TY_ENUM 1 1

declarator tk =
(  jadv k is j
   copy_type ptype k is t t
ret (t.name = j) )

struct_decl tk =
(  struct_of is t
   expect k "{"
   (k.t = t)
   new Type is head
   &head is cur
  (  1b for _ 
    (  !consume k "}"
    && (calloc 1 sizeof Type as T) is g
       (g@ = declarator k)
       (cur.s = g)
       (cur = cur.s) )
  as none )
   (t.a = head.s)
   (k.t = 0 as T)
   (t.q = TY_STRUCT)
   (t.size < 0) ? t
:  0 is bits
  (  !!t.a && t.a for g g.s
  ret (bits = align_to bits (g.align * 8))
     (g.offset = bits / 8)
     (bits = bits + g.size * 8)
     ((t.align < g.align) && (t.align = g.align) as none)
  as none)
   (t.size = align_to bits (t.align * 8) / 8)
   t )

type_specifier_a tkst = (consume k s && t)

type pfn  (k K t T    ) E;

type efn  (k K t T  ) E;
type efna (k K t T a E) E;

p4 pfn;

type_specifier tk =
(  consume k "none"   ? nnone
:  consume k "bit"    ? nbit
:  consume k "byte"   ? nbyte
:  consume k "nat"    ? nnat
:  consume k "struct" ? struct_decl      k
:  consume k "enum"   ? enum_specifier   k
:  consume k "typeof" ? (p4 k nnull).t
:  consume k "same"   ? k.t
: (  (find_type k k.j.loc cast N k.j.n
  && cast none jadv k)
  || nnone ret (jdiag k.j "invalid type specifier") ) )

func_params tk =
(  new Type is head
   0b is is_variadic
   &head is cur
   (1b for _ (!jeq k ")" && !(consume k "..."
?  (is_variadic = 1b)
   1b
:  (cur.s = declarator k)
   (cur = cur.s)
   0b))
as none)
   jadv k
   func_of ptype k is t
   (t.params = head.s)
   (t.is_variadic = is_variadic)
   t )

ptype tk =
(  consume k "@" ? nptr     ptype k
:  consume k "(" ? func_params            k
:  type_specifier k )

tree(j J t T q NodeKind            ) E = (cast E calloc 1 sizeof Node is e e ret (e.j = j)  (e.t = t)  (e.q = q))
t0  (j J t T q NodeKind            ) E = (tree j t q)
t1  (j J t T q NodeKind a E        ) E = (tree j t q is e e ret (e.a   = a))
t2  (j J t T q NodeKind a E b E    ) E = (tree j t q is e e ret (e.a   = a)  (e.a.s = b))
t3  (j J t T q NodeKind a E b E c E) E = (tree j t q is e e ret (e.a   = a)  (e.a.s = b)  (e.a.s.s = c))
tt  (j J t T q NodeKind u T        ) E = (t0 j t q is e e ret (e.t.s = u))
to  (j J t T q NodeKind o O        ) E = (t0 j t q is e e ret (e.o   = o))
tl  (j J t T q NodeKind l N        ) E = (t0 j t q is e e ret (e.l   = l))

type njtu  (j J t T u T        ) E;
type njtua (j J t T u T a E    ) E;
type njta  (j J t T     a E    ) E;
type njtab (j J t T     a E b E) E;

nsizeof     njtu  = tt j nnat     ESIZE  u
nnew        njtu  = tt j u        ENEW   u
nthe        njtua = t1 j a.t      ETHE   a
ncast       njtua = t1 j u        ECAST  a
ncall       njta  = t1 j a.t.a    ECALL  a
nneg        njta  = t1 j nnat     ENEG   a
naddr       njta  = t1 j nptr a.t EADDR  a
nlnot       njta  = t1 j nbit     ELNOT  a
nbnot       njta  = t1 j nnat     EBNOT  a
nderef      njta  = t1 j a.t.a    EDEREF a
nass        njtab = t2 j nnone    EASS   a b
nbor        njtab = t2 j nnat     EBOR   a b
nbitxor     njtab = t2 j nnat     EBXOR  a b
nband       njtab = t2 j nnat     EBAND  a b
neq         njtab = t2 j nbit     EEQ    a b
nneq        njtab = t2 j nbit     ENE    a b
ngt         njtab = t2 j nbit     EGT    a b
nlt         njtab = t2 j nbit     ELT    a b
nge         njtab = t2 j nbit     EGE    a b
nle         njtab = t2 j nbit     ELE    a b
nshl        njtab = t2 j nnat     ESHL   a b
nshr        njtab = t2 j nnat     ESHR   a b
nmul        njtab = t2 j nnat     EMUL   a b
ndiv        njtab = t2 j nnat     EDIV   a b
nmod        njtab = t2 j nnat     EMOD   a b
nthen       njtab = t2 j a.t      ETHEN  a b
nneth       njtab = t2 j b.t      ESEQ   a b
nlor        njtab = t2 j a.t      ELOR   a b
nland       njtab = t2 j b.t      ELAND  a b
nelem  njtab = t2 j a.t.a    EELEM  a b
nadd        njtab = t2 j nnat     EADD   a b
nsub        njtab = t2 j nnat     ESUB   a b

/* oddballs */

nreference  (j J t T                 o O ) E = (to j o.t EVAR  o)
nlit        (j J t T u T             l N ) E = (tl j u   ELIT  l)
nlet        (j J t T         a E b E o O ) E = (t2 j b.t EIS   a b is e e ret (e.o = o))
nrepeat     (j J t T         a E b E o O ) E = (t2 j b.t EFOR  a b is e e ret (e.o = o))
ncond(j J t T         a E b E c E ) E = (t3 j b.t ECOND a b c)

p2    pfn ;
p5    pfn ;
p7    pfn ;
pmul  pfn ;
padd  pfn ;
psh   pfn ;
pcmp  pfn ;
pband pfn ;
pbor  pfn ;
pland pfn ;
plor  pfn ;

esize  efn  = (jadv k is j ptype k is u nsizeof j t u       )
ethe   efn  = (jadv k is j ptype k is u nthe    j t u p4 k t)
ecast  efn  = (jadv k is j ptype k is u ncast   j t u p4 k t)
eas    efna = (jadv k is j ptype k is u ncast   j t u a     )
efrom  efna = (jadv k is j ptype k is u nthe    j t u a     )

elit   efn  = (jadv k is j nlit    j t cast T j.t j.l    )
eaddr  efn  = (jadv k is j naddr   j t     p2 k t        )
eelem  efna = (jadv k is j nelem   j t a   p4 k nnat )
eneg   efn  = (jadv k is j nneg    j t     p4 k t        )
elnot  efn  = (jadv k is j nlnot   j t     p4 k t        )
ebnot  efn  = (jadv k is j nbnot   j t     p4 k t        )
ederef efna = (jadv k is j nderef  j t a                 )
eseq   efna = (k.j    is j nneth   j t a   p5 k t        )
ethen  efna = (jadv k is j nthen   j t a   p5 k nnone    )
emul   efna = (jadv k is j nmul    j t a   p5 k a.t      )
ediv   efna = (jadv k is j ndiv    j t a   p5 k a.t      )
emod   efna = (jadv k is j nmod    j t a   p5 k a.t      )
eland  efna = (jadv k is j nland   j t a   p5 k a.t      )
elor   efna = (jadv k is j nlor    j t a   p5 k a.t      )
econd  efna = (jadv k is j                 p5 k t is b expect k ":"
                           ncond   j t a b p5 k t        )
eadd   efna = (jadv k is j nadd    j t a   pmul  k a.t   )
esub   efna = (jadv k is j nsub    j t a   pmul  k a.t   )
eshl   efna = (jadv k is j nshl    j t a   padd  k a.t   )
eshr   efna = (jadv k is j nshr    j t a   padd  k a.t   )
elt    efna = (jadv k is j nlt     j t a   psh   k nnull )
egt    efna = (jadv k is j ngt     j t a   psh   k nnull )
ele    efna = (jadv k is j nle     j t a   psh   k nnull )
ege    efna = (jadv k is j nge     j t a   psh   k nnull )
eeq    efna = (jadv k is j neq     j t a   psh   k nnull )
ene    efna = (jadv k is j nneq    j t a   psh   k nnull )
eband  efna = (jadv k is j nband   j t a   pcmp  k a.t   )
ebor   efna = (jadv k is j nbor    j t a   pband k a.t   )
eass   efna = (jadv k is j nass    j t a   p7    k a.t   )

enew   efn  = (jadv k is j ptype k is u nlvar k "" u is o                                   tree        k.j nnone EZ is b (b.o = o)    nneth k.j t b nreference k.j t o)
eis    efna = (jadv k is j k.s is s nletvar k get_ident jadv k a.t is o       p5 k t       is b nlet         j   t     a b   o ret (k.s = s))
efor   efna = (jadv k is j k.s is s nletvar k get_ident jadv k a.t is o       p5 k t       is b nrepeat      j   t     a b   o ret (k.s = s))

eid efn  = (
  search_scope k k.j.loc k.j.n is s
  jadv k is j
  ( !!s ? !!s.o ? nreference j t s.o : nlit j t s.t cast N s.v :
    (jdiag k.j "lookup failed")
    cast E 0 )
)

estr efn = (
  cast T k.j.t is u
  nstr k k.j.str u is o
  ncast k.j t nptr u.a nthe k.j u o.t nreference k.j u o ret
  cast none jadv k
)

emem  efna =
(  cast none jadv k
   jadv k is j
   (a.t for t ((t.q == TY_PTR) && t.a)) is t
   ((t.q != TY_STRUCT) && (jdiag j "%s is not a struct" format_type t) as none)
   get_struct_member t j is g
  (  !g
  &&(  jdiag j "(%s . %.*s) no such member" format_type t j.s.n j.s.loc ) as none )
   t1 j g EMEM a )

end_seq(k @Ctx) bit = (
   jeq k ")"
|| jeq k ":"
|| jeq k "?"
|| jeq k "*"
|| jeq k "/"
|| jeq k "%"
|| jeq k "+"
|| jeq k "-"
|| jeq k "<<"
|| jeq k ">>"
|| jeq k "<"
|| jeq k ">"
|| jeq k "<="
|| jeq k ">="
|| jeq k "=="
|| jeq k "!="
|| jeq k "|"
|| jeq k "&&"
|| jeq k "||"
|| jeq k "="
|| jeq k "as"
|| jeq k "from"
)

ecall efna = (
  a.t.params is u
  (  a for b
    (  (!!u || a.t.is_variadic && !end_seq k)
    && (b.s = p4 k u)
       (  !!u 
       && (!type_equal b.s.t u && (jdiag k.j "asymmetric argument from %s to %s" format_type b.s.t format_type u) as none)
          (u = u.s)
       as none)
       b.s )
  as none )
  ncall k.j t a
)

pj(k K t T     q TokenKind e @efn ) E = ((k.j.q == q) && e@ k t)
pl(k K t T     c S e @efn ) E = (jeq k c && e@ k t  )
pr(k K t T a E c S e @efna) E = (jeq k c && e@ k t a)

pcast efna = (                     pr    k t a "as"      &eas    ||
                                   pr    k t a "from"    &efrom     )

p2 efn = ( (
    consume k "(" ? (
      p7    k nnull for a
      pr    k t a "=" &eass ||
      pcast k t a ) ret expect k ")" :
    pl k t "new"  &enew ||
    pj k t TK_ID  &eid  ||
    pj k t TK_STR &estr ||
    pj k t TK_NUM &elit ||
    (jdiag k.j "expected an expression")
  ) for a
  pr    k t     a "^"       &eelem   ||
  pr    k t     a "."       &emem   ||
  pr    k t     a "@"       &ederef
)

p4 efn = (
  pl k t "-" &eneg   ||
  pl k t "!" &elnot  ||
  pl k t "~" &ebnot  || (
    pl k t     "cast"    &ecast  ||
    pl k t     "the"     &ethe   ||
    pl k t     "&"       &eaddr  ||
    pl k t     "sizeof"  &esize  ||
    p2 k nnull
  ) for a
  (a.t.q == TY_FUNC) &&
  ecall k t a
)

p5  efn = (
  p4    k nnull  is a
  pr    k t a "ret"     &ethen  ||
  pr    k t a "is"      &eis    ||
  pr    k t a "for"     &efor   ||
  pr    k t a "&&"      &eland  ||
  pr    k t a "||"      &elor   ||
  pr    k t a "?"       &econd  ||
  end_seq k ? a : eseq k t a
)

pmul  efn = (p5  k t       for a ( pr    k t a "*"       &emul   ||
                                   pr    k t a "/"       &ediv   ||
                                   pr    k t a "%"       &emod      ) )
padd  efn = (pmul  k t     for a ( pr    k t a "+"       &eadd   ||
                                   pr    k t a "-"       &esub      ) )
psh   efn = (padd  k t     for a ( pr    k t a "<<"      &eshl   ||
                                   pr    k t a ">>"      &eshr      ) )
pcmp  efn = (psh   k nnull for a ( pr    k t a "<"       &elt    ||
                                   pr    k t a ">"       &egt    ||
                                   pr    k t a "<="      &ele    ||
                                   pr    k t a ">="      &elt    ||
                                   pr    k t a "=="      &eeq    ||
                                   pr    k t a "!="      &ene       ) )
pband efn = (pcmp  k t     for a   pr    k t a "&"       &eband     )
pbor  efn = (pband k t     for a   pr    k t a "|"       &ebor      )
p7    efn = (pbor  k t     for a   pcast k t a                   )

typedecl(k K) J =
(  k.j for j
  (  !consume k ";"
  &&(  declarator k is t
       ((push_scope k get_ident t.name).t = t)
       k.j ) ) )

create_lvars(k K t T) none =
(  !!t
&& create_lvars k t.s
   (nlvar k get_ident t.name t as none)
as none )

find_func(k K c S n N) O =
(  search_scope k c n is s
   (!!s && !!s.o && (s.o.t.q == TY_FUNC) && s.o) )

function(k K v @VarAttr) none =
(  declarator k is t
  find_func k t.name.loc cast N t.name.n is o
  (  !!o
  ?  ((o.t.q != TY_FUNC)             && (jdiag k.j "redeclared as a different q of symbol") as none)
     (o.is_definition && jeq k "=" && (jdiag k.j "redefinition of %s" o.name) as none)
     ((o.is_export != v.is_export )  && (jdiag k.j "mismatched visibility") as none)
     (o.is_definition = o.is_definition || jeq k "=")
  :  (o = ngvar k get_ident t.name t)
     (o.is_definition = jeq k "=")
     (o.is_export = v.is_export) )
  (  !consume k ";"
  && (k.locals = cast O 0)
     k.s is s
     create_lvars k t.params
     (o.params = k.locals)
     (t.is_variadic && (o.va_area = nlvar k "__va_area__" array_of nbyte 136) as none)
     expect k "="
     (o.body = p4 k t.a as @none)
     (o.locals = k.locals)
     (k.s = s) ) )

parse(j J) O =
(  cast @Ctx calloc 1ul sizeof Ctx is k
   cast @VarAttr calloc 1ul sizeof VarAttr is v
   (k.j = j)
  (  !!k.j && k.j for j
    (  !!j && 
      (v.is_type = 0b)
      (v.is_export = 0b)
      (1b for i
    ((consume k "type"    && 1b ret (v.is_type   = 1b))
  || (consume k "export"  && 1b ret (v.is_export = 1b)) )
as none)
       v.is_type
    ?  typedecl k
    :  function k v
       k.j)
  as none)
   k.globals )

argreg1(d N) S =
(  (d == 0) ? "%dil" :
   (d == 1) ? "%sil" :
   (d == 2) ? "%dl"  :
   (d == 3) ? "%cl"  :
   (d == 4) ? "%r8b" :
              "%r9b" )

argreg8(d N) S =
( (d == 0) ? "di" :
  (d == 1) ? "si" :
  (d == 2) ? "dx" :
  (d == 3) ? "cx" :
  (d == 4) ? "8"  :
             "9"  )

gln(y Y fmt S ...) none =
(  vfprintf y fmt cast @va_list __va_area__
   (cast none fprintf y "\n") )

gbin (y Y s S) none = (gln y "  %s  %%rdi, %%rax" s)
gzero(y Y s S) none = (gln y "  xor %%e%s, %%e%s" s s)
glit (y Y l N) none = (!!l ? (gln y "  mov $%ld , %%rax" l) : gzero y "ax")
gcmpz(y Y    ) none = (gln y "  test %%rax, %%rax"  )
gnot (y Y    ) none = (gln y "  not %%eax"         )
gneg (y Y    ) none = (gln y "  neg %%rax"         )
gmul (y Y    ) none = (gln y "  mul %%rdi"         )
gdiv (y Y    ) none = ( gzero y "dx"
                        (gln y "  div %%rdi"         ) )
gmod (y Y    ) none = ( gdiv y
                        (gln y "  mov %%rdx, %%rax") )
gshx (y Y x C) none = ( (gln y "  mov %%dil, %%cl"   )
                        (gln y "  sh%c %%cl, %%rax" x) )

gadd (y Y) none = (gbin y "add")
gsub (y Y) none = (gbin y "sub")
gand (y Y) none = (gbin y "and")
gor  (y Y) none = (gbin y "or ")
gxor (y Y) none = (gbin y "xor")
gcmp (y Y) none = (gbin y "cmp")
gshr (y Y) none = (gshx y 'r')
gshl (y Y) none = (gshx y 'l')

gpromote(y Y) none = (gln y "  movzbl %%al , %%eax")

gsetf     (y Y         s S) none = ((gln y "  set%s  %%al" s) gpromote y)
gcmp_setf (y Y         s S) none = (gcmp  y gsetf y s)
gcmpz_setf(y Y         s S) none = (gcmpz y gsetf y s)
gj        (y Y e E l S    ) none = (gln y "  jmp %s%ld$"   l e)
gjc       (y Y e E l S s S) none = (gln y "  j%s %s%ld$" s l e)
glabel    (y Y e E l S    ) none = (gln y "%s%ld$:"        l e)

gje  (y Y e E l S) none = gjc y e l "e "
gjne (y Y e E l S) none = gjc y e l "ne"
gjb  (y Y e E l S) none = gjc y e l "b "
gjbe (y Y e E l S) none = gjc y e l "be"
gja  (y Y e E l S) none = gjc y e l "a "
gjae (y Y e E l S) none = gjc y e l "ae"

ge  (y Y) none = gcmp_setf y "e "
gne (y Y) none = gcmp_setf y "ne"
gb  (y Y) none = gcmp_setf y "b "
gbe (y Y) none = gcmp_setf y "be"
ga  (y Y) none = gcmp_setf y "a "
gae (y Y) none = gcmp_setf y "ae"

gcast(y Y a T b T) none =
(  (b.q == TY_VOID) ?  gzero    y "ax"
:  (b.q == TY_BYTE) && gpromote y)

gfpush(y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gln y "  sub $%ld, %%rsp" l1) (c@ = c@ + l1))
gfpop (y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gln y "  add $%ld, %%rsp" l1) (c@ = c@ - l1))
gpush (y Y c @N      ) none = ((gln y "  push %%rax")    (c@ = c@ + 8))
gpop  (y Y c @N  s S ) none = ((gln y "  pop %%r%s" s  )    (c@ = c@ - 8))
gindex(y Y       l N ) none = (!!l && (gln y "  add $%ld, %%rax" l))

gaddr(y Y q TypeKind n N s S d S) none = (gln y "  lea    %lu(%%r%s), %%r%s" n s d)
gload(y Y q TypeKind n N s S d S) none =
( ((q == TY_ARRAY)|| (q == TY_STRUCT)|| (q == TY_FUNC))
? gaddr y q n s d
: ((q == TY_BYTE) || (q == TY_BOOL) || (q == TY_ENUM))
? (gln y "  movzbl %lu(%%r%s), %%e%s" n s d)
: (gln y "  mov    %lu(%%r%s), %%r%s" n s d)
as none )

gaddrg(y Y e E c @N d S) none = (gln y "  lea    %s, %%r%s" e.o.name d)
gloadg(y Y e E c @N d S) none =
( ((e.o.t.q == TY_ARRAY)|| (e.o.t.q == TY_STRUCT)|| (e.o.t.q == TY_FUNC))
? gaddrg y e c d
: ((e.o.t.q == TY_BYTE) || (e.o.t.q == TY_BOOL) || (e.o.t.q == TY_ENUM))
? (gln y "  movzbl %s, %%e%s" e.o.name d)
: (gln y "  mov    %s, %%r%s" e.o.name d)
as none )

gaddrl(y Y e E c @N d S) none = (gaddr y e.o.t.q (e.o.sp ? (gln y "#let from %lu at %lu" e.o.sp c@) (c@ - e.o.sp) : (e.o.offset + c@)) "sp" d)
gloadl(y Y e E c @N d S) none = (gload y e.o.t.q (e.o.sp ? (gln y "#let from %lu at %lu" e.o.sp c@) (c@ - e.o.sp) : (e.o.offset + c@)) "sp" d)


gloadsp(y Y q TypeKind d S) none =
(  ((q == TY_ARRAY)|| (q == TY_STRUCT)|| (q == TY_FUNC))
? (gln y "  mov     %%rsp, %%r%s" d)
: ((q == TY_BYTE) || (q == TY_BOOL) || (q == TY_ENUM))
? (gln y "  movzbl (%%rsp), %%e%s" d)
: (gln y "  mov    (%%rsp), %%r%s" d) )

gstoresp(y Y t T) none =
(  (gln y " mov %%rsp, %%rdi")
   ((t.q == TY_STRUCT) || (t.q == TY_ARRAY)) ? (0 for i ((i < t.size) && (i + 1)
ret (gln y "  mov %ld(%%rax), %%r8b    " i)
    (gln y "  mov %%r8b    , %ld(%%rdi)" i)) as none)
:  (t.size == 1) ? (gln y "  mov %%al , (%%rdi)")
:                  (gln y "  mov %%rax, (%%rdi)") )

gstore(y Y t T c @N) none =
(  gpop y c "di"
   ((t.q == TY_STRUCT) || (t.q == TY_ARRAY)) ? (0 for i ((i < t.size) && (i + 1)
ret (gln y "  mov %ld(%%rax), %%r8b    " i)
    (gln y "  mov %%r8b    , %ld(%%rdi)" i)) as none)
:  (t.size == 1) ? (gln y "  mov %%al , (%%rdi)")
:                  (gln y "  mov %%rax, (%%rdi)") )

glet(y Y o O c @N) none = (
  gfpush y c o.t.size
  (o.sp = c@)
  gstoresp y o.t
)

gulet(y Y o O c @N d S) none = (
  gloadsp y o.t.q d
  (o.sp = 0)
  gfpop y c o.t.size
)

type gexprcat (y Y e E c N l N) N;

gexpr gexprcat;

gdrop (y Y e E c N    ) none = (cast none gexpr y e c 0 is l (l && gln y "#elided loads: %ld" l))
geval (y Y e E c N l N) none = (
  gexpr y e c l is l1
  ((l1 > 1) && gln y "#compacted loads: %ld" (l - 1))
  !!l1 && l1 for l2
  gload y (((l2 == 1) && (l == 0)) ? e.t.q : TY_PTR) 0 "ax" "ax"
  (l2 - 1)
)

gdata(y Y o O) none = (
  (gln y "  .data"                             )
  (gln y "  .type %s, @object" o.name          )
  (gln y "  .size %s, %ld"     o.name o.t.size )
  (gln y "  .align %ld"               o.t.align)
  (gln y "%s:" o.name                          )
  ( 0 for i (i < o.t.size) && (i + 1) ret
    (gln y "  .byte %ld" o.init_data^i)
  as none )
)

gstoreva(y Y o O c N) none = (
  0 is d
  (!!o.params && o.params for o o.s ret (d = d + 8))
  (gln y "  movl $%ld , 24(%%rsp)" d       )
  (gln y "  movq %%rsp, 32(%%rsp)"         )
  (gln y "  addq $%ld , 32(%%rsp)" (c + 16))
  (gln y "  movq %%rsp, 40(%%rsp)"         )
  (gln y "  addq $48  , 40(%%rsp)"         )
  (gln y "  movq %%rdi, 48(%%rsp)"         )
  (gln y "  movq %%rsi, 56(%%rsp)"         )
  (gln y "  movq %%rdx, 64(%%rsp)"         )
  (gln y "  movq %%rcx, 72(%%rsp)"         )
  (gln y "  movq %%r8 , 80(%%rsp)"         )
  (gln y "  movq %%r9 , 88(%%rsp)"         )
)

gtext(y Y o O) none =
( (  !!o.params
  && 16 is t
      0 is g
     o.params for o o.s
  ret (!((g ret (g = g + 1)) < 6)
  && (t        = align_to t 8)
     (o.offset = t           )
     (t        = t + o.t.size) ) )
   0 is bottom
  (  !!o.locals
  && o.locals for o o.s
  ret(  !o.offset
    && (bottom = bottom + o.t.size)
       (bottom = align_to bottom o.t.align)
       (o.offset = -bottom)
    as none )
  as none )
  (bottom = align_to bottom 16) /* abi says bottom of frame is aligned to 16 */
  (gln y "  .text")
  (gln y "  .type %s, @function" o.name)
  (gln y "%s:" o.name)
  (gln y "  enter $%ld, $0" bottom)
  ( o.t.is_variadic && gstoreva y o bottom)
  (  0 is d
     o.params for o
    (  !!o
    && o.s
    ret(  (o.offset > (-1 >> 1))
      && o.t is t
         ((t.size == 1)
      ?  (gln y "  mov %s   , %ld(%%rsp)" argreg1 d (o.offset + bottom))
      :  (gln y "  mov %%r%s, %ld(%%rsp)" argreg8 d (o.offset + bottom)))
      ret (d = d + 1)
      as none ) )
  as none )
  gdrop y cast E o.body bottom
  (gln y "  leave")
  (gln y "  ret")
)

gsym(y Y o O) none = (
  !!o.is_definition &&
  (gln y "  .%s %s" (!o.is_export ? "local" : "globl" ) o.name)
  ((o.t.q == TY_FUNC) ? &gtext : &gdata)@ y o
)

codegen(o O y Y in S) none = (
  (gln y "  .file 0 \q%s\q" in)
  !!o &&
  o for o
  o.s ret gsym y o
)

export main(argc N argv @S) N =
(  open_file argv^2 "w" is y
   (!y ? 1 : 0 ret codegen parse tokenize argv^1 y argv^1)
ret cast none fclose y )





/*

vtables

*/




gelit   gexprcat = (glit  y e.l          0)
gesize  gexprcat = (glit  y e.t.s.size   0)
gderef  gexprcat = (gexpr y e.a c 0  + 1  - l)
geaddr  gexprcat = (gexpr y e.a c (l + 1) - l)
gethe   gexprcat = gexpr y e.a c l

geref   gexprcat = (
  (e.o.is_local ? &gaddrl : &gaddrg) is gaddr
  (e.o.is_local ? &gloadl : &gloadg) is gload
  (!l ? gload : gaddr)
  @ y e &c "ax"
  (!l ? 0 : (1 - l))
)

geelem  gexprcat = (
  geval y e.a    c 0
  gpush y       &c
  geval y e.a.s  c 0
  gpop  y       &c "dx"
  (gln y "  lea (%%rdx, %%rax, %ld), %%rax" e.a.t.a.size)
  (1 - l)
)

gemem   gexprcat = (
  geval y e.a c 0
  ( e.a.t for t
    ( (t.q == TY_PTR) &&
      t.a ret
      gload y t.a.q 0 "ax" "ax"
    as none )
  as none )
  gindex y e.t.offset
  (1 - l)
)

geseq gexprcat = (
  gdrop y e.a   c
  geval y e.a.s c l
  0
)

geret gexprcat = (
  geval y e.a    c l
  gpush y       &c
  gdrop y e.a.s  c
  gpop  y       &c "ax"
  0
)

gecond gexprcat = (
  geval  y e.a     c 0
  gcmpz  y
  gje    y e         "a"
  geval  y e.a.s   c l
  gj     y e         "b"
  glabel y e         "a"
  geval  y e.a.s.s c l
  glabel y e         "b"
  0
)

geland  gexprcat = (
  (e.a.s.t.q == TY_VOID) is keep
  geval y e.a c 0
  gcmpz y
  gje   y e         "a"
  ( keep &&
    gpush y       &c      )
  geval y e.a.s c 0
  ( keep &&
    gpop  y       &c "ax" )
  glabel y e        "a"
  0
)

gelor gexprcat = (
  (e.a.s.t.q == TY_VOID) is keep
  geval   y e.a   c 0
  gcmpz   y
  gjne    y e       "a"
  ( keep &&
    gpush y       &c      )
  geval   y e.a.s c 0
  ( keep &&
    gpop  y       &c "ax" )
  glabel  y e       "a"
  0
)

geneg   gexprcat = (
  geval y e.a c 0
  gneg  y
  0
)

gecast  gexprcat =  (
  geval y e.a c 0
  gcast y e.a.t e.t
  0
)

gelnot  gexprcat =  (
  geval      y e.a c 0
  gcmpz_setf y       "e"
  0
)

gebnot  gexprcat =  (
  geval y e.a c 0
  gnot  y
  0
)

geass   gexprcat = (
  geval  y e.a    c 1
  gpush  y       &c
  geval  y e.a.s  c 0
  gstore y e.a.t &c
  gzero  y         "ax"
  0
)

gelet   gexprcat = (
  geval  y e.a    c 0
  glet   y e.o   &c
  geval  y e.a.s  c l
  gulet  y e.o   &c "dx"
  0
)

gefor   gexprcat = (
  geval    y e.a    c 0
  glet     y e.o   &c
  gj       y e        "b"
  glabel   y e        "a"
  gstoresp y e.a.t
  glabel   y e        "b"
  geval    y e.a.s  c 0
  gcmpz    y
  gjne     y e        "a"
  gulet    y e.o   &c "ax"
  0
)

gargs(y Y e E c @N d N) none =
(  !!e
&&(  (d < 6)
  && gargs y e.s c (d + 1) )
   geval y e c@ 0
   gpush y c
as none )

gecall gexprcat = (
  0 is stack
  0 is d
  ( ( (c + stack) % 16 != 0) &&
    gfpush y &c 1
    (stack = stack + 8)
  as none )
  gargs y e.a.s &c 0
  geval y e.a   c 0
  0 is d
  (!!e.a.s && e.a.s for e e.s ret ((d < 6) && gpop y &c argreg8 d ret (d = d + 1)) as none)
  (gln y "  call *%%rax")
  gfpop y &c (stack >> 3)
  0
)

gez gexprcat = (
  (gln y "  mov $%ld, %%rcx" e.o.t.size)
  gaddrl y e   &c "di"
  (gln y "  mov $0, %%al")
  (gln y "  rep stosb")
  0
)


ge2arya (y Y e E c N) @(y Y) none = (
  (e.q == EDIV ) ? &gdiv :
  (e.q == EMOD ) ? &gmod :
  (e.q == EEQ  ) ? &ge   :
  (e.q == ENE  ) ? &gne  :
  (e.q == ELT  ) ? &gb   :
  (e.q == ELE  ) ? &gbe  :
  (e.q == EGT  ) ? &ga   :
  (e.q == EGE  ) ? &gae  :
  (e.q == EADD ) ? &gadd :
  (e.q == ESUB ) ? &gsub :
  (e.q == EMUL ) ? &gmul :
  (e.q == EBAND) ? &gand :
  (e.q == EBOR ) ? &gor  :
  (e.q == EBXOR) ? &gxor :
  (e.q == ESHL ) ? &gshl :
                   &gshr
)

ge2ary  gexprcat = (
  geval    y e.a.s  c 0
  gpush    y       &c
  geval    y e.a    c 0
  gpop     y       &c "di"
  (ge2arya y e      c       )
  @        y
  0
)

gexpr gexprcat = (
  (gln y ".loc 0 %lu" e.j.line_no)
  e.q is q
(
  (q == EVAR  ) ? &geref  :
  (q == EMEM  ) ? &gemem  :
  (q == EELEM ) ? &geelem :
  (q == EDEREF) ? &gderef :
  (q == ESEQ  ) ? &geseq  :
  (q == ETHEN ) ? &geret  :
  (q == ETHE  ) ? &gethe  :
  (q == ECOND ) ? &gecond :
  (q == ELIT  ) ? &gelit  :
  (q == ESIZE ) ? &gesize :
  (q == ECALL ) ? &gecall :
  (q == EADDR ) ? &geaddr :
  (q == ENEG  ) ? &geneg  :
  (q == ELAND ) ? &geland :
  (q == ELOR  ) ? &gelor  :
  (q == ECAST ) ? &gecast :
  (q == ELNOT ) ? &gelnot :
  (q == EBNOT ) ? &gebnot :
  (q == EASS  ) ? &geass  :
  (q == EIS   ) ? &gelet  :
  (q == EFOR  ) ? &gefor  :
  (q == EZ    ) ? &gez    :
                  &ge2ary )
  @ y e c l
)