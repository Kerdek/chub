type
  va_list struct {}
  FILE    struct {}
;

export __errno_location    ( ) @nat

export open_memstream      (p    @@byte n    @nat) @FILE
export fopen               (path  @byte mode @ byte ) @FILE

export fclose              (io @FILE) nat
export fflush              (io @FILE) nat

export fread               (ptr @none m nat n nat io @FILE) nat
export fwrite              (ptr @none m nat n nat io @FILE) nat
export fputc               (c nat io @FILE) nat
export putc                (c nat) nat
export fputs               (s @byte io @FILE) nat
export puts                (s @byte) nat

export exit                (status nat) none

export calloc              (m nat  n nat) @none
export free                (p @none) none

export memcmp              (p @none q @none n nat) nat

export strtoul             (p @byte q @@byte  b  nat) nat
export strcat              (p @byte q  @byte        ) @byte
export strstr              (p @byte q  @byte        ) @byte
export strncmp             (p @byte q  @byte  n nat)  nat
export strndup             (p @byte         n nat) @byte
export strlen              (p @byte               ) nat

export strerror            (errnum  nat) @byte

/* end preamble */

type
  TokenKind @()none

  File struct {
    name     @byte
    contents @byte
  }

  Token struct {
    q        TokenKind
    s       @Token
    l        nat
    p     @byte
    n        nat
    t       @none
    str     @byte
    line  nat
  }

  Type struct  {
    size          nat
    align         nat
    offset        nat
    n             nat
    s            @Type
    o            @Type
    a            @Type
    params       @Type
    name         @Token
    format @(t @Type s @byte) none
  }

  Obj struct {
    s               @Obj
    name            @byte
    t               @Type
    j               @Token
    offset           nat
    is_local         bit
    is_definition    bit
    is_export        bit
    init_data       @byte
    params          @Obj
    body            @none
    locals          @Obj
    sp nat
  }

  Node struct {
    s @Node
    a @Node
    j @Token
    t @Type
    o @Obj
    l  nat
    gen @(y @FILE e @Node c nat l nat) nat
  }

  Scope struct {
    s @Scope
    c @byte
    o @Obj
    t @Type
  }

  Ctx struct {
    j @Token
    in @File
    locals   @Obj
    globals  @Obj
    s @Scope
  }

  J @Token
  O @Obj
  K @Ctx
  E @Node
  T @Type
  N nat
  C byte
  S @byte
  Y @FILE
;

JID  () none = (0)
JPCT () none = (0)
JSTR () none = (0)
JNUM () none = (0)

type cis  (c C        ) bit;

issp cis = (' '  == c)
istb cis = ('\t' == c)
islf cis = ('\n' == c)
iscr cis = ('\r' == c)
is_  cis = ('_'  == c)

isin(c C a C b C) bit =
((a <= c) && (c <= b))

isAZ cis = isin c 'A' 'Z'
isaz cis = isin c 'a' 'z'
is09 cis = isin c '0' '9'
isaf cis = isin c 'a' 'f'

isws cis =
(  issp c
|| istb c
|| islf c
|| iscr c )
is0f cis =
(  is09 c
|| isaf c )
isid cis =
(  isAZ c
|| isaz c
|| is09 c
|| is_  c )


read_ident(p S) N =
(  0 is r
   cast none (p for q ((isid q@ && &q^1) || '\0' ret (r = q - p as N)))
   r )

startswith(p S q S) bit =
(  1b is r
  cast none (  1b for _
    (  !q@
    ?  0b
    :  (p@ != q@)
    ?  (r = 0b)
       0b
    :  (p = &p^1)
       (q = &q^1)
       1b ) )
   r )

read_punct(p S) N =
(  &startswith is f
  (  f@ p "=="
  || f@ p "!="
  || f@ p "<="
  || f@ p ">="
  || f@ p "&&"
  || f@ p "||"
  || f@ p "<<"
  || f@ p ">>" ) ? 2 :
  (  f@ p "=" 
  || f@ p "<"
  || f@ p ">"
  || f@ p "+"
  || f@ p "-"
  || f@ p "*"
  || f@ p "/"
  || f@ p "&"
  || f@ p "|"
  || f@ p "@"
  || f@ p "#"
  || f@ p "{"
  || f@ p "}"
  || f@ p "("
  || f@ p ")"
  || f@ p "["
  || f@ p "]"
  || f@ p "!"
  || f@ p "?"
  || f@ p ":"
  || f@ p ";"
  || f@ p ","
  || f@ p "."
  || f@ p "~"
  || f@ p "^"
  || f@ p "$"
  || f@ p "`"
  || f@ p "%" ) ? 1 : 0 )

gc (y Y c byte) none = fputc cast N c y
gs (y Y s @byte) none = fputs s y
glf(y Y) none = gc y '\n'

gn1 (y Y n nat) none = (n && gn1 y (n / 10) gc y cast byte ('0' + n % 10))
gn (y Y n nat) none = (n ? gn1 y n : gc y '0')

oc (c byte) none = putc cast N c
os (s @byte) none = puts s
olf() none = oc '\n'
on1 (n nat) none = (n && on1 (n / 10) oc cast byte ('0' + n % 10))
on (n nat) none = (n ? on1 n : oc '0')

ptype(k K) T

maxl (a N b N) N = ((a > b) ? a : b)
minl (a N b N) N = ((a < b) ? a : b)
maxul(a N b N) N = ((a > b) ? a : b)
minul(a N b N) N = ((a < b) ? a : b)

align_to(n N a N) N = ((n + a - 1) / a * a)

vdiag(in S c S line_n N p S s S) none =
(  (p for q ((c < q) && (q^-1 != '\n') && &q^-1)) is line
   (p for q (!!q@  && (q@ != '\n') && &q^1)) is end
   os "./" os in os ":(" on line_n oc ',' on (p - line + 1) os "): " olf
   os s olf )

diag(p S in @File s S) none =
(  1 is line
   (in.contents for p (&p^1 ret ((p@ == '\n') && (line = line + 1) as none)) as none)
   vdiag in.name in.contents line p s
   exit 1 )

jdiag(k K s S) none =
(  vdiag k.in.name k.in.contents k.j.line k.j.p s
   exit 1 )

ntype(size N align N format @(t T s S) none) T = (
  cast T calloc 1 sizeof Type is t t ret
  (t.size  = size  )
  (t.align = align )
  (t.format = format)
)

type ftfn (t T s S) none ;
type gefn (y Y e E c N l N) N;
type tk   (k K        ) T;
type tke  (k K e E    ) T;
type tkt  (k K t T    ) T;
type tktn (k K t T n N) T;
type tkst (k K s S t T) T;
type pfn  (k K t T    ) E;
type efn  (k K t T  ) E;
type efna (k K t T a E) E;

ftnone ftfn
ftbit  ftfn
ftbyte ftfn
ftnat  ftfn
ftstct ftfn
ftptr  ftfn
ftfunc ftfn
ftarr  ftfn


gelit   gefn
gesize  gefn
gederef gefn
geaddr  gefn
gethe   gefn
gecast  gefn
geref   gefn
gelnot  gefn
gebnot  gefn
geneg   gefn
gediv   gefn
gemod   gefn
gee     gefn
gene    gefn
geb     gefn
gebe    gefn
gea     gefn
geae    gefn
geadd   gefn
gesub   gefn
gemul   gefn
geband  gefn
gebor   gefn
gexor   gefn
geshl   gefn
geshr   gefn
geelem  gefn
gemem   gefn
geseq   gefn
geret   gefn
gecond  gefn
geland  gefn
gelor   gefn
geis    gefn
gefor   gefn
gecall  gefn
geass   gefn

format_type(t T) S =
(  cast S calloc 1 1 is s s
ret t.format@ t s )

type_equal(t T u T) bit =
(  !!t
&& !!u
&& t.format is c
  (  (t == u)
  ||(
      !!t.o ? type_equal t.o u
    : !!u.o ? type_equal t u.o
    : (  (c == u.format)
      &&(  (c == &ftnone)
        || (c == &ftbit )
        || (c == &ftbyte)
        || (c == &ftnat )
        || (c == &ftfunc)
          ?  !type_equal t.a u.a
          ?  0b
          :  u.a.s is p
             t.a.s is q (1b for _ (!!p && !!q && type_equal p q && (p = p.s)    (q = q.s) ) as none)
             (p == q)
          :  (c == &ftptr)
          ?  type_equal t.a u.a
          :  0b ) ) ) ) )

nnull () T = cast T 0
nnone () T = ntype 0 0 &ftnone
nbit  () T = ntype 1 1 &ftbit 
nbyte () T = ntype 1 1 &ftbyte
nnat  () T = ntype 8 8 &ftnat 
nptr   (a T    ) T = (ntype 8            8       &ftptr is t t ret (t.a = a)             )
nfunc  (a T    ) T = (ntype 1            1       &ftfunc  is t t ret (t.a = a)             )
array_of (a T n N) T = (ntype (a.size * n) a.align &ftarr is t t ret (t.a = a)    (t.n = n))
struct_of(       ) T =  ntype 0            1       &ftstct

copy_type(t T) T =
(  cast T calloc 1 sizeof Type is u u
ret (u@ = t@)
   (u.o = t) )

ntoken(q TokenKind a S b S) J =
(  cast J calloc 1 sizeof Token is j j
ret (j.q   = q    )
   (j.p = a    )
   (j.n   = b - a) )

escape_one(c C ca C cb C) C =
((c == ca) && cb)

escape(c S in @File) C =
(  &escape_one is f
  (  f@ c@ 'a' '\a'
  || f@ c@ 'b' '\b'
  || f@ c@ 'f' '\f'
  || f@ c@ 'n' '\n'
  || f@ c@ 'r' '\r'
  || f@ c@ 't' '\t'
  || f@ c@ 'v' '\v'
  || f@ c@ 'p' '\p'
  || f@ c@ 'q' '\q'
  || f@ c@ 's' '\s'
  || '\0'
  ret ((c@ != '0') && (diag c in "invalid escape sequence") as none) ) )

string_literal(in @File start S quote S) J =
( (  &quote^1 for q
    (  (q@ != '"')
    && &q^1
    ret ((q@ == '\0') && (diag quote in "unclosed string literal") as none) ) )
is end
   cast S calloc 1 (end - quote) is buf
   0 is n
  (  &quote^1 for p
    (  (p < end)
    && (p@ == '\s')
    ? (  buf^(n ret (n = n + 1)) = (p = &p^1)
         escape p in
      ret (p = &p^1) )
       p
    :  (buf^(n ret (n = n + 1)) = p@)
       &p^1 )
  as none )
   ntoken &JSTR start &end^1 is j
   (j.t = array_of nbyte (n + 1))
   (j.str = buf)
   j )

byte_literal(in @File p S) J =
(  &p^1 is q
   ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
  (  (q@ == '\s')
  ?  (q = &q^1)
     ((q@ == '\0') && (diag p in "unclosed literal byte") as none)
     escape q in
  :  q@ )
is c
   (q = &q^1)
   ((q@ != '\p') && (diag p in "unclosed literal byte") as none)
   ntoken &JNUM p &q^1 is j
   (j.l = c as N)
   (j.t = cast @none nbyte)
   j )

open_file(path S mode S) Y =
(fopen path mode || cast none (os "cannot open file '" os path os "' with mode '" os mode os "': " os strerror (__errno_location)@) olf)

read_file(path S) S =
(  cast S calloc 1 4096 is rfbuf2
   open_file path "r" is fp
   cast S 0 is buf
   0 is buflen
   &buflen is b
   open_memstream &buf b is y
   (1b for k
    fread cast @none rfbuf2 1 4096 fp is n
    ((n == 0) ? (k = 0b) : cast none fwrite cast @none rfbuf2 1 n y)
       k as none)
   free cast @none rfbuf2
   (fclose fp as none)
   fflush y
   (((buflen == 0) || (buf^(buflen - 1) != '\n')) && fputc cast N '\n' y as none)
   fputc 0 y
   fclose y
   buf )

tokenize(path S in @File) J = (
  read_file path is p
  (in.name = path)
  (in.contents = p)
   cast J 0 is j
   &j is k
   (1b for _ p@ &&
    startswith p "/*"
    ?  strstr &p^2 "*/" is q
       (!q && (diag p in "unclosed block comment"))
       (p = &q^2)
    :  (isws p@) ? (p = &p^1)
    :  (is09 p@ || ((p@ == '.') && is09 p^1))
    ?  (&p^1 for q ( isid q@ && &q^1 )) is q
       (k@ = ntoken &JNUM p q)
       (k.p is p
           10 is a
           (  (!strncmp p "0x" 2 && is0f p^2)
           && (p = &p^2)
              (a = 16)
           as none )
            strtoul p &p a is v
            ( (startswith p "b"  ) ? (p = &p^1)            nbit :
                                                           nnat ) is t
            (k.l = v as N )   
            (k.t = t as @none   )   
            1b)
       (k = &k.s)
       (p = q)
    :  (p@ == '"')
    ?  (k@ = string_literal in p p)
       (p = &p^k.n)
       (k = &k.s)
    :  (p@ == '\p')
    ?  (k@ = byte_literal in p)
       (k.l = k.l as C as N)
       (p = &p^k.n)
       (k = &k.s)
    :  0 is n
       (p for q ((isid q@ && &q^1) || cast S 0 ret (n = q - p as N)) as none)
       !!n
    ?  (k@ = ntoken &JID p &p^n)
       (p = &p^k.n)
       (k = &k.s)
    :  read_punct p is n
       !!n
    ?  (k@ = ntoken &JPCT p &p^n)
       (p = &p^k.n)
       (k = &k.s)
    :  (diag p in "invalid token"))
   j ret
   1 is n
  ( in.contents for p
    !!p@ &&
    !!j &&
    ((p == j.p) && (j.line = n) (j = j.s))
    ((p@ == '\n') && (n = n + 1))
    &p^1 )
)

push_scope  (k K c S    ) @Scope = (
  cast @Scope calloc 1 sizeof Scope is s
  (s.c = c)
  (s.s = k.s)
  (k.s = s)
  s
)

try_search_scope(k K c S n N) @Scope = (
  cast @Scope 0 is r
  (!!k.s && k.s for s ((n != strlen s.c )|| !!strncmp s.c c n) ?
    s.s :
  (r = s)
  cast @Scope 0 as none )
  r
)

search_scope(k K c S n N) @Scope = (
  try_search_scope k c n ||
  (jdiag k "lookup failed")
)

type o_kst (k K s S t T) O;

nvar o_kst =
(  cast O calloc 1 sizeof Obj is o
   (o.name = s) 
   (o.t = t) 
   ((push_scope k s).o = o) 
   o )

nbetvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   o )

nlvar o_kst =
(  nvar k s t is o
   (o.is_local = 1b)
   (o.s = k.locals)
   (k.locals = o)
   o )

ngvar o_kst = (
  nvar k s t is o
  (o.s = k.globals)
  (o.is_definition = 0b)
  (k.globals = o)
  o
)

nstr (k K t T) O = (
  cast S 0 is s2
  cast N 0 is n
  open_memstream &s2 &n is y
  (gs y ".s" gn y cast nat k.j)
  fclose y
  ngvar k s2 t is o
  (o.j = k.j)
  (o.is_definition = 1b)
  o
)

id(k K) S = (
  ( !!k.j &&
    (k.j.q != &JID) &&
    (jdiag k "expected <id>") )
  strndup k.j.p k.j.n
)

find_type(k K c S n N) T = (
  (!!k.j && (k.j.q != &JID)) ?
    nnull :
  search_scope k c n is s
  (!!s && s.t)
)

get_struct_member(t T j J) T = (
  nnull is r
  ( t.a for g
    ((g.name.n == j.n) && !strncmp g.name.p j.p j.n)
    ? (r = g)
      nnull :
    g.s )
  r
)

jadv   (k K    ) J    = (k.j ret (k.j = k.j.s))
jeq    (k K c S) bit  = (!!k.j && (!memcmp cast @none k.j.p cast @none c cast N k.j.n && !c^k.j.n))
expect (k K c S) none = ((!jeq k c && (jdiag k "unexpected") as none)    (k.j = k.j.s))
consume(k K c S) bit  = (jeq k c is r r ret (r && (k.j = k.j.s) as none) )

declarator (k K t T) none = (
  jadv k is j
  ptype k is u
  (t@ = u@)
  (t.o = u)
  (t.name = j)
)

struct_decl tk = (
  struct_of is t
  expect k "{"
  &t.a is u
  ( 1b for _ 
    ( !consume k "}" &&
      (calloc 1 sizeof Type as T) is g
      (declarator k g)
      (u@ = g)
      (u = &u.s) ) )
  0 is bits
  ( !!t.a &&
    t.a for g
    (bits = align_to bits (g.align * 8))
    (g.offset = bits / 8)
    (bits = bits + g.size * 8)
    ((t.align < g.align) && (t.align = g.align))
    g.s )
  (t.size = align_to bits (t.align * 8) / 8)
  t
)

func_params tk = (
  cast T 0 is params
  &params is u
  ( 1b for _
    !jeq k ")" &&
    (u@ = cast T calloc 1 sizeof Type)
    declarator k u@
    (u = &u.s)
    1b )
  jadv k
  nfunc ptype k is t
  (t.params = params)
  t
)

ptype tk = (
  consume k "none"   ? nnone               :
  consume k "bit"    ? nbit                :
  consume k "byte"   ? nbyte               :
  consume k "nat"    ? nnat                :
  consume k "@"      ? nptr        ptype k :
  consume k "("      ? func_params       k :
  consume k "struct" ? struct_decl       k :
  search_scope k k.j.p k.j.n is s
  !!s &&
  jadv k
  s.t
)

tree(j J t T gen @gefn            ) E = (cast E calloc 1 sizeof Node is e e ret (e.j = j)  (e.t = t) (e.gen = gen))
t0  (j J t T gen @gefn            ) E = (tree j t gen)
t1  (j J t T gen @gefn a E        ) E = (tree j t gen is e e ret (e.a   = a))
t2  (j J t T gen @gefn a E b E    ) E = (tree j t gen is e e ret (e.a   = a)  (e.a.s = b))
t3  (j J t T gen @gefn a E b E c E) E = (tree j t gen is e e ret (e.a   = a)  (e.a.s = b)  (e.a.s.s = c))
tt  (j J t T gen @gefn u T        ) E = (t0   j t gen is e e ret (e.t.s = u))
to  (j J t T gen @gefn o O        ) E = (t0   j t gen is e e ret (e.o   = o))
tl  (j J t T gen @gefn l N        ) E = (t0   j t gen is e e ret (e.l   = l))

type njtu  (j J t T u T        ) E;
type njtua (j J t T u T a E    ) E;
type njta  (j J t T     a E    ) E;
type njtab (j J t T     a E b E) E;

nsize       njtu  = tt j nnat     &gesize    u
nthe        njtua = t1 j a.t      &gethe     a
ncast       njtua = t1 j u        &gecast    a
ncall       njta  = t1 j a.t.a    &gecall    a
nneg        njta  = t1 j nnat     &geneg     a
naddr       njta  = t1 j nptr a.t &geaddr    a
nlnot       njta  = t1 j nbit     &gelnot    a
nbnot       njta  = t1 j nnat     &gebnot    a
nderef      njta  = t1 j a.t.a    &gederef   a
nass        njtab = t2 j nnone    &geass     a b
nbor        njtab = t2 j nnat     &gebor     a b
nband       njtab = t2 j nnat     &geband    a b
ne          njtab = t2 j nbit     &gee       a b
nne         njtab = t2 j nbit     &gene      a b
na          njtab = t2 j nbit     &gea       a b
nb          njtab = t2 j nbit     &geb       a b
nae         njtab = t2 j nbit     &geae      a b
nbe         njtab = t2 j nbit     &gebe      a b
nshl        njtab = t2 j nnat     &geshl     a b
nshr        njtab = t2 j nnat     &geshr     a b
nmul        njtab = t2 j nnat     &gemul     a b
ndiv        njtab = t2 j nnat     &gediv     a b
nmod        njtab = t2 j nnat     &gemod     a b
nret        njtab = t2 j a.t      &geret     a b
nseq        njtab = t2 j b.t      &geseq     a b
nlor        njtab = t2 j a.t      &gelor     a b
nland       njtab = t2 j b.t      &geland    a b
nelem       njtab = t2 j a.t.a    &geelem    a b
nadd        njtab = t2 j nnat     &geadd     a b
nsub        njtab = t2 j nnat     &gesub     a b

/* oddballs */

nreference  (j J t T         o O ) E = (to j o.t &geref o                        )
nlit        (j J t T u T     l N ) E = (tl j u   &gelit l                        )
nbet        (j J t T a E b E o O ) E = (t2 j b.t &geis   a b is e e ret (e.o = o))
nrepeat     (j J t T a E b E o O ) E = (t2 j b.t &gefor  a b is e e ret (e.o = o))
ncond       (j J t T a E b E c E ) E = (t3 j b.t &gecond a b c                   )

p1    pfn
p2    pfn
p4    pfn
p5    pfn
p7    pfn
pmul  pfn
padd  pfn
psh   pfn
pcmp  pfn
pband pfn
pbor  pfn
pland pfn
plor  pfn

esize  efn  = (jadv k is j ptype k is u nsize j t u       )
ethe   efn  = (jadv k is j ptype k is u nthe  j t u p4 k t)
ecast  efn  = (jadv k is j ptype k is u ncast j t u p4 k t)
eas    efna = (jadv k is j ptype k is u ncast j t u a     )
efrom  efna = (jadv k is j ptype k is u nthe  j t u a     )

elit   efn  = (jadv k is j nlit    j t cast T j.t j.l    )
eaddr  efn  = (jadv k is j naddr   j t     p2 k t        )
eelem  efna = (jadv k is j nelem   j t a   p4 k nnat )
eneg   efn  = (jadv k is j nneg    j t     p4 k t        )
elnot  efn  = (jadv k is j nlnot   j t     p4 k t        )
ebnot  efn  = (jadv k is j nbnot   j t     p4 k t        )
ederef efna = (jadv k is j nderef  j t a                 )
eseq   efna = (k.j    is j nseq    j t a   p5 k t        )
ethen  efna = (jadv k is j nret    j t a   p5 k nnone    )
emul   efna = (jadv k is j nmul    j t a   p5 k a.t      )
ediv   efna = (jadv k is j ndiv    j t a   p5 k a.t      )
emod   efna = (jadv k is j nmod    j t a   p5 k a.t      )
eland  efna = (jadv k is j nland   j t a   p5 k a.t      )
elor   efna = (jadv k is j nlor    j t a   p5 k a.t      )
econd  efna = (jadv k is j                 p5 k t is b expect k ":"
                           ncond   j t a b p5 k t        )
eadd   efna = (jadv k is j nadd    j t a   pmul  k a.t   )
esub   efna = (jadv k is j nsub    j t a   pmul  k a.t   )
eshl   efna = (jadv k is j nshl    j t a   padd  k a.t   )
eshr   efna = (jadv k is j nshr    j t a   padd  k a.t   )
elt    efna = (jadv k is j nb      j t a   psh   k nnull )
egt    efna = (jadv k is j na      j t a   psh   k nnull )
ele    efna = (jadv k is j nbe     j t a   psh   k nnull )
ege    efna = (jadv k is j nae     j t a   psh   k nnull )
eeq    efna = (jadv k is j ne      j t a   psh   k nnull )
ene    efna = (jadv k is j nne     j t a   psh   k nnull )
eband  efna = (jadv k is j nband   j t a   pcmp  k a.t   )
ebor   efna = (jadv k is j nbor    j t a   pband k a.t   )
eass   efna = (jadv k is j nass    j t a   p7    k a.t   )

eis    efna = (jadv k is j k.s is s nbetvar k id k a.t is o jadv k      p5 k t       is b nbet         j   t     a b   o ret (k.s = s))
efor   efna = (jadv k is j k.s is s nbetvar k id k a.t is o jadv k      p5 k t       is b nrepeat      j   t     a b   o ret (k.s = s))

eid    efn  = (jadv k is j
  search_scope k j.p j.n is s
  nreference j t s.o
)

estr   efn  = ( 
  cast T k.j.t is u
  nstr k u is o
  jadv k is j
  ncast j t nptr u.a nthe j u o.t nreference j u o
)

emem  efna =
(  jadv k is j
   cast none jadv k
   (a.t for t ((t.format == &ftptr) && t.a)) is t
   ((t.format != &ftstct) && (jdiag k "not a struct") as none)
   get_struct_member t j.s is g
  (  !g
  &&(  jdiag k "no such member" ) as none )
   t1 j.s g &gemem a )

end_seq(k @Ctx) bit = (
   jeq k ")"
|| jeq k ":"
|| jeq k "?"
|| jeq k "*"
|| jeq k "/"
|| jeq k "%"
|| jeq k "+"
|| jeq k "-"
|| jeq k "<<"
|| jeq k ">>"
|| jeq k "<"
|| jeq k ">"
|| jeq k "<="
|| jeq k ">="
|| jeq k "=="
|| jeq k "!="
|| jeq k "|"
|| jeq k "&&"
|| jeq k "||"
|| jeq k "="
|| jeq k "as"
|| jeq k "from"
)

ecall efna = (
  a.t.params is u
  (  a for b
    ( !!u &&
      (b.s = p4 k u)
      ( !!u &&
        (!type_equal b.s.t u && (jdiag k "asymmetric argument") )
        (u = u.s) )
      b.s ) )
  ncall k.j t a
)

pj(k K t T     q TokenKind e @efn ) E = ((k.j.q == q) && e@ k t)
pl(k K t T     c S         e @efn ) E = (jeq k c && e@ k t  )
pr(k K t T a E c S         e @efna) E = (jeq k c && e@ k t a)

pcast efna = (
  pr k t a "as"   &eas    ||
  pr k t a "from" &efrom
)

p2 efn = ( (
    consume k "(" ? (
      p7    k nnull for a
      pr    k t a "=" &eass ||
      pcast k t a ) ret expect k ")" :
    pj k t &JID  &eid  ||
    pj k t &JSTR &estr ||
    pj k t &JNUM &elit ||
    (jdiag k "expected an expression")
  ) for a
  pr    k t     a "^"       &eelem   ||
  pr    k t     a "."       &emem   ||
  pr    k t     a "@"       &ederef
)

p4 efn = (
  pl k t "-" &eneg   ||
  pl k t "!" &elnot  ||
  pl k t "~" &ebnot  || (
    pl k t     "cast"    &ecast  ||
    pl k t     "the"     &ethe   ||
    pl k t     "&"       &eaddr  ||
    pl k t     "sizeof"  &esize  ||
    p2 k nnull
  ) for a
  (a.t.format == &ftfunc) &&
  ecall k t a
)

p5  efn = (
  p4    k nnull  is a
  pr    k t a "ret"     &ethen  ||
  pr    k t a "is"      &eis    ||
  pr    k t a "for"     &efor   ||
  pr    k t a "&&"      &eland  ||
  pr    k t a "||"      &elor   ||
  pr    k t a "?"       &econd  ||
  end_seq k ? a : eseq k t a
)

pmul  efn = (p5  k t       for a ( pr    k t a "*"       &emul   ||
                                   pr    k t a "/"       &ediv   ||
                                   pr    k t a "%"       &emod      ) )
padd  efn = (pmul  k t     for a ( pr    k t a "+"       &eadd   ||
                                   pr    k t a "-"       &esub      ) )
psh   efn = (padd  k t     for a ( pr    k t a "<<"      &eshl   ||
                                   pr    k t a ">>"      &eshr      ) )
pcmp  efn = (psh   k nnull for a ( pr    k t a "<"       &elt    ||
                                   pr    k t a ">"       &egt    ||
                                   pr    k t a "<="      &ele    ||
                                   pr    k t a ">="      &elt    ||
                                   pr    k t a "=="      &eeq    ||
                                   pr    k t a "!="      &ene       ) )
pband efn = (pcmp  k t     for a   pr    k t a "&"       &eband     )
pbor  efn = (pband k t     for a   pr    k t a "|"       &ebor      )
p7    efn = (pbor  k t     for a   pcast k t a                   )

typedecl(k K) J = (
  k.j for j
  !consume k ";" &&
  push_scope k id k is s
  (s.t = cast T calloc 1u sizeof Type)
  declarator k s.t
  k.j
)

create_lvars(k K t T) none = (
  !!t &&
  create_lvars k t.s
  k.j is j
  (k.j = t.name)
  nlvar k id k t
  (k.j = j)
)

find_func(k K c S n N) O = (
  try_search_scope k c n is s
  (!!s && !!s.o && (s.o.t.format == &ftfunc) && s.o)
)

function(k K) none =
( cast T calloc 1u sizeof Type is t
  consume k "export" is is_export
  declarator k t
  find_func k t.name.p cast N t.name.n is o
  (  !!o
  ?  ((o.t.format != &ftfunc)      && (jdiag k "redeclared as a different type of symbol") as none)
     (o.is_definition && jeq k "=" && (jdiag k "redefinition") as none)
     ((o.is_export != is_export )  && (jdiag k "mismatched visibility") as none)
  :  ( k.j is j
       (k.j = t.name)
       (o = ngvar k id k t)
       (k.j = j)
       (o.is_export = is_export) ) )
  ( consume k "=" &&
    (o.is_definition = 1b)
    (k.locals = cast O 0)
    k.s is s
    create_lvars k t.params
    (o.params = k.locals)
    (o.body = p4 k t.a as @none)
    (o.locals = k.locals)
    (k.s = s) ) )

parse(j J in @File) O = (
  cast @Ctx calloc 1ul sizeof Ctx is k
  (k.j = j)
  (k.in = in)
  ( !!k.j &&
    k.j for j
    ( consume k "type" ?
        typedecl k :
      function k )
    k.j )
  k.globals
)

argreg1(d N) S =
(  (d == 0) ? "%dil" :
   (d == 1) ? "%sil" :
   (d == 2) ? "%dl"  :
   (d == 3) ? "%cl"  :
   (d == 4) ? "%r8b" :
              "%r9b" )

argreg8(d N) S =
( (d == 0) ? "rdi" :
  (d == 1) ? "rsi" :
  (d == 2) ? "rdx" :
  (d == 3) ? "rcx" :
  (d == 4) ? "r8"  :
             "r9"  )

gtreg(y Y s S) none = (gc y '%' gs y s)
gt1  (y Y s S a S) none = (gs y s gc y ' ' gtreg y a glf y)
gt2  (y Y s S a S b S) none = (gs y s gc y ' ' gtreg y a gs y ", " gtreg y b glf y)

gtz (y Y a S) none = gt2 y "xor"  a a
gtcz(y Y a S) none = gt2 y "test" a a

gtlit(y Y l N a S) none = (!!l ? (gs y "  mov $" gn y l gs y " , %rax" glf y) : gtz y "eax")

gtnot(y Y     a S) none = gt1 y "not" a
gtneg(y Y     a S) none = gt1 y "neg" a
gmul (y Y     a S) none = gt1 y "mul" a
gdiv (y Y    ) none = ( gtz y "edx" gt1 y "div" "rdi")
gmod (y Y    ) none = ( gdiv y
                        (gs y "  mov %rdx, %rax" glf y) )
gshx (y Y x C) none = ( (gs y "  mov %dil, %cl" glf y   )
                        (gs y "  sh" gc y x gs y " %cl, %rax" glf y) )

gadd (y Y a S b S) none = gt2 y "add" a b
gsub (y Y a S b S) none = gt2 y "sub" a b
gand (y Y a S b S) none = gt2 y "and" a b
gor  (y Y a S b S) none = gt2 y "or " a b
gxor (y Y a S b S) none = gt2 y "xor" a b
gcmp (y Y a S b S) none = gt2 y "cmp" a b
gshr (y Y) none = gshx y 'r'
gshl (y Y) none = gshx y 'l'

gpromote(y Y b S) none = (gt2 y "movzbl" "al" b)

gsetf     (y Y s S     b S) none = (gs y "  set" gs y s gs y "  %al" glf y gpromote y b)
gcmp_setf (y Y s S a S b S c S) none = (gcmp y a b gsetf y s c)
gcmpz_setf(y Y s S a S b S) none = (gtcz y a gsetf y s b)
glnot     (y Y     a S b S) none = (gcmpz_setf y "e" a b)

gj        (y Y e E l S    ) none = (gs y "  jmp " gs y l gn y cast nat e gc y '$' glf y)
gjc       (y Y e E l S s S) none = (gs y "  j" gs y s gc y ' ' gs y l gn y cast nat e gc y '$' glf y)
glabel    (y Y e E l S    ) none = (gs y l gn y cast nat e gs y "$:" glf y)

gje  (y Y e E l S) none = gjc y e l "e "
gjne (y Y e E l S) none = gjc y e l "ne"
gjb  (y Y e E l S) none = gjc y e l "b "
gjbe (y Y e E l S) none = gjc y e l "be"
gja  (y Y e E l S) none = gjc y e l "a "
gjae (y Y e E l S) none = gjc y e l "ae"

ge  (y Y) none = gcmp_setf y "e " "rdi" "rax" "eax"
gne (y Y) none = gcmp_setf y "ne" "rdi" "rax" "eax"
gb  (y Y) none = gcmp_setf y "b " "rdi" "rax" "eax"
gbe (y Y) none = gcmp_setf y "be" "rdi" "rax" "eax"
ga  (y Y) none = gcmp_setf y "a " "rdi" "rax" "eax"
gae (y Y) none = gcmp_setf y "ae" "rdi" "rax" "eax"

gcast(y Y a T b T) none =
(  (b.format == &ftnone) ?  gtz    y "eax"
:  (b.format == &ftbyte) && gpromote y "eax")

gfpush(y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gs y "  sub $" gn y l1  gs y ", " gtreg y "rsp" glf y) (c@ = c@ + l1))
gfpop (y Y c @N  l N ) none = (!!l && (8 * l) is l1 (gs y "  add $" gn y l1  gs y ", " gtreg y "rsp" glf y) (c@ = c@ - l1))
gpush (y Y c @N      ) none = (gs y "  push " gtreg y "rax" glf y    (c@ = c@ + 8))
gpop  (y Y c @N  s S ) none = (gs y "  pop  " gtreg y s     glf y    (c@ = c@ - 8))
gindex(y Y       l N ) none = (!!l && gs y "  add $" gn y l gs y ", " gtreg y "rax" glf y)

gaddr(y Y q @ftfn n N s S d S) none = (gs y "  lea    " gn y n gs y "(%r" gs y s gs y "), %r" gs y d glf y)
gload(y Y q @ftfn n N s S d S) none = (
  ((q == &ftarr)|| (q == &ftstct)|| (q == &ftfunc)) ?
    gaddr y q n s d :
  ((q == &ftbyte) || (q == &ftbit)) ?
    gs y "  movzbl " gn y n gs y "(%r" gs y s gs y "), %e" gs y d glf y :
  gs y "  mov    " gn y n gs y "(%r" gs y s gs y "), %r" gs y d glf y
)

gaddrg(y Y e E c @N d S) none = (gs y "  lea    " gs y e.o.name gs y ", %r" gs y d glf y)
gloadg(y Y e E c @N d S) none =
( ((e.o.t.format == &ftarr)|| (e.o.t.format == &ftstct)|| (e.o.t.format == &ftfunc))
? gaddrg y e c d
: ((e.o.t.format == &ftbyte) || (e.o.t.format == &ftbit))
? (gs y "  movzbl " gs y e.o.name gs y ", %e" gs y d glf y)
: (gs y "  mov    " gs y e.o.name gs y ", %r" gs y d glf y)
as none )

gaddrl(y Y e E c @N d S) none = (gaddr y e.o.t.format (e.o.sp ? (c@ - e.o.sp) : (e.o.offset + c@)) "sp" d)
gloadl(y Y e E c @N d S) none = (gload y e.o.t.format (e.o.sp ? (c@ - e.o.sp) : (e.o.offset + c@)) "sp" d)


gloadsp(y Y q @ftfn d S) none =
(  ((q == &ftarr)|| (q == &ftstct)|| (q == &ftfunc))
? (gs y "  mov     %rsp,  %r" gs y d glf y)
: ((q == &ftbyte) || (q == &ftbit))
? (gs y "  movzbl (%rsp), %e" gs y d glf y)
: (gs y "  mov    (%rsp), %r" gs y d glf y) )

gstoresp(y Y t T) none =
(  (gs y " mov %rsp, %rdi" glf y)
   ((t.format == &ftstct) || (t.format == &ftarr)) ? (0 for i ((i < t.size) && (i + 1)
ret (gs y "  mov "gn y i"(%rax), %r8b    ")
    (gs y "  mov %r8b    , "gn y i"(%rdi)")) as none)
:  (t.size == 1) ? (gs y "  mov %al , (%rdi)" glf y)
:                  (gs y "  mov %rax, (%rdi)" glf y) )

gstore(y Y t T c @N) none =
(  gpop y c "rdi"
   ((t.format == &ftstct)) ? (0 for i ((i < t.size) && (i + 1)
ret (gs y "  mov " gn y i gs y "(%rax), %r8b    " glf y)
    (gs y "  mov %r8b    , " gn y i gs y "(%rdi)" glf y)) as none)
:  (t.size == 1) ? (gs y "  mov %al , (%rdi)" glf y)
:                  (gs y "  mov %rax, (%rdi)" glf y) )

glet(y Y o O c @N) none = (
  gfpush y c 8
  (o.sp = c@)
  gstoresp y o.t
)

gulet(y Y o O c @N d S) none = (
  gloadsp y o.t.format d
  (o.sp = 0)
  gfpop y c 8
)

gexpr gefn = (
  (gs y ".loc 0 " gn y e.j.line glf y)
  e.gen@ y e c l
)

gdrop (y Y e E c N    ) none = (cast none gexpr y e c 0)
geval (y Y e E c N l N) none = (
  gexpr y e c l is l1
  !!l1 && l1 for l2
  gload y (((l2 == 1) && (l == 0)) ? e.t.format : &ftptr) 0 "ax" "ax"
  (l2 - 1)
)

gescape(y Y s @byte) @byte = (
  (s^0 == '\s') ?
    gc y '\s'
    (s^1 == 'p') ? gc y '\p' &s^2 :
    (s^1 == 'q') ? gc y '\q' &s^2 :
                   gc y s^1  &s^2 :
  gc y s@
  &s^1
)

gdata(y Y o O) none = (
  (gs y "  .data" glf y                             )
  (gs y "  .type " gs y o.name gs y ", @object" glf y)
  (gs y "  .size " gs y o.name gs y ", " gn y o.t.size glf y)
  (gs y "  .align " gn y o.t.align glf y)
  (gs y o.name gc y ':' glf y                          )
  gs y "  .string \q"
  &o.j.p^1 is a
  &o.j.p^(o.j.n - 1) is b
  ( a for i
    (i < b) &&
    gescape y i)
  gs y "\q\n"
)

gtext(y Y o O) none = (
  ( !!o.params &&
    16 is t
     0 is g
    o.params for o
    ( (g > 6) &&
      (t        = align_to t 8)
      (o.offset = t           )
      (t        = t + o.t.size)
      (g = g + 1) ) 
    o.s )
  0 is c
  ( !!o.locals &&
    o.locals for o
    ( !o.offset &&
      (c = c + o.t.size)
      (c = align_to c o.t.align)
      (o.offset = -c) )
    o.s )
  (c = align_to c 16) /* abi says c of frame is aligned to 16 */
  (gs y "  .text" glf y)
  (gs y "  .type " gs y o.name gs y ", @function" glf y)
  (gs y o.name gc y ':' glf y)
  (gs y "  enter $" gn y c gs y ", $0" glf y)
  (  0 is d
     o.params for o
    (  !!o
    && o.s
    ret(  (o.offset > (-1 >> 1))
      && o.t is t
         ((t.size == 1)
      ?  (gs y "  mov " gs y argreg1 d gs y ", " gn y (o.offset + c) gs y "(%rsp)" glf y)
      :  (gs y "  mov %" gs y argreg8 d gs y ", " gn y (o.offset + c) gs y "(%rsp)" glf y  ))
      ret (d = d + 1)
      as none ) )
  as none )
  gdrop y cast E o.body c
  (gs y "  leave" glf y)
  (gs y "  ret" glf y)
)

gsym(y Y o O) none = (
  !!o.is_definition &&
  (gs y "  ." gs y (!o.is_export ? "local" : "globl") gc y ' ' gs y o.name glf y)
  ((o.t.format == &ftfunc) ? &gtext : &gdata)@ y o
)

codegen(o O y Y in S) none = (
  (gs y "  .file 0 \q" gs y in gc y '\q' glf y)
  !!o &&
  o for o
  o.s ret gsym y o
)

export main(argc N argv @S) N =
( open_file argv^2 "w" is y
  cast @File calloc 1 sizeof File is in
  (!y ? 1 : 0 ret codegen parse tokenize argv^1 in in y argv^1)
ret cast none fclose y )



type gelfn (y Y v N) N;
type gegfn (y Y e E c N l N gop @(y Y) none) N;

ge0     gelfn = (
  gtlit  y v "rax"
  0
)

ge1     gegfn = (
  geval y e.a c 0
  gop@  y
  0
)

gegadd (y Y) none = (gadd y "rdi" "rax")
gegsub (y Y) none = (gsub y "rdi" "rax")
gegand (y Y) none = (gand y "rdi" "rax")
gegor  (y Y) none = (gor  y "rdi" "rax")
gegxor (y Y) none = (gxor y "rdi" "rax")
gegcmp (y Y) none = (gcmp y "rdi" "rax")
gegbnot(y Y) none = (gtnot y "rax")
gegneg (y Y) none = (gtneg y "rax")
geglnot(y Y) none = (glnot y "rax" "eax")
gegmul (y Y) none = (gmul y "rdi")
gegdiv (y Y) none = (gdiv y)
gegmod (y Y) none = (gmod y)
gegshr (y Y) none = (gshr y)
gegshl (y Y) none = (gshl y)
gege   (y Y) none = (ge  y)
gegne  (y Y) none = (gne y)
gegb   (y Y) none = (gb  y)
gegbe  (y Y) none = (gbe y)
gega   (y Y) none = (ga  y)
gegae  (y Y) none = (gae y)

ge2     gegfn = (
  geval y e.a.s  c 0
  gpush y       &c
  geval y e.a    c 0
  gpop  y       &c "rdi"
  gop@  y
  0
)

/* fundamentals */

gelit   gefn = ge0 y e.l
gesize  gefn = ge0 y e.t.s.size
gederef gefn = (gexpr y e.a c 0 + 1 - l)
geaddr  gefn = gexpr y e.a c 1
gethe   gefn = gexpr y e.a c l

gecast  gefn =  (
  geval y e.a c 0
  gcast y e.a.t e.t
  0
)

geref   gefn = (
  (e.o.is_local ? &gaddrl : &gaddrg) is gaddr
  (e.o.is_local ? &gloadl : &gloadg) is gload
  (!l ? gload : gaddr)
  @ y e &c "ax"
  0
)

/* arithmetic operations */

gelnot  gefn = ge1 y e c l &geglnot
gebnot  gefn = ge1 y e c l &gegbnot
geneg   gefn = ge1 y e c l &gegneg
gediv   gefn = ge2 y e c l &gegdiv
gemod   gefn = ge2 y e c l &gegmod
gee     gefn = ge2 y e c l &gege
gene    gefn = ge2 y e c l &gegne
geb     gefn = ge2 y e c l &gegb
gebe    gefn = ge2 y e c l &gegbe
gea     gefn = ge2 y e c l &gega
geae    gefn = ge2 y e c l &gegae
geadd   gefn = ge2 y e c l &gegadd
gesub   gefn = ge2 y e c l &gegsub
gemul   gefn = ge2 y e c l &gegmul
geband  gefn = ge2 y e c l &gegand
gebor   gefn = ge2 y e c l &gegor
geshl   gefn = ge2 y e c l &gegshl
geshr   gefn = ge2 y e c l &gegshr

/* pointer magic */

geelem  gefn = (
  geval y e.a    c 0
  gpush y       &c
  geval y e.a.s  c 0
  gpop  y       &c "rdx"
  (gs y "  lea (%rdx, %rax, " gn y e.a.t.a.size gs y "), %rax" glf y)
  (1 - l)
)

gemem   gefn = (
  geval y e.a c 0
  ( e.a.t for t
    ( (t.format == &ftptr) &&
      t.a ret
      gload y t.a.format 0 "ax" "ax"
    as none )
  as none )
  gindex y e.t.offset
  (1 - l)
)

/* sequencing */

geseq gefn = (
  gdrop y e.a   c
  geval y e.a.s c l
  0
)

geret gefn = (
  geval y e.a    c l
  gpush y       &c
  gdrop y e.a.s  c
  gpop  y       &c "rax"
  0
)

gecond gefn = (
  geval  y e.a     c 0
  gtcz  y            "eax"
  gje    y e         "a"
  geval  y e.a.s   c l
  gj     y e         "b"
  glabel y e         "a"
  geval  y e.a.s.s c l
  glabel y e         "b"
  0
)

geland  gefn = (
  (e.a.s.t.format == &ftnone) is keep
  geval y e.a c 0
  gtcz y "eax"
  gje   y e         "a"
  ( keep &&
    gpush y       &c      )
  geval y e.a.s c 0
  ( keep &&
    gpop  y       &c "rax" )
  glabel y e        "a"
  0
)

gelor gefn = (
  (e.a.s.t.format == &ftnone) is keep
  geval   y e.a   c 0
  gtcz   y "eax"
  gjne    y e       "a"
  ( keep &&
    gpush y       &c      )
  geval   y e.a.s c 0
  ( keep &&
    gpop  y       &c "rax" )
  glabel  y e       "a"
  0
)

geis    gefn = (
  geval  y e.a    c 0
  glet   y e.o   &c
  geval  y e.a.s  c l
  gulet  y e.o   &c "dx"
  0
)

gefor   gefn = (
  geval    y e.a    c 0
  glet     y e.o   &c
  gj       y e        "b"
  glabel   y e        "a"
  gstoresp y e.a.t
  glabel   y e        "b"
  geval    y e.a.s  c 0
  gtcz    y "eax"
  gjne     y e        "a"
  gulet    y e.o   &c "ax"
  0
)

gargs(y Y e E c @N d N) none =
(  !!e
&&(  (d < 6)
  && gargs y e.s c (d + 1) )
   geval y e c@ 0
   gpush y c
as none )

gecall gefn = (
  0 is stack
  0 is d
  ( ( (c + stack) % 16 != 0) &&
    gfpush y &c 1
    (stack = stack + 8)
  as none )
  gargs y e.a.s &c 0
  geval y e.a   c 0
  0 is d
  (!!e.a.s && e.a.s for e e.s ret ((d < 6) && gpop y &c argreg8 d ret (d = d + 1)) as none)
  (gs y "  call *%rax" glf y)
  gfpop y &c (stack >> 3)
  0
)

/* ass */

geass   gefn = (
  geval  y e.a    c 1
  gpush  y       &c
  geval  y e.a.s  c 0
  gstore y e.a.t &c
  gtz  y         "eax"
  0
)

ftnone ftfn = strcat s "none"
ftbit  ftfn = strcat s "bit"
ftbyte ftfn = strcat s "byte"
ftnat  ftfn = strcat s "nat"
ftstct ftfn = strcat s "struct"
ftarr  ftfn = strcat s "array"
ftptr  ftfn = (strcat s "@"  ret t.a.format@ t.a s)
ftfunc ftfn = (strcat s "("  ret
              (t.a.s for p (!!p && p.s ret p.format@ p s ) as none)
                         strcat s ")"  ret t.a.format@ t.a s)