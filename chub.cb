type
  va_list struct {
    gp_offset         %nat
    fp_offset         %nat
    overflow_arg_area @none
    reg_save_area     @none
  }

  FILE struct {}

  NodeKind enum
    ND_ADD       ND_SUB     ND_MUL     ND_DIV       ND_THE
    ND_NEG       ND_MOD     ND_BITAND  ND_BITOR     ND_BITXOR
    ND_SHL       ND_SHR     ND_EQ      ND_NE        ND_LT
    ND_LE        ND_GT      ND_GE      ND_ASSIGN    ND_COND
    ND_COMMA     ND_MEMBER  ND_ADDR    ND_DEREF     ND_NOT
    ND_BITNOT    ND_LOGAND  ND_LOGOR   ND_THEN      ND_FUNCALL
    ND_LET       ND_VAR     ND_NUM     ND_CAST      ND_MEMZERO
    ND_REPEAT    ND_SIZE    ND_ALIGN   ND_ELEM
  ;

  TypeKind enum
    TY_VOID
    TY_BOOL
    TY_BYTE
    TY_NAT
    TY_FUNC
    TY_ARRAY
    TY_ENUM
    TY_STRUCT
    TY_PTR
    TY_RING
  ;

  TokenKind enum
    TK_EOF
    TK_ID
    TK_PCT
    TK_KEY
    TK_STR
    TK_NUM
  ;

  File struct {
    name         @byte
    contents     @byte
  }

  Token struct {
    q        TokenKind
    s          @same
    l           nat
    loc        @byte
    n        %nat
    t          @none
    str        @byte
    in         @File
    line_no     nat
  }

  Type struct  {
    q          TypeKind
    size          nat
    align         nat
    offset        nat
    n     nat
    s            @same
    o            @same
    a            @same
    params       @same
    name         @Token
    is_variadic   bit
  }

  Relocation struct {
    s       @same
    offset   nat
    label  @@byte
    addend   nat
  }

  Obj struct {
    s               @same
    name            @byte
    t               @Type
    j               @Token
    offset           nat
    stack_size       nat
    is_local         bit
    is_definition    bit
    is_export        bit
    init_data       @byte
    rel             @Relocation
    params          @same
    body            @none
    locals          @same
    va_area         @same
  }

  Node struct {
    s @same
    a @same
    q  NodeKind
    j @Token
    t @Type
    o @Obj
    l  nat
  }

  Scope struct {
    s @same
    c @byte
    o @Obj
    t @Type
    v  nat
  }

  VarAttr struct {
    is_type    bit
    is_export  bit
  }

  Ctx struct {
    j @Token
    locals         @Obj
    globals        @Obj
    s @Scope
    t @Type
    n  nat
  }
;

export __errno_location    ( ) @nat ;

export aname            (path @byte) @byte ;

export open_memstream      (p    @@byte n    @%nat) @FILE ;
export fopen               (path  @byte mode @ byte ) @FILE ;

export fclose              (io @FILE) nat ;
export fflush              (io @FILE) nat ;

export fread               (ptr @none m %nat n %nat io @FILE) %nat ;
export fwrite              (ptr @none m %nat n %nat io @FILE) %nat ;
export fputc               (c nat io @FILE)  nat ;

export printf              (         fmt @byte ...          ) nat ;
export vprintf             (         fmt @byte args @va_list) nat ;
export fprintf             (io @FILE fmt @byte ...          ) nat ;
export vfprintf            (io @FILE fmt @byte args @va_list) nat ;

export exit                (status nat) none ;

export calloc              (m %nat  n %nat) @none ;

export memcmp              (p @none q @none n %nat) nat ;

export strtoul             (p @byte q @@byte  b  nat) %nat ;
export strcat              (p @byte q  @byte        ) @byte  ;
export strstr              (p @byte q  @byte        ) @byte  ;
export strcmp              (p @byte q  @byte        )  nat ;
export strncmp             (p @byte q  @byte  n %nat)  nat ;
export strncasecmp         (p @byte q  @byte  n %nat)  nat ;
export strndup             (p @byte         n %nat) @byte  ;
export strlen              (p @byte               ) %nat ;

export strerror            (errnum  nat) @byte ;

secondary          (k @Ctx t @Type) @Node ;
tertiary           (k @Ctx t @Type) @Node ;
seq                (k @Ctx t @Type) @Node ;
infix              (k @Ctx t @Type) @Node ;
quaternary         (k @Ctx t @Type) @Node ;

type_suffix        (k @Ctx) @Type ;

gen_rval(out @FILE e @Node c @nat) none;

errno() nat = (__errno_location)@

maxl (a   nat b   nat)   nat = (a > b) ? a : b
minl (a   nat b   nat)   nat = (a < b) ? a : b
maxul(a % nat b % nat) % nat = (a > b) ? a : b
minul(a % nat b % nat) % nat = (a < b) ? a : b

align_to(n nat a nat) nat = (n + a - 1) / a * a

vdiag(in @byte c @byte line_n nat p @byte fmt @byte args @va_list) none =
   (p for q (c < q && q^-1 != '\n' && (q - 1)))    is line
   (p for q (!!q@  && q^ 0 != '\n' && (q + 1)))    is end
   (printf "./%s:(%d,%d): " in line_n (p - line + 1)) is indent
   (cast none printf "%.*s\n%*s^ " (end - line) line ((p - line as nat) + indent) "")
;:  cast none vprintf fmt args
;: (cast none printf "\n")

diag(p@ byte in @File fmt@ byte ...) none =
   1 is line_no
   (in.contents for p (p < p && (p + 1) :; ((p@ == '\n') && (line_no = line_no + 1) as none)) as none)
;: vdiag in.name in.contents line_no p fmt cast @va_list __va_area__
;: exit 1

jdiag(j@ Token fmt@ byte ...) none = vdiag j.in.name j.in.contents j.line_no j.loc fmt cast @va_list __va_area__ ;: exit 1 
jeq(j @Token op @byte) bit = ! memcmp cast @none j.loc cast @none op cast %nat j.n && !op^j.n
jadv(k @@Token) @Token = k@ :; (k@ = k.s) 

expect(j @@Token op@ byte) none = (!jeq j@ op && (jdiag j@ "expected '%s'" op) as none) ;: (j@ = j.s) 
consume(rest@@ Token j@ Token str@ byte) bit = jeq j str is c c :; (rest@ = c ? j.s : j) 

new_type(q TypeKind size nat align nat) @Type
=  cast @Type calloc 1u sizeof Type is t t
:; (t.q     = q    )
:; (t.size  = size )
:; (t.align = align)

format_one_type(q1 TypeKind q2 TypeKind s1 @byte s2 @byte) bit
= (q1 == q2) && strcat s1 s2

format_type_a(t @Type s @byte) none
= &strcat      is f
  &format_type_a is g
           t.q is q

   !t
?  strcat                        s "null"
: (  format_one_type q TY_VOID   s "none"
  || format_one_type q TY_BOOL   s "bit"
  || format_one_type q TY_BYTE   s "byte"
  || format_one_type q TY_NAT    s "nat"
  || format_one_type q TY_ENUM   s "enum"
  || format_one_type q TY_STRUCT s "struct"
  || ( q == TY_RING  ) ? f@ s "%"      :; g@ t.a s :
     ( q == TY_ARRAY ) ? f@ s "^"      :; g@ t.a s :
     ( q == TY_PTR   ) ? f@ s "@"      :; g@ t.a s :
     ( q == TY_FUNC  ) ? f@ s "("      :;
       t.a.s is p (p for p (!!p && p.s :; g@ p   s ) as none) ;:
                         f@ s ")"      :; g@ t.a s :
                         f@ s "???"

  as none )

format_type(t @Type) @byte
=  cast @byte calloc 1u 1u is s s
:; format_type_a t s

type_equal(t @Type u @Type) bit
=  !!t
&& !!u
&& t.q is c
  (  t == u
  ||(
      !!t.o ? type_equal t.o u
    : !!u.o ? type_equal t u.o
    : (  c == u.q
      &&(  c == TY_VOID
        ||   c == TY_BOOL
        ||( (  c == TY_BYTE
            || c == TY_NAT )
          ?  1b
          :  (c == TY_FUNC)
          ?  !type_equal t.a u.a
          ?  0b
          :  u.a.s is p
             t.a.s is q (1b for _ (!!p && !!q && type_equal p q && (p = p.s) ;: (q = q.s) ) as none)
          ;: (p == q)
          :  (c == TY_ARRAY)
          ?  !type_equal t.a u.a
          ?  0b
          :  (t.n == u.n)
          :  (  c == TY_PTR
             || c == TY_RING )
          ?  type_equal t.a u.a
          :  0b ) ) ) ) )

ty_null () @Type = cast @Type 0
ty_none () @Type = new_type TY_VOID 1 1
ty_bit  () @Type = new_type TY_BOOL 1 1
ty_byte () @Type = new_type TY_BYTE 1 1
ty_nat  () @Type = new_type TY_NAT  8 8

copy_type(t @Type) @Type
=  cast @Type calloc 1u sizeof Type is u u
:; (u@ = t@)
;: (u.o = t)

ptr_of(a@ Type) @Type
=  new_type TY_PTR 8 8 is t t
:; (t.a = a)

ring_of(a @Type) @Type
=  new_type TY_RING a.size a.align is t t
:; (t.a = a)

func_of(return_ty@ Type) @Type
=  new_type TY_FUNC 1 1 is t t
:; (t.a = return_ty)

array_of(a @Type n nat) @Type
=  new_type TY_ARRAY (a.size * n) a.align is t t
:; (t.a = a)
;: (t.n = n)

enum_of  () @Type = new_type TY_ENUM   8 8
struct_of() @Type = new_type TY_STRUCT 0 1

new_token(q typeof TK_ID a@ byte b@ byte in @File) @Token
=  cast @Token calloc 1u sizeof Token is j j
:; (j.q   = q    )
;: (j.loc = a    )
;: (j.n = b - a)
;: (j.in  = in   )

startswith(p@ byte q@ byte) bit
= 1b is r
  (  1b for _
    (  (!q@)
    ?  0b
    :  (p@ != q@)
    ?  (r = 0b)
    ;: 0b
    :  (p = p + 1)
    ;: (q = q + 1)
    ;: 1b )
  as none )
;: r

isin(c byte a byte b byte) bit
= a <= c && c <= b

issp(c byte) bit = ' '  == c
istb(c byte) bit = '\t' == c
islf(c byte) bit = '\n' == c
iscr(c byte) bit = '\r' == c
is_ (c byte) bit = '_'  == c

isAZ(c byte) bit = isin c 'A' 'Z'
isaz(c byte) bit = isin c 'a' 'z'
is09(c byte) bit = isin c '0' '9'
isaf(c byte) bit = isin c 'a' 'f'

isws(c byte) bit
=  issp c
|| istb c
|| islf c
|| iscr c
is0f(c byte) bit
=  is09 c
|| isaf c
isid(c byte) bit
=  isAZ c
|| isaz c
|| is09 c
|| is_  c

read_ident(p@ byte) nat
=  0 is r
   (p for q (isid q@ && q + 1 || cast @byte 0 :; (r = q - p as nat)) as none)
;: r

read_punct(p@ byte) nat =
&startswith is f
(  f@ p "<<="
|| f@ p ">>="
|| f@ p "&&="
|| f@ p "||="
|| f@ p "..." ) ? 3 :
(  f@ p "=="
|| f@ p "!="
|| f@ p "<="
|| f@ p ">="
|| f@ p "&&"
|| f@ p "||"
|| f@ p "<<"
|| f@ p ">>"
|| f@ p ";:"
|| f@ p ":;" ) ? 2 :
(  f@ p "=" 
|| f@ p "<"
|| f@ p ">"
|| f@ p "+"
|| f@ p "-"
|| f@ p "*"
|| f@ p "/"
|| f@ p "&"
|| f@ p "|"
|| f@ p "@"
|| f@ p "#"
|| f@ p "{"
|| f@ p "}"
|| f@ p "("
|| f@ p ")"
|| f@ p "["
|| f@ p "]"
|| f@ p "!"
|| f@ p "?"
|| f@ p ":"
|| f@ p ";"
|| f@ p ","
|| f@ p "."
|| f@ p "~"
|| f@ p "^"
|| f@ p "$"
|| f@ p "`"
|| f@ p "%" ) ? 1 : 0

escape_one(c byte ca byte cb byte) byte
= c == ca && cb

escape(c @byte file @File) byte
=  &escape_one is f
  (  f@ c@ 'a' '\a'
  || f@ c@ 'b' '\b'
  || f@ c@ 'f' '\f'
  || f@ c@ 'n' '\n'
  || f@ c@ 'r' '\r'
  || f@ c@ 't' '\t'
  || f@ c@ 'v' '\v'
  || f@ c@ 'p' '\p'
  || f@ c@ 'q' '\q'
  || f@ c@ 's' '\s'
  || '\0'
  :; (c@ != '0' && (diag c file "invalid escape sequence") as none) )

string_literal(file @File start@ byte quote@ byte)@ Token
= (  (quote + 1) for q
    (  q@ != '"'
    && (q + 1)
    :; (q@ == '\0' && (diag quote file "unclosed string literal") as none) ) )
is end
   cast @byte calloc 1u (end - quote as %nat) is buf
   0 is n
  (  (quote + 1) for p
    (  p < end
    && (p@ == '\s')
    ? (  buf^(n:;(n = n + 1)) = (p = p + 1)
      ;: escape p file
      :; (p = p + 1) )
    ;: p
    :  (buf^(n:;(n = n + 1)) = p@)
    ;: (p + 1) )
  as none )
;: new_token TK_STR start (end + 1) file is j
   (j.t = array_of ty_byte (n + 1) as @none)
;: (j.str = buf)
;: j

byte_literal(in @File p@ byte)@ Token
=  (p + 1) is q
   (q@ == '\0' && (diag p in "unclosed literal byte") as none)
;:(  (q@ == '\s')
  ?  (q = q + 1)
  ;: (q@ == '\0' && (diag p in "unclosed literal byte") as none)
  ;: escape q in
  :  q@ )
is c
   (q = q + 1)
;: (q@ != '\p' && (diag p in "unclosed literal byte") as none)
;: new_token TK_NUM p (q + 1) in is j
   (j.l = c as nat)
;: (j.t = cast @none ty_byte)
;: j

open_file(path @byte mode @byte) @FILE =
fopen path mode ||
( cast none printf "cannot open file '%s' with mode '%s': %s" mode path strerror errno )

read_file(path@ byte)@ byte =
   new ^4096 byte is rfbuf2
   open_file path "r" is fp
   cast @byte 0 is buf
   0u is buflen
   &buflen is b
   open_memstream &buf b is out
   (1b for k
    sizeof typeof rfbuf2 is m
    fread cast @none rfbuf2 1u m fp is n
    ((n == 0) ? (k = 0b) : cast none fwrite cast @none rfbuf2 1u n out)
    ;: k as none)
;: (fclose fp as none)
;: fflush out
;: ((buflen == 0 || buf^(buflen - 1u) != '\n') && fputc cast nat '\n' out as none)
;: fputc 0 out
;: fclose out
;: buf

tokenize(path @byte) @Token =
   read_file path is p
   !p
?  cast @Token 0
:  cast @File calloc 1u sizeof File is in
   (in.name = path)
;: (in.contents = p)
;: new Token is j
   (in.contents is p &j is j
   (1b for _ (p@ &&
    startswith p "/*"
    ?  strstr (p + 2) "*/" is q
       (!q && (diag p in "unclosed block comment") as none)
    ;: (p = q + 2)
    :  (p@ == '\n' || isws p@) ? (p = p + 1)
    :  (is09 p@ || (p@ == '.' && is09 p^1))
    ?  ((p + 1) for q ( isid q@ && q + 1 )) is q
       (j.s = new_token TK_NUM p q in)
    ;: (j.s.loc is p
  10 is a
  (  (!strncasecmp p "0x" 2u && is0f p^2)
  && (p = p + 2)
  ;: (a = 16)
  as none )
;: strtoul p &p a is v
   ( (startswith p "b"  ) ? (p = p + 1) ;:         ty_bit :
     (startswith p "u"  ) ? (p = p + 1) ;: ring_of ty_nat :
                                                   ty_nat ) is t
   (j.s.l = v as nat ) ;:
   (j.s.t = t as @none   ) ;:
   1b)
    ;: (j = j.s)
    ;: (p = q)
    :  (p@ == '"')
    ?  (j.s = string_literal in p p)
    ;: (j = j.s)
    ;: (p = p + j.n)
    :  (p@ == '\p')
    ?  (j.s = byte_literal in p)
    ;: (j = j.s)
    ;: (j.l = j.l as byte as nat)
    ;: (p = p + j.n)
    :  0 is n
       (p for q (isid q@ && q + 1 || cast @byte 0 :; (n = q - p as nat)) as none)
    ;: !!n
    ?  (j.s = new_token TK_ID p (p + n) in)
    ;: (j = j.s)
    ;: (p = p + j.n)
    :  read_punct p is n
       !!n
    ?  (j.s = new_token TK_PCT p (p + n) in)
    ;: (j = j.s)
    ;: (p = p + j.n)
    :  (diag p in "invalid token")) as none )
;: (j.s = new_token TK_EOF p p in)
   )
;: j.s is j2
   1 is n
  ( in.contents for p
    (  !!p@
    && (p + 1)
    :; (j2 = (p == j2.loc) ? (j2.line_no = n) ;: j2.s : j2)
    :; (n = n + ((p@ == '\n') ? 1 : 0)) )
  as none )
;: j.s

push_scope  (k @Ctx c @byte       ) @Scope
= cast @Scope calloc 1u sizeof Scope is s s :; (s.c = c) ;: (s.s = k.s) ;: (k.s = s)

search_scope(k @Ctx c @byte n %nat) @Scope
= cast @Scope 0 is r (!!k.s && k.s for s (n != strlen s.c || !!strncmp s.c c n) ? s.s : (r = s) ;: cast @Scope 0 as none) ;: r

new_var(k @Ctx c @byte t @Type) @Obj
=  (calloc 1u sizeof Obj as @Obj) is o
   (o.name = c) 
;: (o.t = t) 
;: ((push_scope k c).o = o) 
;: o

new_lvar(k @Ctx c @byte t @Type) @Obj
=  new_var k c t is o
   (o.is_local = 1b)
;: (o.s = k.locals)
;: (k.locals = o)
;: o

new_gvar(k @Ctx c @byte t @Type) @Obj
=  new_var k c t is o
   (o.s = k.globals)
;: (o.is_definition = 1b)
;: (k.globals = o)
;: o

new_unique_name(k @Ctx) @byte
=  cast @byte  0 is buf
   cast %nat 0 is buflen
   open_memstream &buf &buflen is out
   (fprintf out ".L..%d" k.n)
;: fclose out
;: buf
:; (k.n = k.n + 1)

new_string_literal(k @Ctx p @byte t @Type u @Type) @Obj = new_gvar      k new_unique_name k u is o (o.init_data = p) ;: o

expect_type(j @Token t @Type u @Type) none
=  !!t
&& !type_equal t u
&& (jdiag j "expected %s but found %s" format_type t format_type u) as none

get_ident(j @Token) @byte
=  ((j.q != TK_ID) && (jdiag j "expected an nonymousifier") as none)
;: strndup j.loc cast %nat j.n

find_type(k @Ctx c @byte n %nat) @Type
=  (k.j.q != TK_ID) ? ty_null
:  search_scope k c n is s
   (!!s && s.t)

enum_specifier(k @Ctx) @Type
=  enum_of is t
   0 is l
  (  1b for _
    (  !consume &k.j k.j ";"
    && get_ident k.j is c
       jadv &k.j
    ;: push_scope k c is s
       (s.t = t)
    ;: (s.v = l)
    ;: (l = l + 1) )
  as none )
;: t

declarator(k @Ctx) @Type
=  jadv &k.j is j
   copy_type type_suffix k is t t
:; (t.name = j)

struct_decl(k @Ctx) @Type
=  struct_of is t
   expect &k.j "{"
;: (k.t = t)
;: new Type is head
   &head is cur
  (  1b for _ 
    (  !consume &k.j k.j "}"
    && (calloc 1u sizeof Type as @Type) is g
       (g@ = declarator k)
    ;: (cur.s = g)
    ;: (cur = cur.s) )
  as none )
;: (t.a = head.s)
;: (k.t = 0 as @Type)
;: (t.q = TY_STRUCT)
;: (t.size < 0) ? t
:  0 is bits
  (  !!t.a && t.a for g g.s
  :; (bits = align_to bits (g.align * 8))
  ;: (g.offset = bits / 8)
  ;: (bits = bits + g.size * 8)
  ;: (t.align < g.align && (t.align = g.align) as none)
  as none)
;: (t.size = align_to bits (t.align * 8) / 8)
;: t

type_specifier_a(k @Ctx s @byte t @Type) @Type
=  consume &k.j k.j s && t


type_specifier(k @Ctx) @Type
=  consume &k.j k.j "none"   ? ty_none
:  consume &k.j k.j "bit"    ? ty_bit
:  consume &k.j k.j "byte"   ? ty_byte
:  consume &k.j k.j "nat"    ? ty_nat
:  consume &k.j k.j "struct" ? struct_decl      k
:  consume &k.j k.j "enum"   ? enum_specifier   k
:  consume &k.j k.j "typeof" ? (tertiary k ty_null).t
:  consume &k.j k.j "same"   ? k.t
: (  find_type k k.j.loc cast %nat k.j.n
  && cast none jadv &k.j
  || ty_none :; (jdiag k.j "invalid type specifier") )

func_params(k @Ctx) @Type =
   new Type is head
   0b is is_variadic
   &head is cur
   (1b for _ (!jeq k.j ")" && !(consume &k.j k.j "..."
?  (is_variadic = 1b)
;: 1b
:  (cur.s = copy_type declarator k)
;: (cur = cur.s)
;: 0b))
as none)
;: jadv &k.j
;: func_of type_suffix k is t
   (t.params = head.s)
;: (t.is_variadic = is_variadic)
;: t

array_dimensions(k @Ctx) @Type
=  infix k ty_nat is e
   type_suffix k is t
   cast @byte 0 is label
   array_of t e.l

type_suffix(k @Ctx) @Type =
   consume &k.j k.j "%" ? ring_of    type_suffix k
:  consume &k.j k.j "@" ? ptr_of     type_suffix k
:  consume &k.j k.j "^" ? array_dimensions       k
:  consume &k.j k.j "(" ? func_params            k
:  type_specifier k

new_node       (j @Token t @Type g NodeKind                        ) @Node = cast @Node calloc 1u sizeof Node is e e :; (e.j = j) :; (e.t = t) :; (e.q = g)
new_nullary    (j @Token t @Type g NodeKind                        ) @Node = new_node j t g
new_unary      (j @Token t @Type g NodeKind a @Node                ) @Node = new_node j t g is e e :; (e.a = a) 
new_binary     (j @Token t @Type g NodeKind a @Node b @Node        ) @Node = new_node j t g is e e :; (e.a = a) :; (e.a.s = b) 
new_ternary    (j @Token t @Type g NodeKind a @Node b @Node c @Node) @Node = new_node j t g is e e :; (e.a = a) :; (e.a.s = b) :; (e.a.s.s = c) 
new_typeary    (j @Token t @Type g NodeKind u @Type                ) @Node = new_nullary j t g is e e :; (e.t.s = u)
new_objary     (j @Token t @Type g NodeKind o @Obj                 ) @Node = new_nullary j t g is e e :; (e.o   = o )
new_litary     (j @Token t @Type g NodeKind l nat                  ) @Node = new_nullary j t g is e e :; (e.l   = l )

new_lit        (j @Token t @Type u @Type l nat                  ) @Node = new_litary  j         u       ND_NUM     l
new_reference  (j @Token t @Type         o @Obj                 ) @Node = new_objary  j         o.t     ND_VAR     o
new_sizeof     (j @Token t @Type u @Type                        ) @Node = new_typeary j ring_of ty_nat  ND_SIZE    u
new_alignof    (j @Token t @Type u @Type                        ) @Node = new_typeary j ring_of ty_nat  ND_ALIGN   u
new_the        (j @Token t @Type u @Type a @Node                ) @Node = new_unary   j         a.t     ND_THE     a
new_cast       (j @Token t @Type u @Type a @Node                ) @Node = new_unary   j         u       ND_CAST    a
new_call       (j @Token t @Type         a @Node                ) @Node = new_unary   j         a.t.a   ND_FUNCALL a
new_neg        (j @Token t @Type         a @Node                ) @Node = new_unary   j         a.t     ND_NEG     a
new_addressof  (j @Token t @Type         a @Node                ) @Node = new_unary   j ptr_of  a.t     ND_ADDR    a
new_lognot     (j @Token t @Type         a @Node                ) @Node = new_unary   j         ty_bit  ND_NOT     a
new_bitnot     (j @Token t @Type         a @Node                ) @Node = new_unary   j         a.t     ND_BITNOT  a
new_assign     (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         ty_none ND_ASSIGN  a b
new_bitor      (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_BITOR   a b
new_bitxor     (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_BITXOR  a b
new_bitand     (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_BITAND  a b
new_eq         (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         ty_bit  ND_EQ      a b
new_neq        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         ty_bit  ND_NE      a b
new_gt         (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         ty_bit  ND_GT      a b
new_lt         (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         ty_bit  ND_LT      a b
new_ge         (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         ty_bit  ND_GE      a b
new_le         (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         ty_bit  ND_LE      a b
new_shl        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_SHL     a b
new_shr        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_SHR     a b
new_mul        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_MUL     a b
new_div        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_DIV     a b
new_mod        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_MOD     a b
new_then       (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_THEN    a b
new_neth       (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         b.t     ND_COMMA   a b
new_deref      (j @Token t @Type         a @Node                ) @Node = new_unary   j         a.t.a   ND_DEREF   a
new_deref_all  (j @Token t @Type         a @Node                ) @Node = a for e (e.t.q == TY_PTR && new_deref j t e)
new_let        (j @Token t @Type         a @Node b @Node o @Obj ) @Node = new_binary  j         b.t     ND_LET    a b is e e :; (e.o = o)
new_repeat     (j @Token t @Type         a @Node b @Node o @Obj ) @Node = new_binary  j         b.t     ND_REPEAT a b is e e :; (e.o = o)
new_conditional(j @Token t @Type         a @Node b @Node c @Node) @Node = new_ternary j         b.t     ND_COND   a b c
new_logor      (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_LOGOR  a b
new_logand     (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         b.t     ND_LOGAND a b
new_subscript  (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t.a   ND_ELEM   a b
new_add        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_ADD    a b
new_sub        (j @Token t @Type         a @Node b @Node        ) @Node = new_binary  j         a.t     ND_SUB    a b

left(k @Ctx t @Type op @byte parse_@ (k @Ctx t @Type) @Node) @Node =
jeq k.j op && parse_@ k t 
right(k @Ctx t @Type a @Node op @byte parse_@ (k @Ctx t @Type a @Node) @Node) @Node =
jeq k.j op && parse_@ k t a 

array_access(k @Ctx t @Type a @Node) @Node =
   jadv &k.j is j
   tertiary k ty_nat is b
   new_subscript j t a b

get_struct_member(t @Type j @Token) @Type =
   ty_null is r
   (t.a for g (   (g.q == TY_STRUCT && !g.name) ? (!!get_struct_member g j && g)
:  (g.name.n == j.n && !strncmp g.name.loc j.loc cast %nat j.n && g)
) is g1 !g1 ? g.s : (r = g1) ;: ty_null as none)
;: r

member_access(k @Ctx t @Type a @Node) @Node =
   cast none jadv &k.j
;: jadv &k.j is j
   (a = new_deref_all j t a)
;:(  a.t.q != TY_STRUCT
  && (jdiag j "(%s . %.*s) must be of the form (@*struct . %.*s)" format_type a.t j.s.n j.s.loc j.s.n j.s.loc)
  as none )
;: get_struct_member a.t j is g
  (  !g
  &&(  jdiag j "(%s . %.*s) no such member" format_type a.t j.s.n j.s.loc ) as none )
;: new_unary j g ND_MEMBER a

sizee      (k @Ctx t @Type        ) @Node = jadv   &k.j is j type_suffix k is u                                                        new_sizeof      j   t   u
aligne     (k @Ctx t @Type        ) @Node = jadv   &k.j is j type_suffix k is u                                                        new_alignof     j   t   u
theorem    (k @Ctx t @Type        ) @Node = jadv   &k.j is j type_suffix k is u                                tertiary k t       is a new_the         j   t   u a
axiom      (k @Ctx t @Type        ) @Node = jadv   &k.j is j type_suffix k is u                                tertiary k t       is a new_cast        j   t   u a
deref      (k @Ctx t @Type a @Node) @Node = jadv   &k.j is j                                                                           new_deref       j a.t.a   a
addressof  (k @Ctx t @Type        ) @Node = jadv   &k.j is j                                                  secondary k t       is a new_addressof   j   t     a
neg        (k @Ctx t @Type        ) @Node = jadv   &k.j is j                                                   tertiary k t       is a new_neg         j   t     a
lognot     (k @Ctx t @Type        ) @Node = jadv   &k.j is j                                                   tertiary k t       is a new_lognot      j   t     a
bitnot     (k @Ctx t @Type        ) @Node = jadv   &k.j is j                                                   tertiary k t       is a new_bitnot      j   t     a
then       (k @Ctx t @Type a @Node) @Node = jadv   &k.j is j                                                        seq k ty_none is b new_then        j a.t     a b
neth       (k @Ctx t @Type a @Node) @Node = jadv   &k.j is j                                                        seq k t       is b new_neth        j b.t     a b
conditional(k @Ctx t @Type a @Node) @Node = jadv   &k.j is j                                                        seq k t       is b
                                            expect &k.j ":" ;:                                                      seq k t       is c new_conditional j   t     a b c
islet      (k @Ctx t @Type a @Node) @Node = jadv   &k.j is j k.s is s new_lvar k get_ident jadv &k.j a.t is o       seq k t       is b new_let         j   t     a b   o :; (k.s = s)
repeat     (k @Ctx t @Type a @Node) @Node = jadv   &k.j is j k.s is s new_lvar k get_ident jadv &k.j a.t is o       seq k t       is b new_repeat      j   t     a b   o :; (k.s = s)
newe       (k @Ctx t @Type        ) @Node = jadv &k.j is j
      type_suffix k is u
      new_lvar k "" u is o
      new_node k.j ty_none ND_MEMZERO is b
      (b.o = o) ;:
      new_neth k.j t b new_reference k.j t o

primary(k @Ctx t @Type) @Node =
  ( jeq k.j "new" ? newe k t :
    consume &k.j k.j "(" ? quaternary k t :; expect &k.j ")" :
    (k.j.q == TK_ID) ?
      search_scope k k.j.loc k.j.n is s
      jadv &k.j;:
      (!!s ? !!s.o ? new_reference k.j t s.o : new_lit k.j t s.t cast nat s.v :
      (jdiag k.j "lookup failed") ;: cast @Node 0) :
    (k.j.q == TK_STR) ?
      cast @Type k.j.t is u
      new_string_literal k k.j.str t u is o
      new_cast k.j t ptr_of u.a new_the k.j u o.t new_reference k.j u o :;
      cast none jadv &k.j :
    (k.j.q == TK_NUM) ?
      ( new_lit k.j t cast @Type k.j.t k.j.l :; cast none jadv &k.j ) :
    (jdiag k.j "expected an expression") ;: cast @Node 0)

secondary(k @Ctx t @Type) @Node =
   left    k t       "cast"    &axiom
|| left    k t       "the"     &theorem
|| left    k t       "&"       &addressof
|| left    k t       "sizeof"  &sizee
|| left    k t       "alignof" &aligne
|| primary k t for a
(  right   k t     a "^"       &array_access
|| right   k t     a "."       &member_access
|| right   k t     a "@"       &deref
 )

tertiary_left(k @Ctx t @Type) @Node =
(  left k t "-"     &neg
|| left k t "!"     &lognot
|| left k t "~"     &bitnot
 )

seq(k @Ctx t @Type) @Node = 
  tertiary k ty_null is a
(  right k t a ":;"  &then
|| right k t a ";:"  &neth
|| right k t a "is"  &islet
|| right k t a "for" &repeat
|| right k t a "?"   &conditional
|| a
 )

tertiary(k @Ctx t @Type) @Node =
   tertiary_left k ty_null
|| secondary k ty_null for a
  (  a.t.q == TY_FUNC
  && a.t.params is u
    (  a for b
      (  (!!u || a.t.is_variadic && ! jeq k.j ")")
      && (b.s = tertiary k u)
      ;: (  !!u 
         && (!type_equal b.s.t u && (jdiag k.j "asymmetric argument from %s to %s" format_type b.s.t format_type u) as none)
         ;: (u = u.s)
         as none)
      ;: b.s )
    as none )
  ;: (!!u && (jdiag k.j "not enough arguments") as none)
  ;: new_call k.j t a )

mul        (k @Ctx t @Type) @Node = seq        k t             for a (  jeq k.j "*"  && jadv &k.j is j new_mul    j t a seq        k a.t
                                                                               || jeq k.j "/"  && jadv &k.j is j new_div    j t a seq        k a.t
                                                                               || jeq k.j "%"  && jadv &k.j is j new_mod    j t a seq        k a.t) 
add        (k @Ctx t @Type) @Node = mul        k t             for a (  jeq k.j "+"  && jadv &k.j is j new_add    j t a mul        k a.t
                                                                               || jeq k.j "-"  && jadv &k.j is j new_sub    j t a mul        k a.t) 
shift      (k @Ctx t @Type) @Node = add        k t             for a (  jeq k.j "<<" && jadv &k.j is j new_shl    j t a add        k a.t
                                                                               || jeq k.j ">>" && jadv &k.j is j new_shr    j t a add        k a.t) 
relational (k @Ctx t @Type) @Node = shift      k ty_null  for a (  jeq k.j "<"  && jadv &k.j is j new_lt     j t a shift      k ty_null
                                                                               || jeq k.j ">"  && jadv &k.j is j new_gt     j t a shift      k ty_null
                                                                               || jeq k.j "<=" && jadv &k.j is j new_le     j t a shift      k ty_null
                                                                               || jeq k.j ">=" && jadv &k.j is j new_ge     j t a shift      k ty_null
                                                                               || jeq k.j "==" && jadv &k.j is j new_eq     j t a shift      k ty_null
                                                                               || jeq k.j "!=" && jadv &k.j is j new_neq    j t a shift      k ty_null) 
bitand     (k @Ctx t @Type) @Node = relational k t             for a (  jeq k.j "&"  && jadv &k.j is j new_bitand j t a relational k a.t) 
bitor      (k @Ctx t @Type) @Node = bitand     k t             for a (  jeq k.j "|"  && jadv &k.j is j new_bitor  j t a bitand     k a.t) 
logand     (k @Ctx t @Type) @Node = bitor      k ty_null  for a (  jeq k.j "&&" && jadv &k.j is j new_logand j t a bitor      k a.t) 
logor      (k @Ctx t @Type) @Node = logand     k t             for a (  jeq k.j "||" && jadv &k.j is j new_logor  j t a logand     k a.t) 

infix(k @Ctx t @Type) @Node =
   logor k ty_null for a
  (  jeq k.j "as"   && jadv &k.j is j type_suffix k is u new_cast j u u a :; (t = u)
  || jeq k.j "from" && jadv &k.j is j type_suffix k is u new_the  j u u a :; (t = u) )

quaternary(k @Ctx t @Type) @Node =
   infix k ty_null is a
   jeq k.j "="
?  jadv &k.j is j new_assign j t a infix k a.t
:  a

typedecl(k @Ctx) @Token =
   k.j for j
  (  !consume &k.j k.j ";"
  &&(  declarator k is t
       ((push_scope k get_ident t.name).t = t)
    ;: k.j ) )

create_param_lvars(k @Ctx param @Type) none =
   !!param
&&  create_param_lvars k param.s
;: (new_lvar k get_ident param.name param as none)
as none

find_func(k @Ctx c @byte n %nat) @Obj =
  search_scope k c n is s
  (!!s && !!s.o && s.o.t.q == TY_FUNC && s.o)

function(k @Ctx attr @VarAttr) none =
  declarator k is t
  find_func k t.name.loc cast %nat t.name.n is o
  (  !!o
  ?  (o.t.q != TY_FUNC                && (jdiag k.j "redeclared as a different q of symbol") as none)
  ;: (o.is_definition && jeq k.j "="  && (jdiag k.j "redefinition of %s" o.name) as none)
  ;: (o.is_export != attr.is_export   && (jdiag k.j "mismatched visibility") as none)
  ;: (o.is_definition = o.is_definition || jeq k.j "=")
  :  (o = new_gvar k get_ident t.name t)
  ;: (o.is_definition = jeq k.j "=")
  ;: (o.is_export = attr.is_export) )
;:(  !consume &k.j k.j ";"
  && (k.locals = cast @Obj 0)
  ;: k.s is s
     create_param_lvars k t.params
  ;: t.a is rty
     (o.params = k.locals)
  ;: (t.is_variadic && (o.va_area = new_lvar k "__va_area__" array_of ty_byte 136) as none)
  ;: expect &k.j "="
  ;: (o.body = infix k rty as @none)
  ;: (o.locals = k.locals)
  ;: (k.s = s) )

parse(j @Token) @Obj =
   new Ctx is k
   (k.j        = j            )
;: (k.locals   = cast @Obj   0)
;: (k.globals  = cast @Obj   0)
;: (k.s        = cast @Scope 0)
;: (k.t        = cast @Type  0)
;: k.s is s
  (  k.j for j
    (  !!j.q
    && new VarAttr is v
       (1b for i
  (  consume &k.j k.j "type"    && 1b :; (v.is_type   = 1b)
  || consume &k.j k.j "export"  && 1b :; (v.is_export = 1b) )
as none)
    ;: v.is_type
    ?  typedecl &k
    :  function &k &v
    ;: k.j)
  as none)
;: (k.s = s)
;: k.globals

argreg(sz nat g nat) @byte =
  (sz == 0) ? (g == 0) ? "%dil" :
              (g == 1) ? "%sil" :
              (g == 2) ? "%dl"  :
              (g == 3) ? "%cl"  :
              (g == 4) ? "%r8b" :
                         "%r9b" :
  (sz == 1) ? (g == 0) ? "%edi" :
              (g == 1) ? "%esi" :
              (g == 2) ? "%edx" :
              (g == 3) ? "%ecx" :
              (g == 4) ? "%r8d" :
                         "%r9d" :
              (g == 0) ? "%rdi" :
              (g == 1) ? "%rsi" :
              (g == 2) ? "%rdx" :
              (g == 3) ? "%rcx" :
              (g == 4) ? "%r8"  :
                         "%r9"  


gen_ln(out @FILE fmt @byte ...) none =
  vfprintf out fmt cast @va_list __va_area__
;: (cast none fprintf out "\n")

gen_zero(out @FILE      ) none = (gen_ln out "  xor %%eax, %%eax"  )
gen_cmpz(out @FILE      ) none = (gen_ln out "  cmp $0, %%rax"     )
gen_not (out @FILE      ) none = (gen_ln out "  not %%eax"         )
gen_lit (out @FILE l nat) none = (gen_ln out "  mov $%ld, %%rax"  l)
gen_neg (out @FILE      ) none = (gen_ln out "  neg %%rax"         )

gen_cast1  (out @FILE a @Type b @Type) none = a.q != b.q  && (gen_ln out "  movsbl %%al  , %%eax") as none 
gen_cast8  (out @FILE a @Type b @Type) none = a.q != b.q  && (gen_ln out "  movzbl %%al  , %%eax") as none 
gen_cast64 (out @FILE a @Type b @Type) none = a.size < 32 && (gen_ln out "  movsxd %%eax , %%rax") as none 

gen_cast(out @FILE a @Type b @Type) none
=  (b.q == TY_VOID) ?                      gen_zero   out
:  (b.q == TY_BOOL) ?                      gen_not    out ;: gen_not out
:  (b.q == TY_BYTE) ?                      gen_cast1  out a b
:  (b.q == TY_RING) ? (b.a.q == TY_BYTE) ? gen_cast8  out a b
                                         : gen_cast64 out a b
                                         : gen_cast64 out a b

gen_fpush(out @FILE c @nat  l  nat ) none = (gen_ln out "  sub $%ld, %%rsp" (8 * l)) ;: (c@ = c@ + l)
gen_fpop (out @FILE c @nat  l  nat ) none = (gen_ln out "  add $%ld, %%rsp" (8 * l)) ;: (c@ = c@ - l)
gen_push (out @FILE c @nat         ) none = (gen_ln out "  push %%rax") ;: (c@ = c@ + 1)
gen_pop  (out @FILE c @nat  l @byte) none = (gen_ln out "  pop %s" l  ) ;: (c@ = c@ - 1)
gen_add  (out @FILE         l  nat ) none = (gen_ln out "  add $%d, %%rax" l)
gen_label(out @FILE e @Node l @byte) none = (gen_ln out ".L.%s.%lu:" l e)

gen_load(out @FILE e @Node) none
=  e.t.q == TY_ARRAY
|| e.t.q == TY_STRUCT
|| e.t.q == TY_FUNC
|| (((e.t.q == TY_RING) ? e.t.a : e.t).size == 1)
?  (gen_ln out "  mov%cbl (%%rax), %%eax" ((e.t.q == TY_RING) ? 'z' : 's'))
:  (gen_ln out "  mov     (%%rax), %%rax"                                 )
as none

gen_store(out @FILE t @Type c @nat) none
=  gen_pop out c "%rdi"
;: (t.q == TY_STRUCT || t.q == TY_ARRAY) ? (0 for i (i < t.size && (i + 1)
:; (gen_ln out "  mov %d(%%rax), %%r8b    " i)
;: (gen_ln out "  mov %%r8b    , %d(%%rdi)" i)) as none)
:  (t.size == 1) ? (gen_ln out "  mov %%al , (%%rdi)")
:                  (gen_ln out "  mov %%rax, (%%rdi)")

gen_lval_local (out @FILE e @Node) none = (gen_ln out "  lea %d(%%rbp), %%rax"          e.o.offset)
gen_lval_global(out @FILE e @Node) none = (gen_ln out "  mov %s@GOTPCREL(%%rip), %%rax" e.o.name  )

gen_lval(out @FILE e @Node c @nat) none
=  ( e.q    == ND_COMMA   ) ? gen_rval out e.a   c ;: gen_lval out e.a.s c
:  ( e.q    == ND_THEN    ) ? gen_lval out e.a   c ;: gen_push out c ;: gen_rval out e.a.s c ;: gen_pop out c "%rax"
:  ( e.q    == ND_ELEM    ) ? gen_rval out e.a   c ;: (gen_ln out "  mov %%rax, %%rdx") ;: gen_rval out e.a.s c ;: (gen_ln out "  imul $%ld, %%rax" e.a.t.a.size) ;: (gen_ln out "  add %%rdx, %%rax")
:  ( e.q    == ND_MEMBER  ) ? gen_lval out e.a   c ;: gen_add out e.t.offset
:  ( e.q    == ND_THE    ||
     e.q    == ND_DEREF   ) ? gen_rval out e.a   c
:  ( e.q    == ND_FUNCALL||
     e.q    == ND_COND   ||
     e.q    == ND_LET    ||
     e.q    == ND_REPEAT  ) ? gen_rval out e     c
:  ( e.q    == ND_VAR     ) ? e.o.is_local
                            ?  gen_lval_local  out e
                            :  gen_lval_global out e
                            :  (jdiag e.j "not an lvalue")

push_args2(out @FILE e @Node pass bit c @nat d nat) none
=  !!e
&& push_args2 out e.s pass c (d + 1)
;: (pass == (d < 6))
&& gen_rval out e c
;: gen_push out c
as none

gen_rval(out @FILE e @Node c @nat) none
=  (gen_ln out "  .loc 0 %d" e.j.line_no)
;: (e.q == ND_NUM   )  ? gen_lit  out e.l
:  (e.q == ND_SIZE  )  ? gen_lit  out e.t.s.size
:  (e.q == ND_ALIGN )  ? gen_lit  out e.t.s.align
:  (e.q == ND_THE   )  ? gen_rval out e.a c
:  (e.q == ND_ADDR  )  ? gen_lval out e.a c
:  (e.q == ND_NEG   )  ? gen_rval out e.a c ;: gen_neg  out
:  (e.q == ND_VAR   )  ? gen_lval out e   c ;: gen_load out e
:  (e.q == ND_MEMBER)  ? gen_lval out e   c ;: gen_load out e
:  (e.q == ND_ELEM  )  ? gen_lval out e   c ;: gen_load out e
:  (e.q == ND_DEREF )  ? gen_rval out e.a c ;: gen_load out e
:  (e.q == ND_COMMA )  ? gen_rval out e.a c ;: gen_rval out e.a.s c
:  (e.q == ND_CAST  )  ? gen_rval out e.a c ;: gen_cast out e.a.t e.t
:  (e.q == ND_ASSIGN)  ? gen_lval out e.a c ;: gen_push out c ;: gen_rval out e.a.s c ;: gen_store out e.a.t c ;: gen_zero out
:  (e.q == ND_THEN  )  ? gen_rval out e.a c ;: gen_push out c ;: gen_rval out e.a.s c ;: gen_pop out c "%rax"
:  (e.q == ND_NOT   )  ? gen_rval out e.a c ;: gen_cmpz out   ;: (gen_ln out "  sete %%al") ;: (gen_ln out "  movzx %%al, %%rax")
:  (e.q == ND_BITNOT)  ? gen_rval out e.a c ;: gen_not  out
:  (e.q == ND_LET   )  ? gen_lval_local out e ;: gen_push out c ;: gen_rval out e.a c ;: gen_store out e.a.t c ;: gen_rval out e.a.s c
:  (e.q == ND_REPEAT)  ? gen_lval_local out e ;: gen_push out c ;: gen_rval out e.a c ;: gen_label out e "" ;: gen_store out e.a.t c ;: gen_lval_local out e ;: gen_push out c ;: gen_rval out e.a.s c ;: gen_cmpz out ;: (gen_ln out "  jne .L..%lu" e) ;: gen_pop out c "%rax" ;: gen_load out e.a
:  (e.q == ND_MEMZERO) ? (gen_ln out "  mov $%d, %%rcx" e.o.t.size) ;: (gen_ln out "  lea %d(%%rbp), %%rdi" e.o.offset) ;: (gen_ln out "  mov $0, %%al") ;: (gen_ln out "  rep stosb")
:  (e.q == ND_COND)    ? gen_rval out e.a c ;: gen_cmpz out ;: (gen_ln out "  je .L.a.%lu" e) ;: gen_rval out e.a.s c ;: (gen_ln out "  jmp .L.b.%lu" e) ;: gen_label out e "a" ;: gen_rval out e.a.s.s c ;: gen_label out e "b"
:  (e.q == ND_LOGAND || e.q ==  ND_LOGOR)
?  gen_rval out e.a c
;: gen_cmpz out
;: (gen_ln out "  j%se .L.end.%lu" ((e.q == ND_LOGAND) ? "" : "n") e)
;: (e.a.s.t.q == TY_VOID && gen_push out c)
;: gen_rval out e.a.s c
;: (e.a.s.t.q == TY_VOID && gen_pop out c "%rax")
;: gen_label out e "end"
:  (e.q == ND_FUNCALL)
?  0 is stack
   0 is d
  (  !!e.a.s && e.a.s for arg
     arg.s
  :;(  ((d >= 6) :; (d = d + 1))
    && (stack = stack + 1)
    as none )
  as none )
;:(  (c@ + stack) % 2 == 1
  && gen_fpush out c 1
  ;: (stack = stack + 1)
  as none )
;: push_args2 out e.a.s 1b c 0
;: push_args2 out e.a.s 0b c 0
;:(  (e.a.q == ND_VAR && !e.a.o.is_local)
  ?  0 is d
     (!!e.a.s && e.a.s for e e.s :; (d < 6 && gen_pop out c argreg 2 d :; (d = d + 1)) as none)
  ;: (gen_ln out "  call *%s@GOTPCREL(%%rip)" e.a.o.name)
  :  gen_rval out e.a c
  ;: 0 is d
     (!!e.a.s && e.a.s for e e.s :; (d < 6 && gen_pop out c argreg 2 d :; (d = d + 1)) as none)
  ;: (gen_ln out "  mov %%rax, %%r10")
  ;: (gen_ln out "  call *%%r10") )
;: gen_fpop out c stack
:  gen_rval out e.a.s c
;: gen_push out c
;: gen_rval out e.a c
;: gen_pop out c "%rdi"
;: (e.q == ND_ADD) ? ((e.a.t.q == TY_PTR || e.a.t.q == TY_ARRAY) && (gen_ln out "  imul $%d, %%rdi" e.a.t.a.size) as none) ;:
    ((e.a.s.t.q == TY_PTR || e.a.s.t.q == TY_ARRAY) && (gen_ln out "  imul $%d, %%rax" e.a.s.t.a.size) as none) ;:
    (gen_ln out "  add %%rdi, %%rax") :
  (e.q == ND_SUB) ? 
    ((e.a.t.q == TY_PTR || e.a.t.q == TY_ARRAY) && !(e.a.s.t.q is k (k == TY_PTR || k == TY_ARRAY)) && (gen_ln out "  imul $%d, %%rdi" e.a.t.a.size) as none) ;:
    (gen_ln out "  sub %%rdi, %%rax") ;:
    ((e.a.s.t.q is k (k == TY_PTR || k == TY_ARRAY)) && (gen_ln out "  mov $%d,%%rdi" e.a.s.t.a.size) ;: (gen_ln out "  xor %%rdx, %%rdx") ;: (gen_ln out "  div %%rdi") as none) :
  (e.q == ND_MUL) ? (gen_ln out "  imul %%rdi, %%rax") :
  (e.q == ND_DIV || e.q == ND_MOD) ?
    (  (e.t.q == TY_RING)
    ?  (gen_ln out "  mov $0, %%rdx")
    ;: (gen_ln out "  div %%rdi"    )
    :  (gen_ln out "  cqo"          )
    ;: (gen_ln out "  idiv %%rdi"   ))
    ;: (e.q == ND_MOD && (gen_ln out "  mov %%rdx, %%rax") as none) :
    (e.q == ND_BITAND ) ? (gen_ln out "  and %%rdi, %%rax") :
    (e.q == ND_BITOR  ) ? (gen_ln out "  or  %%rdi, %%rax") :
    (e.q == ND_BITXOR ) ? (gen_ln out "  xor %%rdi, %%rax") :
    (e.q == ND_EQ     ) ? (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  sete  %%al") ;: (gen_ln out "  movzb %%al, %%rax") :
    (e.q == ND_NE     ) ? (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setne %%al") ;: (gen_ln out "  movzb %%al, %%rax") :
    (e.q == ND_SHL    ) ? (gen_ln out "  mov %%rdi, %%rcx") ;: (gen_ln out "  shl %%cl, %%rax")                                   :
    (e.q == ND_LT     ) ? (e.a.t.q == TY_RING) ? (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setb  %%al") ;: (gen_ln out "  movzb %%al, %%rax")
                                               : (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setl  %%al") ;: (gen_ln out "  movzb %%al, %%rax") :
    (e.q == ND_LE     ) ? (e.a.t.q == TY_RING) ? (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setbe %%al") ;: (gen_ln out "  movzb %%al, %%rax")
                                               : (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setle %%al") ;: (gen_ln out "  movzb %%al, %%rax") :
    (e.q == ND_GT     ) ? (e.a.t.q == TY_RING) ? (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  seta  %%al") ;: (gen_ln out "  movzb %%al, %%rax")
                                               : (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setg  %%al") ;: (gen_ln out "  movzb %%al, %%rax") :
    (e.q == ND_GE     ) ? (e.a.t.q == TY_RING) ? (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setae %%al") ;: (gen_ln out "  movzb %%al, %%rax")
                                               : (gen_ln out "  cmp %%rdi, %%rax") ;: (gen_ln out "  setge %%al") ;: (gen_ln out "  movzb %%al, %%rax") :
                          (e.a.t.q == TY_RING) ? (gen_ln out "  mov %%rdi, %%rcx") ;: (gen_ln out "  shr %%cl, %%rax")
                                               : (gen_ln out "  mov %%rdi, %%rcx") ;: (gen_ln out "  sar %%cl, %%rax")

emit_datum_data(out @FILE o @Obj) none
=  (gen_ln out "  .data")
;: (gen_ln out "  .type %s, @object" o.name)
;: (gen_ln out "  .size %s, %d" o.name o.t.size)
;: (gen_ln out "  .align %d" o.t.align)
;: (gen_ln out "%s:" o.name)
;: o.rel is rel
   0 is pos
  (  1b for _
    (  pos < o.t.size
    && (!!rel && rel.offset == pos)
    ?  (gen_ln out "  .quad %s%+ld" rel.label@ rel.addend)
    ;: (rel = rel.s)
    ;: (pos = pos + 8)
    :  (gen_ln out "  .byte %d" o.init_data^((pos :; (pos = pos + 1)))) )
  as none )

store_gp(out @FILE r nat p nat n nat) none
=  (n == 1) ? (gen_ln out "  mov %s, %d(%%rbp)" argreg 0 r p)
:  (n == 8) ? (gen_ln out "  mov %s, %d(%%rbp)" argreg 2 r p)
: (  0 for i
    (  i < n
    && (i + 1)
    :; (gen_ln out "  mov %s, %d(%%rbp)" argreg 0 r (p + i))
    ;: (gen_ln out "  shr $8, %s" argreg 2 r) )
  as none )

emit_datum_text(out @FILE o @Obj) none
= (  !!o.params
  && 16 is t
      0 is g
     o.params for o o.s
  :; (!((g :; (g = g + 1)) < 6)
  && (t        = align_to t 8)
  ;: (o.offset = t           )
  ;: (t        = t + o.t.size) ) )
;: 0 is bottom
  (  !!o.locals
  && o.locals for o o.s
  :;(  !o.offset
    && (bottom = bottom + o.t.size)
    ;: (bottom = align_to bottom o.t.align)
    ;: (o.offset = -bottom)
    as none )
  as none )
;: (o.stack_size = align_to bottom 16)
;: (gen_ln out "  .text")
;: (gen_ln out "  .type %s, @function" o.name)
;: (gen_ln out "%s:" o.name)
;: (gen_ln out "  enter $%d, $0" o.stack_size)
;:(  o.va_area
  && 0 is d
     (!!o.params && o.params for o o.s :; (d = d + 1) as none)
  ;: o.va_area.offset is off
     (gen_ln out "  movl $%d  , %d(%%rbp)" (d * 8) off)
  ;: (gen_ln out "  movq %%rbp, %d(%%rbp)" (off + 8))
  ;: (gen_ln out "  addq $16  , %d(%%rbp)" (off + 8))
  ;: (gen_ln out "  movq %%rbp, %d(%%rbp)" (off + 16))
  ;: (gen_ln out "  addq $%d  , %d(%%rbp)" (off + 24) (off + 16))
  ;: (off + 24) is b
     (gen_ln out "  movq %%rdi, %d(%%rbp)"                b)
  ;: (b = b + 8) ;: (gen_ln out "  movq %%rsi, %d(%%rbp)" b)
  ;: (b = b + 8) ;: (gen_ln out "  movq %%rdx, %d(%%rbp)" b)
  ;: (b = b + 8) ;: (gen_ln out "  movq %%rcx, %d(%%rbp)" b)
  ;: (b = b + 8) ;: (gen_ln out "  movq %%r8 , %d(%%rbp)" b)
  ;: (b = b + 8) ;: (gen_ln out "  movq %%r9 , %d(%%rbp)" b) as none )
;:(  0 is d
     o.params for o
    (  !!o
    && o.s
    :;(  o.offset <= 0
      && o.t is t
        store_gp out ((d :; (d = d + 1))) o.offset t.size
      as none ) )
  as none )
;: 0 is c
   gen_rval out cast @Node o.body &c
;: (gen_ln out "  leave")
;: (gen_ln out "  ret")

emit_datum(out @FILE o @Obj) none
=  !!o.is_definition
&& (  !o.is_export
   ?  (gen_ln out "  .local %s" o.name)
   :  (gen_ln out "  .globl %s" o.name) )
;: (o.t.q == TY_FUNC)
?  emit_datum_text out o
:  emit_datum_data out o

codegen(o @Obj out @FILE in @byte) none
=  (gen_ln out "  .file 0 \q%s\q" in)
;: 0 is c (!!o && o for o o.s :; emit_datum out o &c as none)

export main(argc nat argv @@byte) nat
=  open_file argv^2 "w" is out
   (!out ? 1 : 0 :; codegen parse tokenize argv^1 out argv^1)
:; cast none fclose out